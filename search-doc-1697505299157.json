[{"title":"Release Log","type":0,"sectionRef":"#","url":"/my-website/blog/release blog","content":"","keywords":""},{"title":"V2.3.0.4​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2304","content":"Release Date: 2023/06/30 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.91.0.1 build 0626.0819 FDE: Version: 00.09.08.1 Build: 0613.1936 EME: Version: 00.09.22.01 Build: 0618.1400 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.08.1 Build: 0613.1936 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature","content":"Passive None. Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs","content":"Passive Added exception catch for eme_propagate:facet_data. Fixed the support issue of the whl installation package for the fourth paragraph of the version number. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.3.0.3​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2303","content":"Release Date: 2023/06/21 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-1","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.81.2.1 build 0609.0839 FDE: Version: 00.09.08.1 Build: 0613.1936 EME: Version: 00.09.22.01 Build: 0618.1400 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.08.1 Build: 0613.1936 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-1","content":"Passive None. Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-1","content":"Passive Fixed the boundary condition processing logic problem in the mode_selection:user_select method, and the logic after the fix was: Support setting boundary conditions in the mode_selection:user_select method, the default boundary condition is PEC, where the PML boundary condition parameter is the same as ‘FDE’. If the user specifies a boundary condition, use that condition for calculate mode, otherwise use PEC. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-1","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-1","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.3.0.2​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2302","content":"Release Date: 2023/06/21 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-2","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.81.2.1 build 0609.0839 FDE: Version: 00.09.07.1 Build: 0613.0209 EME: Version: 00.09.22.01 Build: 0618.1400 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-2","content":"Passive None. Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-2","content":"Passive When the relevant parameters of demodulation in the mode_selection:user_select method are not set, the default value is wrong. -&gt; fast_EME.py ModeSource/FDTDPort/EMEPort/ModeExpansion does not have parameters such as n/number_of_trial_modes/bent_waveguide. -&gt; fast_FDTD.py/fast_EME.py Some models report errors in the eme_propagate:facet_data method. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-2","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-2","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.3.0.1​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2301","content":"Release Date: 2023/06/19 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-3","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.81.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 EME: Version: 00.09.22.01 Build: 0618.1400 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-3","content":"Passive None. Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-3","content":"Passive The Source/Port setting is not overridden by the parameters related to demodulation in the mode_selection:user_select method. -&gt; fast_EME.py Active Solve the problem that OEDevice does not support long paths through temporary folders. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-3","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-3","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.3.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2300","content":"Release Date: 2023/06/15 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-4","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.81.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 EME: Version: 00.09.21.01 Build: 0614.1925 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-4","content":"Passive Modified the PML model and parameters for FDE. FDE/EMEPort supports Mode Removal function under PML boundary conditions. -&gt; fast_FDE.py/fast_EME.py Add Periodic Structure function in EME. -&gt; EME_Periodic_Structure.py StructureShow supports custom Border. -&gt; maxoptics.toml Add simu[simu_name].show3d(show_with=&quot;local_gui&quot;) method calls LocalGUI. -&gt; fast_FDE.py Add simulation log aggregation of passive file siblings. -&gt; fast_FDE.py Active Use Solver to output absolute coordinates for result extraction. Updated some Linux operating system adaptations. OEDevice Solver is included by default and requires no additional installation. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-4","content":"Passive passive file after SDK FDE simulation, white screen when opened with LocalGUI. The parameter limit of the PML boundary condition in FDE/EME is unreasonable. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-4","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-4","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.2.3.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2230","content":"Release Date: 2023/05/31 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-5","content":"Passive meshgen: 1.1.0505.1842 FDTD_CPU: V1.17.1.0 build 0517.0826 FDTD_GPU: V0.81.0.0 build 0514.2151 FDE: 00.09.03.1 Build: 0213.1440 EME: 00.09.17.01 Build: 0525.0011 ModeExpansion: 1.16.0.3 Build: 20230525.2010 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 12/16/2022 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-5","content":"Passive AnalyticalWaveguide type in Structure, supporting tilt_angle and location. GaussianSource supports ModeExpansion. StructureShow supports custom colors. Active Result export file format changes from json to csv. Support Schenk trap-assisted tunneling model for Si. Support Schenk and Hurkx band to band tunneling model for Ge. Optimize extraction of photo induced carrier generation rate. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-5","content":"Passive FDTD extracts the ModeProfile coordinate value offset. SDK simulation results are automatically Remesh when LocalGUI is opened. Active Fix extraction of electric field intensity for electric monitor. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-5","content":"Passive Periodic Group Definition function in EME. ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-5","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.2.2.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2220","content":"Release Date: 2023/04/28 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-6","content":"Passive meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDTD_GPU: V0.80.2.1 build 0422.2215 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: 0.93.0.4 Build: 20230410.1606 Active meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 12/16/2022 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-6","content":"Passive Add PASSIVE_FDTD_GPU authorization limit. Structure export as GDSII file. -&gt; Structure_Export_GDS.py Import the GDSII file and stretch it at Middle. -&gt; Rect_Trapezoidal_Extend.py Structure adds the AnalyticalWaveguide type to support the equation formula. -&gt; Analytical_Waveguide.py The extract function supports export mat and zbf format file. -&gt; fast_FDE.py/fast_FDTD.py Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-6","content":"Passive FDE/FDTD simulation results are offset under the Symmetric/Anti-Symmetric boundary conditions. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-6","content":"Passive Periodic Group Definition function in EME. ModeSource/FDTDPort/EMEPort support UserImport. Active None. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-6","content":"Passive FDTD does not support ModeExpansion in the case of Gaussian source excitation. FDTD has problems with FarField calculations at the Symmetric/Anti-Symmetric boundary. When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). Active None. "},{"title":"V2.2.1.2​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2212","content":"Release Date: 2023/04/14 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-7","content":"Passive meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDTD_GPU: V0.80.1.1 build 0414.2224 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: 0.93.0.4 Build: 20230410.1606 Active meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 12/16/2022 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-7","content":"Passive Added the ability to specify the passive file path for simulation, preparing for third-party schedulers -&gt; mo.sdk run. After generating passive by importing GDS, it supports automatic display of groupings in LocalGUI. In structure_show, view=True can directly evoke the GUI for modeling and viewing (simulation results do not support real-time synchronization at the moment). Active Support for GDS file import (Beta version). Support for adding electrical local mesh along a line. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-7","content":"Passive None. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-7","content":"Passive None. Active None. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-7","content":"Passive None. Active None. "},{"title":"V2.2.1.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2210","content":"Release Date: 2023/03/31 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-8","content":"Passive meshgen: 1.1.0320.1930 FDTD: V1.15.2.1 build 0301.2202 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.1.0320.1930 FDTD: V1.15.2.1 build 0301.2202 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-8","content":"Passive Add FarField calculation for PowerMonitor in FDTD. -&gt; FDTD_Far_Field.py Add Symmetric/Anti-Symmetric boundary condition in FDTD. requirements.txt depends only need to set max_optics_sdk~=2.2.1.0. Active run_doping set geometry for doping preview. add_doping supports selected areas or specified material lists. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-8","content":"Passive None. Active Supplement some of the note information. Results such as LPD are output slowly. run_index does not support LocalMesh. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-8","content":"Passive None. Active None. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-8","content":"Passive None. Active None. "},{"title":"V2.2.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2200","content":"Release Date: 2023/03/15 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-9","content":"Passive meshgen: 1.1.0213.1427 FDTD: V1.15.2.1 build 0301.2202 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.1.0213.1427 FDTD: V1.15.2.1 build 0301.2202 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 OEDevice: 20221220 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-9","content":"Passive Enable new authorization controls. Export the historical result file in Local mode. -&gt; Extract_History_Results.py EME supports Custom Setting of Cell Group. -&gt; EME_CellGroup_Custom_Setting.py run_index adds max_index/max_sigma parameter to filter the display results. -&gt; Run_Index_Filter.py Active Enable new authorization controls. When importing DOP doping files, additional Gaussian doping is supported. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-9","content":"Passive None. Active In some electrical simulation scenarios, the boundary file generation error caused the electrical simulation to fail. When the simulation area exceeds the structure boundary, the probability of error will increase. The code comments of some new functions are not completed, such as add_doping, etc. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-9","content":"Passive None. Active None. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-9","content":"Passive The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; V2.2.1.0 by 2023/3/31 In the FDTD_Oblique_Input.py, the material boundary condition and starting position is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; V2.2.1.0 by 2023/3/31 ModeExpansion ‘s calculation results are labeled incorrectly. -&gt; V2.2.1.0 by 2023/3/31 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active None. "},{"title":"V2.1.1.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2110","content":"Release Date: 2023/02/28 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-10","content":"Passive meshgen: 1.1.0213.1427 FDTD: V1.15.1.1 build 0220.0954 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.1.0213.1427 FDTD: V1.15.0.1 build 0219.2157 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 OEDevice: 20221220 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-10","content":"Passive Adjust FDTD ModeExpansion as a submodule of PowerMonitor, which can inherit the geometric parameters of PowerMonitor in SDK/LocalGUI/CloudGUI simulation process. -&gt; fast_FDTD.py Support Overlap/Beam calculation. -&gt; FDE_Beam_Overlap.py Active Support for selecting a specific material or region when adding doping. -&gt; MOD00_doping_import_DOP.py Doping import supports pure doping data files, and at this time also supports setting uniform doping in SDK. -&gt; MOD00_doping_import_DOP.py "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-10","content":"Passive When the simulation results of SDK are run and viewed in LocalGUI, an error is reported when viewing the results of ModeSource in FDTD, the results in FDE Parameter Sweep are not imported, and the intensity graph of SMatrix in EME Parameter Sweep cannot view. The default value of stop_wavelength in FDE Frequency Sweep is smaller than start_wavelength -&gt; scan according to the interval between start_wavelength and stop_wavelength, support stop_wavelength to be smaller than start_wavelength, see fast_FDE.py. Active The current results output by the same script are positive and negative. In Modulator, only max_index is supported, and near_n is not supported. Only the mesh_order of the material is effective in electrical simulation, and the mesh_order of the structure is not effective. When setting the frequency scan for small signals, the literal meaning of the num_frequency_points_per_dec field does not match the actual meaning in the SDK. Change the field to log_num_frequency_points to indicate the total number of frequency scan points including the start frequency and stop frequency. SDK electrical Solver version check fails. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-10","content":"Passive SDK script supports the extraction of historical simulation results. -&gt; V2.2.1.0 by 2023/3/31 Active None "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-10","content":"Passive The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; V2.2.0.0 by 2023/3/15 In the FDTD_Oblique_Input.py, the material boundary condition and starting position is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; V2.2.0.0 by 2023/3/15 ModeExpansion ‘s calculation results are labeled incorrectly. -&gt; V2.2.0.0 by 2023/3/15 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active In some electrical simulation scenarios, the boundary file generation error caused the electrical simulation to fail. When the simulation area exceeds the structure boundary, the probability of error will increase. The code comments of some new functions are not completed, such as add_doping, etc. "},{"title":"V2.1.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2100","content":"Release Date: 2023/02/10 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-11","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.2 build 0104.2052 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221220 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-11","content":"Passive Provide FDTD Parameter Sweep/EME Parameter Sweep/FDE Parameter Sweep -&gt; DC_FDTD_ParameterSweep.py/wg_FDE_ParameterSweep.py/DC_EME_ParameterSweep.py The simulation result of SDK can be viewed in LocalGUI(FDTD Parameter Sweep not support) Active Input parameter of GFile changes from folder path to the absolute path of the file. [46] Modulator Analysis supports users to adjust the voltage interpolation step. Add error reporting for some parameters when no setup. [42] OEDevice license support remote desktop. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-11","content":"Passive None Active [45] The wavelength is 1550 by default in some scenarios. Material index of refraction not interpolated by wavelength. OEDevice doesn’t support cross section other than 2d_x_normal. When the electrical section is set at certain positions, the bnd file generation error occurs due to floating-point errors and the electrical simulation is stuck. norm_length doesn’t support floating numbers. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-11","content":"Passive Adjust FDTD ModeExpansion as a submodule of PowerMonitor, which can inherit the geometric parameters of PowerMonitor in SDK/LocalGUI/CloudGUI simulation process. -&gt; V2.1.0.1 by 2023/2/28 Active None "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-11","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. In the FDTD_Oblique_Input.py, the material boundary condition and starting position is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; V2.1.0.1 by 2023/2/28 ModeExpansion ‘s calculation results are labeled incorrectly. -&gt; V2.1.0.1 by 2023/2/28 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active The output current results sometimes have redundant negative signs. -&gt; V2.1.0.1 by 2023/2/28 The Mode Calculate of Modulator just support max_index, not support near_n -&gt; V2.1.0.1 by 2023/2/28 "},{"title":"V2.0.1.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2010","content":"Release Date: 2023/01/12 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-12","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.2 build 0104.2052 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-12","content":"Passive None Active None "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-12","content":"Passive mesh_factor parameter did not add input parameter range check, modified to [1.05,1.6]. -&gt; fast_FDE.py Fixed FDE FarField in the cloud mode, the parameter settings were displayed incorrectly. -&gt; FDE_Far_Field.py Modify fast_fdtd.gds, put ModeSource at the straight waveguide. -&gt; fast_FDTD.py Active Fix the problem that active emulation occupies passive authorization. Active doping file import run result extraction error. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-12","content":"Passive AIO features include FDTD Parameter Sweep/FDE Parameter Sweep/EME Parameter Sweep-&gt; V2.1.0.0 by 2023/2/10 The simulation result of AIO can be viewed in LocalGUI-&gt; V2.1.0.0 by 2023/2/10 The frequency port setting in the FDTD Port inherits from Global Monitor, which does not support parameter setting alone. -&gt; V2.1.0.0 by 2023/2/10 Modify FDTD ModeExpansion as PowerMonitor sub-attribute and participate in AIO/LocalGUI/CloudGUI simulation process. -&gt; by 2023/2/28 Active None "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-12","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. In the FDTD_Oblique_Input.py, the material boundary condition is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; V2.1.0.0 by 2023/2/10 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; by 2023/2/28 The output current results sometimes have redundant negative signs. -&gt; by 2023/2/28 "},{"title":"V2.0.0.1​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2001","content":"Release Date: 2023/01/10 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-13","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.2 build 0104.2052 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-13","content":"Passive FDE Far Field -&gt; FDE_Far_Field.py Adds material boundary condition into FDTD ModeSource/FDTDPort/ModeExpansion and EME Port/Cell mode calculation result. -&gt; fast_FDTD.py/FDTD_Matrix_Sweep.py/fast_EME.py Add export_c parameter to control σ output result of run_index function . -&gt; fast_FDTD.py Modifies the EME Port/EME Cell legends’ description in the structure_show. -&gt; fast_EME.py Active None "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-13","content":"Passive The run_index result is incorrect when setting GDS as the bottom to perform trapezoidal extend. (The trapezoidal section imported by GDS currently only supports the real trapezoidal structure) -&gt; LN_anisotropy_BENT_FDTD_GDS.py The mode calculation result is incorrect, when selecting near_n in the FDE. -&gt; fast_FDE.py After running mode source in the FDTD, finding that the neff/profile shown in the source-preview-mode is different with neff/profile shown in the source mode.-&gt; fast_FDTD.py Active The title name of Doping Concentration[cm^-3] has been changed to Net Doping[cm^-3] in the run_doping plot. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-13","content":"Passive AIO features include FDTD Parameter Sweep/FDE Parameter Sweep/EME Parameter Sweep-&gt; by 2023/2/10 The simulation result of AIO can be viewed in LocalGUI-&gt; by 2023/2/10 The frequency port setting in the FDTD Port inherits from Global Monitor, which does not support parameter setting alone. -&gt; by 2023/2/10 Modify FDTD ModeExpansion as PowerMonitor sub-attribute and participate in AIO/LocalGUI/CloudGUI simulation process. -&gt; by 2023/2/28 Active None "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-13","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. In the FDTD_Oblique_Input.py, the material boundary condition is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; by 2023/2/10 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; by 2023/2/28 "},{"title":"V2.0.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2000","content":"Release Date: 2023/01/05 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-14","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.2 build 0104.2052 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-14","content":"Passive None Active Support plot net doping Support plot doping of selected materials Optimizing plot of doping Adjust the authorization method and cancel the old authorization and local configuration file "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-14","content":"Passive When ModeSource run fde only , the mesh is 3D Mesh but not 2D Mesh -&gt; fast_FDTD.py The subscript of EME SMatrix does not use determinant -&gt; fast_EME.py The source mode profile of FDE Only is different from source mode profile of FDTD run -&gt; fast_FDTD.py after EME.run(), need one command to extract index for p0,p1, c0, c1, … cxx. also to extract profile, modes -&gt; fast_EME.py When the comment out code is recover，the script is not run -&gt; fast_FDE.py When the background_material of OBoundary is not set to mt or public material, the error message is unclear in meaning -&gt; fast_FDE.py In Cloud run_mode, the plot axis position of FDE result in ModeSource/FDTDPort and EMEPort/EMECell is wrong -&gt; fast_FDTD.py/fast_EME.py The σy output data of run_index in Rect_Trapezoidal_Extend.py script is wrong -&gt; Rect_Trapezoidal_Extend.py ModeExpansion’s mode_list parameter and the mode_index parameter of ModeSource/FDTDPort/EMEPort begin with 1 change to begin with0 -&gt; fast_FDTD.py/fast_EME.py The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from simulation mesh setting. -&gt; fast_FDTD.py Active There is too much messages printed out of result options in running log. The scale and title font of the axis is small in the result image. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-14","content":"Active Supports run_doping method. -&gt; V2.0.0.2 by 2023/2/10 Active Modulator Analysis supports optical simulation in designated mode. -&gt; V2.0.0.2 by 2023/2/10 "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-14","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually. -&gt; V2.0.0.2 by 2023/2/10 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; V2.0.0.2 by 2023/2/10 "},{"title":"V1.9.1.1​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1911","content":"Release Date: 2022/12/27 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-15","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.1 build 1106.1945 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-15","content":"Passive supports script run in cloud mode -&gt; fast_FDE.py/fast_FDTD.py/fast_EME.py Active supports run_index(The type of Terraceneeds changing into Pyramid) "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-15","content":"Passive The order does not start from 0 in the FDE result. -&gt; fast_FDE.py The background material of EME failed to deliver correctly. -&gt; fast_EME.py Script reports an error in Cloud mode : ERROR: Connection Failed -&gt; fast_FDE.py The project gets from Cloud finding that, material does not display in the GUI object tree. -&gt; fast_FDE.py The project gets from Cloud finding that, the color of material does not show in the GUI. -&gt; fast_FDE.py The background material of FDE displays incorrectly in Cloud mode. -&gt; fast_FDE.py FDEresult check reports an error, in Cloud mode. : ERROR: Cannot load backend TkAgg -&gt; fast_FDE.py The result of run_index export reports an error, in Cloud mode. -&gt; fast_FDTD.py The coordinate displays incorrectly in the result image of PowerMonitor, in Cloudmode. -&gt; fast_FDTD.py Active During electrical stimulation, the name of the MY’s temp file can not be changed, causing electrical files to occur conflicts. The parameters of norm and scale do not work in run_doping function. The result image of small signal capacitance is incorrect. Unit is lost in the generation rate result image. Parts of the results’ values extract incorrectly from PD voltage scanning. The show3dmethod in PD, informs that materialID reports an error. The linear image of carrier can not match with golden aims, the reason is that the highest interpolation of chager_monitor , while lower of its precision. Run run_doping directly, while no doping is imported, the electric simulation will be executed. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-15","content":"Passive Supports run_doping method. -&gt; V1.9.1.3 by 2023/1/10 Active Modulator Analysis supports optical simulation in designated mode. -&gt; V1.9.1.2 by 2023/1/3 Supports DC static capacitance calculation. -&gt; V1.9.1.2 by 2023/1/3 The authorized integration of MY needs to be verified -&gt; V1.9.1.2 by 2023/1/3 "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-15","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The start parameters of mode_listof ModeExpansion andmode_index of ModeSource/FDTDPort/EMEPort are 1 -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; TBD The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from simulation mesh setting.-&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The Release Log and Install Doc are not fully translated into English. The format of the parameter list in handbook is not standardized, and the Chinese translation is incomplete. -&gt; V1.9.1.2 by 2023/1/3 The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually. -&gt; V1.9.1.2 by 2023/1/3 The coordinate is incorrect for the mode calculation of FDTD’s source/port and EME’s port/cell in cloud mode. -&gt; WebAPP(V1.4.0.1) by 2022/12/31 The value of mode index of ModeExpansion in FDTDdoes not start from 0-&gt; V1.9.1.2 by 2023/1/3 In the Rect_Trapezoidal_Extend.py script, the output data of run_index is σy, which is incorrect. -&gt; V1.9.1. by 2023/1/3 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; V1.9.1.3 by 2023/1/10 There is too much messages printed out of result options in running log. -&gt; V1.9.1.2 by 2023/1/3 The scale and title font of the axis is small in the result image. -&gt; V1.9.1.2 by 2023/1/3 add_emesh lacks of notes -&gt; V1.9.1.2 by 2023/1/3 "},{"title":"V1.9.1.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1910","content":"Release Date: 2022/12/19 is "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-16","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.1 build 1106.1945 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-16","content":"Passive Modifies the default logic of structure material, and supports simulation even mt without Air material. -&gt; fast_FDE.py The type of Structure supports case sensitivity -&gt; fast_FDE.py Supports trapezoidal extending via GDS importing, the parameters include tilt_angle and tilt_location, tilt_angle, limited from 0 to 180 degrees, which means the upward/downward extending trapezoidal tilt angle. The tilt_location means taking the GDS as bottom/top trapezoidal extending, which option is bottom/top. -&gt; Rect_Trapezoidal_Extend.py Supports wavelength_offset parameter, 0.0001μm by default in FDE/EME to calculate ng . -&gt; fast_FDE.py/fast_EME.py Active Supports simulation in All-In-One SDK template manner. Supports doping checking method. Supports a fixed display of the material color and the show3dfunction has been optimized. Supports transient simulation. Supports custom naming of electrode. Supports high field mobility model of material. Supports customized small signal frequency single-point scanning. Supports adding electrical monitors. Fixed Bug None "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-16","content":"Passive None Active Small-signal frequency multi-point scanning -&gt; V2.0.0.0 by 2022/12/30 Modulator Analysis supports optical simulation in designated mode. -&gt; V2.0.0.0 by 2022/12/31 Supports electrical monitors such asband_monitor/electric_monitor and so on. -&gt; V2.0.0.0 by 2022/12/31 DC static capacitance calculation -&gt; V2.0.0.0 by 2022/12/31 The authorized integration of MY needs to be verified -&gt; V2.0.0.0 by 2022/12/31 "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-16","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The start parameters of mode_listof ModeExpansion andmode_index of ModeSource/FDTDPort/EMEPort are 1 -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. The inner/ external box of the run_indexsimulation boundary can not be shown. -&gt; TBD The scripts reports error, in the Cloud mode. -&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from simulation mesh setting.-&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The Release Log and Install Doc are not fully translated into English. The format of the parameter list in handbook is not standardized, and the Chinese translation is incomplete. -&gt; V1.9.1.2 by 2023/1/3 The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually. -&gt; V1.9.1.2 by 2023/1/3 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; V2.0.0.0 by 2022/12/31 There is no unit in the generation rate result image. -&gt; V2.0.0.0 by 2022/12/31 The current cannot be read according to the binded electrode, resulting in current positive or negative from time to time -&gt; V2.0.0.0 by 2022/12/31 The resistance calculation results are positive or negative from time to time. -&gt; V2.0.0.0 by 2022/12/31 The effective refractive index precision of Modulator does not meet requirements. -&gt; V1.9.1.1 by 2022/12/26 "},{"title":"V1.9.0.4​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1904","content":"Release Date: 2022/12/13 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-17","content":"meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-17","content":"Modifies the data format of DataFrame calling from FDE: order/TEratio/neff_real/neff_imag/ng_real/ng_imag/wavelength_nm/loss_dBpcm -&gt; fast_FDE.py Removes monitor_type parameter in run_index and takes span==0 as auto judgement logic -&gt; fast_FDE.py Modifies geometry assignment method:center/span, center/min, min/max, center/max, span/min and span/maxsix combinations in total.(When there are multiple possible combinations of parameters, the priority is: min/max, min/sfindan , max/span, min/center, max/center, center/span) -&gt; fast_FDE.py Modifies the Structure ‘s ’background_material setting logic, which public materials and materials except mt are forbidden to be input. -&gt; fast_FDE.py Modifies the OBoundary logic, changes the name of general into general_pml, and moves pml_same_settings into general_pml. -&gt; fast_FDE.py The show3dfunction of simu has been optimized, which supports 3D displayed on the webside. (You need to close the webpage and press Enter on the command line to continue the simulation) -&gt; fast_FDE.py Modifies material color ofstructure_show, which supports auto RGB function calculation based on index. -&gt; fast_FDTD.py Removes the Frequency Sweep in the fast_FDE.pyscript. -&gt; fast_FDE.py Adds maxoptics_OEDevice_local_sdk into whl installation package for matching with Active SDK.(Active simulation is not available temporarily)-&gt; wheels/requirements.txt "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-16","content":"Fixed, coordinate offset of mode calculation result caused by incorrect transmit parameters, when setting PML of FDE. -&gt; fast_FDE.py Fixed the PML Region does not show in the Structure_show. -&gt; fast_FDTD.py Fixed, simulation result incorrectly caused by wrong transmit parameters from anisotropy materials -&gt; LN(anisotropy)_EOM.py/LN(anisotropy)_EME_MMI.py/LN(anisotropy)_BENT_FDTD.py Removed useless print messages for modifying in the LN(anisotropy)_EOM.py script. -&gt; LN(anisotropy)_EOM.py Fixed, FDTD would repeat simulation for each Port in the FDTD Matrix Sweep. -&gt; FDTD_Matrix_Sweep.py Fixed, FDTDPort does not show in the Structure_show. -&gt; FDTD_Matrix_Sweep.py Fixed, DataFrame calling from FDE reports an error, caused by incorrectly complex numbers of ng processing. -&gt; FDE_dispersion.py Fixed, when sets y to 0 in the Structure of GratingCoupler , runs run_index , it will report an error. -&gt; GratingCoupler.py The output project files of structure_show are placed into simulations file, and the output files of run_index are placed into main simulation file. -&gt; FDTD_HalfRing.py "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-17","content":"Supports trapezoidal extending via GDS importing. -&gt; V1.9.1.0 by 2022/12/16 "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-17","content":"Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The start parameters of mode_listof ModeExpansion andmode_index of ModeSource/FDTDPort/EMEPort are 1 -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; TBD Script running reports error in Cloud mode. -&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from simulation mesh setting.-&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The Release Log and Install Doc are not fully translated into English. The format of the parameter list in handbook is not standardized, and the Chinese translation is incomplete-&gt; V1.9.1.1 by 2022/12/23 The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually -&gt; V1.9.1.1 by 2022/12/23 The Type of Structure.add_geometry does not type in lowercase. -&gt; V1.9.1.0 by 2022/12/16 FDE does not support ng calculation for incorrect ng parameter transmit. -&gt; V1.9.1.0 by 2022/12/16 The script reports an error when using the background_material default value of Structure and there is no Air material in the mt. -&gt; V1.9.1.0 by 2022/12/16 "},{"title":"V1.9.0.3​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1903","content":"Release Date: 2022/12/06 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-18","content":"meshgen: 1.0.1110.1500 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.08.13.1 Build: 1128.1845 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-18","content":"Moves run_index method from Structure to Simulation. Removes local sdk and whale version information output, only ALL-In-One version information is left. Adds the default values of plot_x and plot_y in the intensity result image. Moves the position of the legend to the upper right in the Line image. Adds a new file named precision with FDTD_HalfRing/EME_SSC/EME_PSR/dc_dummy_1310 scripts. Adds EME_PSR_MMI script in the fast_demo to verify the correctness of EME. Adds FDTD_Matrix_Sweep script in the fast_demo as an example of the FDTD Matrix Sweep function. Adds show3d function in the Simulation. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-17","content":"Fixed,propagation_sweep and wavelength_sweep parameters of EME are processed incorrectly. Modified the inappropriate name of material_name in the script. Fixed, the detailed_dispersion_calculation does not work for FDE Frequency Sweep in Cloud mode. The simulation boundary is lost in thestructure_show. The parameter transmit is incorrect in theglobal_mesh_uniform_grid of FDE. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-18","content":"Supports 3DStructure_show . (The 3d Structure_show function has been developed, and plan to release on December 13th of V1.9.0.4) Supports trapezoidal extending via GDS importing (The function is in progress, and plan to release on December 20th of V 1.9.0.4 ) FDTD/FDE/EME Parameter Sweep (TBD) "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-18","content":"Thestart_frequency of FDE Frequency Sweep does not work The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength The Type of Structure.add_geometry does not type in lowercase There are no default values of PML and Boundary in the Oboundary. Currently, only supports three types for add_geometry with center/span, center/min and min/max. The output project files routes of run_index and structure_show are incorrect in the Local mode. The name of FDE output file has been modified but Cloud Server does not synchronize with. run_index reports an error in Cloud mode, which will be planned to fix after CloudServer updating. -&gt; by 2022/12/31 Therun_index does not support the inner/external simulation boundary box displayed. The column name in the DataFrame returned by the extract method is inappropriate. The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from the simulation mesh setting. The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually. FDTD simulation will run double times for each port of FDTD Matrix Sweep. The useless print messages of LN_EOM in FDE script should be removed. The Release Log and Install Doc are not fully translated into English. The format of the parameter list in handbook is not standardized, and the Chinese translation is incomplete. The usage logic of project_name and simu_name is in chaos in the Cloud mode. The dispersion material does not work, which is caused by theng parameter transmitting incorrectly. "},{"title":"V1.9.0.2​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1902","content":"Release Date: 2022/11/28 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-19","content":"meshgen: 1.0.1110.1500 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.08.13.1 Build: 1128.1845 EME: Version: 00.09.07.01 Build: 1128.1830 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-19","content":"The transmit parameters of pj.Structure with mesh_type/mesh_factor/background_material have been modified as elective options. The maximum_mesh_step_settings name has been changed to global_mesh_uniform_grid. Adds FDE/EME/FDTD related results, which return parameters are DataFrame. The show parameters will be canceled, when setting target=&quot;table&quot; for calculate_modes method, in the fast_FDE. Modified transmit parameters of target default value as intensity with eme_propagate:port_mode_info/eme_propagate:port_overlap/eme_propagate:port_mesh_structure /eme_propagate:cell_mode_info/eme_propagate:cell_p_matrix/eme_propagate:cell_overlap/eme_propagate:cell_s/eme_propagate:internal_s method. Modified the mode transmit parameter default value as 0 with eme_propagate:cell_mode_info method. Modified frequency_analysis method in the FDE . And its attribute includes &quot;neff&quot;/&quot;loss&quot;/&quot;group_index&quot;/&quot;polarization&quot;. Modified the propagation_sweep in the EME and changed the calculation logic of propagation_sweep as an inner calculation in Slover. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-18","content":"An error will occur, when Jupyter imports maxoptics_sdk.all. IF x_min is not set in the Simulation, an error will occur, even the simu region of OBoundary has been set in the EME. The script reports an error, because uses the default list directly without adding necessary values in the EME_PSR.py program. Fixed, set the offset of the port default value to 0 in the EME. Fixed, set the detailed_dispersion_calculation default value to False in the FDE. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-19","content":"3D structure_show. Supports trapezoidal extending via GDS importing FDTD/FDE/EME Parameter Sweep "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-19","content":"The start_frequency function in the FDE Frequency Sweep does not work yet. The detailed_dispersion_calculation in the FDE Frequency Sweep does not work in the Cloud mode. The default value of stop_frequency is less than start_wavelength in the FDE Frequency Sweep. The Type of Structure.add_geometry does not type in lowercase There are no default values of PML and Boundary in the Oboundary. Currently, only supports three types for add_geometry with center/span, center/min and min/max. The usage logic of name in the Simulation and name in the Project are confused, both in the Local and Cloud modes. The name of the FDE output file has been modified but Cloud Server does not synchronize with it . "},{"title":"V1.9.0.1​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1901","content":"Release Date: 2022/11/22 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-20","content":"meshgen: 1.0.1110.1500 FDTD: Version: 0.93.0.1 Build 1106.1945 FDE: Version: 00.08.11.1 Build: 1103.1658 EME: Version: 00.09.05.01 Build: 1009.2025 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-20","content":"Supports hover function with input parameters, whether the property parameter is checked, and the property default value . The parameter default values have been updated. Modified the setting of PML, which only permitted setting in the OBoundary. Modified the Mesh related settings, which only permitted setting in the Structure. The running method of location parameter setting is moved into the project. Notes: Compared with AIO V1.9.0.0 features, the V1.9.0.1 has added five new features. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-19","content":"Fixed, Jupyrer notebook failed to import maxoptics_sdk.all . Fixed, the maximum_mesh_step_settings in the FDE does not transmit correctly. Fixed, the pml_alpha setting in the OBoundary in the FDTD does not transmit to FDTD the Solver.json interface. Fixed, the GlobalMonitor value is not adopted, when sets the override_global_options of PowerMonitor to False, in the FDTD. The mesh_type reports an error, when sets mesh_type of FDTD to staircase and calculates modes alone. IF x_min is not set in the Simulation, an error will occur, even the simu region of OBoundary has been set in the EME. Fixed, EME_PSR.py reports an error running in the Cloud mode. Add a timestamp in the script to create a project to prevent the project and results from being overwritten. The mesh.json y and z values are incorrect in the FDE, after setting the OBoundary. Fixed, the n of search in the FDE does not transmit correctly into solver.json. Fixed, the mesh_type reports an error, when sets mesh_type of FDTD to staircase. The default values in the fast_demo have been commented out or removed. The anisotropy material parameter transmit is incorrect. 3D model structure parameter transmit is incorrect. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-20","content":"FDTD S-Matrix FDE/EME/FDTD parameter sweep Take the method, which AIO reading from output files of results in the json format，to encapsulate. Data reading from json files, and public encapsulation method with searching. SDK material database does not synchronize with Cloud ‘s material database with Standard, User and Project . "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-20","content":"The structure_show does not work, when there has a pyramid or ArcWaveguide3D structure in the modeling script. The anisotropy results of EME and FDTD are incorrect casing by the worng parameter transmit of LN materials. The FDTD S-Matrix feature has not been verified yet. The structure boundary displayed in the calculation mode result image is incorrect. There has a slight difference of V1.9.0.1 fast_FDTD results both in the local and cloud mode with V1.3.9’s results got in local mode The title should be EME in the EME’s monitor result image. Logic adjustment of back-end parameters to front-end page. The types of boundary conditions that can be used in FDE/EME and FDTD are different. For example, FDE/EME supports symmetric and antisymmetric boundary conditions, while FDTD does not. At present, no comprehensive verification has been done The boundary conditions can be set in different ways between FDE/EME and FDTD. For example, there is only one PML parameter for FDE/EME, while FDTD supports setting x/y/z’s PML parameters separately. Due to the support of Python 3.8 for TypingCheck is not good, the implemented spelling check cannot continue to be supported, and will be closed in the next version. Currently， the user cannot know the parameter assignment error in the IDE, and can only view the output in the command line window to check the error. The display of similar materials of the index is not obvious, due to the RGB color of structure_show in the user’s setting material being set according to the index’s real and imaginary auto RGB assignment method. Currently, the run_ index method is based on the 2D mesh created by FDE. When the script is run in cloud mode and viewed in cloud server, finding that there has no results for the index monitor in the result tree. (FDE does not support IndexMonitor in the cloud server) The method of inputting wavelength_min and wavelength_max into waveform and monitor and inputting frequency method has not been verified. The waist_radius/distance_from_waist settings in the gaussian source do not synchronize with beam_radius/divergence_angle settings. When sets x_min&gt;x_span in the geometry, it will report “x_span&lt;0”. When sets run_mode to None in the project, the program does not have any error prompt. When adds several waveforms in the FDTD, and selects one of mode source to calculate mode,the program will report an error. Set the frequency_profile of ModeExpansion in the FDTD finding that the result value is got from the Global monitor. EME_PSR.py reports an error:”in get_source_start_stop spatial = solver_json[ports][self.monitor_index][spatial] IndexError: list index out of range” The simulation will fail if there exists space in the project_name. When getting calculation modes results of cells in the EME, the program will report an error. FDTD runs in cloud mode, reporting an error. When set mesh type is uniform in the FDTD, it will report the inputting parameter error. The Release Log and Install Doc have not been translated into English completely. "},{"title":"V1.9.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1900","content":"Release Date: 2022/11/15 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-21","content":"meshgen: 1.0.1110.1500 FDTD: Version: 0.93.0.1 Build 1106.1945 FDE: Version: 00.08.11.1 Build: 1103.1658 EME: Version: 00.09.05.01 Build: 1009.2025 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-21","content":"Supports FDE Frequency Sweep; Supports EME Wavelength Sweep; Supports FDTD Gaussian Source; Supports FDTD Oblique Input ; Supports full type structure modeling . Notes: Compared with MOL V1.3.9 features, the V1.9.0.0 has added five new features. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-20","content":"fast_FDE.py Fixed, there are a lot of useless {} that have been output, in the cloud mode. Fixed, there are a lot of 1000010000100001 have been output, both in the local and cloud modes. Fixed, the json_body has been output in create_material method, in the cloud mode. fast_FDTD.py The origin coordinates of monitor are incorrect. The ModeExpansion result reports an error. There is no background material in the mesh.mat Adds an ME into Monitor in the mesh.json. 11 frequency points have been set in total in the GolbalMonitor, but only 5 of them exist in the Cloud. The Region of PML in the structure_show is incorrect. The mode_info of the source’s vertical axis is incorrect in the cloud mode. The vertical axis coordinates of the E field image of power monitor are incorrect, in the cloud mode. When in the local mode, it will report an error：TypeError:”passive_fdtd_mode_source_mode_info_chart() takes 5 positional arguments but 6 were given” The horizontal and vertical axes of CSV derived from ModeSource’s independent mode calculation are not absolute coordinate values, in the local mode. fast_EME.py The Cell’s boundary does not show in the structure_show. The port position is incorrect in the structure_show.(The x position of port for solver.json in the EME is incorrect.) The MeshStructure is incorrect in the independent mode calculation results. The independent mode calculation results are incorrect, and both in the local and cloud modes, the left port and right port simulation results are the same. For mode_info of port, the results of leftport and rightport are the same in the cloud mode, while the results are correct in the local mode. The Intensity images of cell_overlap/cell_s/cell_p_matrix and internal_s got by interpolation method are incorrect. The Simu[project_name].run() reports an error:AssertionError: cannot found matched dependency task! in the cloud mode The FDE_passive_parser.py reports an error in the local mode: IndexError: list index out of range. When setting the parameter of the use_full_simulation_span to Ture in the cloud mode, but it shows False on the page. The meshgen reports an error in the local mode. The mode_info of port reports an error:if mode_selection is None and args[-1] in [“TE”, “TM”], im the local mode. The meshgen warns:Edge Filling Algorithm Error, in the local mode. FDTD_HalfRing.py The run_index reports an error: ‘SimulationTaskBase’ object has no attribute ‘run_index’. ME result reports an error:The value of attribute must be in [‘T_backward’, ‘P’, ‘N’, ‘T_forward’, ‘b’, ‘a’], but t_forward is given. When setting y to -3 of run_index, its nx result is incorrect, in the local mode. ERROR:component[“background_material”] = mat_wav_recreation_list[“m”] ,in the cloud mode. The field result image of PowerMonitor at different wavelengths does not change. The meshgen prompt: WARNING: nan or inf eps at(77,15,0) PowerMonitor coordinates are incorrect, in the cloud mode. StraightWaveguide_X_FDTD_Lossy.py There is no background material of Air displayed in the structure_show. The meshgen prompt: WARNING: nan or inf eps at(77,15,0) Exp_Taper_dummy_1550_l_50.py ERROR: ‘transverse_mesh_setting.maximum_mesh_step_settings.dy is not filled’ Input is “layers” You may want to input one of (‘attrs’, ‘base’, ‘name’, ‘order’, ‘pml_layers’) The correct format name of run_index should be Exp_Taper_dummy_1550_l_50_localx_0. The size of submesh is different in local mode. There have two of mesh refinements in the mesh.json, and its data is incorrect. The start mesh_structure of cell coordinates are incorrect in the local mode. The start mode_info of port coordinates are incorrect in the cloud mode. The start mesh_structure of port coordinates are incorrect in the cloud mode. The mesh_structure of cell and mode_info results are incorrect. The mesh of run_index at x=0 results is incorrect. The horizontal axis coordinate of the EME monitor is incorrect, in the cloud mode. The S parameter is incorrect, caused by the parameter transmit wrongly. LN_EOM.py Anisotropic material reports an error: TypeError: Expected 7 arguments, got 18 When adds a LinearTrapezoid, it reports an error: TypeError: init() got an unexpected keyword argument ‘x_span’ Warning: Exception on ln_up.attrs…: &lt;maxoptics.var.models.meta.LinearTrapezoid.LinearTrapezoidAttrs object at 0x000002638BFCB7C0&gt;: expre_rotate_z=’’ is ignored. TypeError: Dimensions of C (583, 481) are incompatible with X (481) and/or Y (584); see help(pcolormesh) -The calculation mode result of border in the mesh_structure is incorrect. Ineffective warning: expre_rotate_z=’’ is ignored,etc. Ineffective output: Point coordinates LN_MMI_EME.py When adds a Pyramid, it will report an error:TypeError: init() got an unexpected keyword argument ‘x_span’ ERROR: No such file or directory: ‘e:\\develop\\js\\lonely\\maxopt_ofl\\flow\\template\\Pyramid.yaml’ When sets port to TE and TM, the result of eme_propagate:port_mode_info reports an error: passive_eme_port_mode_info_option request failed Incorrect response: {‘success’: False, ‘result’: {‘code’: 50002, ‘msg’: ‘Invalid Parameter: chec k Port 0 is TE and TM’}} Data: {‘target’: ‘intensity’, ‘pub’: {‘taskId’: 560576, ‘monitorIndex’: 0}} The title of monitor should be EME. LN_BENT_FDTD.py When adds a Pyramid, it will report an error:TypeError: init() got an unexpected keyword argument ‘x_span’ ArcWaveguide3D error: z_min = geo[“z”] - geo[“z_span”] / 2 KeyError: ‘z_span’ True is not set in the override_x_mesh/override_y_mesh/override_z_mesh,after adding submesh in the cloud mode. Grating_Coupler.py When adds a LinearTrapezoid, it will report an error: TypeError: init() got an unexpected keyword argument ‘x_span’ When adds a gaussian source, it will report an error: passive_project.create_gaussian_source waveform is necessary for initializing gaussian source Gaussian source error: ind = waveforms_id.index(waveform) ValueError: 0 is not in list Structure_show triggers an error:WARNING: nan or inf eps at (995,72,0) FDTD_Oblique_Input.py The tilt direction of the straight waveguide is opposite in the structure_show. Cloud ERROR: passive_fdtd_mode_source_mode_info_chart request failed Incorrect response: {‘success’: False, ‘result’: {‘code’: 502, ‘msg’: ‘Server Failed’}} Data: {‘target’: ‘intensity’, ‘pub’: {‘taskId’: 558051, ‘monitorIndex’: 0, ‘attribute’: ‘E’, ‘operation’: ‘ABS’}, ‘option’: {‘x’: 0, ‘y’: ‘plotX’, ‘z ‘: ‘plotY’, ‘mode’: 0}} AttributeError: ‘dict’ object has no attribute ‘dict’ EME_PSR.py The coordinates of the source mode calculation are incorrect. The coordinates of the source mode calculation in the mesh_structure are incorrect. The S parameters are incorrect caused by parameter transmit worngly. EME_SSC.py The source mode calculation result is incorrect. The coordinates of the source mode calculation in the mesh_structure are incorrect. The S parameters are incorrect caused by parameter transmit worngly. The two ports in the fde_onely are opposite. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-21","content":"FDTD S-Matrix FDE/EME/FDTD parameters sweep Data reading from json files, and public encapsulation method with searching SDK material database does not synchronize with Cloud ‘s material database with Standard, User and Project "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-21","content":"The Structure_show method does not work, when there have paramid or Arcwaveguide 3D structures in the modeling script. The results of EME and FDTD’s anisotropy are incorrect, caused by LN material parameter wrongly transmit. The FDTD S-Matrix feature has not been verified. There have gaps for structure boundary in the mode calculation result. There has a slight difference of V1.9.0.0 fast_FDTD results in the local and cloud mode with localSDK V1.3.9’s results got in local mode. The title of EME monitor in the result image should be EME. Logic adjustment of back-end parameters to front-end page: The processing logic needs to be clarified, when the mesh type/grading factor/background_ Material exists in both Structure and Simulation. The processing logic needs to be clarified, when the boundary conditions are set in both OBoundary and Simulation, The types of boundary conditions that can be used in FDE/EME and FDTD are different. For example, FDE/EME supports symmetric and antisymmetric boundary conditions, while FDTD does not. At present, no comprehensive verification has been done The boundary conditions can be set in different ways between FDE/EME and FDTD. For example, there is only one PML parameter for FDE/EME, while FDTD supports setting x/y/z’s PML parameters separately. The logic needs to be clarified,in which the must inputting options have no default values. Because of the old version used in the development process, after the new version parameter list is completed, the configuration check of the default value of the must-inputting options is only partially checked, not completely checked. The inkage between parameterslogic has not been completely checked and verified. Due to the support of Python 3.8 for TypingCheck is not good, the implemented spelling check cannot continue to be supported, and will be closed in the next version. Currently， the user cannot know the parameter assignment error in the IDE, and can only view the output in the command line window to check the error. The display of similar materials of the index is not obvious, due to the RGB color of structure_show in the user’s setting material being set according to the index’s real and imaginary auto RGB assignment method. For the result import feature,the feature of auto judgment and creation of the path address of the import file has been developed but wait to be verified. Currently, the run_ index method is based on the 2D mesh created by FDE. When the script is run in cloud mode and viewed in cloud server, finding that there has no results for the index monitor in the result tree. (FDE does not support IndexMonitor in the cloud server) The run index and calculate mode methods will create projects separately according to names passed in, which is not convenient to view in the CloudServer. The lack of timestamp of project_name in the script will override previous local simulation results. There is no limitation for geometry, only (x,x_span) or (x,x_span) can be input, and its linkage logic has not been verified. The method of inputting wavelength_min and wavelength_max into waveform and monitor and inputting frequency method has not been verified. The waist_radius/distance_from_waist settings in the gaussian source do not synchronize with beam_radius/divergence_angle settings. "},{"title":"Modulator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/Active_Device/MOD/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#introduction","content":"​We have developed an electro-optic modulator based on carrier-depletion mechanism in silicon to simulate carrier and index distribution in a global structure. The drift and diffusion of carriers result in depletion at the PN junction. Applying a reverse bias voltage at the cathode broadens the depletion region, altering the carrier concentration and modulating the material's refractive index. Gaussian doping was employed in this model. Modulation efficiency, capacitance, and resistance were calculated to analyze the electro-optic characteristics of the modulator. ​The figure below illustrates the device structure we constructed, wherein the aluminum electrode is applied to the silicon modulator, and the entire device is encapsulated with silicon dioxide material.  "},{"title":"Simulation Structure​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#simulation-structure","content":"​The present structural file provides a comprehensive guide for constructing a simulation structure and establishing a Gaussian doping distribution. Initially, one must construct the geometric structure of the device, incorporate materials and physical models, specify the doping distribution, and simulation boundary conditions, and set the light source and simulation solver. Eventually, the simulation result data should be extracted and output. ​Our simulation is designed with a light source entering along the X-axis, and the primary optoelectronic characteristic analysis takes place within the three-dimensional structure on the YZ plane. The FDE solver is utilized to preview the distribution of effective refractive index, and the OEDevice solver is used to preview the doping distribution of the device. Finally, we generate ad output the distribution map of doping and index in modulator structure. Application Library path: :\\SDK\\V2.3.0.4\\examples\\active_demo\\doping_function\\MOD\\MOD00_structure.py "},{"title":"1. Basic Operations​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#1-basic-operations","content":"It is essential to incorporate materials for structure. Although module of maxoptics_sdk.all provides default values for standard semiconductors, these values can be customized in MOD_material.py . Application Library path: :\\SDK\\V2.3.0.4\\examples\\active_demo\\doping_function\\MOD\\MOD_material.py The module of basic specifies the electron affinity and relative dielectric permittivity of the material. It is crucial to define the model type and parameter values, if another model is used instead of the default. The default mobility model of Silicon is Analytic , but we use the mobility model of Masetti in this modulator. The band module includes the model of bandgap, bandgap narrowing , and recombination of Auger, SRH, and Radiative. elec_Si_properties = {&quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.2-1.11452/2.0, &quot;permitti&quot;: 11.7}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Masetti&quot;, &quot;Masetti&quot;: {&quot;mu_min2_h&quot;: 44.9, &quot;mumax_e&quot;: 1471, &quot;mumax_h&quot;: 470.5, &quot;pc_h&quot;: 0}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;dos_formula&quot;: 2, &quot;nc300&quot;: 3.21657e19, &quot;nv300&quot;: 1.82868e19, # Bandgap &quot;eg0&quot;: 1.16, &quot;chi0&quot;: 4.2-1.16/2, # Bandgap Narrowing &quot;bgn_model&quot;: &quot;OldSlotboom&quot;, &quot;e0_bgn_oldslotboom&quot;: 0.0045, &quot;n0_bgn_oldslotboom&quot;: 1.00e17, &quot;deg0_oldslotboom&quot;: 0, # Auger Recombination &quot;augan&quot;: 2.8e-31, &quot;augap&quot;: 9.9e-32, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 3.3e-6, &quot;taupmax&quot;: 4e-6, &quot;nsrh_n&quot;: 7.1e15, &quot;nsrh_p&quot;: 7.1e15, &quot;nc_f&quot;: 1.5, &quot;nv_f&quot;: 1.5, # Radiative Recombination &quot;c_direct&quot;: 1.6e-14,}, &quot;print&quot;: 1}}  The parameter values of matparas_1550 and matparas_1310 are used for converting carrier distribution to a change in refractive index. matparas_1550 = { &quot;dn_an&quot;: -8.8e-22, &quot;dn_en&quot;: 1, &quot;dn_ap&quot;: -8.5e-18, &quot;dn_ep&quot;: 0.8, &quot;dalpha_an&quot;: 8.5e-18, &quot;dalpha_en&quot;: 1, &quot;dalpha_ap&quot;: 6.0e-18, &quot;dalpha_ep&quot;: 1 } matparas_1310 = { &quot;dn_an&quot;: -6.2e-22, &quot;dn_en&quot;: 1, &quot;dn_ap&quot;: -6e-18, &quot;dn_ep&quot;: 0.8, &quot;dalpha_an&quot;: 6e-18, &quot;dalpha_en&quot;: 1, &quot;dalpha_ap&quot;: 4e-18, &quot;dalpha_ep&quot;: 1 }  "},{"title":"2. Code description​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#2-code-description","content":"2.1 Import Modules​ To begin, we need to use the import command to call the relevant functional modules and parameter values of material from previously defined file. import maxoptics_sdk.all as mo import os import time from maxoptics_sdk.helper import timed from pathlib import Path from MOD_material import matparas_1550, matparas_1310, elec_Si_properties  2.2 Define Parameters​ 2.2.1 General Parameters​ We define these parameters for entire simulation process. wavelength = 1.31 egrid_local = 0.01 ogrid_global_y = 0.02 ogrid_global_z = 0.02 ogrid_local = 0.002 temperature = 300 normal_length = 10000 ssac_amplitude = 0.001 # V run_mode = &quot;local&quot; simu_name = &quot;MOD00_struc&quot;  Parameter\tUnits\tDescriptionwavelength\tum\tSpecifies the optical wavelength of the source beam (in the vacuum) for mono-spectral simulations. egrid_loacal\tum\tSpecifies the appropriate size of mesh in the Y and Z direction for overall region of OEDevice simulation. ogrid_global_y\tum\tSpecifies the mesh spacing in the Y direction for region of optical simulation. ogrid_global_z\tum\tSpecifies the mesh spacing in the Z direction for region of optical simulation. ogrid_local\tum\tSpecifies the mesh spacing in the Y and Z direction for local region of optical simulation. temperature\tK\tSpecifies the temperature in Kelvin. normal_length\tum\tSpecifies the extent of a mesh section in the X direction. ssac_amplitude\tV run_mode Specifies the simulate model. simu_name Specifies this file name to define name of output result folder. Since we explore two communication wavelength, you should define the wavelength, and use next code to choose relavent parameters values, which we defines in MOD_material.py . if wavelength &gt; 1.4: Si_index_vs_doping = matparas_1550 else: Si_index_vs_doping = matparas_1310  2.2.2 Structure Geometry​ You should define the location of material in X, Y and Z direction about the modulator structure. st_x_min = -0.3 st_x_max = 0.3 st_x_mean = 0.5*(st_x_min+st_x_max) st_x_span = st_x_max-st_x_min st_y_min = -5 st_y_max = 5 st_y_mean = 0.5*(st_y_min+st_y_max) st_y_span = st_y_max-st_y_min st_z_min = -0.3 st_z_max = 0.8 slab_height = 0.09 rg_height = 0.22 rg_width = 0.5 elec_height = 0.5 elec_width = 1.2  Parameter\tUnits\tDescriptionx_min, x_max, y_min, y_max, z_min, z_max\tum\tSpecifies the minimum or maximum value in X/Y boundary of modulator structure. x_mean, x_span, y_mean, y_span, z_mean, z_span\tum\tSpecifies the center or spacing value in X/Y boundary of modulator structure. slab_height\tum\tSpecifies the height of slab layer in Z direction. rg_height\tum\tSpecifies the height of RG layer in Z direction. elec_height, elec_width\tum\tSpecifies the Z-direction height and Y-direction width of electron. 2.2.3 Electrical Simulation Boundary​ Specifies the boundary of electrical simulation for OEDevice solver in 3D direction. oe_x_min = -0.3 oe_x_max = 0.3 oe_x_mean = 0.5*(oe_x_min+oe_x_max) oe_x_span = oe_x_max-oe_x_min oe_y_min = -4.9 oe_y_max = 4.9 oe_y_mean = 0.5*(oe_y_min+oe_y_max) oe_y_span = oe_y_max-oe_y_min oe_z_min = -0.3 oe_z_max = 0.8 oe_z_mean = 0.5*(oe_z_min+oe_z_max) oe_z_span = oe_z_max-oe_z_min  Specifies the concentration of uniform doping by constant_con and its boundary throuth center and span in Y-Z plane. constant_y_center = 0 constant_y_span = 10 constant_z_center = 0.1 constant_z_span = 0.3 constant_con = 1e15  Specifies the junction width and peak concentration of gaussian doping by_jw and _con , its boundary throuth center and span in Y-Z plane of slab. p_slab_y_center = -2.575 p_slab_y_span = 4.85 p_slab_z_center = -0.105 p_slab_z_span = 0.39 p_slab_jw = 0.1 p_slab_con = 7e17 n_slab_y_center = 2.575 n_slab_y_span = 4.85 n_slab_z_center = -0.105 n_slab_z_span = 0.39 n_slab_jw = 0.1 n_slab_con = 5e17  Specifies the doping region of high concentration in slab layer, including boundary、junction width and peak concentration. p_plus_y_center = -3.5 p_plus_y_span = 3 p_plus_z_center = -0.04 p_plus_z_span = 0.52 p_plus_jw = 0.1 p_plus_con = 1e19 n_plus_y_center = 3.5 n_plus_y_span = 3 n_plus_z_center = -0.04 n_plus_z_span = 0.52 n_plus_jw = 0.1 n_plus_con = 1e19  Specifies the doping region of high concentration in waveguide structure, including boundary、junction width and peak concentration. p_wg_y_center = -0.12 p_wg_y_span = 0.36 p_wg_z_center = 0.1275 p_wg_z_span = 0.255 p_wg_jw = 0.12 p_wg_con = 5e17 n_wg_y_center = 0.105 n_wg_y_span = 0.29 n_wg_z_center = 0.12 n_wg_z_span = 0.235 n_wg_jw = 0.11 n_wg_con = 7e17  2.2.4 Optical simulation Boundary​ Specifies the boundary of optical simulation for FDE solver in 3D direction. We only consider optical characteristic of Y-Z plane, since the light travels along X-axis. x_min = 0 x_max = 0 x_mean = 0.5*(x_min+x_max) x_span = x_max-x_min y_min = -2.3 y_max = 2.3 y_mean = 0.5*(y_min+y_max) y_span = y_max-y_min z_min = -1.5 z_max = 1.5 z_mean = 0.5*(z_min+z_max) z_span = z_max-z_min  2.3 Define Engineering Function​ To facilitate the calling of other simulation scripts, it is recommended to define a function that can set materials, model, dope, and add boundary conditions. 2.3.1 Create Project​ Create a new simulation project. def mod_project(project_name, run_mode, st_type): pj = mo.Project(name=project_name, location=run_mode)  2.3.2 Set Material​ The electrical and optical parameters of SiO2、Al and Si materials in the material library can be accessed. If the parameters defined in the Si section of MOD_material.py are different from the default parameters in the material library, the former will be prioritized. In the overlapping area of the materials, the material with a higher order value will take precedence over the one with a lower value. If the values are the same, the material defined later will override the one defined earlier. It is worth noting that the material Aluminium will call the PEC material library. mt = pj.Material() mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_lib(name=&quot;mat_al&quot;, data=mo.OE_Material.Al, order=2) mt.add_lib(name=&quot;mat_si&quot;, data=mo.OE_Material.Si, order=2, override=elec_Si_properties) mt[&quot;mat_sio2&quot;].set_optical_material(data=mo.Material.SiO2_Palik) mt[&quot;mat_si&quot;].set_optical_material(data=mo.Material.Si_Palik) mt[&quot;mat_al&quot;].set_optical_material(data=mo.Material.PEC)  2.3.3 Define structure​ To begin with, it is advisable to define the geometric region of the device structure in geometry and add materials to this region by material. The background material, which is usually Air or SiO2, should be added first.  st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.4, background_material=mt[&quot;mat_sio2&quot;]) st.add_geometry(name=&quot;BOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z_min&quot;: st_z_min, &quot;z_max&quot;: slab_height}}) st.add_geometry(name=&quot;SOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: st_z_max}}) st.add_geometry(name=&quot;Slab&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z_min&quot;: 0, &quot;z_max&quot;: slab_height}}) st.add_geometry(name=&quot;Rg&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: 0, &quot;y_span&quot;: rg_width, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: rg_height}})  Parameter\tUnits\tDescriptionname Restricts the applicability of the statement to regions with the specified name. material Restricts the applicability of the statement to regions of the specified material. type Specifies the geometry of specified region. geometry Specifies the boundary of specified region in 3D direction We offer several alternative electrode region for establishing the electrical simulation area. if st_type == &quot;normal&quot;: st.add_geometry(name=&quot;Anode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_min, &quot;y_max&quot;: st_y_min + elec_width, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) st.add_geometry(name=&quot;Cathode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_max - elec_width, &quot;y_max&quot;: st_y_max, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) elif st_type == &quot;slab_N&quot;: st.add_geometry(name=&quot;Cathode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_max - elec_width, &quot;y_max&quot;: st_y_max, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) st.add_geometry(name=&quot;Ground&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: rg_width, &quot;z_min&quot;: 0, &quot;z_max&quot;: rg_height}}) elif st_type == &quot;slab_P&quot;: st.add_geometry(name=&quot;Anode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_min, &quot;y_max&quot;: st_y_min + elec_width, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) st.add_geometry(name=&quot;Ground&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: rg_width, &quot;z_min&quot;: 0, &quot;z_max&quot;: rg_height}}) else: print(&quot;st_type must be chosen from 'normal', 'slab_N', 'slab_P'&quot;) raise  2.3.4 Add Doping​ You should define the basic parameters of doping module, such as type、region and model. Then define source face、junction width、peak concentration and reference concentration in gaussian doping, or only concentration in uniform doping. type specifies the n-type or donor dopant in &quot;n&quot; , and p-type or acceptor dopant in &quot;p&quot; , which may be used with gaussian and uniform profile types. ref_concentration specifies the diffusion boundary of Gaussian doping. st.add_doping(name=&quot;background_doping&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: constant_y_center, &quot;y_span&quot;: constant_y_span, &quot;z&quot;: constant_z_center, &quot;z_span&quot;: constant_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: constant_con}}) st.add_doping(name=&quot;p_slab&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: p_slab_y_center, &quot;y_span&quot;: p_slab_y_span, &quot;z&quot;: p_slab_z_center, &quot;z_span&quot;: p_slab_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_slab_jw, &quot;concentration&quot;: p_slab_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;n_slab&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: n_slab_y_center, &quot;y_span&quot;: n_slab_y_span, &quot;z&quot;: n_slab_z_center, &quot;z_span&quot;: n_slab_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: n_slab_jw, &quot;concentration&quot;: n_slab_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;p_plus&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: p_plus_y_center, &quot;y_span&quot;: p_plus_y_span, &quot;z&quot;: p_plus_z_center, &quot;z_span&quot;: p_plus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_plus_jw, &quot;concentration&quot;: p_plus_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;n_plus&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: n_plus_y_center, &quot;y_span&quot;: n_plus_y_span, &quot;z&quot;: n_plus_z_center, &quot;z_span&quot;: n_plus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: n_plus_jw, &quot;concentration&quot;: n_plus_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;p_wg&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: p_wg_y_center, &quot;y_span&quot;: p_wg_y_span, &quot;z&quot;: p_wg_z_center, &quot;z_span&quot;: p_wg_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;lower_y&quot;, &quot;junction_width&quot;: p_wg_jw, &quot;concentration&quot;: p_wg_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;n_wg&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: n_wg_y_center, &quot;y_span&quot;: n_wg_y_span, &quot;z&quot;: n_wg_z_center, &quot;z_span&quot;: n_wg_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_y&quot;, &quot;junction_width&quot;: n_wg_jw, &quot;concentration&quot;: n_wg_con, &quot;ref_concentration&quot;: 1e6}})  2.3.5 Set Optical Simulate Boundry​ You should set the boundry of optical simulation for FDE solver. st.OBoundary(property={ &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;y&quot;: y_mean, &quot;z&quot;: z_mean, &quot;x_span&quot;: x_span, &quot;y_span&quot;: y_span, &quot;z_span&quot;: z_span}, &quot;boundary&quot;: {&quot;y_min&quot;: &quot;PEC&quot;, &quot;y_max&quot;: &quot;PEC&quot;, &quot;z_min&quot;: &quot;PEC&quot;, &quot;z_max&quot;: &quot;PEC&quot;}})  2.3.6 Add Mesh​ When specifying meshes, a balance should be struck between accuracy and numerical efficiency. The accuracy, convergence, and program memory of the subsequent computation are all affected by the quality and size of the elements in the mesh, making mesh partitioning crucial in this module. Achieving accuracy requires a fine mesh that can resolve all significant features of the solution, while numerical efficiency requires a coarse mesh that minimizes the total number of grid points. Due to the relatively simple structure of this modulator, a rough initial mesh can be established for electrical and optical simulation of the entire device. In order to obtain more accurate calculation results and better convergence, the emesh module is employed to refine the mesh of the regions with significant electrical characteristics. st.add_mesh(name=&quot;OMesh_Local&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;x_span&quot;: x_span, &quot;y&quot;: 0, &quot;y_span&quot;: 2*rg_width, &quot;z_min&quot;: -0.5*rg_height, &quot;z_max&quot;: 1.5*rg_height}, &quot;general&quot;: {&quot;dy&quot;: ogrid_local, &quot;dz&quot;: ogrid_local}}) st.add_emesh(name=&quot;EMesh_Local&quot;, property={ &quot;y_min&quot;: st_y_min, &quot;y_max&quot;: st_y_max, &quot;z_min&quot;: st_z_min, &quot;z_max&quot;: st_z_max, &quot;mesh_size&quot;: egrid_local})  2.3.7 Structure Preview Result File​ You should call the previous defined simulation module and define the name and path of the output file. Through invoking the time module and adding it to the file name, the output file of each simulation can be unique, which facilitates accurate file retrieval after multiple simulations. The plot_path will be used as the path for saving extracted results and is set here to the plots folder in the same directory as the script. If this path does not exist, the os.makedirs function needs to be called to create the path. return pj time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) @timed def preview(): pj = mod_project(project_name=simu_name + time_str, run_mode=&quot;local&quot;, st_type=&quot;normal&quot;) plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)  2.3.8 Set Simulate Solver​ Adding electrical and optical silmulation solver, is the prerequisite for output structure file. You can specify solver name and type in name and type module, and then define its other property. The type of AFDE is finite difference eigenmode (FDE) simulation module for active devices, which can be used to investigate the refractive index distribution of a device. This solver solves the single-frequency Maxwell's equations directly on a discretized grid of the waveguide cross-section, enabling exploration of the refractive index distribution of the device. The FDE analysis module can then be used to set the boundary conditions, define the model, mesh structure, and wavelength of the light source for calculation. The type of OEDevice module can be invoked to enable the charge carrier transport solver for analyzing the optoelectronic properties of a device. Since the simulation analysis is conducted in the two-dimensional Y-Z plane that is perpendicular to the X-axis, 2d_x_normal is adopted to define the simulation calculation geometry. We utilize the Newton iteration method for calculation, and the MUMPS direct solver is employed as the linear solver. The max_iterations parameter defines the maximum number of nonlinear iterations. When the number of iterations exceeds this value, the solver reduces the voltage step and starts a new iterative computations. Additionally, we define the length of the three-dimensional X direction and the solution mode and temperature during the composite process. For this study, we set the solver to solve the steady state of the device at room temperature. simu = pj.Simulation() simu.add(name=&quot;preview_fde&quot;, type=&quot;AFDE&quot;, property={ &quot;mesh_settings&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: ogrid_global_y, &quot;dz&quot;: ogrid_global_z}}, &quot;fde_analysis&quot;: {&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: False, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength}, &quot;modulator_analysis&quot;: {&quot;modulator_analysis&quot;: True, &quot;wavelength&quot;: wavelength, &quot;np_path&quot;: &quot;&quot;}}, &quot;other&quot;: {**Si_index_vs_doping}}) simu.add(name=&quot;preview_oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  You can invoke the FDE module to analyze the refractive index distribution of the device. To define the region of the refractive index distribution to be extracted in geometry , which is the coordinate in the two-dimensional Y-Z plane at X-axis equal to 0. Then, define the file name of the result image and save it to the &quot;plot&quot; folder. ​To analyze the doping distribution of the device, the OEDevice module can be invoked. First, define the region from which to extract the refractive index distribution, which is the coordinate in the two-dimensional Y-Z plane where the X-axis equals 0. Then, define the file name for the resulting image and save it to the &quot;plot&quot; folder. Additionally, save the simulation process to the &quot;log&quot; folder in the &quot;project&quot; directory. simu[&quot;preview_oedevice&quot;].run_doping(name=&quot;x_in&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}}, norm=&quot;log&quot;, scale=&quot;equal&quot;, superimpose=False, show=False, material_list=[&quot;Si&quot;], cmin=8e14, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;doping&quot;) simu[&quot;preview_fde&quot;].run_index(name=&quot;index_preview_x_0&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.3, &quot;z_span&quot;: 1}}, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;Index&quot;, export_csv=False, show=False)  "},{"title":"3. Output Result​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#3-output-result","content":"​Here, we present the device geometry as defined in the structure file, along with the P-type and N-type dopant distributions, and the overall doping distribution. ​Application Library path: :examples\\active_demo\\doping\\MOD\\plots\\MOD00_struct_time\\doping Boron Active Doping\tNet Doping\tPhosphorus Active Doping  ​ We can see the distribution of the refractive index in these three directions of device. ​ Application Library path: :examples\\active_demo\\doping\\MOD\\plots\\MOD00_struct_time X-axis\tY-axis\tZ-axis  "},{"title":"Analytic Character​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#analytic-character","content":""},{"title":"1.Modulation efficiency​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#1modulation-efficiency","content":"​The half-wave voltage refers to the applied voltage required by the modulator's optical signal to generate a phase difference of pi radians, directly reflecting the modulation efficiency of the modulator. Usually, the modulation efficiency of a device is represented by multiplying the half-wave voltage with a parameter that represents the length of the modulator required for phase variation. A smaller value of this parameter indicates higher modulation efficiency, resulting in a smaller required device size. ​Application Library path: :\\examples\\active_demo\\doping_function\\MOD\\MOD0A_vpi.py 1.1 Basic Operations​ ​Before analyzing the characteristic parameters of the device, you need to set up the simulation environment in advance and invoke the modules into the file by import . Please refer to the PD documentation for detailed instructions on specific Python commands. 1.2 Code Description​ 1.2.1 Import Modules​ ​To begin, we need to use the import command to call the relevant functional modules. from MOD00_structure import * import time import os from pathlib import Path import numpy as np import sys from matplotlib import pyplot as plt import warnings  ​For specific instructions, see the description document of PD device. ​By adding the runtime function module to the file name, you can ensure the orderly storage of simulation results without data overlay or overwriting during multiple simulation runs. start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime())  1.2.2 Define Parameters​ ​The operational mechanism of the device we simulated in this study primarily revolves around the application of a reverse voltage to modify the width of the depletion region, thereby effectively modifying the carrier concentration and subsequently modulating the refractive index. Hence, it is necessary to specify the voltage of initial、termination and step, with both parameters expressed in volts. It is important to note that vpi_vswing is twice the value of tcad_vstep . tcad_vmin = -0.5 tcad_vmax = 4 tcad_vstep = 0.5 vpi_vswing = 1.0  1.2.3 Set Path​ ​You could define the project name of path, and then define the parameters for path. simu_name = &quot;MOD0A_vpi&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path) neff_real_folder = plot_path + project_name + &quot;neffreal&quot; neff_imag_folder = plot_path + project_name + &quot;neffimag&quot; loss_folder = plot_path + project_name + &quot;loss&quot; vpil_folder = plot_path + project_name + &quot;vpil&quot; vpiloss_folder = plot_path + project_name + &quot;vpiloss&quot;  1.2.4 Confirm swing of voltage​ ​According to the phase change formula, we can determine that the refractive index n is a function of bias voltage, which means that we can change the refractive index of the material by adjusting the bias voltage. To achieve a more precise approximation curve for n-V, we set the vpi_vswing parameter to specify the voltage spacing before and after the voltage transitions, allowing us to make judgments based on user-defined parameters. Δφ=2πλΔn(V)L=2πλdndVΔVL\\Delta\\varphi=\\frac{2\\pi}{\\lambda}\\Delta n(V)L\\\\=\\frac{2\\pi}{\\lambda}\\frac{dn}{dV}\\Delta VLΔφ=λ2π​Δn(V)L=λ2π​dVdn​ΔVL ​With the following formula, when the phase difference is pi: ΔVπL=ΔVΔnλ2\\Delta V_\\pi L=\\frac{\\Delta V}{\\Delta n}\\frac{\\lambda}{2}ΔVπ​L=ΔnΔV​2λ​ di = int(np.round(np.abs(vpi_vswing/tcad_vstep/2))) # Count dot num between volt of vpi and neff. if di &lt; 1: sys.exit(&quot;\\x1b[6;30;41m&quot; + &quot;\\nError: vpi_swing must be &gt;= tcad_vstep.&quot; + &quot;\\x1b[0m&quot;) if np.abs((np.abs(vpi_vswing)-np.abs(di*tcad_vstep*2))/tcad_vstep) &gt; 0.01: warnings.warn(&quot;\\x1b[6;30;43m&quot; + &quot;\\n[Warning: vpi_swing is %(t)sV in program]&quot; % {&quot;t&quot;: di*2*tcad_vstep} + &quot;\\x1b[0m&quot;, UserWarning)  1.2.5 Create Component​ ​You can specify the physical attributes of an electrode. You can set the BC model and scanning method here. The bias voltage range is set for steady-state solutions, and the AC small signal switch is disabled. Detailed information about the Electrode attribute can be found in the appendix of the PD documentation. pj = mod_project(project_name, run_mode, st_type=&quot;normal&quot;) st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  1.2.6 Set Simulation​ ​You can add a physical model solver here. simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}}) simu.add(name=&quot;fde&quot;, type=&quot;AFDE&quot;, property={ &quot;mesh_settings&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: ogrid_global_y, &quot;dz&quot;: ogrid_global_z}}, &quot;fde_analysis&quot;: {&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: False, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength}, &quot;modulator_analysis&quot;: {&quot;modulator_analysis&quot;: True, &quot;wavelength&quot;: wavelength, &quot;mode_select&quot;: 0, &quot;np_path&quot;: &quot;&quot;}}, &quot;other&quot;: {**Si_index_vs_doping}})  1.2.7 Run​ ​It is recommended to include a module that runs the solver and initiates the simulation. The result_device variable stores simulation results for subsequent extraction. result_device = simu[&quot;oedevice&quot;].run() result_fde = simu[&quot;fde&quot;].run()  1.2.8 Extract Parameters​ ​You can extract and export simulation results to the plot folder. result_fde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;real&quot;, show=False, savepath=plot_path + project_name + &quot;neffreal&quot;) result_fde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;imag&quot;, show=False, savepath=plot_path + project_name + &quot;neffimag&quot;) result_fde.extract(data=&quot;loss&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;loss&quot;) result_fde.extract(data=&quot;vpil&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;vpil&quot;) result_fde.extract(data=&quot;vpiloss&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;vpiloss&quot;)  1.2.9 Calculate​ ​This section of the program is dedicated to calculating the parameters VpiL and VpiLoss. ​You should first extract the parameters for transmission loss and the real part of effective refractive index. ​The filename 0_effective index_Real.csv is automatically generated for the n-V data file. The initial 0 indicates the electrode number, which changes when extracting current from different electrodes. Therefore, iterate from 0 to 9 to locate the saved n-V data files. neff_file = os.path.join(neff_real_folder, &quot;0_effective index_Real.csv&quot;) loss_file = os.path.join(loss_folder, &quot;0_loss_Real.csv&quot;) for i in range(10): neff_file = os.path.join(neff_real_folder, str(i) + &quot;_effective index_Real.csv&quot;) if os.path.exists(neff_file): break for i in range(10): loss_file = os.path.join(loss_folder, str(i) + &quot;_loss_Real.csv&quot;) if os.path.exists(loss_file): break rawdata = np.genfromtxt(neff_file, skip_header=3, delimiter=',') neff = rawdata[:,1] volt = rawdata[:,0] rawdata = np.genfromtxt(loss_file, skip_header=3, delimiter=',') loss = rawdata[:,1]  ​Generate the relationship curve and data file for the product of half-wave voltage and effective modulation length (VpiL), the product of half-wave voltage and loss (VpiLoss), as well as VBias, and save them in the respective newly created files. vpil = [] volt_out = [] vpiloss = [] for i in range(di, len(volt)-di): volt_out.append(volt[i]) vpil.append((volt[i+di]-volt[i-di])/(neff[i+di]-neff[i-di])*wavelength/2*1e-4) vpiloss.append(vpil[-1]*loss[i]) vpil_file = os.path.join(vpil_folder, &quot;0_VpiL_Real.csv&quot;) vpil_pic = os.path.join(vpil_folder, &quot;0_VpiL_Real.png&quot;) vpiloss_file = os.path.join(vpiloss_folder, &quot;0_VpiLoss_Real.csv&quot;) vpiloss_pic = os.path.join(vpiloss_folder, &quot;0_VpiLoss_Real.png&quot;) if not os.path.exists(vpil_folder): os.makedirs(vpil_folder) if not os.path.exists(vpiloss_folder): os.makedirs(vpiloss_folder) np.savetxt(vpil_file, np.array((volt_out, vpil)).T, fmt='%f,%.15f', header='voltage,VpiL') np.savetxt(vpiloss_file, np.array((volt_out, vpiloss)).T, fmt='%f,%.15f', header='voltage,VpiLoss')  ​You can use the following program to set up the title and style of the picture. fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(volt_out, vpil, 'b', linewidth=linewidth, label=&quot;VpiL&quot;) ax.plot(volt_out, vpil, 'bo') ax.set_xlabel('VBias[V]') ax.set_ylabel('VpiL[V·cm]') plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1, 2)) ax.grid() plt.savefig(vpil_pic) plt.close() fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(volt_out, vpiloss, 'b', linewidth=linewidth, label=&quot;VpiLoss&quot;) ax.plot(volt_out, vpiloss, 'bo') ax.set_xlabel('VBias[V]') ax.set_ylabel('VpiLoss[V·dB]') plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1, 2)) ax.grid() plt.savefig(vpiloss_pic) plt.close() # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)  1.3 Output Result​ ​Application Library path: :\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD0A_vpi_local_time 1.3.1 Loss​ ​This section displays the variation of losses with bias voltage. 1.3.2 Effective Index​ ​These graphs depict the real and imaginary components of the refractive index as a function of bias voltage. Reffective index real\tReffective index imaginary\t 1.3.3 Modulation efficiency​ ​ These graphs illustrate the relationship between two parameters that represent modulation efficiency as a function of bias voltage. VpiL\tVpiLoss\t "},{"title":"2. Capacitance And Resistance​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#2-capacitance-and-resistance","content":"​Capacitance and resistance play crucial roles in determining the performance of devices. Optimal capacitance values enable the modulator to selectively allow or block signals within specific frequency ranges, facilitating signal coupling. Suitable resistance values enable adjustment of signal amplitude and modulation current determination. ​Application Library path: :\\examples\\active_demo\\doping_function\\MOD\\MOD0B_RC.py 2.1 Basic Operations​ ​The simulation program for calculating capacitance and voltage exhibits numerous similarities to the program used for investigating modulation efficiency. Prior to conducting the simulation, it is necessary to import the module in order to invoke the structures and physical models defined in the structure.py . 2.2 Code Description​ 2.2.1 Import Modules​ ​The necessary Python modules for the program are invoked within the process. from MOD00_structure import * import time import os from pathlib import Path import re import numpy as np from matplotlib import pyplot as plt  2.2.2 Define Parameters​ ​The voltages to be applied to the electrodes of the device are specified. tcad_vmin = -0.5 tcad_vmax = 4 tcad_vstep = 0.5  2.2.3 Set Path​ ​You can use the time module for file naming conventions and then store the files in the &quot;plots&quot; folder. start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) simu_name = &quot;MOD0B_RC&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)  2.2.4 Create Component​ ​You can directly invoke the engineering function and device structure created in the structure.py file, and then add the electrodes and their attributes. In this case, a bias voltage ranging from -0.5 V to 4 V with a scan step of 0.5 V is applied to the cathode electrode during small-signal simulation. pj = mod_project(project_name, run_mode, st_type=&quot;normal&quot;) st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;All&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  2.2.5 Set Simulation​ ​You can add a solver for the simulation and define its properties. Furthermore, the properties of the AC small-signal module are defined in this section. The frequency interval is logarithmically defined, specifying the initial frequency, final frequency, and the number of frequencies. The variable ssac_amplitude&quot; represents the amplitude of the small signal. In this instance, three frequency values (1, 100, and 10000 MHz) are selected from the range of 1e6 to 1e10. simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;SSAC&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;small_signal_ac&quot;: {&quot;frequency_spacing&quot;: &quot;log&quot;, &quot;log_start_frequency&quot;: 1e6, &quot;log_stop_frequency&quot;: 1e10, &quot;log_num_frequency_points&quot;: 3, &quot;perturbation_amplitude&quot;: ssac_amplitude}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  2.2.6 Run​ ​It is recommended to include a module to execute the solver and commence the simulation. result_device = simu[&quot;oedevice&quot;].run()  2.2.7 Extract Parameters​ ​Firstly, the names of the folders used to store the extracted data for the real and imaginary components of the refractive index should be defined. Iac_real_folder = plot_path + project_name + &quot;Iac_real&quot; Iac_imag_folder = plot_path + project_name + &quot;Iac_imag&quot; result_device.extract(data=&quot;Iac&quot;, electrode=&quot;cathode&quot;, operation=&quot;real&quot;, export_csv=True, show=False, savepath=Iac_real_folder) result_device.extract(data=&quot;Iac&quot;, electrode=&quot;cathode&quot;, operation=&quot;imag&quot;, export_csv=True, show=False, savepath=Iac_imag_folder)  ​Secondly, the following program can be used to define the output files for the real and imaginary parts of the refractive index, as well as the capacitance and resistance, while also specifying the data content within the files and ensuring proper attention to the frequency units. Iac_real_files = [] Iac_imag_files = [] resistance_files = [] capacitance_files = [] file_regex = r&quot;([0-9]+)_Iac_Real_(.*)\\.csv&quot; for file in os.listdir(Iac_real_folder): if re.match(file_regex, file, re.I): search_group = re.search(file_regex, file, re.I) if search_group != None: Iac_real_files.append(file) Iac_imag_files.append(search_group.group(1) + &quot;_Iac_Imaginary_&quot; + search_group.group(2) + &quot;.csv&quot;) resistance_files.append(search_group.group(1) + &quot;_Resistance_&quot; + search_group.group(2) + &quot;.csv&quot;) capacitance_files.append(search_group.group(1) + &quot;_Capacitance_&quot; + search_group.group(2) + &quot;.csv&quot;) resistance_folder = plot_path + project_name + &quot;Resistance&quot; capacitance_folder = plot_path + project_name + &quot;Capacitance&quot; if not os.path.exists(resistance_folder): os.makedirs(resistance_folder) if not os.path.exists(capacitance_folder): os.makedirs(capacitance_folder) for i in range(len(Iac_real_files)): Iac_real_file = os.path.join(Iac_real_folder, Iac_real_files[i]) Iac_imag_file = os.path.join(Iac_imag_folder, Iac_imag_files[i]) resistance_file = os.path.join(resistance_folder, resistance_files[i]) capacitance_file = os.path.join(capacitance_folder, capacitance_files[i]) Iac_real_data = np.genfromtxt(Iac_real_file, skip_header=3, delimiter=&quot;,&quot;) Iac_imag_data = np.genfromtxt(Iac_imag_file, skip_header=3, delimiter=&quot;,&quot;) with open(Iac_real_file, 'r') as fp: line = fp.readline() line = fp.readline() frequency = float(re.search(r&quot;.*frequency=(.*)\\[MHz\\]&quot;, line, re.I).group(1))*1e6 if len(Iac_real_data.shape) &lt; 2: Iac_real_data.reshape((1, len(Iac_real_data))) Iac_imag_data.reshape((1, len(Iac_imag_data)))  2.2.8 Calculate​ ​Subsequently, the capacitance and voltage can be calculated based on the current and voltage data that have been read.  Vdc = Iac_real_data[:,0] Vac = ssac_amplitude Iac_real = Iac_real_data[:,1] Iac_imag = Iac_imag_data[:,1] Iac = Iac_real + 1j*Iac_imag Z = Vac/Iac R = np.abs(np.real(Z)) C = np.abs(np.imag(1/Z)/(2*np.pi*frequency))  ​Finally, the column names in the previously defined data files can be set, with the first column representing voltage and the second column representing capacitance or resistance. Additionally, the axis titles and styles should be set for the output images.  np.savetxt(resistance_file, np.array((Vdc, R)).T, fmt='%f,%.15e', header='voltage,resistance') np.savetxt(capacitance_file, np.array((Vdc, C)).T, fmt='%f,%.15e', header='voltage,capacitance') resistance_fig = os.path.splitext(resistance_file)[0] + &quot;.jpg&quot; capacitance_fig = os.path.splitext(capacitance_file)[0] + &quot;.jpg&quot; fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(Vdc, R, 'b', linewidth=linewidth, label=&quot;resistance_&quot; + str(frequency*1e-6) + &quot;MHz&quot;) ax.plot(Vdc, R, 'bo') ax.set_xlabel('VBias[V]') ax.set_ylabel('Resistance[Ohm]') plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1, 2)) ax.grid() plt.savefig(resistance_fig) plt.close() fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(Vdc, C, 'b', linewidth=linewidth, label=&quot;capacitance_&quot; + str(frequency*1e-6) + &quot;MHz&quot;) ax.plot(Vdc, C, 'bo') ax.set_xlabel('VBias[V]') ax.set_ylabel('Capacitance[F]') plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1, 2)) ax.grid() plt.savefig(capacitance_fig) plt.close() # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)  2.3 Output Result​ ​Application Library path: :\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD0B_RC_local_time 2.3.1 Small Signal AC Current​ ​This section displays the variations of the real and imaginary components of the AC current with respect to bias voltage at different frequencies. \t1 MHZ\t100 MHZ\t10000 MHZReal Image  2.3.2 Capacitance​ ​This section displays the variations of capacitance with respect to bias voltage at different frequencies. 1 MHZ\t100 MHZ\t10000 MHZ  2.3.3 Resistance​ ​This section displays the variations of resistance with respect to bias voltage at different frequencies. 1 MHZ\t100 MHZ\t10000 MHZ  "},{"title":"Directional Coupler","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/DirectionalCoupler/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#introduction","content":"Directional couplers (DC) are an important category of optical splitters. They are typically composed of two adjacent single-mode waveguides, and the coupling coefficient is determined by both the length of the coupler and the spacing between them. This feature allows for effective control of the splitting ratio. When it comes to directional couplers, we pay close attention to several key parameters, including insertion loss, splitting ratio, device dimensions, and operating bandwidth. \t "},{"title":"Simulation Methods​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#simulation-methods","content":"The FDE module can be used to calculate the symmetric and anti-symmetric mode field distributions of the directional coupler’s two arms. From these calculations, the effective index can be determined, allowing for the theoretical calculation of the coupling length required to achieve the target splitting ratio. And the FDTD module can be used to perform precise calculations of light propagation in the DC. The light field transmission images in the monitor allow for a visual assessment,the related data of which facilitate further optimization and validation of the coupling length and spacing parameters in the DC splitter. After data processing, it can be obtained that the splitting ratio, insertion loss, and operating bandwidth of DC. In designing high-performance directional couplers for various optical communication and integrated photonics applications, these calculations and optimization processes are instrumental. "},{"title":"Directional Coupler(FDE module)​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#directional-couplerfde-module","content":"Using the FDE module, we will calculate symmetric and antisymmetric modes in a Directional Coupler modeled with the SDK. The input light can be considered a combination of the symmetric mode and the antisymmetric mode so that we can precisely calculate the coupling coefficient by effective index from the FDE module. Referring to the Silicon Photonics Design written by Lukas Chrostowski, we build the structure of the Directional coupler in the simulation. "},{"title":"1. Basic Operations​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#1-basic-operations","content":"1.1 Import File​ Once you have installed and configured the environment, import the python code and the GDS layout. The example library and related model code are usually located in the directory : .venv_maxoptics/site-packages/maxoptics_sdk/examples/func_demo. The GDS file is generally imported into the path : .venv_maxoptics/site-packages/maxoptics_sdk/examples/examples_gds 1.2 SDK Initialization​ Create a new terminal and run the code after you import the python script and GDS file. Max-Optics SDK may take some time to initialize on the first simulation. Version of Max-Optics sdk is 2.3.0.4.630.2000 Max-Optics SDK is initializing...  "},{"title":"2. Code Description​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#2-code-description","content":"Now let's learn the meaning of functions and parameters that correspond to the code. 2.1 import Modules​ To begin, we need to use the import command to call the relevant functional modules. For instance, we import the typing , os and time module in python. At the same time ,we import the customized module maxoptics_sdk.all and maxoptics_sdk.helper. from typing import List, Literal, NamedTuple import os import time import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path  The typing module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. The os module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands. The time module provides various functions to work with time-related operations and to measure time intervals. The maxoptics_sdk package provides all in one optical simulation with Python. 2.2 Define Simulation​ Firstly, We define parameters and give them a default value, such as the simulation wavelength and grid accuracy. Note that we can override this value in the following code. def simulation(*, run_mode='local', wavelength=1.55, grid=0.02, number_of_trial_modes=20, run_options: 'RunOptions', **kwargs):  The provided code contains comments that define the simulation parameters. Let's explain each of these parameters. The function simulation is used to define the simulation parameters for the program. The run_mode parameter determines the type of calculation resources to be used. The wavelength parameter specifies the wavelength of the input light in micrometers. The grid parameter represents the grid accuracy in micrometers. Lastly, the number_of_trial_modes parameter sets the number of modes to be calculated. The **kwargs is a special syntax used in function definitions to accept an arbitrary number of keyword arguments as a dictionary. 2.3 Define Parameters​ Define commonly used parameters in region 0, such as the width and height of the simulation boundary, the start time of the simulation, the path and name for the simulation output, the path to the imported GDS layout, and other parameters required for structural parameterized modeling. # region --- 0. General Parameters --- yspan_solver = 5 zspan_solver = 2 time_str = time.strftime('%Y%m%d_%H%M%S', time.localtime()) path = kwargs['path'] simu_name = f'FDE_DC_yspan={yspan_solver}_{time_str}' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + '/examples_gds/DC.gds' project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = kwargs.get('plot_dir', path) + '/plots/' + project_name + '/' kL = [f'0{k}' for k in range(5)] export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} l_bend=5.6 # the length of z bend l_arm=15 # the length of 2 arms l_input=2.5 # the length of input wg # endregion  The code defines several parameters and variables necessary for the simulation process. The yspan_solver parameter represents the width of the simulation boundary specified in micrometers. Similarly, the zspan_solver parameter denotes the height of the simulation boundary in micrometers. The time_str variable is used to obtain the current time as a timestamp for the simulation. The path variable defines the file path for the simulation, while simu_name specifies the name of the simulation file. The gds_file_root_path variable defines the path for importing the GDS layout. The project_name variable assigns a name to the project for the simulation output. The plot_path variable determines the directory where the simulation result plots will be saved. The export_options parameter allows for the definition of options for exporting the simulation results. Lastly, the variables l_bend ,l_arm, and l_input represent the lengths of specific components within the simulation, such as the length of the z-bend, the length of the two arms, and the length of the input waveguide, respectively. These parameters and variables together facilitate the successful execution and organization of the simulation process. 2.4 Define Materials​ Indeed, let's proceed to the next step, where we set up the materials required for the simulation in region 2. In this case, we will directly use relevant materials from the MO material library. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) mt.add_lib(name='SiO2', data=mo.Material.SiO2_Palik, order=2) mt.add_lib(name='Air', data=mo.Material.Air, order=2) # endregion  The add_lib is used to define three parameters name,data and order. The data calls up the property of simulation materials in the MO material library. The Order parameter determines the mesh order for the material during the simulation. Besides, we also support users to customize the material with add_nondispersionfunction. 2.5 Create Model​ Next, we will create the Directional Coupler model in region 3. We have two options for modeling the structure: # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;SiO2&quot;]) st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 6}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}}) st.add_geometry(name=&quot;dc&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (0, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name='slab', type='Rectangle', property={'geometry': {'x_min': -l_input-l_bend-l_arm/2-3, 'x_max':l_input+l_bend+l_arm/2+3, 'y': 0, 'y_span': 8, 'z': 0.045, 'z_span': 0.09}, 'material': {'material': mt['Si'], 'mesh_order': 2}} ) # endregion  Here, we import the DC layout from the GDS file. we can create the DC model directly within the SDK using the Structure function. The name parameter defines the structure name. The type parameter specifies the structure type. The path, cell_name, and layer_name parameters point to the GDS file and specify the relevant layers and cell names used in the layout. The geometry parameter sets the structure's coordinates. The material parameter specifies the material properties The mesh_order parameter sets the mesh order for the simulation. 2.6 Boundary​ After establishing the model, we can add the simulation region in region 4 and define the simulation boundary conditions. This involves specifying the geometry of the simulation region, the boundary conditions in the xyz directions, and detailed parameters. # region --- 4. Boundary --- st.OBoundary(property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': yspan_solver, 'z': 0, 'z_span': zspan_solver}, 'boundary': {'y_min': 'PEC', 'y_max': 'PEC', 'z_min': 'PEC', 'z_max': 'PEC'}}) # endregion  In this case,we use Perfect Electric Conductor(PEC) boundary condition. The PEC boundary condition is a modeling approach used to simulate the behavior of perfectly conducting surfaces or boundaries in electromagnetic wave propagation analyses. This effectively models the behavior of a material with infinite conductivity and perfect electrical shielding. This boundary condition is particularly relevant when dealing with the interaction of light and electromagnetic fields with highly conductive materials, such as metals. Moreover, We also provide the usual boundary condition like Perfectly Matched Layer(PML) and Perfect Magnetic Conductor (PMC), you can change the PEC to PML or PMCof 6 dimensions in the code. 2.7 Add Sub-mesh​ To achieve more accurate calculations of the model's modal fields, we can add a sub-mesh in region 5. # region --- 5. Sub Mesh --- st.add_mesh(name='sub_mesh', property={'general': {'dx': 0.002, 'dy': 0.002, 'dz': 0.002}, 'geometry': {'x': 0, 'x_span': 6, 'y': 0, 'y_span': 2, 'z': 0.11, 'z_span': 0.22}}) # endregion In this code segment, we use the add_mesh function to add a sub-mesh in region 5. The name parameter defines the name of the mesh. The general parameter specifies the grid accuracy in the xyz directions (in this case, 0.002 micrometers in each direction). The geometry parameter sets the coordinates of the sub-mesh. 2.8 FDE Simulation​ In region 6, we add the FDE simulation module to support mode calculations and frequency scans. # region --- 6. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={ # 'general': {'solver_type': '2d_x_normal'}, # default is '2d_x_normal' 'mesh_settings': { 'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'search': 'max_index', # 'n': 2, 'calculate_group_index': False, 'mode_removal': {'threshold': 0.02}, # 'bent_waveguide': {'bent_waveguide': False, 'radius': 1, 'orientation': 0, 'location': 'simulation_center'} }, &quot;frequency_analysis&quot;: { &quot;frequency_analysis&quot;: run_options.run_frequency_sweep, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 2.67, &quot;detailed_dispersion_calculation&quot;: False }}}) # endregion In this code segment, the name parameter defines the name of the simulation module. The general parameter specifies the type of the simulation module within the structure. It supports the following list selection['2d_x_normal','2d_y_normal','2d_z_normal']. The mesh_settings parameter is set to the previously defined sub_mesh. The wavelength parameter sets the wavelength-related parameters for the simulation. The search parameter specifies the mode search type. It supports the following list selection['near_n','max_index']. In this case, we use max_index to automatically search for the mode with max index in the structure. To use the ‘near_n’, we need to set the data in ‘n’. The bent_waveguide parameter can be used to set parameters for a bent waveguide. The frequency_analysis parameter allows us to set parameters for frequency scans or mode calculations with varying wavelengths. 2.9 Structure Image​ In region 7, you can generate an image of the structure which contains the specific coordinates. # region --- 7. Structure Show --- st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}{kL[0]}_{simu_name}', simulation_name=simu_name) # simu[simu_name].show3d(show_with=&quot;local_gui&quot;) # endregion In this code segment, we use the structure_show function to form a picture. The fig_type specifies the type of figure. It supports the following list selection[&quot;png&quot;, &quot;svg&quot;]. The show , which is a switch that controls whether the picture is generated or not. If you have already installed the GUI locally, you can automatically pop up the 3D structural model within the GUI using show_with=&quot;local_gui&quot;. Additionally, you can also use show_with=&quot;matplotlib&quot; to view the structure. 2.10 Index Preview​ And in region 8, you can generate a material refractive index plot for the structure in different cross-sectional directions(x,y,z). # region --- 8. Mesh View --- if run_options.index_preview: k = kL[1] simu[simu_name].run_index(name=f'{simu_name}_x_0', savepath=f'{plot_path}{k}IndexPreview_x=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 2}}) simu[simu_name].run_index(name=f'{simu_name}_y_0', savepath=f'{plot_path}{k}IndexPreview_y=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 4, 'y': 0, 'y_span': 0, 'z': 0, 'z_span': 2}}) simu[simu_name].run_index(name=f'{simu_name}_z_0', savepath=f'{plot_path}{k}IndexPreview_z=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 4, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 0}}) # endregion 2.11 Run Simulation​ In region 9, you can run the simulation. # region --- 9. Run --- result_fde = simu[simu_name].run() # endregion 2.12 Retrieve Results​ In region 10, you can retrieve and store the simulation results. # region --- 10. See Results --- if run_options.extract: # region --- 10.1 calculate_modes --- if run_options.run: k = kL[2] res = result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_neff_table', export_csv=True) print(res.to_string(index=False)) for m in range(len(res)): k = kL[3] result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_mode{m}', attribute='Ey', mode=m, real=True, imag=False, export_options, show=False) # endregion if run_options.run_frequency_sweep: k = kL[4] result_fde.extract(data=&quot;frequency_analysis&quot;, savepath=f'{plot_path}{k}_freq_sweep_neff', attribute=&quot;neff&quot;, real=True, imag=True, export_csv=True, export_mat=True, show=False) # endregion The extract function allows you to extract specific simulation results and store them for further analysis. The attribute parameter specifies the type of simulation results to be extracted. The mode parameter corresponds to the index of the FDE calculation mode. The real and imag parameters are used to extract the real and imaginary parts of the simulation results, respectively. If you run the frenquency sweep to calculate mode at different wavelength, you can also extract the relevant results. As an example above, we extrat the effective index. 2.13 Switches​ In this section of the code, the simulation function is called and executed, which allows you to reset relevant parameters for more convenient parameter scanning and optimization design. We also support control switches for various functionalities at the end of the code, and you can use configuration flags(True or False). These flags can be used to turn specific functionalities on or off, making it easier to check the model and perform efficient calculations. class RunOptions(NamedTuple): index_preview: bool run: bool run_frequency_sweep: bool extract: bool if __name__ == '__main__': simulation( run_mode=&quot;local&quot;, wavelength=1.55, grid=0.02, number_of_trial_modes=20, run_options=RunOptions(index_preview=True, run=True, run_frequency_sweep=True, extract=True) ) By turning on/off the relevant functionalities, you can control the simulation process and obtain the desired results. For example, the index_preview is to control whether to output images of the structural refractive index. run determines whether to run the program. run_frequency_sweep is used to enable frequency scanning, and extract is used to control data extraction. Properly utilizing these switches can help you inspect the simulation effectively. 3. Output Results​ Schematic diagram of the refractive index of the device. The results of the calculation mode will be stored in a CSV format file for subsequent data processing in Python and Excel. mode_order TE ratio neff_real neff_imag ng_real ng_imag wavelength(nm)\tloss(dB/cm)0\t0.98686\t2.593169\t-4.60E-09\t0\t0\t1550\t0.001621 1\t0.987741\t2.542373\t-3.51E-09\t0\t0\t1550\t0.001236 2\t0.940652\t2.129685\t-5.37E-05\t0\t0\t1550\t18.91018 3\t0.200058\t1.733018\t-0.00545\t0\t0\t1550\t1917.539 Image of the Ey electric field component intensity in symmetric and antisymmetric mode modes. According to the effective refractive index of the obtained mode field, Python is used for data processing and drawing. The coupling length under the gap between two waveguides is calculated with the formula: Lx=λ2∣neff1−neff2∣L_x = \\frac{\\lambda}{2|neff_1-neff_2|}Lx​=2∣neff1​−neff2​∣λ​ We can also get the coupling coefficient by the formula: κ=∣sin(πδ(n)Lλ)∣\\kappa = |sin(\\frac{\\pi\\delta(n)L}{\\lambda})|κ=∣sin(λπδ(n)L​)∣ Similarly, we can obtain the relationship between the gap (distance) between two waveguides and the coupling coefficient and the relationship between the wavelength and the coupling length. Directional Coupler(FDTD module)​ Next, we will learn how to model a Directional Coupler using the SDK and calculate the light propagation in the structure using the FDTD module. 1. Basic Operations​ Similarly, after installing and configuring the environment, we import the relevant python code file and the GDS layout for the model. The example library and related model code are typically stored in the directory .venv_maxoptics/site-packages/maxoptics_sdk/examples, and the GDS file is imported into the folder .venv_maxoptics/site-packages/maxoptics_sdk/examples/examples_gds. 2. Code Description​ Next, we will continue to learn about the specific functionalities corresponding to the code. 2.1 Define Parameters​ Like the operations with the FDE module, after configuring the simulation wavelength, grid precision, and other parameters, we need to set the relevant parameters for simulation and parameterized modeling in Region 0. This includes defining the paths and names for the simulation files and output results and specifying the path for importing the GDS layout. # region --- 0. General Parameters --- l_bend=5.6 # the length of z bend l_arm=15 # the length of 2 arms l_input=2.5 # the length of input wg monitor_w = 3.0 monitor_h = 2.0 waveform_name = &quot;wv&quot; + str(round(wavelength * 1000)) time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) path = kwargs[&quot;path&quot;] simu_name = &quot;FDTD_DC&quot; project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/DC.gds&quot; # endregion 2.2 Define Materials​ Subsequently, in Region 2, we ues the materials required for the simulation. We also support users to specify the refractive indices of Si (Silicon) and SiO2 (Silicon Dioxide) materials. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) mt.add_lib(name='SiO2', data=mo.Material.SiO2_Palik, order=2) # mt.add_nondispersion(name=&quot;Si&quot;, data=[(3.472, 0)], order=2) # mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=2) mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) # endregion The add_nondispersion function adds a non-dispersion material to the project in the simulation. The data, is specified as a list, typically in the format [(index real, index imag)]. This list contains the complex refractive index values for the material, enabling the simulation to model its optical properties accurately. The function allows users to incorporate non-dispersion materials into the simulation, contributing to a comprehensive and precise optical analysis of the system under investigation. 2.3 Define Waveform​ In Region 3, we define the parameters relevant to the wavelength. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=wavelength_span) # endregion The Waveform function is used to retrieve the waveform manager for the current project. It allows users to access and manipulate the waveform sources used in the simulation. The name parameter specifies the name of the waveform source. The Wavelength_center parameter defines the center of the wavelength range for the source. The Wavelength_span parameter determines the span of the wavelength range for the source. 2.4 Create Model\\Boundary\\Sub-mesh​ Next, similar to the procedure in the FDE module, in Region 4, we create the model by importing the GDS layout. Subsequently, in Region 5, we establish the boundary conditions. Additionally, in Region 6, we can set the sub-mesh for improved precision. # region --- 4. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;SiO2&quot;]) st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 6}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}}) st.add_geometry(name=&quot;dc&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (0, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name='slab', type='Rectangle', property={'geometry': {'x_min': -l_input-l_bend-l_arm/2-3, 'x_max':l_input+l_bend+l_arm/2+3, 'y': 0, 'y_span': 8, 'z': 0.045, 'z_span': 0.09}, 'material': {'material': mt['Si'], 'mesh_order': 2}} ) # endregion # region --- 5. Boundary --- st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_arm/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}, &quot;boundary&quot;: {&quot;x_min&quot;: &quot;PML&quot;, &quot;x_max&quot;: &quot;PML&quot;, &quot;y_min&quot;: &quot;PML&quot;, &quot;y_max&quot;: &quot;PML&quot;, &quot;z_min&quot;: &quot;PML&quot;, &quot;z_max&quot;: &quot;PML&quot;}, &quot;general_pml&quot;: {&quot;pml_same_settings&quot;: True, &quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 0.8, &quot;pml_layer&quot;: 8, &quot;pml_polynomial&quot;: 3}}) # endregion # region --- 6. Sub Mesh --- st.add_mesh(name=&quot;sub_mesh&quot;, property={&quot;general&quot;: {&quot;dx&quot;: 0.05, &quot;dy&quot;: 0.02, &quot;dz&quot;: 0.02}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_arm/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}}) # endregion In this code segment, we define simulation region using the OBoundary function. First, we define the size of the boundary with the geometry parameter . Next, we define the boundary conditions for the simulation using the boundary dictionary, where the x ,y and the z directions all have PML boundary conditions. Finally, we set detailed parameters for the PML boundary using the general_pml dictionary, specifying the pml_layer,pml_kappa, pml_sigmaand pml_polynomial, which specific the order of the polynomial. 2.5 Source​ Then we need to establish the light source in the input waveguide, as shown in Region 7. # region --- 7. ModeSource --- src = pj.Source() src.add(name=&quot;source&quot;, type=&quot;mode_source&quot;, axis=&quot;x_forward&quot;, property={&quot;general&quot;: {&quot;mode_selection&quot;: &quot;user_select&quot;, &quot;waveform&quot;: {&quot;waveform_id_select&quot;: wv[waveform_name]}}, &quot;geometry&quot;: {&quot;x&quot;: -l_input-l_arm/2-l_bend+2, &quot;x_span&quot;: 0, &quot;y&quot;: 1.35, &quot;y_span&quot;: monitor_w, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}}) # endregion  The Source function is utilized to retrieve the source manager for the current project. The type parameter specifies the type of the source and is formatted as either [&quot;mode_source&quot;] or [&quot;gaussian_source&quot;]. The name parameter represents the name assigned to the source. The axis parameter defines the axis of the source. The property parameter allows for defining specific properties associated with the source. 2.6 Monitor​ In Region 8, we set up the monitors. # region --- 8. Monitor --- # region --- 8.0 GlobalMonitor --- mn = pj.Monitor() mn.add(name=&quot;Global Option&quot;, type=&quot;global_option&quot;, property={&quot;frequency_power&quot;: {&quot;spacing_type&quot;: &quot;wavelength&quot;, &quot;spacing_limit&quot;: &quot;center_span&quot;, # [&quot;min_max&quot;,&quot;center_span&quot;] &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: , &quot;frequency_points&quot;: 3}}) # endregion # region --- 8.1 input --- mn.add( type=&quot;power_monitor&quot;, name=&quot;input_reflect&quot;, property={&quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 3}}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: -l_input-l_arm/2-l_bend+1.5, &quot;x_span&quot;: 0, &quot;y&quot;: 1.35, &quot;y_span&quot;: monitor_w, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}, 'mode_expansion': {&quot;enable&quot;: True, 'direction': 'positive', 'mode_calculation': {'mode_selection': 'user_select', 'mode_index': [0]}}}) # endregion # endregion  For the global monitor, the Monitor function is utilized to retrieve the monitor manager for the current project, which allows users to access and manage various types of monitors used during simulation. The name parameter represents the name of the Global Option associated with the monitor. The type parameter defines the type of the Global Option and is formatted as a list containing one of several monitor types. The property parameter is used to define and set the relevant parameters specific to the chosen monitor type. These parameters control the monitor's behavior and data collection settings during the simulation. The power monitor is a configuration setting that allows users to specify various simulation parameters. The name parameter assigns a name to the power monitor. The type parameter defines the type of power monitor. The general parameter pertains to settings related to the frequency domain and frequency-dependent behaviors of the simulation. The geometry parameter is used to define the geometric characteristics of the simulated structure. The mode_expansion parameter involves relevant settings for mode expansion simulations. Users can customize the simulation settings by utilizing these input parameters to achieve accurate and comprehensive results based on their specific simulation requirements. 2.7 FDTD Simulation​ In Region 9, we add the FDTD simulation.  # region --- 9. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;FDTD&quot;, property={&quot;general&quot;: {&quot;simulation_time&quot;: 1000}, &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: grids_per_lambda, }, &quot;minimum_mesh_step_settings&quot;: {&quot;min_mesh_step&quot;: 0.01}}}) # endregion  The Simulation manager is critical for setting up and running simulations in the current project. The name parameter allows users to assign a unique name to the simulation for identification purposes. The type parameter defines the type of the simulation. The simulation_time parameter specifies the duration of the simulation. The mesh_settings parameter enables users to configure various settings related to the simulation mesh. The mesh_accuracy parameter controls the precision of the mesh used in the simulation. The cells_per_wavelength parameter determines the wavelength precision used in the simulation. The minimum_mesh_step_settings parameter sets the minimum mesh step, allowing users to define the smallest allowable size for mesh elements. Users can tailor the simulation setup to meet their requirements by utilizing these input parameters, enabling accurate and efficient electromagnetic simulations of complex optical structures. 2.8 Schematic of Structure​ As the same, we generate the device structure of the Directional Coupler in Region 10. # region --- 10. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=plot_path + simu_name, simulation_name=simu_name) # endregion  2.9 Calculate Source​ To calculate the input mode light and save its electric field intensity data in region 11. # region --- 11. Calculate Mode --- if run_options.calculate_modes: simu.add(name=simu_name+&quot;_cal_mode&quot;, type=&quot;mode_selection:user_select&quot;, simulation_name=simu_name, source_name=&quot;source&quot;, property={&quot;modal_analysis&quot;: {&quot;mesh_structure&quot;: True, &quot;calculate_modes&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: 10, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True}}) src_res = simu[simu_name+&quot;_cal_mode&quot;].run() src_res.extract(data=&quot;calculate_modes&quot;, savepath=plot_path + &quot;00_source_modeprofile_fdeonly&quot;, mode=0, attribute=&quot;E&quot;, export_csv=True) # endregion  2.10 Run Simulation​ Then, in Region 12, we run the simulation. We support users to calculate the simulation with GPU by resources to improve the simulation efficiency. # region --- 12. Run --- if run_options.run: fdtd_res = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0}]} ) # endregion  2.11 Results​ In Region 13, we define the desired output results. Lastly, we control the switches of various functional modules at the end of the Python file. # region --- 13. See Results --- if run_options.extract and run_options.run: # region --- z_normal --- &quot;&quot;&quot; 01_top_profile &quot;&quot;&quot; for λ in [1.5, 1.55, 1.6]: fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;01_top_profile_&quot; + str(λ) + &quot;um&quot;, monitor_name=&quot;z_normal&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, wavelength=str(λ), export_csv=True) # endregion # region --- through --- &quot;&quot;&quot; 01_monitorThrough_modeprofile_fdtd &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;01_monitorThrough_modeprofile_fdtd&quot;, monitor_name=&quot;output_up&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, export_csv=True) &quot;&quot;&quot; 02_Trans_ThroughVsLambda_power &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;02_Trans_ThroughVsLambda_power&quot;, monitor_name=&quot;output_up&quot;, attribute=&quot;T&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) &quot;&quot;&quot; 021_ME_ThroughVsLambda_mode &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:mode_expansion&quot;, savepath=plot_path + &quot;021_ME_ThroughVsLambda_mode&quot;, monitor_name=&quot;output_up&quot;, attribute=&quot;t_forward&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, mode=0, export_csv=True) # endregion # region --- cross --- &quot;&quot;&quot; 01_monitorThrough_modeprofile_fdtd &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;01_monitorCross_modeprofile_fdtd&quot;, monitor_name=&quot;output_down&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, export_csv=True) &quot;&quot;&quot; 02_Trans_ThroughVsLambda_power &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;02_Trans_CrossVsLambda_power&quot;, monitor_name=&quot;output_down&quot;, attribute=&quot;T&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) &quot;&quot;&quot; 021_ME_ThroughVsLambda_mode &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:mode_expansion&quot;, savepath=plot_path + &quot;021_ME_CrossVsLambda_mode&quot;, monitor_name=&quot;output_down&quot;, attribute=&quot;t_forward&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, mode=0, export_csv=True) # endregion  2.12 Switches​ At the end of all codes, We control the switches of various functional modules. class RunOptions(NamedTuple): index_preview: bool calculate_modes: bool run: bool extract: bool if __name__ == &quot;__main__&quot;: simulation( run_options=RunOptions(index_preview=True, calculate_modes=True, run=True, extract=True))  "},{"title":"3. Output Results​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#3-output-results-1","content":"After running the program, we can obtain a series of corresponding output results: Incident light electric field intensity, CRO output port electric field intensity, and TRU output port electric field intensity.   DC (Directional Coupler) Z-direction electric field intensity at different wavelengths: 1.50 μm, 1.55 μm, and 1.60 μm.   Cross output port and TRU output port transmittance at different wavelengths: 1.50 μm, 1.55 μm, and 1.60 μm. \t TE0 mode transmittance at Cross output port and TRU output port for different wavelengths: 1.50 μm, 1.55 μm, and 1.60 μm. \t Based on the information provided, we can get the following results when propogating wavelength is 1.55 μm and the two arm length of directional couper is equal to 15 μm: 1. Insertion Loss: 0.177 dB; 2. Power Split Ratio: 13.2 : 83.8 (or approximately 13.2% to one port and 83.8% to the other port); 3. Dimensions: Approximately 5 μm X 25 μm. "},{"title":"Supplement​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#supplement","content":"To view a function's definition and supported parameters or a parameter dictionary, you can right-click on its name and select &quot;Go to Definition&quot; or press &quot;Ctrl&quot; while left-clicking on its name to view its definition, showing the available parameters and their descriptions. And you can also to find the detailed explaination : https://itsays-zqc.github.io/my-website/docs/category/max-optics-sdk "},{"title":"References​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#references","content":"Chrostowski, L., &amp; Hochberg, M. (2015). Silicon Photonics Design: From Devices to Systems. Cambridge: Cambridge University Press. doi:10.1017/CBO9781316084168 "},{"title":"Grating Coupler","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/GratingCoupler/","content":"","keywords":""},{"title":"Introduction:​","type":1,"pageTitle":"Grating Coupler","url":"/my-website/docs/examples/PIC/GratingCoupler/#introduction","content":"Grating coupling is a simple method for connecting photonic integrated chips with optical fibers.  "},{"title":"Simulation​","type":1,"pageTitle":"Grating Coupler","url":"/my-website/docs/examples/PIC/GratingCoupler/#simulation","content":""},{"title":"1 Code Description​","type":1,"pageTitle":"Grating Coupler","url":"/my-website/docs/examples/PIC/GratingCoupler/#1-code-description","content":"1.1 Import Toolkit​ First, we need to import maxoptics_sdk and Python's third-party package. The import module for FDE and FDTD simulation are shown below. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time import numpy as np from typing import NamedTuple  1.2 Define Simulation Function and parameters​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. Before starting the simulation, you can define variables to control the parameters. Set as follows. @timed @with_path def simulation(*, run_mode, wavelength, grids_per_lambda, run_options: 'RunOptions', **kwargs): # region --- 0. General Parameters --- waveform_name = f'wv{wavelength*1e3}' path = kwargs['path'] simu_name = 'GratingCoupler' time_str = time.strftime('%Y%m%d_%H%M%S', time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + '/examples_gds/gc.gds' kL = [f'0{k}' for k in range(5)] # endregion  1.3 Create project​ You can create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion  1.4 Add Material​ Here we demonstrate using the Material function to create material and using the add_lib function to add materials from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_nondispersion(name='Si', data=[(3.47656, 0)], order=2) mt.add_nondispersion(name='SiO2', data=[(1.44402, 0)], order=2) mt.add_lib(name='Air', data=mo.Material.Air, order=2) # endregion  The name is used to define the name of the added material. The data is used to receive refractive index data extracted from the material library. The order is used to set the material priority of the grid. 1.5 Add waveform​ Adding a light source for simulating in 3D FDTD, and we use Waveform to set the waveform parameters of the light source. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1) # endregion  name sets the name of the waveform, wavelength_center sets the center wavelength of the light source, and wavelength_span sets the wavelength range of the light source. 1.6 Add Structure​ Microring resonator is typical filter for Soi waveguide, including two straight optical waveguides and a coupled ring-shaped waveguide. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select the type from the structural components. The specific properties can be set as follows. # region --- 4. Structure --- st = pj.Structure() st.add_geometry(name='top_cladding', type='gds_file', property={'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (1, 0)}, 'geometry': {'z': 0.11, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name='middle_cladding', type='gds_file', property={'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (2, 0)}, 'geometry': {'z': 0.075, 'z_span': 0.15}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name='grating', type='gds_file', property={'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (3, 0)}, 'geometry': {'z': 0.185, 'z_span': 0.07}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name='SiO2_TOX_UP', type='gds_file', property={'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (4, 0)}, 'geometry': {'z': 0.5, 'z_span': 1.0}, 'material': {'material': mt['SiO2'], 'mesh_order': 1}}) st.add_geometry(name='SiO2_TOX_DOWN', type='gds_file', property={'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (5, 0)}, 'geometry': {'z': -1, 'z_span': 2}, 'material': {'material': mt['SiO2'], 'mesh_order': 2}}) st.add_geometry(name='Si_substrate', type='gds_file', property={'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (6, 0)}, 'geometry': {'z': -6, 'z_span': 8}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) # endregion  Key\tValue\ttype\tDescriptionname\ttop_cladding\tstring\tname the added geometry type\tgds_file\tstring\tselect the type of structure x 0 float center position in the x-direction of the geometric structure path\tgds_file\tstring\tfile path of GDS file cell_name\tSSC\tstring\tname of the GDS cell layer_name\t(1,0)\tlist\tname of the GDS layer z\t0.11\tfloat\tcenter position in the z-direction of the geometric structure z_span\t0.22\tfloat\tlength of the geometric structure in the z-direction material\tmt[&quot;Si&quot;]\tmaterial\tselect the material added Materials mesh_order\t2\tinteger\tset the priority of the material 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. Use geometry to set the size and position of the boundary, and use boundary to set the boundary conditions at the boundary. The boundary properties of FDE and FDTD are set as follows. # region --- 5. Boundary --- st.OBoundary(property={'geometry': {'x': -3.5, 'x_span': 47, 'y': 0, 'y_span': 28, 'z': -0.5, 'z_span': 5}, 'boundary': {'x_min': 'PML', 'x_max': 'PML', 'y_min': 'PML', 'y_max': 'PML', 'z_min': 'PML', 'z_max': 'PML'}, 'general_pml': {'pml_same_settings': True, 'pml_layer': 8, 'pml_kappa': 2, 'pml_sigma': 0.8, 'pml_polynomial': 3, 'pml_alpha': 0, 'pml_alpha_polynomial': 1}}) # endregion  1.8 Add source​ In 3D FDTD simulation, a light source is required. We use `Source` to create the light source and `add` to add the required light source. The settings for the light source as follows. # region --- 6. GaussianSource --- so = pj.Source() so.add(name='source', type='gaussian_source', axis='z_backward', property={'general': {'angle_theta': 12, 'angle_phi': 0, 'polarization_angle': 90, 'waveform': {'waveform_id_select': wv[waveform_name]}, 'beam_settings': {'calculation_method': 'use_scalar_approximation', # [use_scalar_approximation,use_vector_approximation] 'beam_parameters': 'waist_size_and_position', # [waist_size_and_position,beam_size_and_divergence] 'waist_radius': 5.2, 'distance_from_waist': 1.5, # 'beam_parameters': 'beam_size_and_divergence', # 'beam_radius': 5.20194, 'divergence_angle': 5.41444 }}, 'geometry': {'x': 4, 'x_span': 20, 'y': 0, 'y_span': 20, 'z': 1.5, 'z_span': 0}}) # endregion  Use type to select the type of light source, and axis to set the direction of the mode light source. 1.9 Add Monitor​ In the simulation, Monitor function is used to create monitor and add function is used to add a monitor. By using type to select a power monitor, the transmittance and field distribution of the cross-section can be obtained. It is necessary to add a time monitor to check the field strength at the end of the simulation to determine the accuracy of the simulation results. # region --- 7. Monitor --- ''' 7.0 GlobalMonitor ''' mn = pj.Monitor() mn.add(name='Global Option', type='global_option', property={'frequency_power': {'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 5}}) ''' 7.1 x_normal ''' mn.add(name='x_normal', type='power_monitor', property={'general': {'frequency_profile': {'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 101}}, 'geometry': {'monitor_type': '2d_x_normal', 'x': -26, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0.11, 'z_span': 3}}) ''' 7.2 y_normal ''' mn.add(name='y_normal', type='power_monitor', property={'geometry': {'monitor_type': '2d_y_normal', 'x': -5, 'x_span': 44, 'y': 0, 'y_span': 0, 'z': 0.2, 'z_span': 3.5}}) # endregion  1.10 Add Solver​ We use the Simulation function to create a simulation and the add function to add a solver. The properties settings of FDE and FDTD solvers as follows. # region --- 8. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type='FDTD', property={'general': {'simulation_time': 30000}, 'mesh_settings': {'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}}}) # endregion  1.11 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}{kL[1]}{simu_name}', simulation_name=simu_name) # simu[simu_name].show3d() # endregion  1.12 Index Preview​ # region --- 10. Index Preview --- if run_options.index_preview: simu[simu_name].run_index(name=f'{simu_name}_y_0', savepath=f'{plot_path}{kL[0]}MeshView_y=0', export_csv=True, show=False, property={'geometry': {'x': 9, 'x_span': 22, 'y': 0, 'y_span': 0, 'z': -0.5, 'z_span': 5}}) simu[simu_name].run_index(name=f'{simu_name}_z_0.17', savepath=f'{plot_path}{kL[0]}MeshView_z=0.17', export_csv=True, show=False, property={'geometry': {'x': -5, 'x_span': 44, 'y': 0, 'y_span': 21, 'z': 0.17, 'z_span': 0}}) # endregion  1.12 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation. # region --- 11. Run --- if run_options.run: fdtd_res = simu[simu_name].run() # endregion  1.13 Run and Extract Results​ Extract data using extract, where data is the calculation result data, savepath is the storage path, target is the classification of the data, and monitor_name is the name of the monitor. The data extraction reference is as follows. # region --- 12. See Results --- if run_options.extract and run_options.run: ''' x_normal ''' wavelength_list_x = np.linspace(wavelength - 0.05, wavelength + 0.05, 51) fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[3]}_x_normal_abs(T)', monitor_name='x_normal', attribute='T', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, show=False) for λ in wavelength_list_x: fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[4]}_x_normal_abs(E)_' + str(round(λ, 3)) + 'um', monitor_name='x_normal', attribute='E', target='intensity', wavelength=str(λ), plot_x='y', plot_y='z', real=True, imag=True, export_csv=True, show=False) ''' y_normal ''' wavelength_list_y = np.linspace(wavelength - 0.05, wavelength + 0.05, 5) for λ in wavelength_list_y: fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[4]}_y_normal_abs(E)_' + str(round(λ, 3)) + 'um', monitor_name='y_normal', attribute='E', target='intensity', wavelength=str(λ), plot_x='x', plot_y='z', real=True, imag=True, export_csv=True, show=False) # endregion return fdtd_res if run_options.run else None  1.14 Control Switch​ We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code. In every simulation, only one solver will be enabled. When using the FDE solver, set &quot;run_fde&quot; to True and &quot;run_fdtd&quot; to False; When using the FDTD solver, set &quot;run_fdtd&quot; to True and &quot;run_fde&quot; to False. class RunOptions(NamedTuple): index_preview: bool run: bool extract: bool if __name__ == '__main__': simulation(run_mode='local', is_gds_import=True, wavelength=1.55, grids_per_lambda=8, run_options=RunOptions(index_preview=True, run=True, extract=True))  "},{"title":"2. Output results​","type":1,"pageTitle":"Grating Coupler","url":"/my-website/docs/examples/PIC/GratingCoupler/#2-output-results","content":"Electric profile​ When the wavelength of the incident light meets the Bragg condition, the incident light will enter the waveguide through grating coupling. Transmission​ The transmittance of grating coupling varies with wavelength as shown in the following figure. "},{"title":"References​","type":1,"pageTitle":"Grating Coupler","url":"/my-website/docs/examples/PIC/GratingCoupler/#references","content":"D. Taillaert, F. Van Laere, M. Ayre, W. Bogaerts, D. Van Thourhout, P. Bienstman and R. Baets, “Grating Couplers for Coupling between Optical Fibers and Nanophotonic Waveguides,” Japanese Journal of Applied Physics, vol. 45, no. 8a, pp. 6071-6077, 2006. "},{"title":"Microring Resonator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/MicroringResonator/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#introduction","content":"Microring resonator is important filtering device in photonic integrated circuits, the high performance filter require a wide free spectrum range(FSR) and high quality factor. Obtaining a large spectral range for microring resonator requires the use of a small radius, but too small radius can cause bending loss and reduce the quality factor. In order to meet the requirements of wide free spectrum range and high quality factor, it is necessary to carefully design the size of the ring and coupling efficiency. In this example, we demonstrate the use of finite difference eigenmode(FDE) solver to calculate the group refractive index of an optical waveguide, then calculate the effective refractive index of symmetric and anti symmetric modes at the coupling region between the straight waveguide and the ring, and finally use 3D FDTD simulation to calculate the transmittance of the drop port. "},{"title":"Simulation​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#simulation","content":""},{"title":"1 Code Description​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#1-code-description","content":"1.1 Import Toolkit​ First, we need to import maxoptics_sdk and Python's third-party package. The import module for FDE and FDTD simulation as follows. from typing import List, Literal, NamedTuple import time import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path  1.2 Define Simulation Function and parameters​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. Before starting the simulation, you can define variables to control the parameters. As shown below. def simulation(*, run_mode, wavelength, grid, number_of_trial_modes, run_options: &quot;RunOptions&quot;, **kwargs): # region --- 0. General Parameters --- time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) path = kwargs[&quot;path&quot;] simu_name = f&quot;Microring_FDE&quot; project_name = f&quot;{simu_name}_{run_mode}_{time_str}&quot; plot_path = f'{kwargs.get(&quot;plot_dir&quot;, path)}/plots/{project_name}/' kL = [f&quot;0{k}&quot; for k in range(5)] export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} # endregion  1.3 Create project​ You can create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion  1.4 Add Material​ Here we demonstrate using the Material function to create material and using the add_lib function to add material from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name=&quot;Si&quot;, data=mo.Material.Si_Palik, order=2) mt.add_lib(name=&quot;SiO2&quot;, data=mo.Material.SiO2_Palik, order=2) # endregion  The name is used to define the name of the added material. The data is used to receive refractive index data extracted from the material library. The order is used to set the material priority of the grid. 1.5 Add waveform​ Adding a light source for simulating in 3D FDTD, and we use Waveform to set the waveform parameters of the light source. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1) # endregion  name sets the name of the waveform, wavelength_center sets the center wavelength of the light source, and wavelength_span sets the wavelength range of the light source. 1.6 Add Structure​ The microring resonator is typical filter for SOI waveguide, including two straight optical waveguides and a ring-shaped waveguide. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select the type from the structural components. Properties settings as follows. # region --- 4. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;SiO2&quot;]) st.add_geometry(name=&quot;ring&quot;, type=&quot;Ring&quot;,property={&quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 3}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22,&quot;inner_radius&quot;: 2.6, &quot;outer_radius&quot;: 3}}) st.add_geometry(name=&quot;waveguide1&quot;, type=&quot;Rectangle&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;:15, &quot;y&quot;: 3.3, &quot;y_span&quot;: 0.4, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;:3}} ) st.add_geometry(name=&quot;waveguide2&quot;, type=&quot;Rectangle&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;:15, &quot;y&quot;: -3.3, &quot;y_span&quot;: 0.4, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;:3}} ) st.add_geometry(name=&quot;substrate&quot;, type=&quot;Rectangle&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;:15, &quot;y&quot;: 0, &quot;y_span&quot;: 10, &quot;z_min&quot;: -3, &quot;z_max&quot;: -0.11}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;:3}} ) # endregion  Key\tValue\ttype\tDescriptionname\tring\tstring\tname the added geometry type\tRing\tstring\tselect the type of structure x 0 float center position in the x-direction of the geometric structure material\tmt[&quot;Si&quot;]\tmaterial\tselect the material added Materials mesh_order\t3\tinteger\tset the priority of the material x\t0\tfloat\tthe center coordinate of the ring in the x-direction y\t0\tfloat\tthe center coordinate of the ring in the y-direction z\t0\tfloat\tthe center coordinate of the ring in the z-direction z_span\t0\tfloat\tthe thickness of the ring in the z-direction inner_radius\t2.6\tfloat\tthe size of the inner radius of the ring outer_radius\t3\tfloat\tthe size of the outer radius of the ring The properties of the ring structure are shown in the table above, properties of Rectangle can refer to the settings of the ring. Select simulation material by using mesh_order in areas where geometry overlaps, the priority of structural materials needs to be higher than that of background material. 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. Use geometry to set the size and position of the boundary, and use boundary to set the boundary conditions at the boundary. The boundary properties of FDE and FDTD as follows. # region --- 5. Boundary --- if run_options.run_fde: st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: -4, &quot;x_span&quot;: 0, &quot;y&quot;: -3.3, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 3}, &quot;boundary&quot;: {&quot;y_min&quot;: &quot;PEC&quot;, &quot;y_max&quot;: &quot;PEC&quot;, &quot;z_min&quot;: &quot;PEC&quot;, &quot;z_max&quot;: &quot;PEC&quot;}}) if run_options.run_fdtd: st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 9, &quot;y&quot;: 0, &quot;y_span&quot;: 9, &quot;z&quot;: 0, &quot;z_span&quot;: 3}, &quot;boundary&quot;: {&quot;x_min&quot;: &quot;PML&quot;, &quot;x_max&quot;: &quot;PML&quot;, &quot;y_min&quot;:&quot;PML&quot;, &quot;y_max&quot;:&quot;PML&quot;, &quot;z_min&quot;: &quot;PML&quot;, &quot;z_max&quot;: &quot;PML&quot;}}) # endregion  1.8 Add source​ In 3D FDTD simulation, a light source is required. We use Source to create the light source and add to add the required light source. The settings for the light source as follows. # region --- 6. Source --- src = pj.Source() if run_options.run_fdtd: src.add(name=&quot;modesource&quot;,type=&quot;mode_source&quot;,axis=&quot;x_forward&quot;,property={ &quot;general&quot;:{&quot;mode_selection&quot;:&quot;fundamental_TE&quot;,&quot;waveform&quot;:{&quot;waveform_id_select&quot;:wv[waveform_name]}}, &quot;geometry&quot;:{&quot;x&quot;:-4,&quot;x_span&quot;:0,&quot;y&quot;:3.3,&quot;y_span&quot;:2,&quot;z&quot;:0,&quot;z_span&quot;:2}}) # endregion  1.9 Add Solver​ We use the Simulation function to create a simulation and the add function to add a solver. The properties settings of FDE and FDTD solvers as follows. # region --- 7. Simulation --- simu = pj.Simulation() if run_options.run_fde: simu.add(name=simu_name, type=&quot;FDE&quot;, property={ &quot;general&quot;: {&quot;solver_type&quot;: &quot;2d_x_normal&quot;}, # default is &quot;2d_x_normal&quot; [&quot;2d_x_normal&quot;,&quot;2d_y_normal&quot;,&quot;2d_z_normal&quot;] &quot;mesh_settings&quot;: { &quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}, # &quot;minimum_mesh_step_settings&quot;: {&quot;min_mesh_step&quot;: 1.0e-4} }, &quot;fde_analysis&quot;: { &quot;modal_analysis&quot;: { &quot;calculate_modes&quot;: run_options.run_fde, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength, &quot;wavelength_offset&quot;: 0.0001, &quot;number_of_trial_modes&quot;: number_of_trial_modes, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True, &quot;mode_removal&quot;: {&quot;threshold&quot;: 0.02}}}}) if run_options.run_fdtd: simu.add(name=simu_name, type='FDTD', property={'general': {'simulation_time': 5000 }, 'mesh_settings': {'mesh_type': 'auto_non_uniform', 'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}, 'minimum_mesh_step_settings': {'min_mesh_step': 1e-4}}, 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-4, 'down_sample_time': 200}}, 'thread_setting': {'thread': 12} }) # endregion  The properties settings for the FDE solver as follows. Key\tValue\tType\tDescriptionsolver_type\t2d_x_normal\tstring\tselect the solution plane dy\tgrid\tfloat\tgrid size along the y-direction dz\tgrid\tfloat\tgrid size along the z-direction calculate_modes\trun_options.run_fde\tbool\tchoose whether to calculate the mode of the waveguide mesh_structure\tFalse\tbool\tchoose whether to calculate the refractive index distribution of the structure wavelength\twavelength\tfloat\tcalculate the wavelength of the mode number_of_trial_modes\tnumber_of_trial_modes\tinteger\tnumber of solving modes search\tmax_index\tstring\tchoose &quot;max_index&quot; or &quot;near_n&quot; for finding modes calculate_group_index\tTrue\tbool\tchoose whether to calculate the group refractive index The properties settings for the FDTD solver as follows. Key\tValue\tType\tDescriptionsimulation_time\t5000\tfloat\tset the maximum simulation time mesh_type\tauto_non_uniform\tstring\tselect 'auto_non_uniform' or 'uniform' to set the type of grid cells_per_wavelength\tgrids_per_lambda\tinteger\tset the size of the grid min_mesh_step\t1e-4\tfloat\tset the minimum grid size auto_shutoff_min\t1.e-4\tfloat\tset the energy threshold for terminating the simulation down_sample_time\t200\tfloat\tset additional simulation duration thread\t4\tinteger\tnumber of threads allocated to run the program In the settings of the FDE solver, use calculate_ modes controls whether to calculate the mode. Note that we need to calculate the group refractive index of the waveguide, so set the calculate_ group_index to True. In the setting of the FDTD solver, simulation_time is used to control the simulation time. We set the simulation time to 5000 fs, which is greater than the default value of 1000 fs. The micro ring resonator has a high quality factor, its simulation requires longer time. If the simulation time is set too small and the simulation stops before the field decays, the results obtained are incorrect. 1.10 Add Monitor​ In the simulation, Monitorfunction is used to create monitor and add function is used to add a monitor. By using type to select a power monitor, the transmittance and field distribution of the cross-section can be obtained. It is necessary to add a time monitor at the end of the simulation to check the field strength to judge the accuracy of the simulation results. # region --- 8. Monitor --- mn = pj.Monitor() mn.add(name='time_monitor1', type='time_monitor', property={'general': { 'stop_method': 'end_of_simulation', 'start_time': 0, 'stop_time': 100, 'number_of_snapshots': 0}, 'geometry': {'monitor_type': 'point', 'x': 0, 'x_span': 0, 'y': 0, 'y_span': 0, 'z': 0, 'z_span': 0}, 'advanced': {'sampling_rate': {'min_sampling_per_cycle': 10}}}) mn.add(name='x_normal', type='power_monitor',property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 300}, }, 'geometry': {'monitor_type': '2d_x_normal', 'x': -4, 'x_span': 0, 'y': -3.3, 'y_span': 2, 'z': 0, 'z_span': 2}}) mn.add(name='z_normal', type='power_monitor',property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 100}, }, 'geometry': {'monitor_type': '2d_z_normal', 'x': 0, 'x_span': 9, 'y': 0, 'y_span': 9, 'z': 0, 'z_span': 0}}) #endregion  1.11 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=f&quot;{plot_path}{kL[0]}_{simu_name}&quot;, simulation_name=simu_name) #simu[simu_name].show3d() # endregion  1.12 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation. # region --- 10. Run --- eme_res = simu[simu_name].run() # endregion  1.13 Run and Extract Results​ Extract data using extract, where data is the calculation result data, savepath is the storage path, target is the classification of the data, and monitor_name is the name of the monitor. The data extraction reference is as follows. # region --- 11. See Results --- if run_options.extract: if run_options.run_fde: k = kL[1] res = results.extract(data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_neff_table&quot;, export_csv=True) print(res.to_string(index=False)) for m in range(len(res)): k = kL[2] results.extract(data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_mode{m}&quot;, attribute=&quot;Ey&quot;, mode=m, real=True, imag=False, **export_options, show=False) if run_options.run_fdtd: res = results.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[3]}_profile', monitor_name='x_normal', target='line', plot_x='wavelength', attribute='T', real=True, imag=False, **export_options, show=False) res = results.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[4]}_profile', monitor_name='z_normal', target='intensity', plot_x='x', plot_y='y', attribute='E', real=True, imag=True, **export_options, show=False) # endregion  1.14 Control Switch​ We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code. In each simulation, only one solver will be enabled. When using the FDE solver, set &quot;run_fde&quot; to True and &quot;run_fdtd&quot; to False; When using the FDTD solver, set &quot;run_fdtd&quot; to True and &quot;run_fde&quot; to False. class RunOptions(NamedTuple): index_preview: bool run_fde: bool run_fdtd: bool extract: bool if __name__ == &quot;__main__&quot;: simulation( run_mode=&quot;local&quot;, wavelength=1.55, grid=0.01, grids_per_lambda=14, number_of_trial_modes=5, run_options=RunOptions(index_preview=False,run_fde=False,run_fdtd=True,extract=True))  "},{"title":"2. Output results​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#2-output-results","content":"Length of ring​ The light traveling in the waveguide generates evanescent field on its surface, so energy couples into a nearby waveguide as the waveguide approaches. We design a microring resonant filter with an FSR of 30nm, and we can calculate the effective circumference of the microring according to the following formula. The FDE solver can be used to calculate the group refractive index of the waveguide. The following table shows the group refractive index of the waveguide cross-section in the first three modes with a wavelength of 1.55um. 2πR=λ2/(FSR∗ng) 2{\\pi}R= {\\lambda}^2/(FSR*n_g)2πR=λ2/(FSR∗ng​) order\tTEratio\tneff_real\tneff_imag\tng_real\tng_imag\twavelength_nm\tloss_dBpcm0\t0.966627\t2.227503\t0.0\t4.434594\t0.0\t1550.0\t0 1\t0.046759\t1.692711\t0.0\t3.467810\t0.0\t1550.0\t0 2\t0.599748\t1.430406\t0.0\t1.683888\t0.0\t1550.0\t0 Considering the transmission of the fundamental mode of TE polarization, a group refractive index of 4.43 can be obtained. Therefore, selecting a ring with an effective radius of 2.87um can meet the free spectrum range of 30nm. Couple gap and length​ The length of the coupling region can be calculated based on the effective refractive index difference between symmetric and antisymmetric modes, as shown in the following formula. Setting the gap between the straight waveguide and the ring to 100nm can generate strong mutual coupling. Using the FDE solver to calculate the effective refractive index of the coupling region between the waveguide and the microring, the corresponding mode distribution is as follows. The coupling distance calculated at wavelength of 1.55um more than 1.4 um. You can choose to increase the radius of the ring to reduce the coupling length. We choose to set the coupling length to zero and obtain sufficient coupling length and expected loop length by increasing the radius. L=λ/(πΔn)sin−1(∣t12∣)L={\\lambda}/({\\pi}{\\Delta}n)sin^{-1}(|t12|)L=λ/(πΔn)sin−1(∣t12∣) Transmission​ Calculate the resonant response of a straight waveguide coupled to a microring with a radius of 2.8um using 3D FDTD. Adding a mode light source as an excitation for straight waveguide, and use a power monitor to view the field distribution and transmittance. When the light field coupled into the microring meets the resonance condition, it will output from the dorp port. As shown in the figure below, there is the maximum electric field at the drop port at the resonant wavelength. The transmittance of the drop end is shown in the following figure. "},{"title":"References​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#references","content":"Hammer, M. and Hiremath, K.R. and Stoffer, R. (2004) Analytical approaches to the description of optical microresonator devices. (Invited) In: Microresonators as Building Blocks for VLSI Photonics, 18-25 October 2003, Erice, Italy. pp. 48-71. AIP Conference Proceedings 709. Springer. ISSN 0094-243X ISBN 978-0-7354-0184-6. "},{"title":"Photodetector","type":0,"sectionRef":"#","url":"/my-website/docs/examples/Active_Device/Photodetector","content":"","keywords":""},{"title":"1. Overview​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#1-overview","content":"This example utilizes FDTD simulation to obtain the optical field distribution in the Ge absorption layer. Subsequently, the photo-induced carrier generation rate is calculated based on the optical field, which is then imported into the OEDevice simulation to obtain the photo current. We also provide scripts for dark current, capacitance and resistance, frequency response, and saturation power. These simulations are divided into separate scripts, and they all call a unified script for modeling and material setup, making it convenient for modifications and management.  "},{"title":"2. Modeling​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#2-modeling","content":"The modeling is completed by a callable function in the script file VPD00_structure.py.  "},{"title":"2.1 Import simulation toolkit​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#21-import-simulation-toolkit","content":"First, import maxoptics_sdk and other packages. [1]  import maxoptics_sdk.all as mo import os import time from maxoptics_sdk.helper import timed from pathlib import Path from VPD_material import *  The script file VPD_material.py stores some modified electronic parameters of the materials, which are referenced to override default parameters in the modeling script.  "},{"title":"2.2 Set general parameters​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#22-set-general-parameters","content":"Set some general parameters before modeling. At the beginning are those that need frequent modification during testing and optimization. [2]  # region --- 0. General Parameters --- wavelength_center = 1.55 # um wavelength_span = 0.1 # um source_fraction = 0.001 temperature = 298.15 # K normal_length = 20 # um egrid_local = 0.1 # um egrid_global is not supported so far egrid_genrate = 0.02 # um egrid_interface = 0.002 # um remesh_thickness = 0.004 # um omesh_grid_Ge = 0.02 # um omesh_grid_Si = 0.025 # um cells_per_wavelength = 14 Ge_SiO2_recombination_velocity = 225000 # cm/s run_mode = &quot;local&quot; simu_name = &quot;VPD00_struc&quot;  Wavelength, temperature, the mesh grid size and some other parameters are defined above. They will be detailed in the subsequent settings.  [3]  # --- structure geometry --- SiO2_x_center = 0 SiO2_x_span = 100 SiO2_y_center = 0 SiO2_y_span = 20 SiO2_z_center = 0 SiO2_z_span = 10 input_wg_x_center = -42.5 input_wg_length = 5 input_wg_width = 0.5 Si_z_span = 0.22 Si_y_center = 0 taper_x_min = input_wg_x_center+input_wg_length/2 taper_length = 40 taper_width = 4 Si_slab_length = 22 Si_slab_x_center = taper_x_min+taper_length+Si_slab_length/2 Si_slab_width = 20 Ge_x_center = 10.75 Ge_x_span_bottom = 20 Ge_x_span_top = 19.5 Ge_y_span_bottom = 4 Ge_y_span_top = 3 Ge_z_span = 0.5 Ge_z_center = Si_z_span+Ge_z_span/2 anode_x_center = 10.75 anode_x_span = 19 anode_y_center = 3.7 anode_y_span_top = 2 anode_y_span_bottom = 2 anode_z_span = 1.37 anode_z_center = Si_z_span+anode_z_span/2 cathode_x_center = 10.75 cathode_x_span = 19 cathode_y_center = 0 cathode_y_span_top = 2.2 cathode_y_span_bottom = 2.2 cathode_z_span = 1 cathode_z_center = Si_z_span+Ge_z_span+cathode_z_span/2  These are geometric parameters of the structures.  [4]  # --- electrical simulation boundary --- oe_x_min = 10 oe_x_max = 10 oe_x_mean = 0.5*(oe_x_min+oe_x_max) oe_x_span = oe_x_max-oe_x_min oe_y_min = 0 oe_y_max = 3.7 oe_y_mean = 0.5*(oe_y_min+oe_y_max) oe_y_span = oe_y_max-oe_y_min oe_z_min = -0.15 oe_z_max = 1.25 oe_z_mean = 0.5*(oe_z_min+oe_z_max) oe_z_span = oe_z_max-oe_z_min  These are geometric parameters of the electrical simulation region.  [5]  # --- doping parameters --- p_uniform_x_center = 10.75 p_uniform_x_span = 22.5 p_uniform_y_center = 0 p_uniform_y_span = 15 p_uniform_z_center = Si_z_span/2 p_uniform_z_span = Si_z_span p_uniform_con = 1e15 p_well_x_center = 10.75 p_well_x_span = 22.5 p_well_y_center = 0 p_well_y_span = 15 p_well_z_center = -0.035 p_well_z_span = 0.53 p_well_junction_width = 0.05 p_well_con = 7e18 p_pplus_x_center = 10.75 p_pplus_x_span = 22.5 p_pplus_y_center = 4.75 p_pplus_y_span = 4.5 p_pplus_z_center = 0.1675 p_pplus_z_span = 0.115 p_pplus_junction_width = 0.2 p_pplus_con = 3e19 n_pplus_x_center = 10.75 n_pplus_x_span = 19.7 n_pplus_y_center = 0 n_pplus_y_span = 3 n_pplus_z_center = 0.72 n_pplus_z_span = 0.02 n_pplus_junction_width = 0.02 n_pplus_con = 1e20 n_pplus_ref = 1e16  These are parameters for doping setup, including doping box, concentration and the diffusion junction width.  [6]  # --- optical simulation boundary --- x_min = -43 # light direction x_max = 21 x_mean = 0.5*(x_min+x_max) x_span = x_max-x_min y_min = -3.2 # lateral y_max = 3.2 y_mean = 0.5*(y_min+y_max) y_span = y_max-y_min z_min = -0.5 # vertical z_max = 1 z_mean = 0.5*(z_min+z_max) z_span = z_max-z_min # endregion  These are geometry parameters for the optical simulation region.  "},{"title":"2.3 Define the function for creating a new project​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#23-define-the-function-for-creating-a-new-project","content":"A function is defined for creating a project, setting materials, modeling, doping, setting boundary conditions, etc., which can be called by other simulation script files. [7]  def pd_project(project_name, run_mode, material_property):   2.3.1 Create a new project​ Create a new simulation project. [8]   # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode) # endregion  mo.Project() parameters: name--Project name, which is also the folder name for the project files to be saved.location--The location of the computing resources. The active device simulation only support the option of &quot;local&quot; currently, which means the simulation uses the local computing resources.  2.3.2 Set materials​ [9]   # region --- 2. Material --- if material_property == &quot;normal&quot;: si_override = elec_Si_properties ge_override = elec_Ge_properties elif material_property == &quot;transient&quot;: si_override = elec_Si_properties ge_override = elec_Ge_properties_for_transient else: print(&quot;material_property must be chosen from 'normal', 'transient'&quot;) raise  The elec_Si_properties and elec_Ge_properties are both variables imported from VPD_material.py, storing the modified electronic parameters for Silicon and Germanium respectively. Besides, more physics models for Germanium are applied in transient simulation, with the elec_Ge_properties_for_transient specified for it. The material_property is used to determine which type of material parameters to choose. For details of the physics model and electronic parameter settings, please refer to the appendix.  [10]   mt = pj.Material() mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_lib(name=&quot;mat_air&quot;, data=mo.OE_Material.Air, order=1) mt.add_lib(name=&quot;pec&quot;, data=mo.OE_Material.Al, order=2, override={ &quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.28}, &quot;print&quot;: 1}}) mt.add_lib(name=&quot;mat_si&quot;, data=mo.OE_Material.Si, order=2, override=si_override) mt.add_lib(name=&quot;mat_ge&quot;, data=mo.OE_Material.Ge, order=2, override=ge_override) mt[&quot;mat_sio2&quot;].set_optical_material(data=mo.Material.SiO2_Palik) mt[&quot;mat_air&quot;].set_optical_material(data=mo.Material.Air) mt[&quot;pec&quot;].set_optical_material(data=mo.Material.PEC) mt[&quot;mat_si&quot;].set_optical_material(data=mo.Material.Si_Palik) mt[&quot;mat_ge&quot;].set_optical_material(data=mo.Material.Ge_Palik) # endregion  When adding materials, start by using the add_lib function to add electrical materials from the material library. add_lib() parameters: name--Custom material namedata--Material data, requiring one of the built-in materials in the electrical material library, namely mo.OE_Materialorder--mesh_order of the material, default to be 2override--Override the default electronic parameters by custom values. It's empty by default, which means default models and parameters are applied  Then, use the set_optical_material function to set the optical property for the material. set_optical_material() parameters： data--Optical material property，which can be one of the built-in materials in the optical material library mo.Material, or be from the custom optical material.  Example of using custom optical material properties [11]  mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_nondispersion(name=&quot;mat_sio2_op&quot;, data=[(1.444, 0)], order=1) mt[&quot;mat_sio2&quot;].set_optical_material(data=mt[&quot;mat_sio2_op&quot;].passive_material)   Note: Although the electrical and optical material properties are bound together through a two-step setting, in reality, there is no inherent connection between them. For instance, it is possible to set both the electrical properties of SiO2 and the optical properties of Si for the same material. The simulation will not generate errors or warnings in such cases, so users need to determine by themselves whether the material settings align with physics. The FDTD simulation currently doesn't support metal materials. Therefore, the optical property of metal materials should be set to mo.Material.PEC and the material name should also be &quot;pec&quot;.  2.3.3 Create structures​ First, initialize an object of pj.Structure(). [12]  # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.4, background_material=mt[&quot;mat_sio2&quot;])  pj.Structure() parameters: mesh_type--Type of mesh refinement for optical simulationmesh_factor--The grading factor of non-uniform gridbackground_material--Background material  [13]   st.add_geometry(name=&quot;BOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: SiO2_x_center, &quot;x_span&quot;: SiO2_x_span, &quot;y&quot;: SiO2_y_center, &quot;y_span&quot;: SiO2_y_span, &quot;z_min&quot;: -SiO2_z_span/2, &quot;z_max&quot;: SiO2_z_center}}) st.add_geometry(name=&quot;SOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: SiO2_x_center, &quot;x_span&quot;: SiO2_x_span, &quot;y&quot;: SiO2_y_center, &quot;y_span&quot;: SiO2_y_span, &quot;z_min&quot;: SiO2_z_center, &quot;z_max&quot;: SiO2_z_span/2}}) st.add_geometry(name=&quot;Si_input&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: input_wg_x_center, &quot;x_span&quot;: input_wg_length, &quot;y&quot;: Si_y_center, &quot;y_span&quot;: input_wg_width, &quot;z&quot;: Si_z_span/2, &quot;z_span&quot;: Si_z_span}}) st.add_geometry(name=&quot;Si_taper&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;point_1_x&quot;: taper_x_min+taper_length, &quot;point_1_y&quot;: taper_width/2, &quot;point_2_x&quot;: taper_x_min+taper_length, &quot;point_2_y&quot;: -taper_width/2, &quot;point_3_x&quot;: taper_x_min, &quot;point_3_y&quot;: -input_wg_width/2, &quot;point_4_x&quot;: taper_x_min, &quot;point_4_y&quot;: input_wg_width/2, &quot;z_min&quot;: 0, &quot;z_max&quot;: Si_z_span, &quot;x&quot;: 0, &quot;y&quot;: 0}}) st.add_geometry(name=&quot;Si_base&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: Si_slab_x_center, &quot;x_span&quot;: Si_slab_length, &quot;y&quot;: Si_y_center, &quot;y_span&quot;: Si_slab_width, &quot;z&quot;: Si_z_span/2, &quot;z_span&quot;: Si_z_span}}) st.add_geometry(name=&quot;Ge&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_ge&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: Ge_x_center, &quot;x_span_bottom&quot;: Ge_x_span_bottom, &quot;x_span_top&quot;: Ge_x_span_top, &quot;y&quot;: 0, &quot;y_span_bottom&quot;: Ge_y_span_bottom, &quot;y_span_top&quot;: Ge_y_span_top, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: Ge_z_span}}) st.add_geometry(name=&quot;Cathode&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;pec&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: cathode_x_center, &quot;x_span_bottom&quot;: cathode_x_span, &quot;x_span_top&quot;: cathode_x_span, &quot;y&quot;: cathode_y_center, &quot;y_span_bottom&quot;: cathode_y_span_bottom, &quot;y_span_top&quot;: cathode_y_span_top, &quot;z&quot;: cathode_z_center, &quot;z_span&quot;: cathode_z_span}}) st.add_geometry(name=&quot;Anode&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;pec&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: anode_x_center, &quot;x_span_bottom&quot;: anode_x_span, &quot;x_span_top&quot;: anode_x_span, &quot;y&quot;: anode_y_center, &quot;y_span_bottom&quot;: anode_y_span_bottom, &quot;y_span_top&quot;: anode_y_span_top, &quot;z&quot;: anode_z_center, &quot;z_span&quot;: anode_z_span}})  add_geometry() parameters: name--Structure nametype--Structure typeproperty--Other properties, listed below  Rectangle property list： \tdefault\ttype\tnotesgeometry.x_span float\tRestrained by condition: &gt;0. geometry.x_min float geometry.x_max float geometry.y_span float\tRestrained by condition: &gt;0. geometry.y_min float geometry.y_max float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0.  LinearTrapezoid property list： \tdefault\ttype\tnotesgeometry.point_1_x float geometry.point_1_y float geometry.point_2_x float geometry.point_2_y float geometry.point_3_x float geometry.point_3_y float geometry.point_4_x float geometry.point_4_y float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0.  Pyramid property list： \tdefault\ttype\tnotesgeometry.x_span_bottom float\tRestrained by condition: &gt;=0. geometry.y_span_bottom float\tRestrained by condition: &gt;=0. geometry.x_span_top float\tRestrained by condition: &gt;=0. geometry.y_span_top float\tRestrained by condition: &gt;=0. geometry.theta_x\t0\tfloat geometry.theta_y\t0\tfloat geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0.  Note: The mesh_order of a structure is default to be the mesh order of its material. And the default value will be overridden when the structure's mesh_order is set explicitly.The larger of the mesh_order of a structure, the higher of its priority. With mesh_order of two structures being the same, the structure created later has a higher priority than the one created earlier. When structures overlap, the one with higher priority overrides the one with lower priority.  2.3.4 Add doping​ [14]   st.add_doping(name=&quot;Uniform&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_uniform_x_center, &quot;x_span&quot;: p_uniform_x_span, &quot;y&quot;: p_uniform_y_center, &quot;y_span&quot;: p_uniform_y_span, &quot;z&quot;: p_uniform_z_center, &quot;z_span&quot;: p_uniform_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: p_uniform_con}}) st.add_doping(name=&quot;p_well&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_well_x_center, &quot;x_span&quot;: p_well_x_span, &quot;y&quot;: p_well_y_center, &quot;y_span&quot;: p_well_y_span, &quot;z&quot;: p_well_z_center, &quot;z_span&quot;: p_well_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_well_junction_width, &quot;concentration&quot;: p_well_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;p_pplus&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_pplus_x_center, &quot;x_span&quot;: p_pplus_x_span, &quot;y&quot;: p_pplus_y_center, &quot;y_span&quot;: p_pplus_y_span, &quot;z&quot;: p_pplus_z_center, &quot;z_span&quot;: p_pplus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_pplus_junction_width, &quot;concentration&quot;: p_pplus_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;n_pplus&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: n_pplus_x_center, &quot;x_span&quot;: n_pplus_x_span, &quot;y&quot;: n_pplus_y_center, &quot;y_span&quot;: n_pplus_y_span, &quot;z&quot;: n_pplus_z_center, &quot;z_span&quot;: n_pplus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: n_pplus_junction_width, &quot;concentration&quot;: n_pplus_con, &quot;ref_concentration&quot;: n_pplus_ref}})  add_doping() parameters: name--Doping nametype--Doping type. Options are &quot;n&quot; or &quot;p&quot; for n-type, p-type doping respectivelyproperty--Other properties According to the selection of general.distribution_function, doping is divided into constant doping and gaussian doping. Detailed properties are listed below.  Doping property list: \tdefault\ttype\tnotesgeometry.x float geometry.x_span float geometry.y float geometry.y_span float geometry.z float geometry.z_span float geometry.rotate_x float geometry.rotate_y float geometry.rotate_z float geometry.x_min float geometry.x_max float geometry.y_min float geometry.y_max float geometry.z_min float geometry.z_max float general.distribution_function str\tSelections are ['constant', 'gaussian'] general.concentration float general.source_face str\tAvailable when distribution_function is 'gaussian' general.junction_width float\tAvailable when distribution_function is 'gaussian' general.ref_concentration float\tAvailable when distribution_function is 'gaussian' volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' Description: geometry--Set the geometry parameters of doping box general--Set the distribution function, concentration and so on distribution_function: When it's set to &quot;constant&quot;, only concentration is requiredWhen it's set to &quot;gaussian&quot;: concentration, ref_concentration, junction_width, source_face are required concentration--Concentration in the non-diffusion arearef_concentration--Concentration on the edge of diffusion area (edge of doping box)junction_width--Diffusion junction widthsource_face--The doping source face. Options are &quot;lower_x&quot;, &quot;lower_y&quot;, &quot;lower_z&quot;, &quot;upper_x&quot;, &quot;upper_y&quot; or &quot;upper_z&quot;. &quot;lower_x&quot; means the source face is x=x_min. Similarly for the rest. There is no diffusion area on the edge of source face. As for the other edges, there is a diffusion area within the doping box. volume--Set a list of regions or materials to be doped volume_type: When it's set to &quot;all&quot;(by default)，the doping is applied to all the (semiconductor) structures, restricted by the doping box When it's set to &quot;material&quot;, material_list is required, which means the doping is applied to the structures with one of the specified materials and restricted by the doping box When it's set to &quot;region&quot;, region_list is required, which means the doping is applied to the specified structures and restricted by the doping box  Examples for complete doping setting syntax [15]  st.add_doping(name=&quot;p_pplus&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_pplus_x_center, &quot;x_span&quot;: p_pplus_x_span, &quot;y&quot;: p_pplus_y_center, &quot;y_span&quot;: p_pplus_y_span, &quot;z&quot;: p_pplus_z_center, &quot;z_span&quot;: p_pplus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_pplus_junction_width, &quot;concentration&quot;: p_pplus_con, &quot;ref_concentration&quot;: 1e6}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat_si&quot;], mt[&quot;mat_ge&quot;]]}}) st.add_doping(name=&quot;n_pplus&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: n_pplus_x_center, &quot;x_span&quot;: n_pplus_x_span, &quot;y&quot;: n_pplus_y_center, &quot;y_span&quot;: n_pplus_y_span, &quot;z&quot;: n_pplus_z_center, &quot;z_span&quot;: n_pplus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: n_pplus_junction_width, &quot;concentration&quot;: n_pplus_con, &quot;ref_concentration&quot;: n_pplus_ref}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;region&quot;, &quot;region_list&quot;: [&quot;Si_base&quot;, &quot;Ge&quot;]}})   2.3.5 Add surface recombination​ [16]   # surface recombination st.add_surface_recombination(name=&quot;Cathode_Ge&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;MetalOhmicInterface&quot;, &quot;domain_1&quot;: &quot;Cathode&quot;, &quot;domain_2&quot;: &quot;Ge&quot;, &quot;infinite_recombination&quot;: False, &quot;velocity_electron&quot;: 1e7, &quot;velocity_hole&quot;: 1e7}) st.add_surface_recombination(name=&quot;Anode_Si&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;MetalOhmicInterface&quot;, &quot;domain_1&quot;: &quot;Anode&quot;, &quot;domain_2&quot;: &quot;Si_base&quot;, &quot;infinite_recombination&quot;: False, &quot;velocity_electron&quot;: 1e7, &quot;velocity_hole&quot;: 1e7}) st.add_surface_recombination(name=&quot;Ge_SiO2&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;InsulatorInterface&quot;, &quot;domain_1&quot;: &quot;Ge&quot;, &quot;domain_2&quot;: &quot;SOX&quot;, &quot;velocity_electron&quot;: Ge_SiO2_recombination_velocity, &quot;velocity_hole&quot;: Ge_SiO2_recombination_velocity}) st.add_surface_recombination(name=&quot;Ge_Si&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;HeteroJunction&quot;, &quot;domain_1&quot;: &quot;Ge&quot;, &quot;domain_2&quot;: &quot;Si_base&quot;}) # endregion  add_surface_recombination() parameters： name--Custom nameproperty--Other properties  Surface recombination property list: \tdefault\ttype\tnotessurface_type\tdomain_domain\tstring\tSelections are ['domain_domain', 'material_material']. interface_type\tnull\tstring\tSelections are ['null', 'InsulatorInterface', 'HomoJunction', 'HeteroJunction', 'MetalOhmicInterface', 'SolderPad']. infinite_recombination\ttrue\tbool\tAvailable when interface_type is 'MetalOhmicInterface' velocity_hole\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' velocity_electron\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' domain_1 string\tAvailable when surface_type is 'domain_domain' domain_2 string\tAvailable when surface_type is 'domain_domain' material_1 material\tAvailable when surface_type is 'material_material' material_2 material\tAvailable when surface_type is 'material_material' Description: surface_type--Type of selection for the surface When surface_type is &quot;domain_domain&quot;, the surface is the interface between two structures When surface_type is &quot;material_material&quot;`, the surface is the interface between two materials interface_type--Type of contact for the surface &quot;InsulatorInterface&quot;--Semiconductor-insulator interface&quot;HomoJunction&quot;--Homogeneous semiconductor-semiconductor interface&quot;HeteroJunction&quot;--Heterogeneous semiconductor-semiconductor interface&quot;MetalOhmicInterface&quot;--Semiconductor-conductor interface&quot;SolderPad&quot;--Conductor-insulator interface infinite_recombination--Only available when interface_type is &quot;MetalOhmicInterface&quot;. The surface recombination velocity of holes and electrons will be available when infinite_recombination is False velocity_hole, velocity_electron--Surface recombination velocity of holes and electrons. Available when interface_type is &quot;MetalOhmicInterface&quot; or &quot;InsulatorInterface&quot; domain_1, domain_2--Names of the two structures at the interface. They must be set explicitly when surface_type is &quot;domain_domain&quot; material_1, material_2--The two materials at the interface. They must be set explicitly when surface_type is &quot;material_material&quot;  2.3.6 Set waveform​ [17]   # region --- 4. Waveform --- wv = pj.Waveform() wv.add(name=&quot;waveform&quot;, wavelength_center=wavelength_center, wavelength_span=wavelength_span) # endregion  wv.add() parameters： name--Name of the waveformwavelength_center--Center of wavelengthwavelength_span--Span of wavelengthunit--Unit of wavelength. Options are&quot;um&quot; and &quot;nm&quot;，default to be&quot;um&quot;  2.3.7 Set boundary conditions of optical simulation​ [18]   # region --- 5. oboundary --- for FDTD simulation st.OBoundary(property={ &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;y&quot;: y_mean, &quot;z&quot;: z_mean, &quot;x_span&quot;: x_span, &quot;y_span&quot;: y_span, &quot;z_span&quot;: z_span}}) # endregion   Boundary conditions of optical simulation property list: \tdefault\ttype\tnotesgeneral_pml.pml_same_settings\ttrue\tbool general_pml.pml_profile\tstandard\tstring general_pml.pml_layer integer general_pml.pml_kappa float general_pml.pml_sigma float general_pml.pml_polynomial integer general_pml.pml_alpha float general_pml.pml_alpha_polynomial integer general_pml.pml_min_layers integer general_pml.pml_max_layers integer geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float boundary.x_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.x_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.y_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.y_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.z_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.z_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. Description: geometry--Set the optical simulation region boundary--Set the optical boundary conditions, default to be &quot;PML&quot; for all the boundaries general_pml--Set pml-related parameters  2.3.8 Set local mesh​ [19]   # region --- 6. mesh --- st.add_mesh(name=&quot;OMesh_Ge&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: x_min+1, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: Ge_z_span}, &quot;general&quot;: {&quot;dz&quot;: omesh_grid_Ge}}) st.add_mesh(name=&quot;OMesh_Si&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: x_min+1, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: Si_z_span/2, &quot;z_span&quot;: Si_z_span}, &quot;general&quot;: {&quot;dz&quot;: omesh_grid_Si}}) st.add_emesh(name=&quot;EMesh_Local&quot;, property={ &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: oe_y_max, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;mesh_size&quot;: egrid_local}) st.add_emesh(name=&quot;EMesh_Genrate&quot;, property={ &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: Ge_y_span_top/2, &quot;z_min&quot;: Si_z_span, &quot;z_max&quot;: Ge_z_span+Si_z_span, &quot;mesh_size&quot;: egrid_genrate}) st.add_emesh(name=&quot;EMesh_Ge_SiO2_Interface&quot;, property={ &quot;y&quot;: 0, &quot;y_span&quot;: Ge_y_span_top, &quot;z&quot;: Si_z_span+Ge_z_span, &quot;z_span&quot;: remesh_thickness, &quot;mesh_size&quot;: egrid_interface}) st.add_emesh(name=&quot;EMesh_Ge_Si_Interface&quot;, property={ &quot;y&quot;: 0, &quot;y_span&quot;: Si_slab_width, &quot;z&quot;: Si_z_span, &quot;z_span&quot;: remesh_thickness, &quot;mesh_size&quot;: egrid_interface}) st.add_emesh_along_line(name=&quot;EMesh_Ge_SiO2_Slope_Interface&quot;, property={ &quot;start_x&quot;: oe_x_mean, &quot;start_y&quot;: Ge_y_span_bottom/2, &quot;start_z&quot;: Si_z_span, &quot;end_x&quot;: oe_x_mean, &quot;end_y&quot;: Ge_y_span_top/2, &quot;end_z&quot;: Si_z_span+Ge_z_span, &quot;mesh_size&quot;: egrid_interface}) # endregion  add_mesh() set the local mesh for optical simulation, parameters: name--Custom nameproperty--Other properties  Optical local mesh property list: \tdefault\ttype\tnotesgeneral.dx float\tRestrained by condition: &gt;0. general.dy float\tRestrained by condition: &gt;0. general.dz float\tRestrained by condition: &gt;0. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t Description: geometry--Set the region of local mesh. When x_span doesn't vanish, the mesh setting will be applied to the range along the x axis. Similarly for the rest general--Set the mesh size in the corresponding direction  add_emesh() set a rectangle region for local mesh of electrical simulation. Parameters: name--Custom nameproperty--Other properties  Local mesh of electrical simulation in rectangle region property list: \tdefault\ttype\tnotesx float x_span float\tRestrained by condition: &gt;=0. x_min float x_max float y float y_span float\tRestrained by condition: &gt;=0. y_min float y_max float z float z_span float\tRestrained by condition: &gt;=0. z_min float z_max float mesh_size float\tmax size of electrical simulation mesh Note: When the simulation region is in the xy plane, only the parameters in the x, y direction are effective, and parameters in the z direction will be ignored. Similarly for the rest.  add_emesh_along_line() set a line region for local mesh of electrical simulation. Parameters： name--Custom nameproperty--Other properties  Local mesh of electrical simulation in line region property list: \tdefault\ttype\tnotesstart_x\t0\tfloat start_y\t0\tfloat\tRestrained by condition: &gt;=0. start_z\t0\tfloat end_x\t1\tfloat end_y\t1\tfloat end_z\t1\tfloat\tRestrained by condition: &gt;=0. mesh_size\t0.01\tfloat\t Note: When the simulation region is in the xy plane, besides start_x, start_y, end_x and end_y, it is also required to set the start_z and end_z, which should both be the same as the z coordinate of the plane. Similarly for the rest.  2.3.9 Set optical sources​ [20]   # region --- 7. source --- src = pj.Source() src.add(name=&quot;Mode Source&quot;, axis=&quot;x_forward&quot;, type=&quot;mode_source&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: x_min+1, &quot;x_span&quot;: 0, &quot;y&quot;: y_mean, &quot;y_span&quot;: y_span, &quot;z&quot;: z_mean, &quot;z_span&quot;: z_span}, &quot;general&quot;: {&quot;mode_selection&quot;: &quot;user_select&quot;, &quot;waveform&quot;: {&quot;waveform_id_select&quot;: wv[&quot;waveform&quot;]}}}) # endregion  src.add() parameters： name--Name of the sourceaxis--Direction of the source. &quot;x_forward&quot; means light propagating along x axis and in the direction of increasing x coordinate. &quot;x_forward&quot; means the opposite direction. Similarly for the resttype--Type of the source. It is mode source in this exampleproperty--Other properties  Mode source property list: \tdefault\ttype\tnotesgeneral.amplitude\t1.0\tfloat general.phase\t0.0\tfloat general.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. general.mode_index\t0\tinteger general.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. general.n\t1.0\tfloat general.number_of_trial_modes\t20\tinteger general.waveform.waveform_id_select any general.rotations.theta\t0\tfloat general.rotations.phi\t0\tfloat general.rotations.rotation_offset\t0\tfloat bent_waveguide.bent_waveguide\tfalse\tbool bent_waveguide.radius\t1\tfloat bent_waveguide.orientation\t20\tfloat bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t Description: geometray--Set geometric parameters of optical source bent_waveguide--Set parameters related to bent waveguide general： mode_selection--Set the type of selection for the eigen mode. When it is &quot;user_select&quot;, the mode of index in mode_index is selectedwaveform--Set the waveform of the source waveform_id_select--Set to be a specified waveform  2.3.10 Set monitors​ [21]   # region ---8.monitor --- mn = pj.Monitor() mn.add(name=&quot;Power Monitor&quot;, type=&quot;power_monitor&quot;, property={ &quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength_center, &quot;wavelength_span&quot;: wavelength_span}}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;3d&quot;, &quot;x_min&quot;: Ge_x_center-Ge_x_span_bottom/2, &quot;x_max&quot;: Ge_x_center+Ge_x_span_bottom/2, &quot;y&quot;: 0, &quot;y_span&quot;: Ge_y_span_bottom, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: Ge_z_span}}) mn.add(name=&quot;y=0&quot;, type=&quot;power_monitor&quot;, property={ &quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength_center, &quot;wavelength_span&quot;: wavelength_span}}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_y_normal&quot;, &quot;x_min&quot;: Ge_x_center-Ge_x_span_bottom/2, &quot;x_max&quot;: Ge_x_center+Ge_x_span_bottom/2, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: Ge_z_span}}) mn.add(name=&quot;z=0.47&quot;, type=&quot;power_monitor&quot;, property={ &quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength_center, &quot;wavelength_span&quot;: wavelength_span}}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_min&quot;: Ge_x_center-Ge_x_span_bottom/2, &quot;x_max&quot;: Ge_x_center+Ge_x_span_bottom/2, &quot;y&quot;: 0, &quot;y_span&quot;: Ge_y_span_bottom, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: 0}}) # endregion  The monitor &quot;Power Monitor&quot; is of the 3D type, set to record the optical field profile in the &quot;Ge&quot; structure, which will be used to calculate the optical generation rate. The monitors &quot;y=0&quot; and &quot;z=0.47&quot; are both of the 2D type, set to visualize the optical field profile at the specified cross-sections. mn.add() parameters： name--Name of the monitortype--Type of the monitorproperty--Other properties  Power monitor property list: \tdefault\ttype\tnotesgeneral.frequency_profile.sample_spacing\tuniform\tstring\tSelections are ['uniform']. general.frequency_profile.use_wavelength_spacing\ttrue\tbool general.frequency_profile.spacing_type\twavelength\tstring\tSelections are ['wavelength', 'frequency']. general.frequency_profile.wavelength_min float general.frequency_profile.wavelength_max float general.frequency_profile.wavelength_center float general.frequency_profile.wavelength_span float general.frequency_profile.frequency_min float general.frequency_profile.frequency_max float general.frequency_profile.frequency_center float general.frequency_profile.frequency_span float general.frequency_profile.frequency_points integer geometry.monitor_type string\tSelections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float advanced.sampling_frequency.min_sampling_per_cycle\t2\tinteger\t Description: geometry--Set the geometric parameters of the monitor, including the dimension and the size general--Set the frequency points of the monitor frequency_profile: sample_spacing--Only support &quot;uniform&quot; currently, which means the frequency points are uniformly sampled in either wavelength or frequency use_wavelength_spacing--Default to be True. When it' True, the frequency points in sampled in wavelength, otherwise, in frequency. spacing_type--Default to be &quot;wavelength&quot;. When it's &quot;wavelength&quot;, the frequency range is set in wavelength; When it's &quot;frequency&quot;, the frequency range is set in frequency frequency_points--Number of frequency points  2.3.11 Preview the structures​  2.3.11.1 Define the preview function​ [22]  # ------------- preview -------------- time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) @timed def preview(): pj = pd_project(project_name=simu_name + time_str, run_mode=&quot;local&quot;, material_property=&quot;normal&quot;) plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)  Call the pd_project function defined earlier to create a new project pj. simu_name is set in the general parameters. time_str is the time stamp when the function started running and is added to the project name, to make the project name unique for each simulation and the simulation results not overwritten by each other. plot_path will be set to the save path of the result extraction. Here, it is set to the 'plots' folder located in the same directory as this script. If the path doesn't exist, os.makedirs() should be called to create it.  2.3.11.2 Add solvers​ Optical and electrical solvers are added within the preview function. The corresponding structure preview is only available when the solvers are present. [23]   simu = pj.Simulation() simu.add(name=&quot;preview_fdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}}) simu.add(name=&quot;preview_oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: &quot;&quot;, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  simu.add() parameters： name--Name of the solvertype--Type of the solver. For active device simulation, the type of FDTD solver is &quot;AFDTD&quot;, and the type of carrier transport solver is &quot;OEDevice&quot;property--Other properties  For AFDTD，mesh_settings.mesh_accuracy.cells_per_wavelength means the number of mesh cells per wavelength. The larger the number, the smaller the mesh size and the longer the simulation time. For OEDevice，other properties are not necessary. So property can be empty. Detailed parameter settings for OEDevice can be found in the appendix.  2.3.11.3 Preview doping profile​ Preview the doping profile by the run_doping function of the OEDevice solver. [24]   simu[&quot;preview_oedevice&quot;].run_doping(name=&quot;x_in&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}}, norm=&quot;log&quot;, scale=&quot;equal&quot;, superimpose=False, show=False, material_list=[&quot;Ge&quot;, &quot;Si&quot;], cmin=8e5, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;doping_x_in&quot;)  run_doping() parameters: name--Custom namenorm--Set the normalization method for the intensity plot, default to be &quot;linear&quot;, which means linear normalization. It can also be set to &quot;log&quot;, which means taking the logarithm of the intensity first, and then performing linear normalization. The net doping is calculated as $N_D-N_A$, where $N_D$ denotes the donor concentration and $N_A$ denotes the acceptor concentrationscale--Set the scaling method of the vertical and horizontal axes, default to be &quot;equal&quot;, which means the two axes are scaled proportional. It can also be set to &quot;auto&quot;, which means the two axes are scaled automaticallysuperimpose--Set whether the structure plot and the doping plot superimpose or not, default to be &quot;True&quot;show--Set whether the result plot should be displayed in a popup window, default to be False, which means not and it will be saved to the savepath automatically. When it is True, the result plot won't pop up and will not be saved unless operated manuallymaterial_list--Specify a list of materials to preview the doping profile. And each item in the list should be the chemical formula of the material. Default to be empty, which means all the materials will be previewedregion_list--Specify a list of structures to preview the doping profile. And each item in the list is the name of the structure. Default to be empty, which means all the structures will be previewed. When it's not empty, it will override the material_list settingcmax--Set the maximum of the colorbar for the intensity plot. When the concentration is greater than this value, it will be displayed as this value. It is ineffective for net dopingcmin--Set the minimum of the colorbar for the intensity plot. When the concentration is smaller than this value, it will be displayed as this value. It is ineffective for net dopingsavepath--The save path for the resultproperty--Other properties  run_doping property list: \tdefault\ttype\tnotesgeometry.dimension string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t Description: geometry--Set the region of doping preview dimension--Set the dimension of doping preview. The electrical simulation only supports the 2D type currently, so the doping and its preview are all considered in a plane. When dimension is &quot;2d_x_normal&quot;, it means the preview is in the yz plane. Similarly for the rest.  Result show of the doping preview  Fig 1. Net doping  2.3.11.4 Preview index profile​ Preview the index profile by the run_index function of the AFDTD solver. [25]   simu[&quot;preview_fdtd&quot;].run_index(name=&quot;index_preview_x_10&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 10, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 4, &quot;z_min&quot;: -0.5, &quot;z_max&quot;: 0.72}}, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;MeshView/&quot; + &quot;x=10&quot;, export_csv=False, show=False) simu[&quot;preview_fdtd&quot;].run_index(name=&quot;index_preview_z_0.11&quot;, property={ &quot;geometry&quot;: {&quot;x_min&quot;: -43, &quot;x_max&quot;: 19, &quot;y&quot;: 0, &quot;y_span&quot;: 6.4, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0}}, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;MeshView/&quot; + &quot;z=0.11&quot;, export_csv=False, show=False)  run_index() parameters： name--Custom nameexport_csv--Whether to export csv file, default to be Falsesavepath--Save path of the result extractionshow--Whether to show the plot in a popup window, default to be Falseexport_n--Whether to export nx, ny, nz, default to be Trueexport_c--Whether to export σx, σy, σz, default to be Falsemax_index--Set the maximum of the intensity plot of index, default to be Nonemax_sigma--Set the maximum of the intensity plot of conductivity, default to be Noneproperty--Other properties  run_index property list： \tdefault\ttype\tnotesgeometry.monitor_type string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t Description: geometry--Set the region of index preview. The run_index function currently only supports the index preview in a 2D plane. If x_span is set to 0, the preview will be performed in the yz plane. Similarly for the rest.  Result show of the index preview  Fig 2. nx  "},{"title":"3. Simulation​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#3-simulation","content":" "},{"title":"3.1 Dark current​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#31-dark-current","content":"This section performs the simulation of dark current in the VPD0B_Id.py script by invoking the pd_project function.  3.1.1 Import simulation toolkit​ [26]  from VPD00_structure import * import time import os from pathlib import Path  All the variables and functions from VPD00_structure.py are imported.  3.1.2 Set general parameters​ [27]  start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # region --- 0. General Parameters --- tcad_vmin = 0 # unit:Volt tcad_vmax = 4 # unit:Volt tcad_vstep = 0.5 # unit:Volt # endregion # ---------------------- set project_path simu_name = &quot;VPD0B_Id&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str material_property = &quot;normal&quot; genrate_file_path = &quot;&quot; # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)   3.1.3 Create a new project​ [28]  pj = pd_project(project_name, run_mode, material_property)   3.1.4 Add electrodes​ [29]  st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  add_electrode() parameters: name--Name of the electrodeproperty--Other properties The detailed property list of electrode can be found in the appendix. Here a range of voltage from 0V to 4V is applied to the electrode &quot;cathode&quot;, and the step of the voltage is 0.5V.  3.1.5 Add the solver​ [30]  # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  Description: The detailed property list of OEDevice solver can be found in the appendix. Here: genrate--Set the properties for optical generation rate genrate_path--It's set to genrate_file_path, which is &quot;&quot;, an empty string. That means no optical generation rate is imported to the OEDevice solver. Therefore, the simulation is for dark current. And the rest properties in genrate is ineffective in this case geometry--Set the geometric parameters for the simulation region dimension--It's set to 2d_x_normal, which means the simulation is in the yz plane general: norm_length--It's set to normal_length, which is 20, meaning that the size of the device in the third dimension is 20μm. That is to say its length in the x-direction is 20μmsolver_mode--It's set to &quot;steady_state&quot;, which means a steady state simulation  3.1.6 Run the solver​ [31]  # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run()  result_device stores the information of the simulation result, which can be used to perform result extraction.  3.1.7 Extract the result​ [32]  # --- Extract --- result_device.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;IV_cathode&quot;)  result_device.extract() parameters： data--Type of the result. Here it's set to &quot;I&quot; to extract the I-V curve from the simulation resultelectrode--Name of an electrode, which means the current data is from the electrodeexport_csv--Whether to export the csv resultshow--Whether to show the plot in a popup windowsavepath--The save path for the result extraction  Result show of the dark current extraction  Fig 3. Dark Current  3.1.8 Print the simulation time​ [33]  print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   "},{"title":"3.2 Resistance​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#32-resistance","content":"This simulation applies a forward bias to the electrode &quot;anode&quot;. And then the I-V curve is extracted and fitted to obtain the resistance. The script is in the VPD0C_Rs.py file.  3.2.1 Simulate and extract the I-V curve​ [34]  from VPD00_structure import * import time import os from pathlib import Path import numpy as np from matplotlib import pyplot as plt # region --- 0. General Parameters --- tcad_vmin = 0 # unit:Volt tcad_vmax = 1.5 # unit:Volt tcad_vstep = 0.25 # unit:Volt # endregion start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # ---------------------- set project_path simu_name = &quot;VPD0C_Rs&quot; material_property = &quot;normal&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str genrate_file_path = &quot;&quot; # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path) # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property) st = pj.Structure() st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}}) # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run() # --- Extract IV --- IV_file_folder = plot_path + project_name + &quot;IV_anode&quot; result_device.extract(data=&quot;I&quot;, electrode=&quot;anode&quot;, export_csv=True, show=False, savepath=IV_file_folder)  A range of voltage from 0V to 1.5V is applied to the electrode &quot;anode&quot;, with a step of 0.25V. No optical generation rate is applied. And a steady state simulation is performed to extract the I-V curve, which is saved to the folder IV_file_folder.  Result show of the I-V curve Fig 4. I-V curve  3.2.2 Fit V-I curve to obtain resistance​  3.2.2.1 Read the saved I-V data​ [35]  # region --- calculate R --- IV_file = os.path.join(IV_file_folder, &quot;0_I_Real.csv&quot;) for i in range(10): IV_file = os.path.join(IV_file_folder, str(i) + &quot;_I_Real.csv&quot;) if os.path.exists(IV_file): break rawdata = np.genfromtxt(IV_file, skip_header=3, delimiter=',') I = rawdata[:,1] V = rawdata[:,0]  &quot;0_I_Real.csv&quot; is filename generated automatically of the I-V result. The &quot;0&quot; in the beginning indicates the index of the electrode. When the I-V curve is from a different electrode, the index will change. Therefore, a iteration from 0 to 9 is applied to find the saved I-V data file.  3.2.2.2 Fit the data to obtain resistance​ [36]  start_idx = len(V)//2 coeffs = np.polyfit(I[start_idx:], V[start_idx:], 1) V_fit = coeffs[0]*I + coeffs[1] R = abs(coeffs[0])  Fit the data after the index start_idx, which is the start index of the approximately linear portion of the curve. A first-order polynomial fitting is performed on the V-I data. Then the coefficient of the first-order term is the device resistance.  3.2.2.3 Save data and plots​ [37]  Rdata_folder = os.path.join(plot_path, project_name, &quot;resistance&quot;) if not os.path.exists(Rdata_folder): os.makedirs(Rdata_folder) Rdata_file = os.path.join(Rdata_folder, &quot;Rdata.dat&quot;) Rdata_fig = os.path.join(Rdata_folder, &quot;resistance.jpg&quot;) with open(Rdata_file, &quot;w&quot;) as fp: fp.write(&quot;Resistance: &quot; + f&quot;{R} Ohm\\n&quot;) fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(I, V, c=&quot;b&quot;, linewidth=linewidth, label=&quot;V-I&quot;) ax.plot(I, V_fit, c=&quot;g&quot;, linewidth=linewidth, label=&quot;V_fit-I&quot;) ax.set_xlabel(&quot;I[A]&quot;) ax.set_ylabel(&quot;V[V]&quot;) plt.legend() plt.ticklabel_format(style=&quot;sci&quot;, scilimits=(-1, 2)) ax.grid() plt.savefig(Rdata_fig) plt.close() # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   Result show of the V-I fitting Fig 5. V-I fitting  "},{"title":"3.3 Capacitance​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#33-capacitance","content":"This section performs a SSAC simulation, and extracts the capacitance. The script is in the VPD0A_C.py file. [38]  from VPD00_structure import * import time import os from pathlib import Path # region --- 0. General Parameters --- tcad_vmin = 0 # unit:Volt tcad_vmax = 3 # unit:Volt tcad_vstep = 0.5 # unit:Volt # endregion start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) simu_name = &quot;VPD0A_C&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path) # ---------------------- set project_path material_property = &quot;normal&quot; genrate_file_path = &quot;&quot; # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property) st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;All&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;SSAC&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;small_signal_ac&quot;: {&quot;frequency_spacing&quot;: &quot;single&quot;, &quot;frequency&quot;: 1e8}, # &quot;small_signal_ac&quot;: {&quot;frequency_spacing&quot;: &quot;log&quot;, &quot;log_start_frequency&quot;: 1e6, &quot;log_stop_frequency&quot;: 1e10, &quot;log_num_frequency_points&quot;: 3}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}}) # ---------------------- run # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run() # ---------------------- extract result_device.extract(data=&quot;C&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;C&quot;) print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)  Description: For OEDevice solver, the detailed properties can be found in the appendix. Here: general: solver_mode--It's set to &quot;SSAC&quot;, which means a SSAC simulation small_signal_ac--Set the frequency points frequency_spacing--It's set to &quot;single&quot;, which means a single frequency point frequency--Set the value of the single frequency  For the electrode &quot;cathode&quot;, a range of voltage from 0V to 3V is applied to it, with a step of 0.5V. apply_AC_small_signal--It's set to All, which means the small signal analysis is applied at each voltage step  For the result extraction: data--It's set to &quot;C&quot;, which is available after the SSAC simulation and is used to extract the capacitance  Result show of the capacitance Fig 6. Capacitance  "},{"title":"3.4 Optical generation rate​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#34-optical-generation-rate","content":"This section performs a FDTD simulation to obtain the optical field profile in the structure of &quot;Ge&quot;, and then calculate the photo-induced carrier generation rate. The average of the optical generation rate in the light propagating direction, which is the x-direction, is then taken to obtain the profile in the yz plane to be imported to the OEDevice simulation. The script is in the VPD01_FDTD.py file.  3.4.1 Import simulation toolkit​ [39]  from VPD00_structure import * import time import os from pathlib import Path   3.4.2 Set general parameters​ [40]  start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # ---------------------- set project_path simu_name = &quot;VPD01_FDTD&quot; material_property = &quot;normal&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; genrate_file_folder = plot_path + project_name + &quot;genrate&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)   3.4.3 Create a new project​ [41]  # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property)   3.4.4 Add the solver​ [42]  # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;fdtd&quot;, type=&quot;FDTD&quot;, property={ &quot;general&quot;: {&quot;simulation_time&quot;: 2000}, &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}}) simu.add(name=&quot;afdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;general&quot;: {&quot;simulation_time&quot;: 2000}, &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}})  The AFDTD solver for active device simulation can be used to extract the optical generation rate, but can't export the optical field profile. And the usage of the FDTD solver is exactly the opposite. Therefore, both solvers are added here to serve the different purposes.  3.4.5 Run and extract the result​ [43]  # --- Run --- # check license and print version before &amp; after simulation. # result_fdtd = simu[&quot;fdtd&quot;].run() # result_fdtd.extract(data=&quot;fdtd:power_monitor&quot;, monitor_name=&quot;y=0&quot;, savepath=plot_path + project_name + &quot;E_y=0&quot;, # attribute=&quot;E&quot;, target=&quot;intensity&quot;, wavelength=str(wavelength_center), export_csv=True) # result_fdtd.extract(data=&quot;fdtd:power_monitor&quot;, monitor_name=&quot;z=0.47&quot;, savepath=plot_path + project_name + &quot;E_z=0.47&quot;, # attribute=&quot;E&quot;, target=&quot;intensity&quot;, wavelength=str(wavelength_center), export_csv=True) result_afdtd = simu[&quot;afdtd&quot;].run() result_genrate = result_afdtd.run_generation_rate_analysis(name=&quot;genrate&quot;, monitor=&quot;Power Monitor&quot;, average_dimension=&quot;x&quot;, light_power=1, coordinate_unit=&quot;m&quot;, field_length_unit=&quot;m&quot;) # unit： m, cm, um, nm #average_dimension: x/y/z result_genrate.extract(data=&quot;generation_rate&quot;, export_csv=True, show=False, log=False, savepath=genrate_file_folder) result_genrate.extract(data=&quot;pabs_total&quot;, export_csv=True, show=False, log=False, savepath=genrate_file_folder) print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)  run_generation_rate_analysis() parameters： name--Custom namemonitor--Name of the power_monitor for calculating optical generation rate. The power_monitor is required to be of 3D typeaverage_dimension--Set the direction to take the average of the optical generate ratelight_power--Set the power of the light source, measured in W. The optical generation rate will be scaled based on the powercoordinate_unit--Set the coordinate unit in the optical generation rate file (gfile)field_length_unit--Set the length unit in the generation rate unit in the optical generation rate file (gfile). If it's set to &quot;m&quot;, the generation rate unit in the gfile will be /m^3/s. Similarly for the rest  result_genrate.extract() parameters： data--Type of the result When data is set to &quot;generation_rate&quot;, besides an image file and a csv file, the result files also include a text file in .gfile format. The coordinate unit in the csv and the image file is um, and the generation rate unit in the two files is /cm^3/s. These units can't be modified when extracting the result. However, the units in the gfile are controlled by coordinate_unit、field_length_unit. And only the gfile can be imported to the OEDevice solverWhen data is set to &quot;pabs_total&quot;, the total absorption power is extracted export_csv--Whether to export csv file show--Whether to show the plot in a popup window log--Whether to apply a logarithmic normalization in the intensity plot savepath--The save path of the result extraction  Result show of the optical generation rate Fig 7. Optical generation rate  "},{"title":"3.5 Photo current​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#35-photo-current","content":"This section imports the optical generation rate to the OEDevice solver, and performs a steady state simulation to obtain the photo current. The script is in the VPD02_Ip.py file.  3.5.1 Import simulation toolkit​ [44]  from VPD00_structure import * import time import os from pathlib import Path   3.5.2 Set general parameters​ [45]  start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # region --- 0. General Parameters --- tcad_vmin = 0 # unit:Volt tcad_vmax = 4 # unit:Volt tcad_vstep = 0.5 # unit:Volt # endregion # ---------------------- set project_path simu_name = &quot;VPD02_Ip&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str material_property = &quot;normal&quot; genrate_file_folder = str(Path(__file__).parent.as_posix()) genrate_file_path = genrate_file_folder + &quot;/VPD01_FDTD.gfile&quot; # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)  genrate_file_path is the absolute path of the gfile to be imported to the OEDevice solver. Here it's set to the absolute path of VPD01_FDTD.gfile in the same directory. And this can be changed to the path of the gfile extracted by the AFDTD simulation.  3.5.3 Create a new project​ [46]  # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property)   3.5.4 Add electrodes​ [47]  st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   3.5.5 Add the solver​ [48]  # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  Description: genrate: genrate_path--Here it's not empty, meaning that the file at the path will be imported to the OEDevice solvercoordinate_unit--Set the coordinate unit in the gfilefield_length_unit--Set the length unit in the generation rate unit in the gfilesource_fraction--Set the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport  3.5.6 Run and extract the result​ [49]  # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run() # --- Extract --- result_device.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;IV_cathode&quot;) print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   Result show of the photo current Fig 8. Photo current  "},{"title":"3.6 Bandwidth​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#36-bandwidth","content":"This section performs a transient simulation to extract the step response of the photo current. Then the bandwidth is obtained by postprocessing the I-t curve. The script is in the VPD03_bw.py file.  3.6.1 Import simulation toolkit​ [50]  from VPD00_structure import * import time import os from pathlib import Path import numpy as np from scipy import interpolate as scip, fft as scfft from matplotlib import pyplot as plt   3.6.2 Set general parameters​ [51]  start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # region --- 0. General Parameters --- tcad_vbias = 1 # the bias voltage on cathode source_fraction = 1e-4 # the source generation rate is multiplied by this factor # endregion # ---------------------- set project_path simu_name = &quot;VPD03_bw&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str material_property = &quot;transient&quot; genrate_file_folder = str(Path(__file__).parent.as_posix()) genrate_file_path = genrate_file_folder + &quot;/VPD01_FDTD.gfile&quot; # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)   3.6.3 Create a new project​ [52]  # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property)   3.6.4 Add electrodes​ [53]  st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: tcad_vbias, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 2.001e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 30e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.001e-12, &quot;time_stop&quot;: 2.01e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 60e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.01e-12, &quot;time_stop&quot;: 2.03e-12, &quot;initial_step&quot;: 60e-18, &quot;max_step&quot;: 2e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.03e-12, &quot;time_stop&quot;: 10e-12, &quot;initial_step&quot;: 2e-15, &quot;max_step&quot;: 50e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 10e-12, &quot;time_stop&quot;: 500e-12, &quot;initial_step&quot;: 50e-15, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}]}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  Description: For the electrode &quot;cathode&quot;: bc_mode--Here it's set to &quot;transient&quot;, which means a transient boundary condition is applied to this electrode. Then the time dependence of the optical generation rate can be set at this electrodevoltage--Here it's set to tcad_vbias, which is 1, meaning that the voltage is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation.v_step_max--Set the max step of the voltage from the equilibrium state to steady state at the bias of voltage.time_table--Set the time dependence of optical generation rate. It's of a list type, whose item is of a dictionary type. In each of its item: time_start--Set the start time point of the range. The value of 0 represents the steady state of the earlier simulation.time_stop--Set the stop time point of the rangeinitial_step--Set the initial time step of the rangemax_step--Set the max time step of the rangeoptical--Set the optical generation rate during the time range enabled--Whether to apply optical generation rate during the time range. The value of 1 means True, and 0 means Falseenvelop--The envelop of the scaling factor of the light power during the time range. When it's set to 0, the envelop is uniformsource_fraction--When envelop is set to0, this value is the scaling factor of the light power during the time range Note: The dependency of scaling factor of light power on time is a step function here.  3.6.5 Add the solver​ [54]  # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: 0}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;transient&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;use_global_max_iterations&quot;: False, &quot;poisson_max_iterations&quot;: 50, &quot;ddm_max_iterations&quot;: 20, &quot;use_quasi_fermi&quot;: &quot;enabled&quot;, &quot;damping&quot;: &quot;potential&quot;, &quot;potential_update&quot;: 2, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e7}})  Description: general: solver_mode--Here it's set to &quot;transient&quot;, which means a transient simulation advanced: use_global_max_iterations--Whether to use global max iterations during the initialization of solving the Poisson equations and the subsequent computing for solving the drift-diffusion equations coupling with Poisson equationspoisson_max_iterations--Set the max iterations during the initialization of solving the Poisson equations, available when use_global_max_iterations is Falseddm_max_iterations--Set the max iterations during the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, available when use_global_max_iterations is Falseuse_quasi_fermi--Whether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. &quot;enabled&quot; means True, and &quot;disabled&quot; means Falsedamping--Set the nonlinear update damping scheme. &quot;potential&quot; means the damping is based on the potential variationpotential_update--Set the threshold potential for potential damping. The large value will reduce the strength of damping effectrelative_tolerance--Set the relative update tolerancetolerance_relax--Set the tolerance relaxation factor for convergence on relative tolerance criteria  3.6.6 Run the solver​ [55]  # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run()   3.6.7 Extract the result​ The I-t curve is extracted. Because the dependency of the light power on time is a step function, the I-t curve here represents the step response of the photo current. [56]  # --- Extract --- It_file_folder = plot_path + project_name + &quot;I&quot; result_device.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, show=False, export_csv=True, savepath=It_file_folder) # result_device.extract(data=&quot;In&quot;, electrode=&quot;cathode&quot;, show=False, export_csv=True, savepath=plot_path + project_name + &quot;In&quot;) # result_device.extract(data=&quot;Ip&quot;, electrode=&quot;cathode&quot;, show=False, export_csv=True, savepath=plot_path + project_name + &quot;Ip&quot;)   Result show of the step response Fig 9. Step response  3.6.8 Postprocess​ By taking the derivative of the step response, the impulse response is obtained. Then the Fast Fourier Transform is applied to the impulse response, resulting in the frequency response, which allows to determine the device bandwidth.  3.6.8.1 Obtain the impulse response​ [57]  # region Calculate 3dB bandwidth It_file = os.path.join(It_file_folder, &quot;0_I_Real.csv&quot;) for i in range(10): It_file = os.path.join(It_file_folder, str(i) + &quot;_I_Real.csv&quot;) if os.path.exists(It_file): break rawdata = np.genfromtxt(It_file, skip_header=3, delimiter=',') I = rawdata[:,1] t = rawdata[:,0]*1e-15 start_idx = 2 t = t[start_idx:] I = I[start_idx:] # Calculate impulse response dI/dt from step response I(t) # Impulse response at t[i] is the average of dI[i-1]/dt[i-1] and dI[i]/dt[i] dt = np.diff(t) dI = np.diff(I) dIdt = (dI[1:] + (dt[1:]/dt[:-1])**2*dI[:-1])/(dt[1:]*(1+dt[1:]/dt[:-1])) delta_t = 1e-13 th = t[1:len(t)-1] nt = int(np.ceil((th[-1]-th[0])/delta_t)) t_interp = np.linspace(th[0], th[-1], nt) interp1d_func = scip.interp1d(th, dIdt) dIdt_interp = interp1d_func(t_interp)  First, take the derivative of the step response to obtain the impulse response. And then uniform time intervals and perform interpolation on the impulse response to facilitate the subsequent application of the Fast Fourier Transform.  3.6.8.2 Export the impulse response result​ [58]  # Output impulse response bandwidth_folder = str(Path(It_file_folder).parent.as_posix()) + &quot;/3dB_bandwidth&quot; if not os.path.exists(bandwidth_folder): os.makedirs(bandwidth_folder) impulse_fig = os.path.join(bandwidth_folder, &quot;impulse_response.jpg&quot;) fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(t_interp*1e12, dIdt_interp/np.max(np.abs(dIdt_interp)), c='b', linewidth=linewidth, label=&quot;Impulse response&quot;) ax.set_ylabel(&quot;Impulse response&quot;) ax.set_xlabel(&quot;Time [ps]&quot;) ax.grid() plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1,2)) plt.savefig(impulse_fig) plt.close()   Result show of the impulse response Fig 10. Impulse response  3.6.8.3 Obtain the frequency response​ [59]  fresponse = scfft.rfft(dIdt_interp) freq = scfft.rfftfreq(len(t_interp), t_interp[1]-t_interp[0]) fresponse = np.abs(fresponse)/np.max(np.abs(fresponse)) # Calculate 3dB bandwidth by interpolation log_freq = np.log10(freq[1:]) log_fresp = 20*np.log10(np.abs(fresponse[1:])) resp_3dB = -3 log_freq_3dB = scip.interp1d(log_fresp, log_freq)(resp_3dB) bandwidth_GHz = 10**log_freq_3dB*1e-9  Obtain the frequency response by Fast Fourier Transform. And then calculate the 3dB bandwidth by interpolation.  3.6.8.4 Export the frequency response result​ [60]  bandwidth_file = os.path.join(bandwidth_folder, &quot;3dB_bandwidth.txt&quot;) bandwidth_fig = os.path.join(bandwidth_folder, &quot;3dB_bandwidth.jpg&quot;) with open(bandwidth_file, 'w') as fp: fp.write(&quot;3dB bandwidth: &quot; + f&quot;{bandwidth_GHz:.6f} GHz\\n&quot;) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(freq[1:]*1e-9, 20*np.log10(np.abs(fresponse[1:])), 'b', linewidth=linewidth, label=&quot;Normalized response&quot;) ax.plot(freq[1:]*1e-9, resp_3dB*np.ones(len(freq[1:])), 'g', linewidth=linewidth) ax.set_xlim(left = 1, right = 300) ax.set_ylim(bottom = -25) ax.set_xscale('log') ax.set_ylabel('Normalized response [dB]') ax.set_xlabel('Frequency [GHz]') ax.grid(which='both', axis='both') plt.savefig(bandwidth_fig) # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   Result show of the frequency response Fig 11. Frequency response  "},{"title":"3.7 Saturation power​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#37-saturation-power","content":"This section scans the input light power and obtains the I-P curve, thereby roughly determining the saturation light power. The script is in the VPD04_Psat.py file.  3.7.1 Import simulation toolkit​ [61]  from VPD00_structure import * import time import os from pathlib import Path import numpy as np from matplotlib import pyplot as plt   3.7.2 Set general parameters​ [62]  # region --- 0. General Parameters --- sweep_parameter_name = &quot;source_fraction&quot; sweep_value_table = np.linspace(0.001, 0.02, 20) vbias = 1 # unit:Volt, voltage on cathode # endregion start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path) simu_name = &quot;VPD04_Psat&quot; material_property = &quot;normal&quot; genrate_file_folder = str(Path(__file__).parent.as_posix()) genrate_file_path = genrate_file_folder + &quot;/VPD01_FDTD.gfile&quot;   3.7.3 Define a sweeping function​ [63]  def sweep_simulation(sweep_value):   3.7.3.1 Set the sweeping parameter​ [64]   # ---------------------- set sweep parameter if not sweep_parameter_name in globals(): raise Exception(f&quot;Parameter {sweep_parameter_name} not found!&quot;) exec(f&quot;global {sweep_parameter_name}; {sweep_parameter_name} = sweep_value&quot;)  Using the features of Python, modify the value of parameter source_fraction corresponding to sweep_parameter_name to the value of sweep_value which is passed from the sweep_simulation function.  3.7.3.2 Create a new project​ [65]   # ---------------------- set project_path project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str + sweep_parameter_name + &quot;_&quot; + str(sweep_value) + &quot;/&quot; # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property)   3.7.3.3 Add electrodes​ [66]   st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: vbias, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  Apply a voltage of 1V to the electrode &quot;cathode&quot; to perform a steady state simulation.  3.7.3.4 Add the solver​ [67]   # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})   3.7.3.5 Run the solver​ [68]   # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run()   3.7.3.6 Extract and return the I-V result​ [69]   # --- Extract --- IV_file_folder = plot_path + project_name + &quot;IV_cathode&quot; result_device.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=IV_file_folder) IV_file = os.path.join(IV_file_folder, &quot;0_I_Real.csv&quot;) for i in range(10): IV_file = os.path.join(IV_file_folder, str(i) + &quot;_I_Real.csv&quot;) if os.path.exists(IV_file): break data = np.genfromtxt(IV_file, skip_header=3, delimiter=',') return data   3.7.4 Run the sweeping function and export the result​ [70]  # region --- sweep result postprocess --- fontsize = 20 linewidth = 1 sweep_parameter_label = sweep_parameter_name sweep_parameter_unit = &quot;&quot; Isweep = [] voltages = np.zeros(0) for sweep_value in sweep_value_table: data = sweep_simulation(sweep_value) if len(data.shape) == 1: data = data.reshape((1, len(data))) voltages = data[:,0] Isweep.append(data[:, 1]) Isweep_folder = os.path.join(plot_path, simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str + &quot;Isweep&quot;) if not os.path.exists(Isweep_folder): os.makedirs(Isweep_folder) Isweep = np.array(Isweep) sweep_value_table = np.array(sweep_value_table) plt.rcParams.update({&quot;font.size&quot;: fontsize}) for i in range(len(voltages)): Isweep_fig = os.path.join(Isweep_folder, &quot;Isweep_&quot; + str(voltages[i]) + &quot;V.jpg&quot;) Isweep_file = os.path.join(Isweep_folder, &quot;Isweep_&quot; + str(voltages[i]) + &quot;V.csv&quot;) Iresp = Isweep[:,i] with open(Isweep_file, &quot;w&quot;) as fp: fp.write(f&quot;Vbias={voltages[i]}V,\\n&quot;) fp.write(f&quot;{sweep_parameter_name}&quot; + (f&quot;[{sweep_parameter_unit}]&quot; if sweep_parameter_unit else &quot;&quot;) + &quot;,Current[A]\\n&quot;) for j in range(len(Iresp)): fp.write(f&quot;{sweep_value_table[j]:.15e},{Iresp[j]:.15e}\\n&quot;) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(sweep_value_table, Iresp, c='b', linewidth=0.5, label=f&quot;Vbias={voltages[i]}V&quot;) ax.plot(sweep_value_table, Iresp, 'bo') ax.set_ylabel(&quot;I[A]&quot;) ax.set_xlabel(f&quot;{sweep_parameter_name}&quot; + (f&quot;[{sweep_parameter_unit}]&quot; if sweep_parameter_unit else &quot;&quot;)) plt.legend() plt.ticklabel_format(style=&quot;sci&quot;, scilimits=(-1, 2)) ax.grid() plt.savefig(Isweep_fig) plt.close() # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   Result show of the I-P curve Fig 12. I-P curve  "},{"title":"4. Appendix​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#4-appendix","content":" "},{"title":"4.1 Electronic parameters of the materials​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#41-electronic-parameters-of-the-materials","content":"The parameter settings in the VPD_material.py file: [71]  elec_Si_properties = {&quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.59-1.11452/2.0, &quot;permitti&quot;: 11.7}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Masetti&quot;, &quot;Masetti&quot;: {&quot;mu_min2_h&quot;: 44.9, &quot;mumax_e&quot;: 1471, &quot;mumax_h&quot;: 470.5, &quot;pc_h&quot;: 0}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;dos_formula&quot;: 2, &quot;nc300&quot;: 3.21657e19, &quot;nv300&quot;: 1.82868e19, # Bandgap &quot;eg0&quot;: 1.16, &quot;chi0&quot;: 4.59-1.16/2, # Bandgap Narrowing &quot;bgn_model&quot;: &quot;OldSlotboom&quot;, &quot;e0_bgn_oldslotboom&quot;: 0.0045, &quot;n0_bgn_oldslotboom&quot;: 1.00e17, &quot;deg0_oldslotboom&quot;: 0, # Auger Recombination &quot;augan&quot;: 2.8e-31, &quot;augap&quot;: 9.9e-32, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 1.5e-9, &quot;taupmax&quot;: 1.5e-9, &quot;nsrh_n&quot;: 7.1e15, &quot;nsrh_p&quot;: 7.1e15, &quot;nc_f&quot;: 1.5, &quot;nv_f&quot;: 1.5, # Radiative Recombination &quot;c_direct&quot;: 1.6e-14}, &quot;print&quot;: 1}} elec_Ge_properties = {&quot;model&quot;: {&quot;high_field&quot;: False}, &quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.5-0.65969/2.0, &quot;permitti&quot;: 16.0}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Analytic&quot;, &quot;Analytic&quot;: {&quot;alphan&quot;: 0.56, &quot;alphap&quot;: 1.0, &quot;mun_max&quot;: 3900, &quot;mun_min&quot;: 850, &quot;mup_max&quot;: 1800, &quot;mup_min&quot;: 300, &quot;nrefn&quot;: 2.6e17, &quot;nrefp&quot;: 1e17, &quot;nun&quot;: -1.66, &quot;nup&quot;: -2.33}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;nc300&quot;: 1.0516e19, &quot;nv300&quot;: 3.9189e+18, # Bandgap &quot;eg300&quot;: 0.65969, &quot;chi300&quot;: 4.5-0.65969/2.0, # Bandgap Narrowing &quot;v0_bgn&quot;: 0, # Auger Recombination &quot;augan&quot;: 1e-30, &quot;augap&quot;: 1e-30, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 1.5e-9, &quot;taupmax&quot;: 1.5e-9, &quot;nsrhn&quot;: 7.1e15, &quot;nsrhp&quot;: 7.1e15, # Radiative Recombination &quot;c_direct&quot;: 6.41e-14}, &quot;print&quot;: 1}} elec_Ge_properties_for_transient = {&quot;model&quot;: {&quot;high_field&quot;: True, &quot;mobility_force&quot;: &quot;EQF&quot;}, &quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.5-0.65969/2.0, &quot;permitti&quot;: 16.0}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Masetti&quot;, &quot;Masetti&quot;: {&quot;pc_e&quot;: 0, &quot;mu_min1_e&quot;: 850, &quot;mu_min2_e&quot;: 850, &quot;mu1_e&quot;: 0, &quot;mumax_e&quot;: 3900, &quot;cr_e&quot;: 2.6e17, &quot;alpha_e&quot;: 0.56, &quot;pc_h&quot;: 0, &quot;mu_min1_h&quot;: 300, &quot;mu_min2_h&quot;: 300, &quot;mu1_h&quot;: 0, &quot;mumax_h&quot;: 1800, &quot;cr_h&quot;: 1e17, &quot;alpha_h&quot;: 1}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;nc300&quot;: 1.1372e+19, &quot;nv300&quot;: 3.9189e+18, # Bandgap &quot;eg300&quot;: 0.65969, &quot;chi300&quot;: 4.5-0.65969/2.0, # Bandgap Narrowing &quot;v0_bgn&quot;: 0, # Auger Recombination &quot;augan&quot;: 1e-30, &quot;augap&quot;: 1e-30, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 1.5e-9, &quot;taupmax&quot;: 1.5e-9, &quot;nsrhn&quot;: 7.1e15, &quot;nsrhp&quot;: 7.1e15, # Radiative Recombination &quot;c_direct&quot;: 6.41e-14}, &quot;print&quot;: 1}, &quot;vsat&quot;: {&quot;model&quot;: &quot;Canali&quot;, &quot;Canali&quot;: {&quot;beta0n&quot;: 2, &quot;beta0p&quot;: 1, &quot;betaexpn&quot;: 0, &quot;betaexpp&quot;: 0, &quot;alpha&quot;: 0, &quot;vsatn0&quot;: 6e6, &quot;vsatp0&quot;: 5.4e6, &quot;vsatn_exp&quot;: 0, &quot;vsatp_exp&quot;: 0}, &quot;print&quot;: 1}}  Description: basic--Set the permittivity and affinity band--Set models and parameters of the band and the recombination mobility--Set the model and parameters of mobility model--Set the switch of high field mobility model and Fermi-Dirac statistics model vsat--Set the model and parameters of velocity saturation For the detailed introduction about electronic parameters, please refer to the document examples/active_demo/Physics_Model_in_OEDevice.pdf.  "},{"title":"4.2 OEDevice settings​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#42-oedevice-settings","content":"OEDevice property list： \tdefault\ttype\tnotesgeneral.norm_length\t1.0\tfloat general.solver_mode\tsteady_state\tstring\tSelections are ['steady_state', 'transient', 'SSAC']. general.temperature_dependence\tIsothermal\tstring\tSelections are ['Isothermal']. general.simulation_temperature\t300\tfloat advanced.non_linear_solver\tNewton\tstring\tSelections are ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', 'LU', 'BCGS']. advanced.use_quasi_fermi\tdisabled\tstring\tSelections are ['disabled', 'enabled']. advanced.damping\tnone\tstring\tSelections are ['none', 'potential']. advanced.potential_update\t1.0\tfloat advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. advanced.thread_count\t4\tinteger advanced.max_iterations\t30\tinteger advanced.use_global_max_iterations\ttrue\tbool advanced.poisson_max_iterations\t30\tinteger advanced.ddm_max_iterations\t30\tinteger advanced.relative_tolerance\t1.0e-5\tfloat advanced.tolerance_relax\t1.0e+5\tfloat advanced.divergence_factor\t1.0e+25\tfloat genrate.genrate_path string genrate.source_fraction float genrate.coordinate_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float geometry.z_min float geometry.z_max float small_signal_ac.perturbation_amplitude\t0.001\tfloat small_signal_ac.frequency_spacing\tsingle\tstring\tSelections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat small_signal_ac.start_frequency\t1.0e+06\tfloat small_signal_ac.stop_frequency\t1.0e+09\tfloat small_signal_ac.frequency_interval\t9.9999e+10\tfloat small_signal_ac.num_frequency_points\t2\tinteger small_signal_ac.log_start_frequency\t1.0e+06\tfloat small_signal_ac.log_stop_frequency\t1.0e+10\tfloat small_signal_ac.log_num_frequency_points\t2\tinteger\t Description: geometry： dimension--Set the dimension of the simulation region. Only 2D simulation is supportd currently. When it's set to &quot;2d_x_normal&quot;, the simulation is on the yz plane. Similarly for the rest general: norm_length--Set the length in the third dimension, default to be 1solver_mode--Set the simulation mode. Steady state, transient and SSAC simulations are supportedtemperature--Set the simulation temperaturetemperature_dependence--Set the type of the temperature dependence. Only &quot;Isothermal&quot; is supported currently genrate: genrate_path--Set the absolute path of the optical generation rate file (gfile) When it's set to &quot;&quot; (by default), and empty string , no optical generation rate will be appliedWhen it's not empty, the gfile at the path will be imported to apply the optical generation rate coordinate_unit--Set the coordinate unit in the gfile field_length_unit--Set the length unit in the generation rate unit in the gfile source_fraction--Set the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport small_signal_ac: perturbation_amplitude--Set the voltage amplitude of the small signal frequency_spacing--Set the spacing type of the frequency When it's set to &quot;single&quot;, the frequency point is singleWhen it's set to &quot;linear&quot;, the frequency points are uniformly sampledWhen it's set to &quot;log&quot;，the frequency points are uniformly sampled base on the logarithm of frequency frequency--Set the value of the single frequency start_frequency--Set the start frequency of linear spacing stop_frequency--Set the stop frequency of linear spacing frequency_interval--Set the frequency interval of linear spacing num_frequency_points--Set the number of frequency points of linear spacing log_start_frequency--Set the start frequency of logarithmic spacing log_stop_frequency--Set the stop frequency of logarithmic spacing log_num_frequency_points--Set the number of frequency points of logarithmic spacing advanced: non_linear_solver--Set the non-linear solver, only Newton method is supported currentlylinear_solver--Set the linear solver. Options are &quot;MUMPS&quot;, &quot;LU&quot;, &quot;BCGS&quot;. MUMPS and LU are direct linear solvers which usually give the exact solution. However, MUMPS supports parallel computation while LU doesn't. ；&quot;BCGS&quot; is a Krylov subspace (KSP) iterative solver, which also supports parallel computation and is more efficient but can only give approximate results.use_quasi_fermi--Whether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. &quot;enabled&quot; means True, and &quot;disabled&quot; means Falsedamping--Set the nonlinear update damping scheme. &quot;potential&quot; means the damping is based on the potential variationpotential_update--Set the threshold potential for potential damping. The large value will reduce the strength of damping effectmulti_threads: When it's set to &quot;let_solver_choose&quot;, the solver will determine the number of threads to use. The default maximum number of threads is 4When it's set to &quot;set_thread_count&quot;, the number of threads is set by the user to thread_count thread_count--Custom number of threadsmax_iterations--Set global maximum number of iterations, available when use_global_max_iterations is Trueuse_global_max_iterations--Whether to use global max iterations during the initialization of solving the Poisson equations and the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, default to be Truepoisson_max_iterations--Set the max iterations during the initialization of solving the Poisson equations, available when use_global_max_iterations is Falseddm_max_iterations--Set the max iterations during the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, available when use_global_max_iterations is Falserelative_tolerance--Set the relative update tolerancetolerance_relax--Set the tolerance relaxation factor for convergence on relative tolerance criteriadivergence_factor--Nonlinear solver fault with divergence when each individual function norm exceeds the threshold as its absolute tolerance multiply by this factor  "},{"title":"4.3 Electrode settings​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#43-electrode-settings","content":"Electrodes are added and set up through the add_electrode function. The format of the function is [72]  st.add_electrode(name, property)  add_electrode() parameters: name--Electrode nameproperty--Other properties  There are two different type of electrical boundary conditions, which are &quot;steady_state&quot;and &quot;transient&quot;, specified by the property bc_mode.  4.3.1 Steady state boundary condition​ When the property bc_mode is set to &quot;steady_state&quot;, the steady state boundary condition is applied.  Property list of steady state boundary condition: \tdefault\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode\tsteady_state\tstring\tSelections are ['steady_state']. apply_AC_small_signal\tnone\tstring\tSelections are ['none', 'All']. sweep_type\tsingle\tstring\tSelections are ['single', 'range', 'value']. voltage\t0\tfloat\tAvailable when sweep_type is 'single' range_start\t0\tfloat\tAvailable when sweep_type is 'range' range_stop\t1\tfloat\tAvailable when sweep_type is 'range' range_interval\t1\tfloat\tAvailable when sweep_type is 'range' range_num_points\t2\tinteger\tAvailable when sweep_type is 'range' []sweep_value_table.index integer\tAvailable when sweep_type is 'value'. []sweep_value_table.number float\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t Description: surface_type--Type of the surface to be set as an electrode. Currently only &quot;solid&quot; is supported, meaning that all the surfaces of a structure are selected solid--Name of the structure to be set as an electrode. Available when surface_type is set to &quot;solid&quot; force_ohmic--Whether the electrode is ohmic, default to be True. Currently only ohmic contact is supported, so force_ohmic can't be set to False bc_mode--Set to &quot;steady_state&quot; for steady state boundary condition apply_AC_small_signal: When it's set to &quot;none&quot; (as default), no AC small signal is applied at each sweeping voltageWhen it's set to &quot;All&quot;, the AC small signal is applied after steady state simulation at each sweeping voltage sweep_type--Type of sweeping voltage. Options are &quot;single&quot;, &quot;range&quot; and &quot;value&quot; When it's set to &quot;single&quot;, voltage is requiredWhen it's set to &quot;range&quot;, range_start, range_stop, and range_interval or range_num_points are requiredWhen it's set to &quot;value&quot;, sweep_value_table is required voltage--Set the value of the single voltage range_start--Set the start value of the voltage range range_stop--Set the stop value of the voltage range range_interval--Set the voltage interval of the voltage range range_num_points--Set the number of points of the voltage range sweep_value_table--Table of voltage values. It's a list, whose item is a dictionay. In each of its item: index--Set the index of the voltage valuenumber--Set the value of the voltage  Example for single voltage [73]  st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   Example for voltage range [74]  st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: 0, &quot;range_stop&quot;: 1, &quot;range_interval&quot;: 0.5, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   Example for voltage table [75]  st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;value&quot;, &quot;sweep_value_table&quot;: [{&quot;index&quot;: 0, &quot;number&quot;: 0}, {&quot;index&quot;: 1, &quot;number&quot;: 0.5}, {&quot;index&quot;: 2, &quot;number&quot;: 1}]})   4.3.2 Transient boundary condition​ When the property bc_mode is set to &quot;transient&quot;, the transient boundary condition is applied.  Property list of transient boundary condition: \tdefault\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode string\tSelections are ['transient']. voltage\t0\tfloat []time_table.time_start float []time_table.time_stop float []time_table.initial_step float []time_table.max_step float []time_table.optical.enabled\t0\tinteger\tSelections are [0, 1] []time_table.optical.envelop integer\tSelections are [0] []time_table.optical.source_fraction float surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t Description: surface_type, solid, force_ohmic--The same as the one in steady state conditionbc_mode--Set to &quot;transient&quot; for transient boundary condition. Then the time dependence of the optical generation rate can be set at this electrodevoltage--Set the voltage that is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation.v_step_max--Set the max step of the voltage from the equilibrium state to steady state at the bias of voltage.time_table--Set the time dependence of optical generation rate. It's a list, whose item is a dictionary. In each of its item: time_start--Set the start time point of the range. The value of 0 represents the steady state of the earlier simulation.time_stop--Set the stop time point of the rangeinitial_step--Set the initial time step of the rangemax_step--Set the max time step of the rangeoptical--Set the optical generation rate during the time range enabled--Whether to apply optical generation rate during the time range. The value of 1 means True, and 0 means Falseenvelop--The envelop of the scaling factor of the light power during the time range. When it's set to 0, the envelop is uniformsource_fraction--When envelop is set to0, this value is the scaling factor of the light power during the time range  Example for transient boundary condition [76]  st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: 1, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 50e-12, &quot;initial_step&quot;: 1e-15, &quot;max_step&quot;: 1e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}, {&quot;time_start&quot;: 50e-12, &quot;time_stop&quot;: 600e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}]})   "},{"title":"1X2 MMI","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/MMI/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"1X2 MMI","url":"/my-website/docs/examples/PIC/MMI/#introduction","content":"Multi-mode interferometer, due to their advantages of low insertion loss, wide bandwidth, simple fabrication process, and good tolerance, have been widely used in important optical devices such as optical switches and wavelength-division multiplexers. The main performance parameters of multi-mode interference couplers include insertion Loss, imbalance, device dimensions, operating bandwidth. \t "},{"title":"Simulation Methods​","type":1,"pageTitle":"1X2 MMI","url":"/my-website/docs/examples/PIC/MMI/#simulation-methods","content":"With the EME module, the corresponding cell groups and cell numbers can be set up with the structure, and a parameter sweep can be performed in the propagation sweep to obtain the S-parameters of the device. This parameter sweep helps optimize the core dimensions of the multi-mode interferometer, ensuring desired performance characteristics. Alternatively, FDTD module can be conducted to obtain the intensity distribution of the optical field and the transmittance at each port. This allows the verification of the optimized results for the multi-mode interferometer. After data processing, performance parameters such as the imbalance, insertion loss, and bandwidth of the device can be determined. "},{"title":"Multi-Mode Interference(EME module)​","type":1,"pageTitle":"1X2 MMI","url":"/my-website/docs/examples/PIC/MMI/#multi-mode-interferenceeme-module","content":"The simulation design of a multimode interference coupler typically employs the EME module. This allows for a rapid scan of the length of the multimode interference region to quickly identify the optimal length for beam splitting. Therefore, in the following code, we will learn how to create a Multi-Mode Interference (MMI) simulation and output the results for data processing. "},{"title":"1.Basic Options​","type":1,"pageTitle":"1X2 MMI","url":"/my-website/docs/examples/PIC/MMI/#1basic-options","content":"1.1 Import File​ Once you have installed and configured the environment, import the python code and the GDS layout. The example library and related model code are usually located in the directory : .venv_maxoptics/site-packages/maxoptics_sdk/examples. The GDS file is generally imported into the path : .venv_maxoptics/site-packages/maxoptics_sdk/examples/examples_gds 1.2 SDK Initialization​ Create a new terminal and run the code after you import the python script and GDS file. Max-Optics SDK may take some time to initialize on the first simulation. Version of Max-Optics sdk is 2.3.0.4.630.2000 Max-Optics SDK is initializing...  "},{"title":"2.Code Description​","type":1,"pageTitle":"1X2 MMI","url":"/my-website/docs/examples/PIC/MMI/#2code-description","content":"Now let's learn the meaning of functions and parameters that correspond to the code. 2.1 import Modules​ To begin, we need to use the import command to call the relevant functional modules. For instance, we import the typing , os and time module in python. At the same time ,we import the customized module maxoptics_sdk.all and maxoptics_sdk.helper. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple  The maxoptics_sdk package provides all in one optical simulation with Python. The os module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands. The time module provides various functions to work with time-related operations and to measure time intervals. The typing module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. 2.2 Define Simulation​ Firstly, We define parameters and give them a default value, such as the simulation wavelength and number of modes. Note that we can override this value in the following code. def simulation(*, run_mode, wavelength=1.55, number_of_modes=10, global_mesh_grid=0.155,local_mesh_grid=0.01,run_options: &quot;RunOptions&quot;, **kwargs):  The provided code contains comments that define the simulation parameters. Let's explain each of these parameters. The function simulation is used to define the simulation parameters for the program. The run_mode parameter determines the type of calculation resources to be used. The wavelength parameter specifies the wavelength of the input light in micrometers. The number_of_trial_modes parameter sets the number of modes to be calculated. The **kwargs is a special syntax used in function definitions to accept an arbitrary number of keyword arguments as a dictionary. 2.3 Define Parameters​ Define commonly used parameters in region 0, such as the mesh grid of the simulation boundary, the start time of the simulation, the path and name for the simulation output, the path to the imported GDS layout, and other parameters required for structural parameterized modeling. If you need to calculate the bandwith of the device in the EME simulation, you can also decide the wavelength for sweeping in this section. # region --- 0. General Parameters --- path = kwargs[&quot;path&quot;] simu_name = &quot;EME_1X2MMI&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/1X2MMI.gds&quot; wavelength_start = 1.55 wavelength_stop = 1.65 wavelength_points = 10 # endregion  The code defines several parameters and variables necessary for the simulation process. The global_mesh_grid parameter represents the mesh in the EME simulation region. Similarly, the local_mesh_grid parameter denotes the customized mesh for user defined region. The path variable defines the file path for the simulation, while simu_name specifies the name of the simulation file. The time_str variable is used to obtain the current time as a timestamp for the simulation. The project_name variable assigns a name to the project for the simulation output. The plot_path variable determines the directory where the simulation result plots will be saved. The gds_file_root_path variable defines the path for importing the GDS layout. The parameters wavelength_start,wavelength_stop,wavelength_points are for sweeping. These parameters and variables together facilitate the successful execution and organization of the simulation process. 2.4 Creat Project​ You can create a new project using the Project function of Max's software development toolkit in region 1. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion  2.5 Define Materials​ Let's proceed to the next step, where we set up the materials required for the simulation in region 2. In this case, we will directly use relevant materials from the MO material library. # region --- 2. Material --- mt = pj.Material() mt.add_nondispersion(name=&quot;Si&quot;, data=[(3.454996, 0)], order=2) mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444991, 0)], order=2) mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) # endregion  The add_lib contains three parameters name,data and order. The data calls up the property of simulation materials in the MO material library. The Order parameter determines the mesh order for the material during the simulation. As the same, we also support users to customize the material with add_nondispersionfunction. Detailed explaination about material : https://itsays-zqc.github.io/my-website/docs/test/v2_core/1Material 2.6 Create Model​ Next, we will create the MMI model in region 3. # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;Air&quot;]) st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 4}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name=&quot;psr&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (2, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) # endregion  We can import the MMI layout from the GDS file. The name parameter defines the structure name. The type parameter specifies the structure type. The path, cell_name, and layer_name parameters point to the GDS file and specify the relevant layers and cell names used in the layout. The geometry parameter sets the structure's coordinates. The material parameter specifies the material properties The mesh_order parameter sets the mesh order for the simulation. Detailed explaination about structure : https://itsays-zqc.github.io/my-website/docs/test/v2_core/2Structure 2.7 Boundary​ After establishing the model, we can add the simulation region in region 4 and define the simulation boundary conditions. This involves specifying the geometry of the simulation region, the boundary conditions in the xyz directions, and the other detailed parameters. # region --- 4. Boundary --- st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 30.75, &quot;x_span&quot;: 55.5, &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0, &quot;z_span&quot;: 4}, &quot;boundary&quot;: {&quot;y_min&quot;: &quot;PML&quot;, &quot;y_max&quot;: &quot;PML&quot;, &quot;z_min&quot;: &quot;PML&quot;, &quot;z_max&quot;: &quot;PML&quot;}, &quot;general_pml&quot;: {&quot;pml_same_settings&quot;:True,&quot;pml_kappa&quot;: 1, &quot;pml_sigma&quot;: 5, &quot;pml_layer&quot;: 10, &quot;pml_polynomial&quot;: 3}}) # endregion  Detailed explaination about boundary : https://itsays-zqc.github.io/my-website/docs/test/v2_core/3Boundary 2.8 Add Sub-mesh​ To achieve more accurate calculations of the model's modal fields, we can add a sub-mesh in region 5. # region --- 5. Sub Mesh --- st.add_mesh( name=&quot;mesh&quot;, property={&quot;general&quot;: {&quot;dx&quot;: local_mesh_grid,&quot;dy&quot;: local_mesh_grid, &quot;dz&quot;: local_mesh_grid}, &quot;geometry&quot;: {&quot;x&quot;: 30.75, &quot;x_span&quot;: 11.5, &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.4}}) # endregion  In this code segment, we use the add_mesh function to add a sub-mesh in region 5. The name parameter defines the name of the mesh. The general parameter specifies the grid accuracy in the xyz directions . The geometry parameter sets the coordinates of the sub-mesh. Detailed explaination about mesh : https://itsays-zqc.github.io/my-website/docs/test/v2_core/3Boundary#32-mesh 2.9 EME Port​ In region 6, we add the EME Port for calculating modes in the simulation. # region --- 6. Port --- pjp = pj.Port(property={&quot;source_port&quot;: &quot;input_te_tm&quot;}) # region --- input_te_tm --- pjp.add(name=&quot;input_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;use_full_simulation_span&quot;: True, &quot;y&quot;: 1.256, &quot;y_span&quot;: 5, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;mode_index&quot;: 0}, &quot;advanced&quot;: {&quot;offset&quot;: 0.1, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # region --- output_up_te_tm --- pjp.add(name=&quot;output_up_te_tm&quot;, type=&quot;eme_port&quot;, property={ &quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: 0.85, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;mode_index&quot;: 0}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # region --- output_down_te_tm --- pjp.add(name=&quot;output_down_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: -0.85, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;mode_index&quot;: 0, &quot;search&quot;: &quot;max_index&quot;}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # endregion  The name parameter defines the name of the EME port. The port_location parameter sets the location type of EME port. Selections are ['left', 'right']. The use_full_simulation_span parameter confirms whether to use full simulation span. The mode_selection parameter decides the mode which propagates in the waveguide. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. The mode_index is used to decide the source mode in the 'user_select' condition. The search parameter calculates the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. Selections are ['near_n', 'max_index']. The number_of_trial_modes parameter determines the calculated number of modes around the refractive index. Detailed explaination about port : https://itsays-zqc.github.io/my-website/docs/test/v2_core/4Source#44-eme-port 2.10 Add Monitor​ In region 7, we add the profile monitors for the EME simulation. # region --- 7. Monitor ---确保monitor的尺寸在仿真区域内 mn = pj.Monitor() mn.add(name=&quot;z_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 30.75, &quot;x_span&quot;: 55.5, &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0}}) # endregion  The monitor_type parameter selects the profile monitor type and the orientation.Selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. The x_resolution parameter decides the resolution of output simulation results in profile monitor.  Detailed explaination about port : https://itsays-zqc.github.io/my-website/docs/test/v2_core/4Source#44-eme-port 2.11 EME Simulation​ In region 8, we add the EME simulation module.  # region --- 8. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 20, &quot;cell_number&quot;: 3, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 11.5, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 20, &quot;cell_number&quot;: 3, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, ]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {'dx':global_mesh_grid,&quot;dy&quot;: global_mesh_grid, &quot;dz&quot;: global_mesh_grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;wavelength_sweep&quot;: { &quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: wavelength_start, &quot;stop&quot;: wavelength_stop, &quot;number_of_wavelength_points&quot;: wavelength_points}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) # endregion  In this code segment, we can run the wavelength sweep and the propagation sweep. The detailed examples refer to https://itsays-zqc.github.io/my-website/docs/test/v2_core/6Simulation#623-eme-propagation-sweep The name parameter defines the name of the simulation module. The general parameter specifies the general property of the simulation module within the structure, such as the geometry of cell, wavelength and so on. The energy_conservation parameter specifies the type of energy conservation when calculating the S matrix. Selections are ['none', 'make_passive']. The cell_group_definition parameter specifies the general property of the cell group. The number_of_modes parameter specifies the general property of the simulation module within the structure, such as the geometry of cell, wavelength and so on. The sc parameter sets the subcell method in EME simulation. Selections are ['none', 'sub_cell', 'sc']. The eme_propagate parameter determines whether to calculate the propogation fields and the s matrix. Detailed explaination about EME simulation : https://itsays-zqc.github.io/my-website/docs/test/v2_core/6Simulation#62-eme 2.12 Structure Show​ In region 9, you can generate an image of the structure which contains the specific coordinates. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, savepath=plot_path + simu_name, simulation_name=simu_name, celldisplay=True, xyratio=(1, 5), disabled_components=(&quot;box.coordinate&quot;,), show=False) # endregion  In this code segment, we use the structure_show function to form a picture. The fig_type specifies the type of figure. It supports the following list selection[&quot;png&quot;, &quot;svg&quot;]. The show , which is a switch that controls whether the picture is generated or not. If you have already installed the GUI locally, you can automatically pop up the 3D structural model within the GUI using show_with=&quot;local_gui&quot;. Additionally, you can also use show_with=&quot;matplotlib&quot; to view the structure. Detailed explaination about EME simulation : https://itsays-zqc.github.io/my-website/docs/test/v2_core/7Preview#72-structure-show-and-show-3d 2.13 Calculate Mode​ In this region, we use the simu.add to calculate the modes of ports. mode_selection:user_select and its properties are shown in the table below. Before running EME simulation calculations, we can calculate the mode field distribution of the port by setting the type of mode selection to True and other simulations to False. # region --- 10. Calculate Mode --- if run_options.calculate_modes: for port in [&quot;input_te_tm&quot;, &quot;output_up_te_tm&quot;, &quot;output_down_te_tm&quot;]: simu.add(name=simu_name+&quot;_&quot;+port+&quot;_cal_mode&quot;, simulation_name=simu_name, source_name=port, type=&quot;mode_selection:user_select&quot;, property={&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: True, &quot;mesh_structure&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: number_of_modes, &quot;calculate_group_index&quot;: True}}) port_res = simu[simu_name+&quot;_&quot;+port+&quot;_cal_mode&quot;].run() for m in range(number_of_modes): port_res.extract(data=&quot;calculate_modes&quot;, savepath=plot_path + &quot;00_modeprofile_fdeonly_&quot; + port + &quot;_mode#&quot; + str(m), mode=m, attribute=&quot;E&quot;, export_csv=False) # endregion  key\tValue\tType\tDescriptionmesh_structure\tTrue\tbool\tselect to view the refractive index distribution of the port calculate_modes True bool select to calculate the mode of cross-section Wavelength\twavelength\tfloat\tcalculate the wavelength of the mode number_of_trial_modes\tnumber_of_modes\tfloat\tnumber of calculation modes search\t&quot;max_index&quot;\tfloat\tmethod of calculating mode calculate_group_index\tTrue\tbool\tselect to calculate group refractive index bent_waveguide\tFalse\tbool\tselect to enable bent waveguide in calculation mode radius\t1\tfloat\tset the radius of the bent waveguide orientation\t0\tfloat\tset the bending direction of the waveguide location\t&quot;simulation_center&quot;\tstring\tset the position of the bent waveguide Detailed explaination about modes calculation : https://itsays-zqc.github.io/my-website/docs/test/v2_core/6Simulation#62-eme 2.14 Run​ In the region 11 ,we can recall the simulation name to run it. # region --- 11. Run --- eme_res = simu[simu_name].run() # endregion  2.15 Extract Results​ In region 12, you can retrieve and store the simulation results. # region --- 12. See Results -- if run_options.extract: # region --- 12.1 EME Results -- if run_options.run: # region --- facet data --- eme_res.extract(data='eme_propagate:facet_data', savepath=plot_path, real=True, imag=True, export_csv=True) # endregion # region --- smatrix_intensity --- eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) # endregion # region --- monitor --- eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True) for i in range(5): eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_section&quot;+str(i+1), monitor_name=&quot;section&quot;+str(i+1), attribute=&quot;E&quot;, export_csv=True) # endregion # endregion # region --- 12.2 EME Wavelength Sweep Results --- if run_options.run_wavelength_sweep: &quot;&quot;&quot; 20_wavelength_sweep &quot;&quot;&quot; eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) # endregion # endregion  The extract function allows you to extract specific simulation results and store them for further analysis. The data parameter is to decide what type/field data will be extracted. The savepath parameter specifies the save path of picture. The monitor_name parameter specifies the name of monitor which provides the data needed. The attribute parameter specifies which attribute will extracted. The plot_x parameter specifies the data of x axis. The export_csv parameter is to decide whether to export a csv. Default as False. Detailed explaination about data extraction : https://itsays-zqc.github.io/my-website/docs/test/v2_core/8Extract#811-calculate-mode-result 2.16 Switches​ In this section of the code, the simulation function is called and executed, which allows you to reset relevant parameters for more convenient parameter scanning and optimization design. We also support control switches for various functionalities at the end of the code, and you can use configuration flags(True or False). These flags can be used to turn specific functionalities on or off, making it easier to check the model and perform efficient calculations. class RunOptions(NamedTuple): calculate_modes: bool run: bool run_wavelength_sweep: bool extract: bool if __name__ == &quot;__main__&quot;: simulation(run_mode=&quot;local&quot;, global_mesh_grid=0.155, local_mesh_grid=0.01, number_of_modes=10 run_options=RunOptions(calculate_modes=True,run=True, run_wavelength_sweep=True, extract=True))  By turning on/off the relevant functionalities, you can control the simulation process and obtain the desired results. For example, the calculate_modes determines whether to calculate the modes. The run determines whether to do the EME propagation in the program. run_wavelength_sweep is used to enable wavelength scanning, and extract is used to control data extraction. Properly utilizing these switches can help you inspect the simulation effectively. "},{"title":"3.Output Results​","type":1,"pageTitle":"1X2 MMI","url":"/my-website/docs/examples/PIC/MMI/#3output-results","content":"The electric intensity profile of fundamental TE mode and fundamental TM mode in the ports. The fundamental modes in the input ports: \t The fundamental modes in the upwards output ports: \t The fundamental modes in the downwards output ports: \t the z-normal E intensity of EME propagation  The S matrix of EME propagation. As shown in the figure below, the S-matrix is a 3∙3 matrix.  The S parameters and transmission at different wavelength. The S21 parameter represents the absolute value of the transmission coefficient from port 1 input to port 2 output. Due to the symmetry of the structure, S31=S21. The transmission result is shown in the left picture below which is calculted form the S parameter about the one of output ports. Therefore, we can obtain the insert loss is about 0.125 dB at 1.55 micrometer wavelength. \t "},{"title":"Supplement​","type":1,"pageTitle":"1X2 MMI","url":"/my-website/docs/examples/PIC/MMI/#supplement","content":"To view a function's definition and supported parameters or a parameter dictionary, you can right-click on its name and select &quot;Go to Definition&quot; or press &quot;Ctrl&quot; while left-clicking on its name to view its definition, showing the available parameters and their descriptions. And you can also to find the detailed explainnation : https://itsays-zqc.github.io/my-website/docs/category/max-optics-sdk "},{"title":"Polarization Splitter-Rotator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/PolarizationSplitter-Rotator/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Polarization Splitter-Rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitter-Rotator/#introduction","content":"The large refractive index difference of silicon waveguides on insulators can produce strong birefringence effects, making many optical devices very sensitive to the polarization of light. The polarization beam splitter-rotator(PSR) can separate light of different polarizations and output light of the same polarization, which can effectively solve the problem of polarization sensitivity in silicon waveguides. In this example, we demonstrated the simulation process of a compact PSR using an EME solver. the TM0 mode can effectively evolve into the TE1 mode, which can then be converted into the TE0 mode in a narrow waveguide using ADC. "},{"title":"Simulation​","type":1,"pageTitle":"Polarization Splitter-Rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitter-Rotator/#simulation","content":""},{"title":"1. Code Description​","type":1,"pageTitle":"Polarization Splitter-Rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitter-Rotator/#1-code-description","content":"1.1 Import Toolkit​ First, we need to import `maxoptics_sdk` and Python's third-party package. The import module for EME simulation is shown below. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple  1.2 Define Simulation Function​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. def simulation(*, run_mode, wavelength=1.54, global_mesh_grid=0.02, local_mesh_grid=0.01, number_of_modes=10, run_options: &quot;RunOptions&quot;, **kwargs):  The run_mode variable parameter is used to define the location of the simulation run. The wavelength variable is defined as wavelength of the optical source. The grid variable is defined as grid size. The number_of_modes variable is used to define the number of modes of calculation. 1.3 Define Parameters​ Before starting the simulation, we can define parameters to facilitate modeling and parameterization sweep. The defined parameters are as follows. # region --- 0. General Parameters --- cell_number = 72 wavelength_start = 1.50 wavelength_stop = 1.58 wavelength_points = 3 path = kwargs[&quot;path&quot;] simu_name = &quot;EME_PSR&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/PSR.gds&quot; # endregion  The path variable is used to store the path of this Python file. The simu_name variable is used to store simulation names. The time_str variable is used to store the timestamp. The project_name variable is used to store the project name. The plot_path variable is used to store the result path. The gds_file variable is used to store the file path of GDS. 1.4 Create project​ You can create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion  1.5 Add Material​ Here we demonstrate using the Material function to create material and using the add_lib function to add materials from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name=&quot;Si&quot;, data=mo.Material.Si_Palik, order=2) mt.add_lib(name=&quot;SiO2&quot;, data=mo.Material.SiO2_Palik, order=2) # endregion  The name is used to define the name of the added material. The data is used to receive refractive index data extracted from the material library. The order is used to set the material priority of the grid. 1.6 Add Structure​ The structure of PSR is shown in the figure, which consists of an adiabatic conical waveguide, ADC, and MMI mode filter. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select &quot;gds_file&quot; in type to establish the model by importing the GDS file. The properties of GDS modeling are shown in the table below. # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;Air&quot;]) st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;PSR&quot;, &quot;layer_name&quot;: (1, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: -2, &quot;z_span&quot;: 4}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name=&quot;psr&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;PSR&quot;, &quot;layer_name&quot;: (2, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) # endregion  Key\tValue\ttype\tDescriptionname\tbox\tstring\tname the added geometry type\tgds_file\tstring\tselect the type of structure path\tgds_file\tstring\tfile path of GDS file cell_name\t(1,0)\tstring\tname of the GDS cell layer_name\tPSR\tlist\tname of the GDS layer x 0 float center position in the x-direction of the geometric structure z\t-2\tfloat\tcenter position in the z-direction of the geometric structure z_span\t4\tfloat\tlength of the geometric structure in the z-direction material\tmt[&quot;SiO2&quot;]\tmaterial\tselect the material in Material mesh_order\t2\tinteger\tset the priority of the material Select simulation material by using mesh_order in areas where geometry overlaps, the higher the number of mesh_order, the higher the priority of the material. 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. The properties are shown below. # region --- 4. Boundary --- st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 6.05, &quot;x_span&quot;: 73.1, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;boundary&quot;: {&quot;y_min&quot;: &quot;PEC&quot;, &quot;y_max&quot;: &quot;PEC&quot;, &quot;z_min&quot;: &quot;PEC&quot;, &quot;z_max&quot;: &quot;PEC&quot;}, &quot;general_pml&quot;: {&quot;pml_same_settings&quot;:True,&quot;pml_kappa&quot;: 1, &quot;pml_sigma&quot;: 5, &quot;pml_layer&quot;: 10, &quot;pml_polynomial&quot;: 3}}) # endregion  1.8 Add Sub Mesh​ After light passes through tapered silicon waveguide gradually becoming smaller, the mode field is strongly limited to a very small range. Therefore, it is necessary to use add_mesh to add a transverse grid to accurately calculate the limited light field. Add local mesh as shown below. # region --- 5. Sub Mesh --- st.add_mesh( name=&quot;sub_mesh&quot;, property={&quot;general&quot;: {&quot;dy&quot;: local_mesh_grid, &quot;dz&quot;: local_mesh_grid}, &quot;geometry&quot;: {&quot;x&quot;: 6.05, &quot;x_span&quot;: 73.1, &quot;y&quot;: 1.256, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.4}}) # endregion  The dx,dy,dz are the mesh sizes in the x, y, and z directions, respectively. 1.9 Add EME port​ You can use the port function to create a port and use the &quot;source_port&quot; property to set the location of the source port. You can use the add function to add ports and the properties of port are shown in the table below.  # region --- 6. Port --- pjp = pj.Port(property={&quot;source_port&quot;: &quot;input_te_tm&quot;}) # region --- input_te_tm --- pjp.add(name=&quot;input_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;use_full_simulation_span&quot;: True, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1}, &quot;advanced&quot;: {&quot;offset&quot;: 0.1, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # region --- output_up_te_tm --- pjp.add(name=&quot;output_up_te_tm&quot;, type=&quot;eme_port&quot;, property={ &quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: 2.6785, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # region --- output_down_te_tm --- pjp.add(name=&quot;output_down_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: 0, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1, &quot;search&quot;: &quot;max_index&quot;}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # endregion  key\tvalue\ttype\tdescriptionname\tleft_port\tstring\tthe name of port type\teme_port\tstring\tselect type of port port_location\tleft\tstring\tselect the location of the port y\t2.6785\tfloat\tcenter position of the port in the y-direction y_span\t2\tfloat\tlength of the port in the y-direction z\t0.11\tfloat\tcenter position of the port in the z-direction z_span\t2\tfloat\tlength of the port in the z-direction mode_selection\tfundamental_TE\tstring\tselect the mode of port number_of_trial_modes number_of_modes integer set the number of port modes  1.10 Add Monitor​ In the simulation, Monitorfunction is used to create monitor and add function is used to add a monitor. Select profile_monitor type monitor from the added monitors to view the mode field distribution. # region --- 7. Monitor --- mn = pj.Monitor() mn.add(name=&quot;z_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 6.05, &quot;x_span&quot;: 73.1, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0}}) for i, pos in enumerate([-29.5, 17.5, 23.5, 34.5, 39.5]): mn.add(name=&quot;section&quot;+str(i+1), type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: pos, &quot;x_span&quot;: 0, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}}) # endregion  1.11 Add EME solver​ We use the Simulation function to create a simulation and the add function to add a solver. Select the EME solver in the type, and the properties of the solver are shown in the table below. # region --- 8. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 6, &quot;cell_number&quot;: 6, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 30, &quot;cell_number&quot;: 6, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 12, &quot;cell_number&quot;: 6, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 8.9, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 5, &quot;cell_number&quot;: 10, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 5.2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 5, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: global_mesh_grid, &quot;dz&quot;: global_mesh_grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;wavelength_sweep&quot;: { &quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: wavelength_start, &quot;stop&quot;: wavelength_stop, &quot;number_of_wavelength_points&quot;: wavelength_points}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) # endregion  key\tvalue\ttype\tdescriptionname\tsimu_name string name of simulation type\tEME\tstring\tselect the type of solver wavelength\t1.5\tfloat\twavelength of mode use_wavelength_sweep\tTrue\tbool\tselect to enable wavelength sweep span\t2\tfloat\tthe span of cell group cell_number\t1\tfloat\tnumber of cell in the cell group number_of_modes\t15\tfloat\tCalculate the number of modes per cell sc\tnone\tstring\tselect to enable subcell method dy\t0.05\tfloat\thorizontal mesh of cross-section dz\t0.05\tfloat\tLongitudinal mesh of cross-section eme _propagate\tTrue\tbool\tselect to enable EME propagation propagation_sweep True\tbool\tselect to enable length sweep parameter\tgrop_span_3\tstring\tthe area of length sweep start\t50\tfloat\tstarting length of sweep stop\t250\tfloat\tstoping length of sweep number_of_points\t50\tfloat\tnumber of sweep lengths phase\t0\tfloat\tthe initial phase of optical source select_mode\tTE\tstring\tmode of optical source According to different geometric structures and materials, the PSR is divided into 8 cell groups using cell_group_definition. Set the length of the cell group in span, use cell_number to set the number of cell. The divided cell structure is shown in the following figure. Use number_of_modes to set the number of modes calculated at the interface of adjacent cells, and it is necessary to set a sufficient number of modes to obtain the correct results. The area where the structure has not changed, the number of cell_number is set to 1, and sc is set to &quot;none&quot;. In the area of structural changes, multiple cell number need to be used to characterize the structure and the &quot;sub_cell&quot; method is used to reduce the staircase effect caused by discrete changes of the cross-section.  1.12 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, savepath=plot_path + simu_name, simulation_name=simu_name, celldisplay=True, xyratio=(1, 5), disabled_components=(&quot;box.coordinate&quot;,), show=False) #simu[simu_name].show3d() # endregion  The celldisplay control whether to display the boundaries of the divided cells. The xyration controls the aspect ratio of the image. 1.13 Calculate Mode​ You can create a new simulation using simu.add function and run the simulation using simu.add function. The type of simulation needs to be selected as &quot;mode_selection:user_select&quot;, and its properties are shown in the table below. Before running EME simulation calculations, we can calculate the mode field distribution of the port by setting the type of mode selection to True and other simulations to False. # region --- 10. Calculate Mode --- if run_options.calculate_modes: for port in [&quot;input_te_tm&quot;, &quot;output_up_te_tm&quot;, &quot;output_down_te_tm&quot;]: simu.add(name=simu_name+&quot;_&quot;+port+&quot;_cal_mode&quot;, simulation_name=simu_name, source_name=port, type=&quot;mode_selection:user_select&quot;, property={&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: True, &quot;mesh_structure&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: number_of_modes, &quot;calculate_group_index&quot;: True}}) port_res = simu[simu_name+&quot;_&quot;+port+&quot;_cal_mode&quot;].run() for m in range(number_of_modes): port_res.extract(data=&quot;calculate_modes&quot;, savepath=plot_path + &quot;00_modeprofile_fdeonly_&quot; + port + &quot;_mode#&quot; + str(m), mode=m, attribute=&quot;E&quot;, export_csv=False) # endregion  key\tValue\tType\tDescriptionmesh_structure\tTrue\tbool\tselect to calculate the refractive index distribution of the port calculate_modes True bool select to calculate mode of cross-section Wavelength\twavelength\tfloat\tcalculate the wavelength of the mode number_of_trial_modes\tnumber_of_modes\tinteger\tnumber of calculation modes search\t&quot;max_index&quot;\tfloat\tmethod of finding mode calculate_group_index\tTrue\tbool\tselect to calculate group refractive index 1.14 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation. # region --- 11. Run --- eme_res = simu[simu_name].run() # endregion  1.15 Run and Extract Results​  # region --- 12. See Results -- if run_options.extract: # region --- 12.1 EME Results -- if run_options.run: # region --- facet data --- eme_res.extract(data='eme_propagate:facet_data', savepath=plot_path, real=True, imag=True, export_csv=True) # endregion # region --- smatrix_intensity --- eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) # endregion # region --- monitor --- eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True) for i in range(5): eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_section&quot;+str(i+1), monitor_name=&quot;section&quot;+str(i+1), attribute=&quot;E&quot;, export_csv=True) # endregion # endregion # region --- 12.2 EME Wavelength Sweep Results --- if run_options.run_wavelength_sweep: &quot;&quot;&quot; 20_wavelength_sweep &quot;&quot;&quot; eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) # endregion # endregion  1.16 Control Switch​ We can control the operation of the simulation by passing bool values through tuples, as shown in the following code. class RunOptions(NamedTuple): calculate_modes: bool run: bool run_wavelength_sweep: bool extract: bool if __name__ == &quot;__main__&quot;: simulation(run_mode=&quot;local&quot;, wavelength=1.50, global_mesh_grid=0.05, local_mesh_grid=0.03, number_of_modes=15, run_options=RunOptions(calculate_modes=True, run=True, run_wavelength_sweep=True, extract=True))  "},{"title":"2 Output Results​","type":1,"pageTitle":"Polarization Splitter-Rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitter-Rotator/#2-output-results","content":"2.1 taper waveguide​ Change taper width The asymmetry of the cross-section of a waveguide can lead to hybridization of polarization modes within a certain width range, which is a commonly used method for designing polarization conversion. We can easily obtain the effective refractive index of silicon waveguides with different widths by using the SDK's multiple cyclic FDE. As shown in the figure below, mode hybridization occurs near the waveguide width of 0.65um in the air cladding. As the waveguide width widens, the input TE0 mode light field changes to TM1. Therefore, the width variation range of the adiabatic conical waveguide we designed should include the range of mode hybridization.Scan taper length It should be noted that the tapered waveguide must be long enough to convert the input TM mode of the waveguide into TE mode without generating other modes. Here, the length scanning of EME can be used to obtain the optimal mode conversion efficiency of the tapered waveguide length. 2.2 Coupling waveguide​ Add a narrow waveguide near the conical waveguide and convert TE1 in the wide waveguide to TE0 in the narrow waveguide through the design of an asymmetric directional coupler. In this way, the input TM mode is converted to TE0 mode, while the input TE0 mode maintains the same polarization in the conical waveguide transmission, and does not meet the mode conversion conditions in the asymmetric directional coupling region and is output from the through port. 2.3 Mode filtering​ The polarization beam splitter rotator cascades an MMI mode filter at the through port to eliminate residual TM0 and TE1 modes at the output port and improve the extinction ratio of the modes. 2.2 EME Propagation​ The calculation of EME requires adding multiple elements in the area where the cross-section of the waveguide changes, and the more severe the structural change, the more elements are needed. After the calculation of `EME propagation`` is completed, the electric field inside the waveguide can be observed. Using EME simulation can quickly optimize length, and you can use `propagation_sweep` to optimize transmittance.  "},{"title":"Analysis and Discuss​","type":1,"pageTitle":"Polarization Splitter-Rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitter-Rotator/#analysis-and-discuss","content":"For the calculation of long-distance waveguide transmission models, EME has significant advantages. The mode field distribution of input TE0 and TM0 is shown in the following figure. "},{"title":"References​","type":1,"pageTitle":"Polarization Splitter-Rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitter-Rotator/#references","content":"Dai D, Wu H. Realization of a compact polarization splitter-rotator on silicon[J]. Optics letters, 2016, 41(10): 2346-2349. "},{"title":"Spot Size Converter","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/ssc/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Spot Size Converter","url":"/my-website/docs/examples/PIC/ssc/#introduction","content":"The spot size converter (SSC) is an important device for connecting silicon photonic integrated chips and external optical fibers, which can couple light transmitted in silicon waveguides into the fiber at low loss. As shown in the figure, SSC has a tapered silicon waveguide with gradually thinning ends and a low refractive index waveguide covered with SiON, and the entire waveguide device is placed in a silicon dioxide environment [1]. The mode field size at the end of the tapered waveguide is similar to that of the optical fiber, so it can effectively couple light from the waveguide into the fiber. Eigenmode expansion (EME) method has great advantages in calculating long taper waveguide. By dividing multiple cells in the cross-sectional variation area, and then calculating the modes at the interface of the cells and the bidirectional transmission of the modes, the s-matrix of the taper waveguide transmission can be quickly obtained. When using length sweep, only the bidirectional transmission part needs to be calculated to obtain the S parameter of length sweep. "},{"title":"Simulation​","type":1,"pageTitle":"Spot Size Converter","url":"/my-website/docs/examples/PIC/ssc/#simulation","content":""},{"title":"1. Code Description​","type":1,"pageTitle":"Spot Size Converter","url":"/my-website/docs/examples/PIC/ssc/#1-code-description","content":"1.1 Import Toolkit​ First, we need to import maxoptics_sdk and Python's third-party package. The import module for EME simulation as follows. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple  1.2 Define Simulation Function​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. def simulation(*, run_mode=&quot;local&quot;, wavelength=1.55, grid=0.08, number_of_modes=10, run_options: &quot;RunOptions&quot;, **kwargs):  The run_mode variable parameter is used to define the location of the simulation run. The wavelength variable is defined as wavelength of the optical source. The grid variable is defined as grid size. The number_of_modes variable is used to define the number of modes of calculation. 1.3 Define Parameters​ Before starting the simulation, we can define parameters to facilitate modeling and parameterization sweep. The defined parameters as follows. # region --- 0. General Parameters --- path = kwargs[&quot;path&quot;] simu_name = &quot;EME_SSC&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/SSC.gds&quot; # endregion  The path variable is used to store the path of this Python file. The simu_name variable is used to store simulation names. The time_str variable is used to store the timestamp. The project_name variable is used to store the project name. The plot_path variable is used to store the result path. The gds_file variable is used to store the file path of GDS. 1.4 Create project​ we create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion  1.5 Add Material​ Here we demonstrate using the Material function to create material and using the add_nondispersion function to add non dispersive materials, as well as using the add_lib function to add materials from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_nondispersion(name=&quot;Si&quot;, data=[(3.476, 0)], order=2) mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.465, 0)], order=2) mt.add_nondispersion(name=&quot;SiON&quot;, data=[(1.50, 0)], order=2) mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) # endregion  The name is used to define the name of the added material. The data is used to input the real and imaginary parts of the refractive index of the material. The order is used to set the grid order of the material. 1.6 Add Structure​ The structure is composed of silicon dioxide substrate, adiabatic tapered silicon waveguide and polymer covered waveguide. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select &quot;gds_file&quot; in type to establish the model by importing the GDS file method. The properties of GDS modeling are shown in the table below. # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;SiO2&quot;]) st.add_geometry(name=&quot;sub&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;SSC&quot;, &quot;layer_name&quot;: (1, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: -1.5, &quot;z_span&quot;: 3}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}}) st.add_geometry(name=&quot;ssc&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;SSC&quot;, &quot;layer_name&quot;: (2, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.1, &quot;z_span&quot;: 0.2}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name=&quot;cover&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;SSC&quot;, &quot;layer_name&quot;: (3, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 1.5, &quot;z_span&quot;: 3}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiON&quot;], &quot;mesh_order&quot;: 1}}) # endregion  Key\tValue\ttype\tDescriptionname\tsub\tstring\tname the added geometry type\tgds_file\tstring\tselect the type of structure path\tgds_file\tstring\tfile path of GDS file cell_name\tSSC\tstring\tname of the GDS cell layer_name\t(1,0)\tlist\tname of the GDS layer x 0 float center position in the x-direction of the geometric structure y\t0\tfloat\tcenter position in the y-direction of the geometric structure z\t-1.5\tfloat\tcenter position in the z-direction of the geometric structure z_span\t3\tfloat\tlength of the geometric structure in the z-direction material\tmt[&quot;Si&quot;]\tmaterial\tselect the material in Material mesh_order\t2\tinteger\tset the priority of the mesh Select simulation material by using mesh_order in areas where geometry overlaps, the higher the number of mesh_order, the higher the priority of the material. 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. The properties are shown below. # region --- 4. Boundary --- st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) # endregion  1.8 Add Sub Mesh​ After light passes through tapered silicon waveguide that gradually becoming smaller, the mode field is strongly limited to a very small range. Therefore, it is necessary to use add_mesh to add a transverse grid to accurately calculate the limited light field. Add local mesh as shown below. # region --- 5. Sub Mesh --- st.add_mesh( name=&quot;sub_mesh&quot;, property={&quot;general&quot;: {&quot;dx&quot;: grid, &quot;dy&quot;: grid, &quot;dz&quot;: grid}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) # endregion  The dx,dy,dz are the mesh sizes in the x, y, and z directions, respectively. 1.9 Add EME port​ You can use the port function to create a port and use the &quot;source_port&quot; property to set the location of the source port. You can use the add function to add ports and the properties of port are shown in the table below. # region --- 6. Port --- pjp = pj.Port(property={&quot;source_port&quot;: &quot;left_port&quot;}) pjp.add(name=&quot;left_port&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;}, &quot;advanced&quot;: {&quot;number_of_trial_modes&quot;: 15}}}) pjp.add(name=&quot;right_port&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;}, &quot;advanced&quot;: {&quot;number_of_trial_modes&quot;: 15}}}) # endregion  key\tvalue\ttype\tdescriptionname\tleft_port\tstring\tthe name of port type\teme_port\tstring\tselect type of port port_location\tleft\tstring\tselect the location of the port y\t0\tfloat\tcenter position of port width y_span\t5.5\tfloat\tport width y\t0.5\tfloat\tcenter position of port height z_span\t7\tfloat\tport height mode_selection\tfundamental_TE\tstring\tselect the mode of port number_of_trial_modes 15 integer set the number of port modes  1.10 Add Monitor​ The Monitorfunction is used to create monitor and add function is used to add a monitor. Select profile_monitor type monitor from the added monitors to view the mode field distribution. # region --- 7. Monitor --- mn = pj.Monitor() for i, _pos in enumerate([-102, -99, 102]): mn.add(name=&quot;section&quot;+str(i+1), type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: _pos, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) mn.add(name=&quot;y_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_y_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) mn.add(name=&quot;z_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.1, &quot;z_span&quot;: 0}}) # endregion  1.11 Add EME solver​ We use the Simulation function to create a simulation and the add function to add a solver. Select the EME solver in the type, and the properties of the solver are shown in the table below. # region --- 8. solver --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: 15, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: 15, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 200, &quot;cell_number&quot;: 50, &quot;number_of_modes&quot;: 15, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 3, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: 15, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_length_sweep, &quot;parameter&quot;: &quot;group_span_3&quot;, &quot;start&quot;: 50, &quot;stop&quot;: 250, &quot;number_of_points&quot;: 100}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) # endregion  key\tvalue\ttype\tdescriptionname\tsimu_name string name of simulation type\tEME\tstring\tselect the type of solver wavelength\t1.5\tfloat\twavelength of mode use_wavelength_sweep\tTrue\tbool\tselect to enable wavelength sweep span\t2\tfloat\tthe span of cell group cell_number\t1\tfloat\tnumber of cell in the cell group number_of_modes\t15\tfloat\tCalculate the number of modes per cell sc\tnone\tstring\tselect to enable subcell method dy\t0.05\tfloat\thorizontal mesh of cross-section dz\t0.05\tfloat\tLongitudinal mesh of cross-section eme _propagate\tTrue\tbool\tselect to enable EME propagation propagation_sweep True\tbool\tselect to enable length sweep parameter\tgrop_span_3\tstring\tthe area of length sweep start\t50\tfloat\tstarting length of sweep stop\t250\tfloat\tstoping length of sweep number_of_points\t50\tfloat\tnumber of sweep lengths phase\t0\tfloat\tthe initial phase of optical source select_mode\tTE\tstring\tmode of optical source According to different geometric structures and materials, the SSC is divided into four cell groups using cell_group_definition. Set the length of the cell group in span, use cell_number to set the number of cell. The divided cell structure is shown in the following figure. Use number_of_modes to set the number of modes calculated at the interface of adjacent cells, and it is necessary to set a sufficient number of modes to obtain the correct results. In the area where the cross-sectional area of cells remains unchanged, the number of cell_number is set to 1, and sc is set to &quot;none&quot;; In the area of structural changes, multiple cell number need to be used to characterize the structure and the &quot;sub_cell&quot; method is used to reduce the staircase effect caused by discrete changes of the cross-section.  1.12 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=plot_path + simu_name, simulation_name=simu_name, celldisplay=True, xyratio=(1, 40)) #simu[simu_name].show3d() # endregion  The celldisplay control whether to display the boundaries of the divided cells. The xyration controls the aspect ratio of the image. 1.13 Calculate Mode​ You can create a new simulation using simu.add function and run the simulation using simu.run function. The type of simulation needs to be selected as &quot;mode_selection:user_select&quot;, and its properties are shown in the table below. Before running EME simulation calculations, we can calculate the mode field distribution of the port by setting the type of mode selection to True and other simulations to False. # region --- 10. Calculate Mode --- if run_options.calculate_modes: for port in [&quot;left_port&quot;, &quot;right_port&quot;]: simu.add(name=port + &quot;_cal_mode&quot;, simulation_name=simu_name, source_name=port, type=&quot;mode_selection:user_select&quot;, property={&quot;modal_analysis&quot;: { &quot;mesh_structure&quot;: True, &quot;calculate_modes&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: number_of_modes, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True, &quot;bent_waveguide&quot;: {&quot;bent_waveguide&quot;: False, &quot;radius&quot;: 1, &quot;orientation&quot;: 0, &quot;location&quot;: &quot;simulation_center&quot;}}}) port_res = simu[port + &quot;_cal_mode&quot;].run() for m in [0, 1]: port_res.extract(data=&quot;calculate_modes&quot;, savepath=plot_path + &quot;00_modeprofile_fdeonly_&quot; + port + &quot;_mode#&quot; + str(m), mode=m, attribute=&quot;E&quot;, real=True, imag=True, export_csv=False, show=False) # endregion  key\tValue\tType\tDescriptionmesh_structure\tTrue\tbool\tselect to view the refractive index distribution of the port calculate_modes True bool select to calculate the mode of cross-section Wavelength\twavelength\tfloat\tcalculate the wavelength of the mode number_of_trial_modes\tnumber_of_modes\tfloat\tnumber of calculation modes search\t&quot;max_index&quot;\tfloat\tmethod of calculating mode calculate_group_index\tTrue\tbool\tselect to calculate group refractive index bent_waveguide\tFalse\tbool\tselect to enable bent waveguide in calculation mode radius\t1\tfloat\tset the radius of the bent waveguide orientation\t0\tfloat\tset the bending direction of the waveguide location\t&quot;simulation_center&quot;\tstring\tset the position of the bent waveguide 1.14 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation, and assign the result to eme_res. # region --- 11. Run --- eme_res = simu[simu_name].run() # endregion  1.15 Run and Extract Results​ Extract data using extract, where data is the calculated result data, savepath is the storage path, target is the classification of the data, and monitor_name is the name of the monitor. # region --- 12. see result --- eme_res.extract(data=&quot;eme_propagate:facet_data&quot;, savepath=plot_path, real=True, imag=True, export_csv=True) eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) eme_res.extract( data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_y_normal&quot;, monitor_name=&quot;y_normal&quot;, attribute=&quot;E&quot;, export_csv=True) eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;014_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True) for i in range(3): eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;0&quot;+str(15+i)+&quot;_eme_section&quot;+str(i+1), monitor_name=&quot;section&quot;+str(i+1), attribute=&quot;E&quot;, export_csv=True) # --- EME Propagation Sweep Results --- if run_options.run_length_sweep: eme_res.extract(data=&quot;propagation_sweep:sweep&quot;, savepath=plot_path + &quot;10_length_sweep&quot;, export_csv=True) # endregion  The &quot;eme_propagate:facet_data&quot; stores the calculation mode of cells and ports and the total S-matrix. The &quot;eme_propagate:smatrix&quot; stores the S-matrix after bidirectional transmission of the calculation port mode. The &quot;propagation_sweep:sweep&quot; stores the S-matrix corresponding to each length after sweeping. 1.16 Control Switch​ We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code. class RunOptions(NamedTuple): calculate_modes: bool run: bool run_length_sweep: bool extract: bool if __name__ == &quot;__main__&quot;: simulation(run_mode=&quot;local&quot;, wavelength=1.5, grid=0.02, number_of_modes=20, run_options=RunOptions(calculate_modes=True, run=True, run_length_sweep=True, extract=True))  "},{"title":"2 Output Results​","type":1,"pageTitle":"Spot Size Converter","url":"/my-website/docs/examples/PIC/ssc/#2-output-results","content":"2.1 ModeProfile​ We extracted the first two modes of the input port, and the mode field distribution as following figure.After the propagation calculation is completed, the extracted results can be viewed in the storage path, and the extraction of the results can only be set before the program running. The mode fields of TE polarization at the input and output ends are shown below, it is clearly observed that the output mode field size is larger than the input. Silicon waveguides have a strong ability to limit the light field, but it can leak into the environment when the waveguide size is too small. By adding a low refractive index waveguide outside the taper waveguide, the leaked light field is limited and the size of the mode spot is increased.  2.2 EME Propagation​ The EME solver first calculates the mode of the cell boundary cross-section, and then obtains the scattering matrix for each cross-section by matching the tangential electric and magnetic fields. After bidirectional transmission of the scattering matrix for each cross-section, the S-matrix of the entire device can be obtained. To ensure the accuracy of the calculation results, the number of calculated modes in the cross-section can be gradually increased until the results converge. After bidirectional transmission calculation of mode, the electric field distribution in the transmission direction can be constructed. The distribution of the electric field is shown in the following figure. The EME propagation calculation all modes, but only returns the S-matrix of the port mode. As shown in the figure below, the S-matrix is a 2∙2 matrix, where S21 represents the absolute value of the transmission coefficient from port 1 input to port 2 output. Due to the symmetry of the transmission behavior, S12=S21. "},{"title":"Analysis and Discuss​","type":1,"pageTitle":"Spot Size Converter","url":"/my-website/docs/examples/PIC/ssc/#analysis-and-discuss","content":"When calculating the area of structural change in EME, it is necessary to divide the structure into multiple cells, and the calculated modes are located at interface between adjacent cells. The more cells divided, the more accurate the characterization of the structure. In the adiabatic tapered waveguide region, the number of cells divided is too small, and the calculated cross-section area varies greatly, resulting in a strong staircase effect. Therefore, before calculating EME, it is necessary to divide the structure into enough cells to ensure the accuracy of the results. It should be noted that when calculating the EME transmission of taper waveguide, we need to use the &quot;sub_cell&quot; method, which can reduce the non physical reflection caused by the step change of the unit cross-section. Within the range of input and output straight waveguides, the cross-section of the waveguide remains unchanged, and the &quot;none&quot; method is used to calculate the transmission. In order to meet the adiabatic condition, we set &quot;run_length_sweep&quot; to True and conducted a length sweep of 50-250 um in the tapered silicon waveguide area. The number of cells divided in the region where the silicon waveguide changes is 50. As shown in the following figure. When the sweeping length is greater than 100 um, the transmission coefficient S21 will fluctuate with the increase of length. When we increase the number of tapered silicon waveguide to 150, the transmission coefficient curve between the sweeping length of 50-250 um becomes smooth. Therefore, in addition to ensuring the number of modes in the unit cross-section, the EME simulation should also have sufficient number of cells.  If you need to sweep the wavelength, you can use &quot;wavelength_sweep&quot; to turn on wavelength sweep. Similar to length sweep, it is necessary to input the starting and ending wavelength and the number of wavelength points in the EME simulation. At each frequency point, the modes of all cell interfaces and EME propagation parts are also calculated. Therefore, wavelength sweep will take longer than length sweep. "},{"title":"References​","type":1,"pageTitle":"Spot Size Converter","url":"/my-website/docs/examples/PIC/ssc/#references","content":"[1] T. Tsuchizawa et al, “Microphotonics devices based on silicon microfabrication technology”, IEEE J. Select. Topics Quantum Electron. 11, 2005, 232-240 "},{"title":"General","type":0,"sectionRef":"#","url":"/my-website/docs/faq/General","content":"","keywords":""},{"title":"What is Max-Optics?​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#what-is-max-optics","content":"公司简介：​ 上海曼光信息科技有限公司，成立于2018年8月。公司依托山东大学科研团队力量，凭借坚实的电磁场仿真与分析理论与技术基础，以及完备的自动化设备设计与制造、软件设计与开发能力研发出覆盖微波及光学频段的电磁场可视化软硬件产品，为客户提供完善的电磁场相关的仿真、设计、分析、测量解决方案。 公司业务面向5G、光通信、光电传感、光计算、工业物联网、国防安全等领域，主要涵盖电磁场仿真与测量两大业务。电磁仿真业务主要产品包括无源/有源光电芯片及系统仿真设计软件、光电芯片仿真设计服务、微波/射频天线仿真设计服务。电磁场测量业务光电子器件测量与参数提取平台；微波毫米波测量业务主要产品包括5G NR OTA测试系统、平面/柱面/球面近远场天线测试系统；公司以客户为中心，从客户直接需求出发，完成涵盖自动化测量设备软硬件定制化设计、制造、开发、交付的交钥匙工程，并提供电磁场相关设计与测量分析增值服务。 Company Profile:​ Shanghai Max-Optics Information Technology Co.,Ltd was established in August 2018. With the support of the research team from Shandong University, the company has developed electromagnetic field visualization software and hardware products covering microwave and optical frequency bands, based on solid electromagnetic field simulation and analysis theory and technology foundation, as well as comprehensive capabilities in automated equipment design and manufacturing, software design and development. These products provide customers with comprehensive solutions for electromagnetic field simulation, design, analysis, and measurement. The company's business focuses on 5G, optical communication, optoelectronic sensing, optical computing, industrial IoT, and defense security. It mainly covers two major businesses: electromagnetic field simulation and measurement. The electromagnetic simulation business includes simulation design software for passive/active optoelectronic chips and systems, optoelectronic chip simulation design services, and microwave/radio frequency antenna simulation design services. The electromagnetic field measurement business includes optoelectronic device measurement and parameter extraction platforms. The microwave millimeter wave measurement business mainly includes 5G NR OTA testing systems, planar/cylindrical/spherical near-field and far-field antenna testing systems. The company is customer-oriented, starting from the direct needs of customers, and completes turnkey projects that cover customized design, manufacturing, development, and delivery of automated measurement equipment hardware and software. It also provides value-added services for electromagnetic field design and measurement analysis. What are our advantages?​ We are the first company in the industry to offer a &quot;local + cloud&quot; computing platform for photonics integrated circuit (PIC) simulation software. We provide a one-stop solution, delivering software, resources, and technical support anytime, anywhere. The Importance of Software Simulation: As semiconductor devices continue to evolve towards smaller sizes and more complex structures, the use of simulation software solutions offers numerous advantages over laboratory measurement methods, playing a crucial role in semiconductor device development. Highly accurate algorithms enable rapid modeling and simulation of devices, allowing the observation of internal physical processes. Through simulation software, customers can not only design new and complex device structures but also propose solutions to optimize device performance by altering operating conditions or various physical quantities and parameters within device models. From simulating photonic integrated circuits to various types of simulations in different fields, spanning from materials to systems, the use of simulation software not only reduces production costs, shortens development cycles, and increases productivity but also provides clear and concise results data for researchers in various domains to collaborate on complex projects more effectively. Software Uniqueness: We offer two software forms based on 'local + cloud' integration. The first is a software development toolkit SDK based on Python scripting, which includes modeling, simulation, post-processing, and data visualization capabilities. It can call all modules and is user-friendly, easy to learn, and easy to extend. The second is a GUI user interface, enabling interactive simulations using both forms. Additionally, we incorporate advanced grid optimization and GPU acceleration to reduce simulation times. We also provide virtual machine and Windows versions to accommodate various simulation environments preferred by our customers. Key Product Advantages: We currently provide an efficient and reliable one-stop solution for both passive and active devices, combining multiple simulation algorithms. Our simulations exhibit industry-leading accuracy and speed. What products do we currently have?​ We currently support a range of devices, including passive devices, modulators, detectors, and lasers. We've enhanced classical CEM algorithms for analyzing the behavior of light and introduced a novel 'local + cloud' user interface configuration to utilize passive modules for simulating optical waveguides and passive optical devices. Additionally, we've combined carrier transport simulation algorithms with electromagnetic simulation algorithms, providing an efficient and reliable one-stop solution for simulating optoelectronic active devices. For more detailed information on specific device products, please visit the 'Example Library' section on our website. To learn more about our SDK software products, please visit the 'Max-Optics SDK' section on our website for case descriptions related to the software. What functions are available for passive devices simulation?​ We have enhanced the classical CEM algorithm and introduced a novel 'local + cloud' user interface configuration to utilize passive modules for simulating optical waveguides and passive optical devices. The following are the modules supported for passive component simulation: FDTD Module\tShared Module\tEME Module• Mode/Gaussian/Import source • PML/PEC boundary • 0D/1D/2D/3D frequency monitor • 0D/1D/2D/3D time monitor • Early Shutoff • Transmission calculation • Mode expansion • S-parameters calculation • Global parameter sweeping • Multi-threaded computing\t• 3D Modeling• GDS import • Tilt slope of waveguide profile • Non-Uniform/Uniform Mesh • Conformal Mesh Refinement • Standard material library • Custom isotropic/diagonally anisotropic materials • Far field\t• Effective Index Calculation • Group Index Calculation • Arbitrary port settings • PEC/PMC/PML boundary • 2D frequency domain monitor • S-parameter calculation • Frequency Sweeping • Group span quick sweeping • Overlap Analysis • Multi-threaded Computing What functions are available for active component simulation?​ Our active module seamlessly integrates optical and electrical modules, combining carrier transport simulation algorithms with electromagnetic simulation algorithms. This one-stop solution allows for efficient and reliable simulation of optoelectronic active devices with the ability to perform multiple diverse simulations in a single model. The following are the modules supported for active component simulation. AFDTD Module\tAFDE Module\tOEDevice Module• Mode Source • PML/PEC Boundary • 0D/1D/2D/3D Frequency Monitor • Early Shutoff • Transmission Calculation • Multi-thread Computing • Generation Rate Extraction\t• Effective Index Calculation • Group Index Calculation • VpiL, VpiLoss Extraction\t• Steady State / SSAC / Transient Simulation • Physical Models and Parameters of Electrical • Materials • Multi-thread Computing • Convergence Control • Carrier / Potential / Band Profile Monitor • Doping Import • Generation Rate ImportShared Module\tShared Module for AFDTD and AFDE• 3D Modeling • GDS Import\t• Non-Uniform/Uniform Mesh • Conformal Mesh Refinement • Standard Material Library • Custom Isotropic Optical Materials Which simulation modules are applied?​ We employ the finite-difference numerical method for device structure, doping, and grid division within the simulation region. It approximates differentiation with finite differences. We use the Finite-Difference Eigenmode (FDE) method to investigate the field distribution of eigenmodes, as well as the refractive index and losses of devices. The Finite-Difference Time-Domain (FDTD) method is used to study the transmission rate, reflectance, and losses of small to medium-sized devices. For longer devices, we utilize the Eigenmode Expansion Method (EME) to discuss their transmission rate, reflectance, and losses. 1、Max-Optics Studio-FDTD Max-Optics Studio FDTD is a powerful domestic tool for simulating micro-nano optoelectronic devices. It boasts advanced GPU acceleration capabilities, enabling fast solutions to three-dimensional/two-dimensional Maxwell's equations. It offers precise analysis of various sub-wavelength structures in micro-nano optoelectronic devices and the propagation of electromagnetic fields in materials, as well as the interaction between light and matter. It supports both a graphical user interface and script-based operations, making it a valuable assistant for your optoelectronic innovations. It features the unique real-time field overlay function, allowing the direct overlay of the optical field iteration progress onto the 3D CAD structure, providing a clear visual representation of the simulation progress. Key Product Features： —— GPU Acceleration Technology Max-Optics offers a unique GPU FDTD algorithm acceleration technology that leverages the GPU's multi-core resources to increase FDTD computational speed by more than tenfold. This is achieved through efficient thread management and memory access planning, making the most of the GPU's capabilities. 2、Max-Optics Studio-EME Max-Optics Studio EME is an efficient simulation tool for modeling long-distance transmission devices. It supports mode analysis using the Finite-Difference Eigenmode (FDE) method under the Finite-Difference Algorithm, as well as Eigenmode Expansion for propagation, and overlap integral calculations. Key Product Features： —— Curve Mesh Technology Max-Optics introduces a unique 3D curve mesh grid technology that enables precise equivalence for curved or surface structures when using a hexahedral grid. This allows for reduced mesh density without sacrificing computational accuracy, resulting in improved computational efficiency. —— Curve Mesh Technology • The EME module benefits from a 50% reduction in the number of required computational modes, leading to increased computational stability. 3、Max-Optics Studio-OE Device OE Device is a one-stop solution, providing a convenient tool for simultaneous electromagnetic field and carrier motion simulation in active optoelectronic devices. It allows for self-consistent solutions of the electromagnetic field (Maxwell's equations), electrostatic potential (Poisson's equation), and free carrier density (drift-diffusion equations). The entire modeling and simulation process can be completed in one interface. 4、Max-Optics Studio-MO Link MO Link is a link-level simulation tool for photonic chips, supporting multi-mode, bidirectional, and multi-channel simulations. What product forms do we offer?​ We have introduced two software formats that accommodate both offline and cloud-based usage. Offline simulations can be carried out solely using local computing resources. These formats comprise a Software Development Toolkit (SDK) and a GUI user interface. SDK is based on Python scripting. It offers a standardized approach for invoking all modules and supports the import of GDS files. When building simulations within the SDK, the option to generate GUI files is available, providing a more intuitive simulation experience. Product Formats\tWeb-based\tStandalone\tSDKDisplay Features\t•Supports cross-platform login •Flexible scheduling of cloud-based computing resources\t•Local computing resources •Familiar and straightforward operation •Complete 3D modeling interface •Automatic simulation history saving and playback •Allows setting global variable expressions in any input box •Supports non-proportional scaling of simulation structures •Supports script-based modeling •Supports GDS-II import •Integrates a variety of third-party Python open-source libraries •Allows for the use of local and cloud-based computing resources •Convenient interaction with third-party tools •Includes built-in example code for quick start If you would like to learn more about SDK installation and usage instructions, please visit the 'Max-Optics SDK' section on our website for detailed information. What services do we provide?​ Our company's core businesses primarily encompass two major sectors: optoelectronic integrated circuit (OEIC) simulation software and chip and system testing. In the field of optoelectronic integrated circuit simulation software, our main products include passive/active OEIC and system simulation design software, OEIC testing system solutions and services, customized OEIC simulation process services, customized microwave/RF simulation and testing system services. These products and solutions have been successfully applied to top domestic clients, ensuring business continuity within the domestic industry and earning us an excellent reputation. In particular, in the field of optoelectronic integrated circuit simulation design software, Max-Optics has broken through international technical barriers related to the core algorithms and 'know-how' of optoelectronic chips. We have pioneered the development of a cloud-based optoelectronic chip simulation design platform, providing efficient optoelectronic integrated circuit simulation design tools for optical communication, optical computing, optical sensing, quantum computing, and optical displays. Our services benefit areas such as 5G, artificial intelligence, and national defense and security. Education and Training: On our official website, we offer answers to common questions related to device simulation and software installation, which you can independently access online. We have a detailed and typical device case library, complemented by instructional videos and documentation, making it easy for users to acquire professional knowledge about semiconductor physics and software usage. For detailed information about device cases and calculation methods, please visit the 'Example Library' and 'Tutorials' sections on this website. For software installation and usage inquiries, please visit the 'Max-Optics SDK' section. Technical Support Team: Our technical support team possesses extensive professional knowledge and can understand, diagnose, and resolve technology-related issues. We are committed to optimizing devices using proven device modeling methods to address technology development and manufacturing issues, providing customers with calibration, simulation, model development, and consultation services. For users with unique semiconductor device modeling requirements but lacking the time or resources to use SDK software in-house, we offer modeling services, providing complete, fast, and accurate solutions. Deliverables include but are not limited to graphical outputs (structural and characteristic diagrams), structures (device structures and grids), and device characteristic data. You can submit feedback online, or contact us via phone and email. Software Support Team: Our software support team consists of experienced engineers dedicated to software product feature and algorithm development. They also provide license verification, software, and computing platform installation services to customers. Feel free to reach out to us via phone or email:： Phone：150 6666 1688 E-mail：sales@max-optics.com How to access technical support services?​ When you need technical support or have inquiries related to using Max-Optics, you can follow these steps to obtain support and write a request for assistance: Clearly State the Issue or Requirement: Describe the issue or requirement concisely. Use clear language to explain the specific support you are seeking. Provide Detailed Information: Provide as much relevant information as possible about the issue, such as error messages, steps taken, software version, operating system, etc. This will assist the support personnel in analyzing and diagnosing the problem. Include Screenshots or Log Files: If applicable, attach relevant screenshots or log files to supplement the problem description. These visual aids provide additional context and facilitate the identification and resolution of the issue. List Attempted Solutions: If you have already attempted some solutions without success, mention them in your request. Provide details of the steps you have taken and the outcomes. This will help the support team understand the efforts you have already made and avoid repetition. Be Polite and Clear: Maintain a polite and clear tone when writing your support request. Use professional language and appropriate etiquette to express your issue or requirement and express gratitude for the support team's assistance. User Feedback： Please enter your question and feedback below: Thank you for your feedback! We will address your question as soon as possible. If you need further assistance, please contact our customer support team. Contact Information: Phone: 150 6666 1688Email: sales@max-optics.com How to set up licensing for remote work or home office use?​ If your company has a group licensing arrangement with the server set up on the corporate intranet, this answer explains how individuals can set up licensing to successfully use our software when working remotely or from home. You can use a VPN to connect to the corporate network from a remote location. If you don't have VPN access, you can request permission from your company's internal licensing server administrator to open public access (with a public IP and port) for you. Then, in the software settings, you can specify the server's IP address as the newly approved public address. Alternatively, we can guide the administrators of your company's licensing server to implement a 'group licensing checkout' mode, allocating one license from the total number of licenses purchased as a temporary offline license. The specific steps for this process are as follows. Setting Up Group Licensing Checkout Mode: (1) Log in to https://bit.bitanswer.cn (2) In the left sidebar, select the '业务' menu. (3) In the '授权信息' on the right, select '授权借出'. How to configure a jupyter environment for AIO SDK?​ In the command line, activate the virtual environment where the All-in-One SDK is located, and then follow these steps: (1) Install ipykernel. pip install ipykernel (2) Write the environment to the kernel of notebook. python -m ipykernel install --user --name &quot;mang1903&quot; --display-name &quot;mang1903&quot; (3) Open Jupyter Notebook. jupyter notebook (4) Click 'New' to create an ipynb file. You will see the kernel option 'mang1903' ('mang1903' is the display name of the previously set 'mang1903' virtual environment, and users can customize it). What to do if there are spaces in the python installation path?​ If there are spaces in the Python installation path, you may encounter errors when creating a virtual environment in the first step of installing AIO. The system may mistakenly interpret the path before the space as a separate command. In such cases, if you cannot modify the Python installation path, you can enclose the path in double quotes or use a raw string, as shown below: path = &quot;C:/Program files/Python/python.exe&quot;  "},{"title":"Y branch","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/ybranch/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Y branch","url":"/my-website/docs/examples/PIC/ybranch/#introduction","content":"The Y branch is a fundamental component of integrated optics. Its primary function is to split the incoming light from a single input waveguide into two separate waveguides (splitter). Likewise, it can also combine light from two waveguides into a single waveguide (combiner). The main performance parameters of the Y branch include insertion loss, device dimensions, and operating bandwidth. Simulation Methods​ Through the FDTD module or EME module, the Y branch's structure can be optimized to obtain the transmittance of fundamental mode or S-parameters of each output port. This allows the verification of the optimized results for the multi-mode interferometer.This optimization process aims to improve the Y branch's insertion loss and bandwidth performance. Y branch(FDTD module)​ 1.Basic Options​ 1.1 Import File​ Once you have installed and configured the environment, import the python code and the GDS layout. The example library and related model code are usually located in the directory : .venv_maxoptics/site-packages/maxoptics_sdk/examples. The GDS file is generally imported into the path : .venv_maxoptics/site-packages/maxoptics_sdk/examples/examples_gds 1.2 SDK Initialization​ Create a new terminal and run the code after you import the python script and GDS file. Max-Optics SDK may take some time to initialize on the first simulation. Version of Max-Optics sdk is 2.3.0.4.630.2000 Max-Optics SDK is initializing... 2.Code Description​ Now let's learn the meaning of functions and parameters that correspond to the code. 2.1 import Modules​ To begin, we need to use the import command to call the relevant functional modules. For instance, we import the typing , os and time module in python. At the same time ,we import the customized module maxoptics_sdk.all and maxoptics_sdk.helper. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple The maxoptics_sdk package provides all in one optical simulation with Python. The os module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands. The time module provides various functions to work with time-related operations and to measure time intervals. The typing module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. 2.2 Define Simulation​ Firstly, We define parameters and give them a default value, such as the simulation wavelength and number of modes. Note that we can override this value in the following code. def simulation(*, run_mode='local', wavelength=1.575, grids_per_lambda=25, run_options: 'RunOptions', **kwargs): The provided code contains comments that define the simulation parameters. Let's explain each of these parameters. The function simulation is used to define the simulation parameters for the program. The run_mode parameter determines the type of calculation resources to be used. The wavelength parameter specifies the wavelength of the input light in micrometers. The grids_per_lambda parameter sets the simulation mesh grid. The **kwargs is a special syntax used in function definitions to accept an arbitrary number of keyword arguments as a dictionary. 2.3 Define Parameters​ Define commonly used parameters in region 0, such as the mesh grid of the simulation boundary, the start time of the simulation, the path and name for the simulation output, the path to the imported GDS layout, and other parameters required for structural parameterized modeling. If you need to calculate the bandwith of the device in the EME simulation, you can also decide the wavelength for sweeping in this section. # region --- 0. General Parameters --- waveform_name = f'wv{wavelength * 1e3}' path = kwargs['path'] simu_name = 'FDTD_y_branch' time_str = time.strftime('%Y%m%d_%H%M%S', time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + '/examples_gds/splitter1.gds' # endregion The code defines several parameters and variables necessary for the simulation process. The waveform_name parameter is the name of waveform. The path variable defines the file path for the simulation, while simu_name specifies the name of the simulation file. The time_str variable is used to obtain the current time as a timestamp for the simulation. The project_name variable assigns a name to the project for the simulation output. The plot_path variable determines the directory where the simulation result plots will be saved. The gds_file_root_path and gds_file variable defines the path for importing the GDS layout. 2.4 Creat Project​ You can create a new project using the Project function of Max's software development toolkit in region 1. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode) # endregion 2.5 Define Materials​ Let's proceed to the next step, where we set up the materials required for the simulation in region 2. In this case, we will directly use relevant materials from the MO material library. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) mt.add_lib(name='SiO2', data=mo.Material.SiO2_Palik, order=2) mt.add_lib(name='Air', data=mo.Material.Air, order=2) # endregion The add_lib contains three parameters name,data and order. The data calls up the property of simulation materials in the MO material library. The Order parameter determines the mesh order for the material during the simulation. As the same, we also support users to customize the material with add_nondispersionfunction. Detailed explaination about material : https://itsays-zqc.github.io/my-website/docs/test/v2_core/1Material 2.6 Waveform​ In this section, we will define the property of wave. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.15) wv_struct = wv[waveform_name] # endregion Detailed explaination about waveform: https://itsays-zqc.github.io/my-website/docs/test/v2_core/4Source#41-waveform 2.7 Create Model​ Next, we will create the structure of Y branch. # region --- 4. Structure --- st = pj.Structure(mesh_type='curve_mesh', mesh_factor=1.2, background_material=mt['SiO2']) st.add_geometry(name='in', type='Rectangle', property={'geometry': {'x': -1.5, 'x_span': 1, 'y': 0, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name=&quot;gds_file&quot;, type=&quot;gds_file&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 1, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22}, &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;splitter1&quot;, &quot;layer_name&quot;: (0, 0)}}) st.add_geometry(name='out_up', type='Rectangle', property={'geometry': {'x': 3.1, 'x_span': 0.2, 'y': 0.35, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name='out_down', type='Rectangle', property={'geometry': {'x': 3.1, 'x_span': 0.2, 'y': -0.35, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name=&quot;waveguide_up&quot;, type=&quot;BezierCurve&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22, &quot;width&quot;: 0.5, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;point_1_x&quot;: 3.2, &quot;point_1_y&quot;: 0.35, &quot;point_2_x&quot;: 4, &quot;point_2_y&quot;: 0.35, &quot;point_3_x&quot;: 4, &quot;point_3_y&quot;: 0.85, &quot;point_4_x&quot;: 5.2, &quot;point_4_y&quot;: 0.85}}) st.add_geometry(name=&quot;waveguide_down&quot;, type=&quot;BezierCurve&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22, &quot;width&quot;: 0.5, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;point_1_x&quot;: 3.2, &quot;point_1_y&quot;: -0.35, &quot;point_2_x&quot;: 4, &quot;point_2_y&quot;: -0.35, &quot;point_3_x&quot;: 4, &quot;point_3_y&quot;: -0.85, &quot;point_4_x&quot;: 5.2, &quot;point_4_y&quot;: -0.85}}) st.add_geometry(name='wg_up', type='Rectangle', property={'geometry': {'x': 5.4, 'x_span': 0.8, 'y': 0.85, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name='wg_down', type='Rectangle', property={'geometry': {'x': 5.4, 'x_span': 0.8, 'y': -0.85, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) # endregion We import the core of Y branch from the GDS file when other part is created by MO add_geometry function. The name parameter defines the structure name. The type parameter specifies the structure type. The path, cell_name, and layer_name parameters point to the GDS file and specify the relevant layers and cell names used in the layout. The geometry parameter sets the structure's coordinates. The material parameter specifies the material properties The mesh_order parameter sets the mesh order for the simulation. Detailed explaination about structure : https://itsays-zqc.github.io/my-website/docs/test/v2_core/2Structure 2.8 Boundary​ After establishing the model, we can add the simulation region in region 5 and define the simulation boundary conditions. This involves specifying the geometry of the simulation region, the boundary conditions in the xyz directions, and the other detailed parameters. # region --- 5. Boundary --- st.OBoundary(property={'geometry': {'x': 2, 'x_span': 7, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 3}, 'boundary': {'x_min': 'PML', 'x_max': 'PML', 'y_min': 'anti_symmetric', 'y_max': 'PML', 'z_min': 'PML', 'z_max': 'PML'}, 'general_pml': {'pml_same_settings': True, 'pml_layer': 6, 'pml_kappa': 2, 'pml_sigma': 0.8, 'pml_polynomial': 3, 'pml_alpha': 0, 'pml_alpha_polynomial': 1}}) # endregion Detailed explaination about boundary : https://itsays-zqc.github.io/my-website/docs/test/v2_core/3Boundary 2.9 Add Sub-mesh​ To achieve more accurate calculations of the model's modal fields, we can add a sub-mesh in region 6. # region --- 6. Sub Mesh --- st.add_mesh( name='sub_mesh', property={'general': {'dx': 0.025, 'dy': 0.025, 'dz': 0.1}, 'geometry': {'x': 2, 'x_span': 4, 'y': 0, 'y_span': 1.6, 'z': 0, 'z_span': 0.22}}) # endregion In this code segment, we use the add_mesh function to add a sub-mesh in region 6. The name parameter defines the name of the mesh. The general parameter specifies the grid accuracy in the xyz directions . The geometry parameter sets the coordinates of the sub-mesh. Detailed explaination about mesh : https://itsays-zqc.github.io/my-website/docs/test/v2_core/3Boundary#32-mesh 2.10 Source​ Then we need to establish the light source in the input waveguide, as shown in Region 7. # region --- 7. ModeSource --- src = pj.Source() src.add(name='source', type='mode_source', axis='x_forward', property={'general': {'mode_selection': 'fundamental', 'waveform': {'waveform_id_select': wv_struct}}, 'geometry': {'x': -1.2, 'x_span': 0, 'y': 0, 'y_span': 1, 'z': 0, 'z_span': 1}}) # endregion The Source function is utilized to retrieve the source manager for the current project. The type parameter specifies the type of the source and is formatted as either [&quot;mode_source&quot;] or [&quot;gaussian_source&quot;]. The name parameter represents the name assigned to the source. The axis parameter defines the axis of the source. The property parameter allows for defining specific properties associated with the source. Detailed explaination about mode source : https://itsays-zqc.github.io/my-website/docs/test/v2_core/4Source#42-mode-source 2.11 Monitor​ In Region 8, we set up the monitors. # region --- 8. Monitor --- mn = pj.Monitor() mn.add(name='Global Option', type='global_option', property={'frequency_power': { # 'sample_spacing': 'uniform', 'use_wavelength_spacing': True, # ['min_max','center_span'] 'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.15, 'frequency_points': 100}}) mn.add(name='monitor_in', type='power_monitor', property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.15, 'frequency_points': 100},}, 'geometry': {'monitor_type': '2d_x_normal', 'x': -1.19, 'x_span': 0, 'y': 0, 'y_span': 1.2, 'z': 0, 'z_span': 1.2}}) mn.add(name='monitor_out', type='power_monitor', property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.15,'frequency_points': 200},}, 'geometry': {'monitor_type': '2d_x_normal', 'x': 5.4, 'x_span': 0, 'y': 0.85, 'y_span': 1.2, 'z': 0, 'z_span': 1.2}}) mn.add(name='filed_power', type='power_monitor', property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.15, 'frequency_points': 100}, }, 'geometry': {'monitor_type': '2d_z_normal', 'x': 2, 'x_span': 7, 'y': 0, 'y_span': 3, 'z': 0.01, 'z_span': 0}}) # endregion For the global monitor, the Monitor function is utilized to retrieve the monitor manager for the current project, which allows users to access and manage various types of monitors used during simulation. The name parameter represents the name of the Global Option associated with the monitor. The type parameter defines the type of the Global Option and is formatted as a list containing one of several monitor types. The property parameter is used to define and set the relevant parameters specific to the chosen monitor type. These parameters control the monitor's behavior and data collection settings during the simulation. The power monitor is a configuration setting that allows users to specify various simulation parameters. The name parameter assigns a name to the power monitor. The type parameter defines the type of power monitor. The general parameter pertains to settings related to the frequency domain and frequency-dependent behaviors of the simulation. The geometry parameter is used to define the geometric characteristics of the simulated structure. The mode_expansion parameter involves relevant settings for mode expansion simulations. Users can customize the simulation settings by utilizing these input parameters to achieve accurate and comprehensive results based on their specific simulation requirements. Detailed explaination about monitors : https://itsays-zqc.github.io/my-website/docs/test/v2_core/5Mornitor 2.12 FDTD Simulation​ In Region 9, we add the FDTD simulation. # region --- 9. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type='FDTD', property={'general': {'simulation_time': 1000, }, 'mesh_settings': {'mesh_type': 'auto_non_uniform', 'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}, 'minimum_mesh_step_settings': {'min_mesh_step': 1e-4}}, 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-5, 'down_sample_time': 200}}, 'thread_setting': {'thread': 8} }) # endregion The Simulation manager is critical for setting up and running simulations in the current project. The name parameter allows users to assign a unique name to the simulation for identification purposes. The type parameter defines the type of the simulation. The simulation_time parameter specifies the duration of the simulation. The mesh_settings parameter enables users to configure various settings related to the simulation mesh. The mesh_accuracy parameter controls the precision of the mesh used in the simulation. The cells_per_wavelength parameter determines the wavelength precision used in the simulation. The minimum_mesh_step_settings parameter sets the minimum mesh step, allowing users to define the smallest allowable size for mesh elements. Users can tailor the simulation setup to meet their requirements by utilizing these input parameters, enabling accurate and efficient electromagnetic simulations of complex optical structures. Detailed explaination about FDTD simulation : https://itsays-zqc.github.io/my-website/docs/test/v2_core/6Simulation#63-fdtd 2.13 Schematic of Structure​ As the same, we generate the device structure of the Directional Coupler in Region 10. # region --- 10. Structure Show --- st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}00_{simu_name}', simulation_name=simu_name) # endregion In this code segment, we use the structure_show function to form a picture. The fig_type specifies the type of figure. It supports the following list selection[&quot;png&quot;, &quot;svg&quot;]. The show , which is a switch that controls whether the picture is generated or not. If you have already installed the GUI locally, you can automatically pop up the 3D structural model within the GUI using show_with=&quot;local_gui&quot;. Additionally, you can also use show_with=&quot;matplotlib&quot; to view the structure. Detailed explaination about EME simulation : https://itsays-zqc.github.io/my-website/docs/test/v2_core/7Preview#72-structure-show-and-show-3d 2.14 Run​ In the region 11 ,we can recall the simulation name to run it. # region --- 11. Run --- if run_options.run: fdtd_res = simu[simu_name].run() # endregion 2.15 Run Simulation​ Then, in Region 12, we run the simulation. We support users to calculate the simulation with GPU by resources to improve the simulation efficiency. # region --- 12. Run --- if run_options.extract: if run_options.run: # region --- mode profile --- fdtd_res.extract(data='fdtd:mode_source_mode_info', savepath=f'{plot_path}_source_modeprofile', source_name='source', attribute='E', target='intensity', mode=0, export_csv=True) # endregion # region --- x_normal --- fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}_monitor_in_abs(T)', monitor_name='monitor_in', attribute='T', target='line', plot_x='wavelength', export_csv=True) fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}_monitor_out_abs(T)', monitor_name='monitor_out', attribute='T', target='line', plot_x='wavelength', export_csv=True) fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}_filed_power_abs(T)', monitor_name='filed_power', attribute='E', target='intensity', plot_x='x', plot_y='y', real=True, imag=True, export_csv=True, show=False) return f'{plot_path}_monitor_out_abs(T).csv' # endregion # endregion The extract function allows you to extract specific simulation results and store them for further analysis. The data parameter is to decide what type/field data will be extracted. The savepath parameter specifies the save path of picture. The monitor_name parameter specifies the name of monitor which provides the data needed. The attribute parameter specifies which attribute will extracted. The plot_x parameter specifies the data of x axis. The export_csv parameter is to decide whether to export a csv. Default as False. Detailed explaination about data extraction : https://itsays-zqc.github.io/my-website/docs/test/v2_core/8Extract#811-calculate-mode-result 2.16 Switches​ In this section of the code, the simulation function is called and executed, which allows you to reset relevant parameters for more convenient parameter scanning and optimization design. We also support control switches for various functionalities at the end of the code, and you can use configuration flags(True or False). These flags can be used to turn specific functionalities on or off, making it easier to check the model and perform efficient calculations. lass RunOptions(NamedTuple): run: bool extract: bool if __name__ == '__main__': out_file_path=simulation(run_mode='local', wavelength=1.575, grids_per_lambda=25, run_options=RunOptions(run=True, extract=True)) print(out_file_path) By turning on/off the relevant functionalities, you can control the simulation process and obtain the desired results. 3.Output Results​ 1.The electric intensity profile of the input fundamental TE mode. 2.The z-normal E intensity of Y branch structure. 3.The transimission at different wavelengths. Above all,the insert loss of this Y branch device is about 0.6 dB at 1.55 micrometer wavelength. Supplement​ To view a function's definition and supported parameters or a parameter dictionary, you can right-click on its name and select &quot;Go to Definition&quot; or press &quot;Ctrl&quot; while left-clicking on its name to view its definition, showing the available parameters and their descriptions. And you can also to find the detailed explaination : https://itsays-zqc.github.io/my-website/docs/category/max-optics-sdk "},{"title":"Installation","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Installation","content":"","keywords":""},{"title":"How to Install Max-Optics GUI Software?​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#how-to-install-max-optics-gui-software","content":"Max-Optics Studio Local Passive Software Installation 1. Open the Installation Package​ Find the Setup.exe package, double-click to open the MOPassive-x.x.x.x+build.xxxxxxxx-setup installation package.  If there is a pop-up window come out, please press the “Run” button and wait to run.  Check the contents and click &quot;I Accept The Agreement&quot; item, then click &quot;Next&quot;.  2. Select Destination Location​ User can custom destination location by pressing “Browse...” button , or just use the auto-default location, then press the “Next” button.  3. Select Start Menu Folder &amp; Create a Shortcut​ In the &quot;Select Start Menu Folder&quot; window, users can either click the &quot;Next&quot; button directly or customize the location for shortcuts by clicking the &quot;Browse...&quot; button.  In the &quot;Select Additional Tasks&quot; window, users can choose to create a desktop shortcut by selecting the &quot;Create a desktop shortcut&quot; option, and then proceed by clicking the &quot;Next&quot; button. Alternatively, users can simply uncheck the option and click the &quot;Next&quot; button directly.  4. Ready to Install​ In the &quot;Ready to Install&quot; window, click the &quot;Install&quot; button to proceed with the installation. 5. Installing​ Please wait, until installation is complete.  6. Restart​ Check either the “yes, restart the computer now” or “No, I will restart the computer later” to invoke the software. Then press “Finish” button.  7. Complete​ Once the installation is complete, the user can find a shortcut to the software on their desktop.  Notes: User can double click the shortcut to invoke the software; User also can double click a .passive file to open the software automatically "},{"title":"How to Install Max-Optics SDK Software?​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#how-to-install-max-optics-sdk-software","content":"1. Installing Python.​ AIO SDK only supports Python 3.8.x. If you have Python already installed, please verify its version. If you have multiple Python versions installed, ensure that the version specified in the PATH environment variable is Python 3.8.x. If Python is not installed, follow the instructions below: ① Open the 'python-3.8.X-amd64.exe' from the trial package.  ② Choose 'Customize installation'. ③ Check the 'Add Python 3.8 to PATH' option.  Note: When customizing the installation path, ensure that the folder name in the installation path does not contain any spaces. Spaces can cause the SDK to be unable to locate the Python path (due to code syntax reasons) . We recommend using the installation path: 'D:\\Python\\Python38,' as this path aligns with the default setting path in SDK's settings.json. 2. Install VS Code​ For Python code environment, using a code editor is helpful for managing the SDK simulation script results. Here, we select the free code editor, Visual Studio Code (VSCode) , as the editor for SDK scripts. This section provides guidance on the installation process and considerations for VSCode. ① Install 'VSCodeUserSetup-x64-1.74.3.exe,' just as the default settings.  ② In the extensions, search for and install the Python plugin to enhance VSCode's support for the Python development environment.  Note that the installation of the SDK and subsequent model simulations will be done within the VSCode interface. 3. Install the SDK​ SDK Directory Structure: ├─.vscode │ settings.json │ tasks.json │ ├─ci │ requirements.txt │ └─wheels SDK dependencies.whl  .vscode：Configuration files to enable running tasks in the SDK within VSCode.ci：The requirements.txt file contains information about dependencies and their versions needed to install the SDK.wheels：This directory contains all the dependencies required to install the SDK. P.S.This directory contains all the dependencies required to install the SDK. 3.1 Placing the SDK Folder Put the SDK folder in the directory where you want to manage model scripts and simulation data. It is recommended to place it in the root directory of the D drive. 3.2 Opening the SDK Folder with VSCode (1) Click 'File' in VSCode. (2) Select 'Open Folder' from the dropdown menu. (3) Choose the 'AIO_SDK' folder. 3.3 Configuring the VSCode Environment for the SDK (1) In VSCode's file explorer, open the 'settings.json' file within the '.vscode' folder.  (2) In the editing area, set the path to the location of 'python3.8.x.exe,' which is by default 'D:\\Python\\Python38\\python.exe.'  3.4 Reasons for Creating a Python Virtual Environment A virtual environment is an isolated environment separate from the entire computer's operating system. When you install and run AIO_SDK within a virtual environment, it ensures that AIO_SDK doesn't conflict with dependencies already present in the Windows environment. Dependency conflicts can potentially prevent the SDK from functioning correctly. We have already configured a script (tasks.json) to generate a virtual environment and install AIO_SDK. However, Windows, in the interest of system security, may prevent the execution of this configuration script. Therefore, we need to modify the execution policy for Windows scripts to ensure that the subsequent steps proceed smoothly. 3.5 Modify the Execution Policy for Windows Scripts (1) Run 'Windows PowerShell' as an administrator.  (2) Enter 'Set-ExecutionPolicy RemoteSigned' and press Enter. If prompted to change the policy, type 'Y' and press Enter. At this point, the security policy for running Windows scripts has been changed.  3.6 Create the virtual environment through the 'Create PIP' task. Click on 'Terminal' and select 'Run Task' from the dropdown menu. A new menu will pop up in VSCode, and within that menu, choose 'Create PIP'.   VSCode will automatically open a terminal to install the SDK. After the installation is complete, press any key to exit.  4. Enable the Virtual Environment​ Through the previous steps, you should see the .venv_maxoptics folder in the VSCode file explorer. We need to activate the virtual environment where the SDK is installed. Here are the configuration steps:  (1) In VSCode, press F1 to bring up the menu, as shown in the image.  (2) Click 'Python: Select Interpreter' and in the new menu, select the interpreter as shown in the image. This interpreter is the virtual environment where the SDK is installed.  (3) Start a new terminal and you should see the virtual environment indicator (.venv_maxoptics) in the terminal bar, indicating the successful activation of the virtual environment.  5. How to Access the Handbook​ In VSCode, open a terminal, and the .venv_maxoptics virtual environment will be activated. You can access the handbook by entering the 'mo.sdk doc' command. This step can also serve as a test to verify the correct installation of the software.   6. Copying Examples​ In VSCode, open a terminal, and the .venv_maxoptics virtual environment will be activated. You can import simulation model examples by entering the 'mo.sdk init -n examples' command. Here, '-n' specifies the name of the target folder to copy the examples to.  At this point, a set of example script samples named 'examples' will be created in the AIO_SDK folder.  7. Run File​ In the 'examples' folder, open a .py script file for a specific example. Run the 'Run File' task in the terminal to execute the script and perform the simulation.  8. License Configuration:​ Note: Trial licenses and the passive standalone version use the same configuration. If you've already configured a passive standalone license, there's no need to repeat the process. (1) Online License Activation: ① Open the 'MaxOpticsSDK__LicenseManager_x64.exe' license management tool. ② Click 'Activate' (the first button on the upper left) . ③ Select 'Activate automatically via the internet,' and confirm. (2) Offline License Activation: ① Open the 'MaxOpticsSDK__LicenseManager_x64.exe' license management tool. ② Click 'Activate' (the first button on the upper left) .Choose 'Unable to connect to the internet, activate via offline mode' and confirm. ③ Select 'Use activation file,' change the file type to *.txt, and open the 'ZAKT5VW6LY37KNU7-pre.txt' file. ④ A dialog will appear confirming a successful license activation and prompting you to save a confirmation file. Click 'Confirm' and select any folder to save the confirmation file. "},{"title":"What to Do If You Encounter an Error During \"Create PIP\" with a Version Not Found?​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#what-to-do-if-you-encounter-an-error-during-create-pip-with-a-version-not-found","content":"If you encounter an error stating that the required version cannot be found while creating a PIP during the SDK installation： ERROR: Could not find a version that satisfies the requirement max_optics_sdk~  You should first check whether your Python version is 3.8.* as we currently only support this version. Additionally, ensure that the &quot;wheels&quot; folder contains the following three files: max_optics_local_sdk-2.3.0.4.630.2001-cp38-cp38-win_amd64.whl max_optics_sdk-2.3.0.4.630.2000-py3-none-any.whl max_optics_whale-2.3.0.4.630.2003-cp38-cp38-win_amd64.whl Finally, double-check the version information in the &quot;requirements.txt&quot; file to ensure that it matches the versions of the three files mentioned earlier. "},{"title":"The error \"Tunnel Breakoff\" occurs when you open the software for the first time after installation. What should you do?​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#the-error-tunnel-breakoff-occurs-when-you-open-the-software-for-the-first-time-after-installation-what-should-you-do","content":"You can check if the software was mistakenly installed in a Chinese directory path, if any antivirus software that does not support installation has been closed (currently Tencent Guardian and Windows Defender support MO software usage) , and if the service has been started. Then, restart your computer, reinstall the software, and check if it's installed on the C drive (some users may not have sufficient permissions on the C drive) . Finally, run it as an administrator..\\MOService\\bin\\Release\\mol-mid-pas-console.exe(中间件服务) 。 "},{"title":"How to configure and use group services?​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#how-to-configure-and-use-group-services","content":"Our Max-Optics series products utilize group authorization services to provide a secure and reliable software protection and authorization management solution. The same licensing configuration method is available for end-users. Since standalone active software products involve and utilize third-party software, you will need to separately configure the license for third-party software. Group authorization refers to deploying it within the local area network of group users, and users will need to install a dedicated group authorization service program to provide comprehensive authorization support for users within the group. After installing the relevant Max-Optics software product, the process for configuring the group service is as follows: 1、Firstly, you need to obtain the License Server IP address and port number from your company's administrator, typically in the format such as 192.168.91.67:8273. 2、In the software installation package, locate the BitAnswer user client configuration software, typically found within the BitAnswer folder.  3、Double-click the configuration software to open the configuration interface.  4、You can configure the License service address using either the &quot;自动查找&quot; or &quot;手动设置&quot; method. (1) Auto Search ① In the &quot;集团服务器列表&quot; select the corresponding IP address row. If there is no corresponding IP address, click the &quot;刷新&quot; button.  ② In the &quot;集团服务器列表&quot; select the corresponding IP address row, and then click the &quot;应用&quot; button.  ③ A prompt saying &quot;服务器设置成功&quot; will appear. Click the &quot;确定&quot; button.  ④ In the &quot;集团服务器设置工具&quot; window, click the &quot;退出&quot; button. Your configuration is now complete.  (2) Manual Settings ① In the &quot;设置集团服务器地址&quot; window, enter the IP address and port number that you obtained, then click the &quot;设置&quot; button.  ② In the &quot;Group Server Configuration Tool&quot; window, click the &quot;Exit&quot; button. Your configuration is now complete.  4、Max-Optics Studio Active Standalone Version and SDK Extra Configuration Max-Optics Studio active standalone version and SDK products require additional configuration for third-party software components. These components come with two types of license files: trial and full versions. The trial version allows multi-user access and serves as a trial version for users to evaluate before making a formal purchase. The full version, on the other hand, is restricted to a single user and binds to a unique physical machine address for usage. If you install both the Max-Optics Studio active standalone version and the SDK, the configuration of the third-party software's license only needs to be done once. (1) Configuration Method 1 First, place the license file, and then configure the environment variables. This configuration method is only applicable to trial version license files. ① Start by placing the license file in a specified directory. The path for this directory can be chosen based on your preferences. In this document, the author has set the path as shown in the following image:  ② Open the system environment variable configuration interface and create a new variable in the system variables. The variable name should be &quot;LM_LICENSE_FILE&quot; (it must be this name) , and the value of the variable should be the absolute path to the license file. Open the &quot;Search&quot; window and type &quot;environment variables&quot; to find &quot;Edit the system environment variables.&quot; Select and open this window.  Select the &quot;Advanced&quot; tab, then choose the &quot;Environment Variables&quot; button.  Click the &quot;New&quot; button.  After filling in the &quot;Variable name&quot; and &quot;Variable value,&quot; click the &quot;OK&quot; button to return to the previous screen.  After filling in the &quot;Variable name&quot; and &quot;Variable value,&quot; click the &quot;OK&quot; button to return to the previous screen.  On the interface, click the &quot;OK&quot; button to complete the setup.  (1) Configuration Method 2 Formal version license files are only applicable to Configuration Method 2, but trial version licenses can also be configured using this method. ① Check your local machine information. Run &quot;ipconfig /all&quot; in the command line to view the Windows IP configuration. Take note of two pieces of data: the hostname and the physical address of the Ethernet adapter, as you will need them in the following steps.  ② Modify the License File You need to modify the license file (*.lic) that was provided to you. The normal content should be as follows:  In the first line, modify the data according to your local machine. Replace &quot;MG-SE-limao-01&quot; with your machine's hostname, and &quot;1C697AF3CF58&quot; with your machine's physical address (do not include the hyphens when inputting) . The second line must be &quot;VENDOR COGENDA,&quot; please keep it consistent with the image. The third line must be &quot;USE_SERVER,&quot; also keep it consistent with the image. ③ Double-Click to Start the shell.bat Script Locate the directory where you have installed the third-party software (default installation path: C:\\Program Files\\Genius) . Enter the &quot;Bin&quot; folder and copy the modified license file there. Then, double-click the &quot;shell.bat&quot; located in the same directory.  ④ Enter the Activation Service Command In the startup window, enter the command: &quot;lmgrd -c license_filename.lic,&quot; where the &quot;-c&quot; option is the certificate address path for the third-party software.  After successful validation, two windows will pop up. Do not close these windows while using the third-party software.  Group authorization services support a specific number of users. When the user limit is reached, it will prompt: &quot;The number of activated machines has reached the limit, and the authorization code cannot be used on more machines.&quot; For more common issues and error messages, please visit the following URL: https://bit.bitanswer.cn/doc/?t=welcome If you encounter any issues during usage, please contact your company's administrator or Max-Optics technical support personnel: Phone: 150 6666 1688Email: sales@max-optics.com "},{"title":"Obtain Technical Support","type":0,"sectionRef":"#","url":"/my-website/docs/faq/ObtainTechnicalSupport","content":"","keywords":""},{"title":"Clearly State the Issue or Requirement:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#clearly-state-the-issue-or-requirement","content":"Describe the issue or requirement concisely. Use clear language to explain the specific support you are seeking. "},{"title":"Provide Detailed Information:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#provide-detailed-information","content":"Provide as much relevant information as possible about the issue, such as error messages, steps taken, software version, operating system, etc. This will assist the support personnel in analyzing and diagnosing the problem. "},{"title":"Include Screenshots or Log Files:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#include-screenshots-or-log-files","content":"If applicable, attach relevant screenshots or log files to supplement the problem description. These visual aids provide additional context and facilitate the identification and resolution of the issue. "},{"title":"List Attempted Solutions:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#list-attempted-solutions","content":"If you have already attempted some solutions without success, mention them in your request. Provide details of the steps you have taken and the outcomes. This will help the support team understand the efforts you have already made and avoid repetition. "},{"title":"Others:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#others","content":"If you have other suggestions for designing software features or optimizing physical modules, we look forward to talking to you. User Feedback Please enter your question and feedback below:   Thank you for your feedback! We will address your question as soon as possible. If you need further assistance, please contact our customer support team. Contact Information: Phone: 150 6666 1688Email: sales@max-optics.com "},{"title":"How to set boundary condition?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/BC","content":"","keywords":""},{"title":"1.PML​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#1pml","content":"The intensity of the light field after entering the PML will decay, which can be used to absorb the electromagnetic field at the boundary. You can set the absorption of PML through the following parameters. Number of layers of PML.Kappa Alpha and Sigma are the orders of polynomials.Increasing Kappa will enhance the absorption of evanescent waves and weaken the absorption of guided modes.Increasing Sigma will reduce reflection and increase dispersion error.Increasing the value of Alpha/Sigma improves the stability of absorption, but the absorption effect will decrease.Increasing Alpha/Sigma increases stability and reduces absorption capacity. The light on the PML interface also generates reflections, which can be reduced by extending the structure through the boundary region.For the EME solver, Max-Optics optimized PML to improve mode orthogonality, which resulted in reduced absorption of guided modes. The general PML parameters of FDTD are as follows: {&quot;pml_layer&quot;:8,&quot;pml_kappa:2,&quot;pml_sigma&quot;:0.8,&quot;pml_polynomial&quot;:3,&quot;pml_alpha&quot;:0,&quot;pml_alpha_polynomial&quot;:1}. "},{"title":"About the basic concept","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/basic concept","content":"","keywords":""},{"title":"Mode​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#mode","content":"Modes refer to the stable transmission of electromagnetic waves in a waveguide, with each mode corresponding to a characteristic solution of Maxwell's equation in the waveguide. Each mode has a stable field distribution and different modes are orthogonal to each other. "},{"title":"Propagation constant​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#propagation-constant","content":"The real part of the propagation constant represents the phase velocity, while the imaginary part represents the loss or gain. "},{"title":"Effective refractive index​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#effective-refractive-index","content":"The direction and velocity of propagation vary with wavelength, medium structure, and refractive index. The ratio of propagation constant to vacuum wave vector is defined as the effective refractive index of the propagation direction. β=neff2πλβ = n_eff \\frac{2π}{λ}β=ne​ffλ2π​ "},{"title":"Phase velocity​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#phase-velocity","content":"The propagation speed of light of a certain mode at a single frequency. Vp=cneffV_p = \\frac{c}{n_eff}Vp​=ne​ffc​ "},{"title":"Group refractive index​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#group-refractive-index","content":"A type of average refractive index formed by changes in the speed and direction of light propagation due to factors such as non-uniformity of the propagation medium and wavelength of light. ng=neff−λdndλn_g=n_eff-λ\\frac{dn}{dλ}ng​=ne​ff−λdλdn​ "},{"title":"Coupling​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#coupling","content":"When power transmission occurs within or between waveguides, it is called coupling between two modes. Two conditions need to be met: The mode overlap integral is not zero.the phase matching condition. "},{"title":"2.PEC​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#2pec","content":"The conductivity of PEC is infinite and the penetration depth is almost zero, used to reflect electromagnetic fields. It reflects almost 100% without any energy loss. In FDE/EME simulation, the default boundary condition is PEC, and it can greatly reduce simulation time. "},{"title":"3.Symmetric​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#3symmetric","content":"When there is a symmetry plane in the structure, certain field components must be zero on the symmetry plane. The use of symmetric boundary conditions can make the horizontal component of the electric field and the vertical component of the magnetic field zero. In periodic structures, using symmetric boundary conditions at the boundary where the source polarization is tangent can shorten the simulation time by half. "},{"title":"4.Anti-Symmetric​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#4anti-symmetric","content":"Similarly, using asymmetric boundary conditions can make the vertical component of the electric field and the horizontal component of the magnetic field zero. In periodic structures, asymmetric boundary conditions are used at the boundary perpendicular to the source polarization. If used together with symmetric boundary conditions, it can save four times the time. "},{"title":"What situations require strengthening the absorption of PML?​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#what-situations-require-strengthening-the-absorption-of-pml","content":"The default parameters of PML are more accurate for the simulation results of (Bragg grating, spot size converter), and parameter settings that increase guided mode absorption are needed for radiation devices. For the FDTD solver, the absorption parameters of the PML layer are consistent with the Gloden software. Grating coupler is a device with strong radiation, which requires an increase in PML during simulation_ Sigma to improve absorption capacity.Users can moderately increase PML as needed_ The number of layers, but having too many layers can greatly increase simulation time.The PML boundary is calculated in the complex domain, so the calculation time and memory are generally more than twice that of the PEC/PML boundary. "},{"title":"How to set up EME scanning?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/EME wavelength sweep","content":"","keywords":""},{"title":"EME length sweep​","type":1,"pageTitle":"How to set up EME scanning?","url":"/my-website/docs/faq/Physics/EME wavelength sweep#eme-length-sweep","content":"EME has great advantages in scanning calculation in the length direction, it does not need to repeatedly calculate the modes at the interface of the divided units, and can quickly obtain the transmitted S-matrix. Open the &quot;length sweep&quot; in the EME solver, select the length range of the scanning area, the number of scanning points, and the mode of the light source to obtain the s matrix transmitted by this mode. "},{"title":"EME wavelength sweep​","type":1,"pageTitle":"How to set up EME scanning?","url":"/my-website/docs/faq/Physics/EME wavelength sweep#eme-wavelength-sweep","content":"Due to the variation of mode distribution and effective refractive index with wavelength, wavelength scanning of EME is not suitable for scenarios with high material dispersion and mode dispersion. Taking the classic core size 500∙200 nm^2 SOI waveguide as an example, the accuracy of wavelength scanning is within 5% in the ±40 nm wavelength range. However, this result varies depending on the size, structure, and material of the waveguide, and requires users to judge and verify based on the usage scenario. In order to improve the calculation speed, this feature is disabled by default and can be opened in the settings of the solver EME with the option &quot;use wavelength sweep&quot;. "},{"title":"How to set the position of the light source and monitor?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/location","content":"How to set the position of the light source and monitor? To reduce simulation errors caused by grid accuracy, the Source and Monitor should be placed in the position of the straight waveguide. The calculation of &quot;mode source&quot; in FDTD is based on the position and size of the mode light source, so the calculated mode is suitable for stable transmission on cross-sections of the same size. If the position of the light source set by the user is in an area with structural changes, numerical errors may occur when encountering other waveguide cross-sections of different sizes without forming stable transmission due to the discretization of the Yee grid. Therefore, it is recommended that at least 3 grids around the Source be in the straight waveguide region, and the Monitor will also have the same problem when detecting mode energy. It is also recommended that at least 3 grids around the Monitor be in the straight waveguide region.","keywords":""},{"title":"How to set mesh?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/mesh","content":"","keywords":""},{"title":"1 Mesh type​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#1-mesh-type","content":"Solver\tFDE\tEME\tFDTD\tdescriptionuniform\t√\t√\t√\tThe grid size in the x, y, and z directions are the same in the structure. auto non-uniform √ The size of the non-uniform grid is determined by &quot;cells per wavelength&quot;, and the grid size is the wavelength in the structure divided by &quot;cells per wavelength&quot;. "},{"title":"1.1 Uniform​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#11-uniform","content":"The uniform type of grid is evenly distributed in the x, y, and z directions, and the step size of the grid is set by the user. "},{"title":"1.2 Auto non-uniform​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#12-auto-non-uniform","content":"Global automatic non-uniform grid distribution, with &quot;cells per wavelength&quot; determining the grid size at different positions. The grid division uses the same &quot;cells per wavelength&quot;, so the grid step size is smaller in areas with high refractive index. "},{"title":"2 Mesh type refinement​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#2-mesh-type-refinement","content":"According to the different ways in which the refractive index of materials is filled in hexahedral and rectangular grids, they can be divided into &quot;staircase&quot; and &quot;curve mesh&quot; types of grids. "},{"title":"2.1Staircase​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#21staircase","content":"When multiple materials appear in a grid, one of them will be selected as the filling material for the grid. The size of the divided grid is too large, which can easily create a stepped shape in curved structures. As shown in the figure below, the refractive index distribution of the structure is observed, and a stepped shape appears at the boundary of the curved waveguide. "},{"title":"2.2 Curve mesh​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#22-curve-mesh","content":"In the case of multiple materials in the grid, the equivalent refractive index within the grid is calculated based on the electromagnetic field equation at the boundary, and then filled into the grid. Using &quot;curve mesh&quot; can significantly improve the accuracy of calculations with the same grid accuracy. The refractive index of different materials in the &quot;staircase&quot; type of mesh varies directly at the interface, while the interface of the &quot;curve mesh&quot; material is gradient.Under the same grid size, using a &quot;curve mesh&quot; type of grid is more accurate in characterizing the structure, and the accuracy of the calculation results is significantly improved. From the following example, it can be seen that using a grid size of &quot;cells per wavelength&quot; of 15 for the &quot;curve mesh&quot; type mesh is equivalent to using a grid size of &quot;cells per wavelength&quot; of 22 for the &quot;staircase&quot; type mesh, but the simulation time is saved by four times.The “curve mesh” is applicable to FDE, EME, and FDTD solvers. "},{"title":"3 Mesh accuracy​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#3-mesh-accuracy","content":"The mesh accuracy represents the size of the mesh, and the commonly used grid accuracy is shown in the table below. Mesh Accuracy of &quot;Gloden&quot;\t1\t2\t3\t4\t5 cells per wavelength of &quot;Max-optics&quot; 6 10 14 18 22  To meet the accuracy requirements of the calculation, it is recommended to set &quot;cells per wavelength&quot; to 14 or above.If we only focus on the transmission rate, it is not necessary to set &quot;cells per wavelength&quot; above 22. Generally, the transmission rate set to 18 is within ±0.01 of the transmission rate error for higher grid accuracy.If more accurate reflectivity (-60 dB) is required, &quot;cells per wavelength&quot; should be set to be greater than 26. "},{"title":"4 Mesh factor​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#4-mesh-factor","content":"The grid growth factor is only applicable to non-uniform grids and is used to control the rate of grid size change at the junction of different sizes of grids.To ensure the accuracy of the calculation results, the change rate of the grid should not be too large, and the default value of mesh factor is 1.2. In the area where the global mesh and local mesh are connected, the gradient trend of grid size with different growth factors is as follows. It is obvious that the larger the growth factor, the faster the grid change rate in the connected areas, and the corresponding number of meshs is smaller. If the size of the local area network grid is a, the size of the global grid is b, and the grid factor is m, then there will be a grid gradient process of a, a∙m, a∙m^2, a∙m^3, ...b in the connected areas. The mesh factor cannot be too small. If the mesh factor is 1, the grid will be evenly distributed throughout the entire space without any changes in size, and the number of meshs will increase significantly. "},{"title":"What is Mode expansion monitor?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/mode expansion monitor","content":"What is Mode expansion monitor? The pattern expansion monitor, as a sub attribute of the power monitor, inherits the position, size, wavelength range, and frequency points of the power monitor. The meaning of each option in mode selection? In the user selection feature, the mode index starts from 0, and users can customize the number of monitoring modes by entering a list [0, 1, 2, 3,...]. &quot;Fundamental Mode&quot; represents the selection of the first given mode, &quot;Fundamental TE Mode&quot; represents the selection of the first TE mode, which is usually TE0 mode in the 2D waveguide section, &quot;Fundamental TM Mode&quot; represents the selection of the first TM mode, which is usually TM0 in the 2D waveguide section, and &quot;User Select&quot; represents user-defined &quot;. Frequency points can be set separately and will solve for the specified number of FDE modes. Before simulation, FDE calculations will be performed on each frequency point of the mode monitor. When is the mode extension monitor enabled? If there are too many frequency points in the mode monitor, it will increase the simulation time. If the input and output waveguides of the device are both single-mode waveguides, the distance between waveguides is relatively long, and the coupling is weak, and the device does not have polarization and mode conversion, the mode extension of the power monitor can not be enabled.In the presence of polarization, mode conversion, or overlap in the monitoring area of the power monitor in the device, it is necessary to enable mode unfolding of the power monitor to obtain more accurate simulation results.The settings for mode deployment monitoring can refer to (examples\\precision\\FDTD_HalfRing.py).","keywords":""},{"title":"What is the process of simulation?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/Simulation process","content":"","keywords":""},{"title":"FDE​","type":1,"pageTitle":"What is the process of simulation?","url":"/my-website/docs/faq/Physics/Simulation process#fde","content":"The Finite Difference Eigenmode (FDE ) is a numerical solution algorithm that discretizes the Maxwell equations and solves the constructed feature matrix. The solution process for FDE is as follows. Calculate the propagation of electromagnetic waves and the field distribution of harmonic modes with high accuracy.The calculation cost is relatively low. The mode profile of the waveguide using FDE is shown in the following figure. "},{"title":"EME​","type":1,"pageTitle":"What is the process of simulation?","url":"/my-website/docs/faq/Physics/Simulation process#eme","content":"The Eigenmode Expansion Method (EME) calculates the bidirectional transmission of interface modes in partitioned units to obtain the transfer matrix, which has significant advantages over FDTD in simulating length scanning photonic devices. Calculate the transmission characteristics of the device and quickly scan and optimize the device.Compared to FDTD methods, the treatment of nonlinearity and dispersion equivalence has certain disadvantages. Calculate the electric field distribution of silicon waveguide and silicon nitride waveguide using EME, as shown in the following figure. "},{"title":"FDTD​","type":1,"pageTitle":"What is the process of simulation?","url":"/my-website/docs/faq/Physics/Simulation process#fdtd","content":"Finite Difference Time Domain (FDTD) represents the solution of a partial differential equation as discrete points in time and space, and then uses finite difference to solve the partial differential equation.The simulation process of FDTD is as follows. No approximation was used when solving partial differential equations.By using time-domain solutions, it is convenient to observe the propagation of light.Obtain the broadband response of the device through a single calculation in the time domain. Using FDTD to calculate light field transmission, the electric field distribution in the power monitor is shown in the following figure. "},{"title":"How to set simulation time?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/Simulation time","content":"How to set simulation time? When either the maximum simulation time is reached or the energy in the simulation area is less than the convergence threshold, the simulation project will end. In order to obtain convergence results, the simulation time should be set long enough, and it is recommended that the simulation time be no less than 1000 fs. Relationship between structural dimensions and simulation time The estimated time required for simulating and calculating non resonant devices is: L𝑛_𝑔/c;For SOI devices with a 100 micron length and a group refractive index of 4.23, the simulation time should be at least 1410 fs;For SiN devices with a 100 micron length and a group refractive index of 2.01, the simulation time is at least 670fs.In general, we need the light field energy in the simulation to converge below 1e-4. In order to ensure that the energy at the end of the simulation is less than 1e-4, the simulation time should be set sufficiently large. What is the relationship between the 'step. 0.39%' printed during the simulation process and the simulation time? At the beginning of the simulation, a maximum simulation time will be estimated based on the number of grid points, simulation time, and current computer performance, corresponding to the sum of &quot;elapsed&quot; and &quot;remaining&quot; times in each row of the following figure. After each iteration, the program will calculate the current elapsed time elapsed time and the maximum required simulation time remaining time until the end of the simulation. When the simulation time is set sufficiently large, the Early shutdown condition will be triggered when the energy of light in the simulation area decreases to the convergence level, and the simulation time used is less than 100%. step = elapsed_time/(elapsed_time + remain_time) ","keywords":""},{"title":"What is the difference between Staircase and Subcell methods?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/Subcell","content":"","keywords":""},{"title":"Staircase approximation​","type":1,"pageTitle":"What is the difference between Staircase and Subcell methods?","url":"/my-website/docs/faq/Physics/Subcell#staircase-approximation","content":"The Staircase approximation simply uses the mode field of discrete points to represent the mode field of the entire element, which has high computational efficiency. When the cell undergoes discontinuous changes, it can cause non physical reflections at the interface of the cell. The Staircase approximation method is applicable to staircase waveguides, mosaic type photonic devices, and square wave modulated waveguide gratings. "},{"title":"Subcell approximation​","type":1,"pageTitle":"What is the difference between Staircase and Subcell methods?","url":"/my-website/docs/faq/Physics/Subcell#subcell-approximation","content":"The Subcell approximation calculates the mode at the interface of each cell as a first-order interpolation of adjacent cells, and can simulate continuously changing photonic structures with smaller cells.The Subcell approximation method is suitable for gradient waveguides, tapers, and sinusoidal modulated waveguide gratings. When using the Subcell method, it is important to perform convergence analysis on the number of cells in the structural change area to ensure that the number of slices is sufficient. "},{"title":"Passive Device Simulation","type":0,"sectionRef":"#","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation","content":"","keywords":""},{"title":"1. How to create a new SDK simulation project?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#1-how-to-create-a-new-sdk-simulation-project","content":"First, we need to import the SDK package to perform optical simulation calculations. import maxoptics_sdk.all as mo  Following that, as shown in the following list, create a simulation project. In this list, name represents the project's name, and location represents the server's location/run mode, which can be set to run_mode=&quot;local&quot; or run_mode=&quot;cloud&quot; at this point. # region --- Project --- pj = mo.Project(name=project_name, location=run_mode) # endregion  "},{"title":"2. How to add materials in SDK simulation?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#2-how-to-add-materials-in-sdk-simulation","content":"Next, we need to add the materials used in the simulation process, as shown in the following code. Here, name represents the material's name, data represents the material object from the material library, and order is the priority of material coverage. When structures of different materials overlap, materials with higher order values will take precedence over those with lower values. In the case of equal values, the one added later takes precedence. # region --- Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) # endregion  "},{"title":"2.1 How to add a non-dispersive material?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#21-how-to-add-a-non-dispersive-material","content":"Additionally, you can add a non-dispersive material using add_nondispersion. The data in data=[(real, imag)] represents the real and imaginary parts of the refractive index. mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=1)  "},{"title":"2.2 How to add a dispersive material?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#22-how-to-add-a-dispersive-material","content":"You can add a dispersive material using add_dispersion, as shown in the following code. data=[(wavelength, real, imag)] represents the real and imaginary parts of the refractive index at different wavelengths. You can perform fitting to obtain the refractive index of the material at different wavelengths. mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;,data=[(1.55e-06, 1.444, 0), (1.30e-06, 1.81, 0.227)], order=1)  "},{"title":"2.3 How to add an anisotropic material?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#23-how-to-add-an-anisotropic-material","content":"You can add an anisotropic material using add_anisotropy. In this case, data=[(wavelength, nx_real, nx_imag, ny_real, ny_imag, nz_real, nz_imag)] represents the anisotropic refractive index's real and imaginary parts at different wavelengths. Similarly, you can use fitting to obtain the anisotropic refractive index of the material at various wavelengths. mt = pj.Material() mt.add_anisotropy(name=&quot;LN&quot;, fitting=None, data=[(wavelength * 1e-6, 2.211, 0, 2.138, 0, 2.211, 0)], order=2 )  "},{"title":"3. How to add geometric structures in SDK simulation?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#3-how-to-add-geometric-structures-in-sdk-simulation","content":"Next, let's learn how to create a geometric structure in SDK. "},{"title":"3.1 How to add background refractive index?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#31-how-to-add-background-refractive-index","content":"Define the background refractive index in Structure as shown below. background_material represents the background material, mesh_type is the material's mesh type, which can be &quot;curve_mesh&quot; or &quot;staircase&quot;, and mesh_factor determines the maximum mesh gradient that can be generated. # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.4, background_material=mt[&quot;Air&quot;]) # endregion  "},{"title":"3.2 How to add a rectangular structure?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#32-how-to-add-a-rectangular-structure","content":"As shown in the code below, you can add a structure within the Structure function using add_geometry. To add a rectangular structure, use type='Rectangle'. Specify the material from the previously defined material types, and set the mesh_order to determine the material coverage priority, as explained earlier in the material addition section. Within the parameters of the geometry section, x/y/z represent the center coordinates of the structure in three directions, while x_span/y_span/z_span determine the width of the structure in these three directions. st.add_geometry(name=&quot;rectangle&quot;, type=&quot;Rectangle&quot;, property={&quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: size, &quot;y&quot;: space, &quot;y_span&quot;: wg_width, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, }})  "},{"title":"3.3 How to add an arc waveguide in SDK simulation?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#33-how-to-add-an-arc-waveguide-in-sdk-simulation","content":"Similarly, we can add an arc waveguide structure in SDK. In the geometry section, inner_radius and out_radius represent the inner and outer radii of the arc structure, angle specifies the bending angle (with positive and negative values indicating clockwise and counterclockwise directions, respectively), and xyz determines the center position of the structure in three directions. z_span defines the thickness of the waveguide. st.add_geometry(name=&quot;arc&quot;, type=&quot;ArcWaveguide&quot;, property={&quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;inner_radius&quot;: size-wg_width/2, &quot;outer_radius&quot;: size+wg_width/2, &quot;angle&quot;: 90, &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}})  "},{"title":"3.4 How to add a circular structure?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#34-how-to-add-a-circular-structure","content":"Next, we'll learn how to add a circular structure using the following code. In this code, radius represents the radius of the circle, and x/y denote the coordinates of the center of the circle. st.add_geometry(name=&quot;circle&quot;, type=&quot;Circle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: size, &quot;x&quot;: 4*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}})  "},{"title":"3.6 How to add a linear taper (Taper) structure?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#36-how-to-add-a-linear-taper-taper-structure","content":"To create a linear taper structure, use the add_geometry function with type=&quot;LinearTrapezoid&quot;. Specify the coordinates of the four vertices of the taper structure using point_{1,2,3,4}_x and point_{1,2,3,4}_y. x/y/z determine the 3D reference point of the taper structure, and z_span sets the thickness of the taper waveguide. st.add_geometry(name=&quot;linear_trapezoid&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size/2, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size, &quot;point_4_x&quot;: size, &quot;point_4_y&quot;: 0, &quot;x&quot;: 2*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, }})  "},{"title":"3.7 How to add a custom function-based geometric structure?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#37-how-to-add-a-custom-function-based-geometric-structure","content":"Let's take the example of a taper structure with a custom function curve. To do this, use the add_geometry function with type=&quot;AnalyticalWaveguide&quot;. In this case, equation1 represents the expression of the waveguide boundary function. The parameters x/y/z denote the center coordinates, x span/y span define the domain range, resolution sets the resolution, nonsymmetric determines if the structure is non-symmetric, tilt_location specifies the location of the tilt, and tilt_angle represents the angle of the structure. st.add_geometry(name=&quot;taper_symmetric&quot;, type=&quot;AnalyticalWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: L, &quot;y&quot;: 0, &quot;y_span&quot;: taper_width, &quot;z&quot;: 0, &quot;z_sapn&quot;: 0.22, &quot;equation1&quot;: f'{str(A)*({str(L/2)}-x)^{str(m)}+1.5, &quot;nonsymmetric&quot;: False, &quot;tilt_location&quot;: &quot;user_defined&quot;, &quot;tilt_angle&quot;: 80, &quot;user_defined&quot;: 0.5, &quot;resolutionn&quot;: 1000 }}})  "},{"title":"3.8 How to import a GDS file and create the corresponding model in SDK?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#38-how-to-import-a-gds-file-and-create-the-corresponding-model-in-sdk","content":"The following code example demonstrates how to import a GDS file and create the corresponding structure in SDK. First, you need to obtain the full file path of the GDS file (gds_file). Then, use the add_geometry function with type=&quot;gds_file&quot; to import the GDS file. The path parameter should contain the full path to the GDS file, cell_name is the name of the cell to be imported from the GDS file, layer_name specifies the layer type and data type to be imported, and material is the material associated with the structure. gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/DC.gds&quot; st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 6}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}})  During the process of modeling by importing GDS files, it's important to pay attention to the setting of the material's mesh_order to ensure that the overlapping structures are covered in the correct order. "},{"title":"4. How to set up FDE simulation in SDK?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#4-how-to-set-up-fde-simulation-in-sdk","content":""},{"title":"4.1 How to configure various parameters for FDE simulation?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#41-how-to-configure-various-parameters-for-fde-simulation","content":"Next, we will learn how to add an FDE simulation and set its simulation parameters in SDK using the Simulation function. First, you need to set the boundary conditions through OBoundary, where geometry defines the boundary geometry parameters, and boundary specifies the cross-sectional simulation boundary parameters. Next, within the simu.add section, you can set the simulation name name, simulation type type, and various simulation parameters in the property field. Within property, you can set the simulation solver type through general (with the default value as 2d_x_normal). In the mesh_settings section, you can configure mesh parameters, including setting the grid sizes in different directions using global_mesh_uniform_grid. Here are the other parameters you can configure: calculate_modes: Determines whether to calculate modes.mesh_structure: Determines whether to compute refractive index profiles.wavelength: Represents the wavelength in the frequency domain.wavelength_offset: Calculates the wavelength offset for group index computation.number_of_trial_modes: Sets the number of modes for FDE calculations.search: Specifies the mode index search method, with two options: ['max_index', 'near n'].calculate_group_index: Decides whether to compute group index.bent_waveguide: Indicates whether to calculate modes for bent waveguides.radius: Specifies the curvature radius of the waveguide.orientation: Determines the orientation of the bent waveguide. You can use frequency_analysis to compute modes at various frequencies, with parameters such as start_wavelength, stop_wavelength, and number_of_points representing the starting wavelength, ending wavelength, and the number of sampled points. # region --- Boundary --- st.OBoundary(property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': yspan_solver, 'z': 0, 'z_span': zspan_solver}, 'boundary': {'y_min': 'PEC', 'y_max': 'PEC', 'z_min': 'PEC', 'z_max': 'PEC'}, }) # endregion # region --- Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={ # 'general': {'solver_type': '2d_x_normal'}, # default is '2d_x_normal' ['2d_x_normal','2d_y_normal','2d_z_normal'] 'mesh_settings': { 'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'search': 'max_index', # ['near_n','max_index'] # 'n': 2, 'calculate_group_index': False, 'mode_removal': {'threshold': 0.02}, # 'bent_waveguide': {'bent_waveguide': False, 'radius': 1, 'orientation': 0, 'location': 'simulation_center'} }, &quot;frequency_analysis&quot;: { &quot;frequency_analysis&quot;: run_options.run_frequency_sweep, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 2.67, &quot;detailed_dispersion_calculation&quot;: False }}}) # endregion  "},{"title":"4.2 How to calculate the overlap in FDE simulation?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#42-how-to-calculate-the-overlap-in-fde-simulation","content":"Overlap calculations in FDE simulation can be performed by utilizing the following code to calculate the overlap between the mode light and a Gaussian light source, as illustrated in the figure below. if run_options.run: fde_res = simu[simu_name].run() if run_options.run_overlap: if run_options.run_beam: beam_res = simu[simu_name].run_fde_beam_and_extract( property={ &quot;define_gaussian_beam_by&quot;: &quot;waist_size_and_position&quot;, # [waist_size_and_position,beam_size_and_divergence], &quot;waist_radius&quot;: 10, &quot;distance_from_waist&quot;: 0, &quot;refractive_index&quot;: 1, &quot;theta&quot;: 0, &quot;phi&quot;: 0, &quot;polarization_angle&quot;: 0, &quot;sample_span&quot;: 10, &quot;sample_resolution&quot;: 200}, savepath=plot_path + 'beam_heatmap') overlap_res = simu[simu_name].run_fde_overlap_and_extract( property={&quot;add_global_mode&quot;: {&quot;task_path&quot;: beam_res.task_path, &quot;mode&quot;: 0}, &quot;mode&quot;: 0, &quot;optimize_position&quot;: True}, export_csv=True, savepath=plot_path + 'overlap') if not run_options.run_beam: overlap_res = simu[simu_name].run_fde_overlap_and_extract( property={&quot;add_global_mode&quot;: {&quot;mode&quot;: 0}, &quot;mode&quot;: 0}, export_csv=True, savepath=plot_path + 'overlap')  "},{"title":"4.3 How to view the refractive index profile in the FDE/FDTD/EME modules?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#43-how-to-view-the-refractive-index-profile-in-the-fdefdtdeme-modules","content":"As demonstrated in the code below, you can visualize the refractive index profile of a device's cross-section using the run_index simulation. First, assume that you want to calculate the refractive index profile on the x-direction cross-section of the device. Set the position of the cross-section along the x-axis by specifying x=0 and setting x_span=0. Then, configure the center coordinates y/z and the dimensions y_span/z_span for the cross-sectional refractive index profile calculation area. The setup for calculating the refractive index profile in the y/z-direction cross-section is analogous. simu[simu_name].run_index(name=f'{simu_name}_x_0', savepath=f'{plot_path}{k}IndexPreview_x=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 2}})  "},{"title":"4.4 How to retrieve simulation data in the FDE module of SDK?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#44-how-to-retrieve-simulation-data-in-the-fde-module-of-sdk","content":"To obtain simulation data in the FDE module of SDK, you can first use result_fde.extract with data='calculate_modes' to retrieve simulation mode fields, which can be saved in the savepath directory. You can choose to export the mode field data as a CSV file by using export_csv. Set the attribute, mode, real, and imag parameters to extract the specific mode-related data you need. When using the frequency scan feature in the FDE module, you can extract data by specifying data='frequency_analysis'. As shown in the code, you can retrieve various components such as &quot;neff,&quot; &quot;loss,&quot; &quot;group_index,&quot; &quot;polarization,&quot; and more. # region --- See Results --- if run_options.extract: # region --- calculate_modes --- if run_options.run: k = kL[2] res = result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_neff_table', export_csv=True) print(res.to_string(index=False)) for m in range(len(res)): k = kL[3] result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_mode{m}', attribute='E', mode=m, real=True, imag=True, **export_options, show=False) # endregion if run_options.run_frequency_sweep: attr_selections: List[Literal[&quot;neff&quot;, &quot;loss&quot;, &quot;group_index&quot;, &quot;polarization&quot;]] = [&quot;neff&quot;, &quot;loss&quot;, &quot;group_index&quot;, &quot;polarization&quot;] for i, a in enumerate(attr_selections): k = kL[4] result_fde.extract(data=&quot;frequency_analysis&quot;, savepath=f'{plot_path}{k}_freq_sweep_{a}}', attribute=&quot;a&quot;, real=True, imag=True, export_csv=True, export_mat=True, show=False) # endregion  "},{"title":"5. How to set up EME simulation in SDK?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#5-how-to-set-up-eme-simulation-in-sdk","content":""},{"title":"5.1 How to configure boundary conditions and ports in EME simulation?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#51-how-to-configure-boundary-conditions-and-ports-in-eme-simulation","content":"To begin with, you need to define the boundary conditions using OBoundary. Then, you can set the geometric dimensions of the boundaries with geometry and configure the boundary parameters for each dimension with boundary. Next, you should configure the EME ports using Port. You can add a new port using add. Specify the port_location for the port's location. You can choose the mode for this port through mode_selection, such as fundamental_TE or fundamental_TM. Additionally, you can select user_select to define a custom mode for the port by setting mode_index to a positive integer value. Use use_full_simulation_span to determine whether the full simulation span should be used. Specify the offset to set the port's offset relative to the simulation boundaries, and set number_of_trial_modes for EME mode solving. # region --- Boundary --- st.OBoundary(property={'geometry': {'x': 0, 'x_span': 2, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 3}, 'boundary': {'y_min': 'PEC', 'y_max': 'PEC', 'z_min': 'PEC', 'z_max': 'PEC'} }) # region --- Port --- pjp = pj.Port(property={'source_port': 'eme_in'}) # region --- eme_in --- pjp.add(name='eme_in', type='eme_port', property={'geometry': {'port_location': 'left', # 'use_full_simulation_span': True, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 3}, 'eme_port': { 'general': {'mode_selection': 'fundamental_TE', # 'mode_index': 0, 'search': 'max_index' }, 'advanced': {'offset': 0, 'number_of_trial_modes': number_of_modes, # 'mode_removal': {'is_used': False, 'threshold': 0.01} }}}) # endregion # region --- eme_out --- pjp.add(name='eme_out', type='eme_port', property={'geometry': {'port_location': 'right', # 'use_full_simulation_span': True, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 3}, 'eme_port': { 'general': {'mode_selection': 'fundamental_TE', # 'mode_index': 0, 'search': 'max_index' }, 'advanced': {'offset': 0, 'number_of_trial_modes': number_of_modes, # 'mode_removal': {'is_used': False, 'threshold': 0.01} }}}) # endregion # endregion  "},{"title":"5.2 How to add a profile monitor in EME simulation?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#52-how-to-add-a-profile-monitor-in-eme-simulation","content":"As shown in the code below, you can add a new monitor to your EME simulation. Use type='profile_monitor' to specify the type of monitor you want to add. In the property section, you can configure various parameters for the monitor. For example, set monitor_type to determine the direction of the monitor. Define the coordinates and dimensions of the monitor using x/y/z and x_span/y_span/z_span, with the normal span width set to zero. It's important to note that the monitor region must be smaller than or equal to the simulation region's size. For XY-plane profile monitors, it's common to set the monitoring region's dimensions to be the same as the simulation region. The setup for profile monitors in FDTD is the same as in EME. # region --- Monitor --- mn = pj.Monitor() mn.add(name='x_normal', type='profile_monitor', property={'geometry': {'monitor_type': '2d_x_normal', # 'x_resolution': 100, 'x': 0.9, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 3}}) # endregion  "},{"title":"5.3 How to configure parameters for EME simulation?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#53-how-to-configure-parameters-for-eme-simulation","content":"Next, we will learn how to set the parameters for EME simulation within the code below. Under the general parameters, you can define the wavelength for the EME simulation wavelength. Following that, you can define the EME simulation cells using cell_group_definition. Within this section, span represents the length of each cell, cell_number specifies how many cells the length should be evenly divided into, number_of_modes determines the number of modes to be solved during the calculation, and sub_cell_method determines the method for calculating the S-matrix between cells. The transverse_mesh_setting section allows you to configure the transverse mesh settings. Under eme_analysis, you can set eme_propagate to determine whether to calculate EME propagation, propagation_sweep specifies whether to perform EME length sweeps, and wavelength_sweep determines whether to conduct EME wavelength sweeps. # region --- Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type='EME', property={ 'general': {'wavelength': wavelength, 'wavelength_offset': 0.0003 }, 'eme_setup': {'cell_geometry': { 'cell_group_definition': [ {'span': 2, 'cell_number': cell_number, 'number_of_modes': number_of_modes, 'sc': 'sub_cell'}]}}, 'transverse_mesh_setting': {'global_mesh_uniform_grid': {'dy': grid, 'dz': grid} }, 'eme_analysis': { 'eme_propagate': run_options.run, 'propagation_sweep': {'propagation_sweep': run_options.run_length_sweep, 'parameter': 'group_span_1', 'start': 0, 'stop': 5, 'number_of_points': 6}, 'wavelength_sweep': {'wavelength_sweep': run_options.run_wavelength_sweep, 'start': wavelength - 0.5, 'stop': wavelength + 0.5, 'number_of_wavelength_points': 3} }}) # endregion  "},{"title":"5.4 How to set up a preview of EME simulation structure images?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#54-how-to-set-up-a-preview-of-eme-simulation-structure-images","content":"You can preview the EME simulation structure and images using structure_show. In the example code below, the parameter fig_type determines the image format, typically &quot;png.&quot; Use show to specify whether you want to generate images. Set savepath for the path where the result images will be saved, and define simulation_name for the image's name. You can use celldisplay to control whether cells are displayed in the image, and xyratio adjusts the aspect ratio between the x and y coordinates in the image, with the default value being (1,1). # region --- Structure Show --- st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}{kL[0]}{simu_name}', simulation_name=simu_name, celldisplay=True, xyratio=(1, 1)) # simu[simu_name].show3d(show_with=&quot;local_gui&quot;) # endregion  "},{"title":"5.5 How to obtain EME port mode results?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#55-how-to-obtain-eme-port-mode-results","content":"You can retrieve the results of your EME simulation by using eme_res.extract. In the example code below, you can extract the port mode information. Set data='eme_propagate:port_mode_info' to specify that you want to retrieve EME port mode results. Use save_path to specify the data saving path, and define attribute to specify the data content you wish to extract. plot_x and plot_y determine the x and y coordinates for line plots or heat maps. real and imag control the output data. If both are set to False, the program will result in an error, &quot;real and imag are both false,&quot; and won't output any results. If both are set to True, the output values will be in absolute form. If one of them is set to True, it will output either the real or imaginary part of the data. Use show to control whether to display the images, and export_csv determines whether to save the data as a CSV file. for port_name in ['eme_in', 'eme_out']: res = eme_res.extract(data='eme_propagate:port_mesh_structure', savepath=f'{plot_path} {kL[3]}_eme_structure_{port_name}', port_name=port_name, target='intensity', attribute=&quot;E&quot;, # plot_x='y', plot_y='z', real=True, imag=True, # export_csv=False, show=False )  "},{"title":"5.6 How to obtain mode field plots for EME/FDTD?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#56-how-to-obtain-mode-field-plots-for-emefdtd","content":"Similarly, you can use eme_res.extract to retrieve simulation results. In the example code below, you can set data='eme_propagate:monitor' to specify that you want to obtain monitor results. Define the save_path for data storage and use the attribute parameter to specify the data to be extracted. plot_x and plot_y control the x and y-axis coordinates for line or heatmap plots. Use real and imag to determine how the output data should be handled: when both are False, the program will raise an error with &quot;real and imag are both false&quot;; when both are True, the results will be taken as the absolute value; if one is True, either the real or imaginary part will be output. show controls whether images are displayed, and export_csv determines if data should be saved as a CSV file. eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, # plot_x='y', plot_y='z', # real=True, imag=True, # export_csv=False, show=False )  "},{"title":"5.7 How to perform EME length sweeps?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#57-how-to-perform-eme-length-sweeps","content":"As demonstrated in the code below, you can generate N x N S-parameter matrix length sweep plots using data=&quot;propagation_sweep:sweep&quot;, where N represents the number of ports. # region --- EME Propagation Sweep Results --- if run_options.run_length_sweep: eme_res.extract(data=&quot;propagation_sweep:sweep&quot;, savepath=plot_path + &quot;10_length_sweep&quot;, export_csv=True) # endregion  "},{"title":"5.8 How to perform EME wavelength sweeps?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#58-how-to-perform-eme-wavelength-sweeps","content":"As shown in the code below, you can generate N x N S-parameter matrix wavelength sweep plots using data=&quot;wavelength_sweep:sweep&quot;, where N represents the number of ports. # region --- EME Wavelength Sweep Results --- if run_options.run_wavelength_sweep: eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) # endregion  "},{"title":"5.9 During EME simulations, is overlap recalculated when wavelength scans are repeated?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#59-during-eme-simulations-is-overlap-recalculated-when-wavelength-scans-are-repeated","content":"During EME simulations, when performing wavelength sweeps, the workflow involves first computing all the modes within the cells, and then during the sweep, calculating overlap and normalization as needed. If you repeat wavelength scans, there is no need to recalculate overlap. The program will perform the overlap calculation only once. "},{"title":"6. How to configure FDTD simulations in SDK?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#6-how-to-configure-fdtd-simulations-in-sdk","content":""},{"title":"6.1 How to set the wavelength for FDTD simulations?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#61-how-to-set-the-wavelength-for-fdtd-simulations","content":"Waveform supports defining wavelength, wavelength span, and related parameters. It includes common communication wavelengths like 1550 nm and 1310 nm, as well as visible light wavelengths. The name is the waveform's name, wavelength_center is the central wavelength, and wavelength_span is the bandwidth. # region --- Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1) wv_struct = wv[waveform_name] # endregion  "},{"title":"6.2 How to set up light sources for FDTD simulations?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#62-how-to-set-up-light-sources-for-fdtd-simulations","content":"You can configure light sources for FDTD simulations using the source function, as shown in the code below. In this setup, the type specifies the source type, commonly using mode sources in waveguides and Gaussian sources in free space. The axis determines the reference axis for the light source, with options including x_forward, y_forward, and z_forward. You can select specific modes using mode_selection and mode_index, and choose a specific waveform with waveform. The geometry parameter defines the geometric dimensions of the light source. src = pj.Source() src.add(name='source', type='mode_source', axis='x_forward', property={'general': { # 'amplitude': 1, 'phase': 0, 'mode_index': 0, 'rotations': {'theta': 0, 'phi': 0, 'rotation_offset': 0} 'mode_selection': 'user_select', 'waveform': {'waveform_id_select': wv_struct} }, 'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}})  "},{"title":"6.3 How to configure monitors in FDTD simulations?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#63-how-to-configure-monitors-in-fdtd-simulations","content":"Let's briefly introduce the setup of FDTD monitors, including global monitors, power monitors, and mode expansion monitors. As shown in the code below, you can use type='global_option' to select a global monitor. Set wavelength_center to specify the center wavelength for the monitor, wavelength_span for the wavelength range, and frequency_points to determine the number of points monitored within that wavelength range. mn = pj.Monitor() mn.add(name='Global Option', type='global_option', property={'frequency_power': { # 'sample_spacing': 'uniform', 'use_wavelength_spacing': True, # ['min_max','center_span'] 'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.1, }})  As shown in the following code, you can set up power monitors and mode expansion monitors in FDTD simulations using the type='power_monitor'. The name parameter specifies the monitor's name. In the property section, you can configure various monitor parameters, including wavelength-related settings such as wavelength_center, wavelength_span, and frequency_points. The geometry section allows you to set the monitor's orientation, position, and dimensions with parameters such as monitor_type, x/y/z, and x_span/y_span/z_span. mn.add(name='through', type='power_monitor', property={'general': {'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}, }, 'geometry': {'monitor_type': '2d_x_normal', 'x': ports['op_1']['position'][0], 'x_span': 0, 'y': ports['op_1']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'mode_expansion': {&quot;enable&quot;: True, 'direction': 'positive', 'mode_calculation': { 'mode_selection': 'user_select', 'mode_index': [0, 1, 2, 3], 'override_global_monitor_setting': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}}}})  "},{"title":"6.4 How to configure Port-related parameters in FDTD?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#64-how-to-configure-port-related-parameters-in-fdtd","content":"You can set the parameters related to ports in FDTD simulations as demonstrated in the code below. The waveform_id specifies the input wavelength, and source_port determines the input port. Then, using the add method, you can add the corresponding port with type='fdtd_port', providing a name for the port. In the property section, you can configure its relevant parameters, and in the geometry section, you can set the port's position and dimensions. The modal_properties parameter allows you to specify the properties of the input light, including inject_axis for the light's injection axis, direction for the direction of the incident light, and mode_selection for selecting the light mode. pt = pj.Port(property={'waveform_id': wv_struct, 'source_port': 'port_left'}) if run_options.matrix_sweep: pt.add(name='port_left', type='fdtd_port', property={'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'forward', 'mode_selection': 'fundamental', }}}) pt.add(name='port_right', type='fdtd_port', property={'geometry': {'x': ports['op_1']['position'][0], 'x_span': 0, 'y': ports['op_1']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'backward', 'mode_selection': 'fundamental', }}})  "},{"title":"6.5 How to extract relevant results from FDTD simulations?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#65-how-to-extract-relevant-results-from-fdtd-simulations","content":"As shown in the following code, you can specify the savepath for saving the results. Use target='line' for line plots or target='intensity' for intensity plots. The attribute parameter specifies the parameters to be extracted, and wavelength is used to specify the wavelength. To extract the mode field at a specific wavelength from a power monitor: fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[3]}_monitorT_modeprofile_fdtd', monitor_name='through', target='intensity', plot_x='y', plot_y='z', attribute='E', wavelength=f'{wavelength}', real=True, imag=False, export_csv=True, show=False)  Extracting the transmittance at different wavelengths from a power monitor: fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[7]}_RlVsLambda_power', monitor_name='reflection', target='line', plot_x='wavelength', attribute='T', real=True, imag=False, export_csv=True, export_mat=True, show=False)  Extracting the response of a mode expansion monitor to a specific mode from a power monitor: fdtd_res.extract(data='fdtd:mode_expansion', savepath=f'{plot_path}{kL[5]}_TransVsLambda_mode=0', monitor_name='through', target='line', plot_x='wavelength', mode=0, attribute='T_forward', real=True, imag=True, export_csv=True, export_mat=True, show=False)  Extracting the S-matrix results from FDTD simulations: smatrix_res.extract(data='smatrix_sweep', savepath=f'{plot_path}{kL[8]}_smatrix_sweep', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"6.6 Why does the S-matrix in FDTD simulation sometimes exceed 1?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#66-why-does-the-s-matrix-in-fdtd-simulation-sometimes-exceed-1","content":"In FDTD simulations, the presence of a light source in the simulation region can lead to incorrect S-matrix results, such as some port responses exceeding 1. To ensure accurate S-matrix calculations, it's essential to make sure that there are no light sources within the simulation region. "},{"title":"曼光介绍","type":0,"sectionRef":"#","url":"/my-website/docs/intro","content":"曼光介绍","keywords":""},{"title":"Active Device Simulation","type":0,"sectionRef":"#","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation","content":"","keywords":""},{"title":"1. How to perform an active device simulation​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#1-how-to-perform-an-active-device-simulation","content":"Follow the steps below to perform an electrical simulation Create a simulation projectAdd materials and modify the parametersAdd structures and specify the materialAdd dopingAdd electrodesAdd local mesh, surface recombination, electrical monitorsAdd an OEDevice solver, including simulation region, solver mode, generation rate, and convergence control settingsRun solverExtract results  Note: If optical simulation is still required, after adding materials, you need to bind optical material properties to each material and add other optical simulation-related settings.For electrical simulation, materials, structures, electrode settings, and an OEDevice solver are essential. Doping, local mesh, surface recombination, and electrical monitors can be set as needed.  "},{"title":"2. How to set up doping​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#2-how-to-set-up-doping","content":"Doping is added and set up through the add_doping function. The format of the function is st.add_doping(name, type, property)  add_doping() parameters: name--Doping nametype--Doping type. Options are &quot;n&quot;, &quot;p&quot; and &quot;file&quot;. property--Other properties  "},{"title":"2.1 Function doping​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#21-function-doping","content":"When type is set to &quot;n&quot; or &quot;p&quot;, function doping is applied. In this case, type also means the doping species, with &quot;n&quot; for donor and &quot;p&quot; for acceptor.  Property list of function doping: \tdefault\ttype\tnotesgeometry.x float geometry.x_span float geometry.y float geometry.y_span float geometry.z float geometry.z_span float geometry.x_min float geometry.x_max float geometry.y_min float geometry.y_max float geometry.z_min float geometry.z_max float general.distribution_function str\tSelections are ['constant', 'gaussian'] general.concentration float general.source_face str\tAvailable when distribution_function is 'gaussian' general.junction_width float\tAvailable when distribution_function is 'gaussian' general.ref_concentration float\tAvailable when distribution_function is 'gaussian' volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' Description: geometry--Set the geometry parameters of doping box general--Set the distribution function, concentration and so on distribution_function: When it's set to &quot;constant&quot;, constant doping is applied and only concentration is requiredWhen it's set to &quot;gaussian&quot;, Gaussian function doping is applied, and concentration, ref_concentration, junction_width, source_face are required concentration--Concentration in the non-diffusion arearef_concentration--Concentration on the edge of diffusion area (edge of doping box)junction_width--Diffusion junction widthsource_face--The doping source face. Options are &quot;lower_x&quot;, &quot;lower_y&quot;, &quot;lower_z&quot;, &quot;upper_x&quot;, &quot;upper_y&quot; or &quot;upper_z&quot;. &quot;lower_x&quot; means the source face is x=x_min. Similarly for the rest. There is no diffusion area on the edge of source face. As for the other edges, there is a diffusion area respectively within the doping box. volume--Set a list of regions or materials to be doped volume_type:When it's set to &quot;all&quot;(by default)，the doping is applied to all the (semiconductor) structures, restricted by the doping boxWhen it's set to &quot;material&quot;, material_list is required, which means the doping is applied to the structures of the specified materials and restricted by the doping boxWhen it's set to &quot;region&quot;, region_list is required, which means the doping is applied to the specified structures and restricted by the doping box  Gaussian doping explanation​  Fig 1. Gaussian doping As shown above, for Gaussian doping, there is a partition of constant doping profile in the doping box, and the constant concentration is the value of concentration. The width from the edge of constant area to the edge of doping box is junction_width. Concentration on the edge of doping box is the value of ref_concentration. (Note: There is no junction at the edge of source face.)  Example for function doping​ st.add_doping(name=&quot;p_constant&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 1, &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: 1e16}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat1&quot;], mt[&quot;mat2&quot;]]}}) st.add_doping(name=&quot;n_diffusion&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 1, &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: 0.1, &quot;concentration&quot;: 1e18, &quot;ref_concentration&quot;: 1e6}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;region&quot;, &quot;region_list&quot;: [&quot;Structure1&quot;, &quot;Structure2&quot;]}})   "},{"title":"2.2 Imported doping​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#22-imported-doping","content":"When type is set to &quot;file&quot;, doping is imported from a file.  Property list for imported doping: \tdefault\ttype\tnotesgeneral.format str\tSelections are ['DOP'] general.file_path str general.species str\tSelections are ['n', 'p'] volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' Description: general: format--Set the format of doping file. Only &quot;DOP&quot; is supported currently When it's set to &quot;DOP&quot;, the doping file is a text file that stores a doping profile in rectangular grid. There are three columns in the file, which are the first dimension coordinate [um], the second dimension coordinate [um] and the doping concentration [cm^-3] respectively. Doping concentration should be non-negative. file_path--The absolute path of the doping filespecies--Set the doping species. Option are &quot;n&quot; and &quot;p&quot;, with &quot;n&quot; for donor and &quot;p&quot; for acceptor. volume--Set a list of regions or materials to be doped, which is exactly the same as the case of function doping.  Example for imported doping​ st.add_doping(name=&quot;p_imported&quot;, type=&quot;file&quot;, property={ &quot;general&quot;: {&quot;format&quot;: &quot;DOP&quot;, &quot;file_path&quot;: p_file_path, &quot;species&quot;: &quot;p&quot;}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat1&quot;], mt[&quot;mat2&quot;]]}})   "},{"title":"3. How to set up electrical boundary condition​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#3-how-to-set-up-electrical-boundary-condition","content":"Electrodes and electrical boundary conditions are set up through the add_electrode function. The format of the function is st.add_electrode(name, property)  add_electrode() parameters: name--Electrode nameproperty--Other properties  There are two different type of electrical boundary conditions, which are &quot;steady_state&quot;and &quot;transient&quot;, specified by the property bc_mode.  "},{"title":"3.1 Steady state boundary condition​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#31-steady-state-boundary-condition","content":"When the property bc_mode is set to &quot;steady_state&quot;, the steady state boundary condition is applied.  Property list of steady state boundary condition: \tdefault\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode\tsteady_state\tstring\tSelections are ['steady_state']. apply_AC_small_signal\tnone\tstring\tSelections are ['none', 'All']. sweep_type\tsingle\tstring\tSelections are ['single', 'range', 'value']. voltage\t0\tfloat\tAvailable when sweep_type is 'single' range_start\t0\tfloat\tAvailable when sweep_type is 'range' range_stop\t1\tfloat\tAvailable when sweep_type is 'range' range_interval\t1\tfloat\tAvailable when sweep_type is 'range' range_num_points\t2\tinteger\tAvailable when sweep_type is 'range' []sweep_value_table.index integer\tAvailable when sweep_type is 'value'. []sweep_value_table.number float\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t Description: surface_type--Type of the surface to be set as an electrode. Currently only &quot;solid&quot; is supported, meaning that all the surfaces of a structure are selected solid--Name of the structure to be set as an electrode. Available when surface_type is set to &quot;solid&quot; force_ohmic--Whether the electrode is ohmic, default to be True. Currently only ohmic contact is supported, so force_ohmic can't be set to False bc_mode--Set to &quot;steady_state&quot; for steady state boundary condition apply_AC_small_signal: When it's set to &quot;none&quot; (as default), no AC small signal is applied at each sweeping voltageWhen it's set to &quot;All&quot;, the AC small signal is applied after steady state simulation at each sweeping voltage sweep_type--Type of sweeping voltage. Options are &quot;single&quot;, &quot;range&quot; and &quot;value&quot; When it's set to &quot;single&quot;, voltage is requiredWhen it's set to &quot;range&quot;, range_start, range_stop, and range_interval or range_num_points are requiredWhen it's set to &quot;value&quot;, sweep_value_table is required voltage--Set the value of the single voltage range_start--Set the start value of the voltage range range_stop--Set the stop value of the voltage range range_interval--Set the voltage interval of the voltage range range_num_points--Set the number of points of the voltage range sweep_value_table--Table of voltage values. It's a list, whose item is a dictionay. In each of its item: index--Set the index of the voltage valuenumber--Set the value of the voltage  Example for single voltage​ st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   Example for voltage range​ st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: 0, &quot;range_stop&quot;: 1, &quot;range_interval&quot;: 0.5, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   Example for voltage table​ st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;value&quot;, &quot;sweep_value_table&quot;: [{&quot;index&quot;: 0, &quot;number&quot;: 0}, {&quot;index&quot;: 1, &quot;number&quot;: 0.5}, {&quot;index&quot;: 2, &quot;number&quot;: 1}]})   "},{"title":"3.2 Transient boundary condition​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#32-transient-boundary-condition","content":"When the property bc_mode is set to &quot;transient&quot;, the transient boundary condition is applied.  Property list of transient boundary condition: \tdefault\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode string\tSelections are ['transient']. voltage\t0\tfloat []time_table.time_start float []time_table.time_stop float []time_table.initial_step float []time_table.max_step float []time_table.optical.enabled\t0\tinteger\tSelections are [0, 1] []time_table.optical.envelop integer\tSelections are [0] []time_table.optical.source_fraction float surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t Description: surface_type, solid, force_ohmic--The same as the one in steady state conditionbc_mode--Set to &quot;transient&quot; for transient boundary condition. Then the time dependence of the optical generation rate can be set at this electrodevoltage--Set the voltage that is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation.v_step_max--Set the max step of the voltage from the equilibrium state to steady state at the bias of voltage.time_table--Set the time dependence of optical generation rate. It's a list, whose item is a dictionary. In each of its item: time_start--Set the start time point of the range. The value of 0 represents the steady state of the earlier simulation.time_stop--Set the stop time point of the rangeinitial_step--Set the initial time step of the rangemax_step--Set the max time step of the rangeoptical--Set the optical generation rate during the time range enabled--Whether to apply optical generation rate during the time range. The value of 1 means True, and 0 means Falseenvelop--The envelop of the scaling factor of the light power during the time range. When it's set to 0, the envelop is uniformsource_fraction--When envelop is set to0, this value is the scaling factor of the light power during the time range  Example for transient boundary condition​ st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: 1, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 50e-12, &quot;initial_step&quot;: 1e-15, &quot;max_step&quot;: 1e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}, {&quot;time_start&quot;: 50e-12, &quot;time_stop&quot;: 600e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}]})   "},{"title":"3.3 Set up the appropriate boundary condition​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#33-set-up-the-appropriate-boundary-condition","content":"When solving the frequency response of optical signal for the device, transient simulation should be performed. In this case, the bc_mode of the corresponding electrode should be set to &quot;transient&quot;, and the solver_mode of OEDevice solver should be set to &quot;transient&quot;, too. In most of other cases, steady state or SSAC simulation is needed, the bc_mode of electrodes should be &quot;steady_state&quot;. When solving capacitance and resistance with respect to frequency, SSAC simulation is required. The solver_mode of OEDevice solver should be set to &quot;SSAC&quot;, and the apply_AC_small_signal of the corresponding electrode should be set to &quot;All&quot;.When running steady state simulation, just set the solver_mode of OEDevice solver to &quot;steady_state&quot;.  "},{"title":"4. How to set up surface recombination​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#4-how-to-set-up-surface-recombination","content":"Surface recombination is added and set up through add_surface_recombination function. The format of the function is st.add_surface_recombination(name, property)  add_surface_recombination() parameters: name--Name of the surface recombinationproperty--Other properties  Property list of surface recombination: \tdefault\ttype\tnotessurface_type\tdomain_domain\tstring\tSelections are ['domain_domain', 'material_material']. interface_type\tnull\tstring\tSelections are ['null', 'InsulatorInterface', 'HomoJunction', 'HeteroJunction', 'MetalOhmicInterface', 'SolderPad']. infinite_recombination\ttrue\tbool\tAvailable when interface_type is 'MetalOhmicInterface' velocity_hole\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' velocity_electron\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' domain_1 string\tAvailable when surface_type is 'domain_domain' domain_2 string\tAvailable when surface_type is 'domain_domain' material_1 material\tAvailable when surface_type is 'material_material' material_2 material\tAvailable when surface_type is 'material_material' Description: surface_type--Type of selection for the surface When surface_type is &quot;domain_domain&quot;, the surface is the interface between two structures When surface_type is &quot;material_material&quot;`, the surface is the interface between two materials interface_type--Type of contact for the surface &quot;InsulatorInterface&quot;--Semiconductor-insulator interface&quot;HomoJunction&quot;--Homogeneous semiconductor-semiconductor interface&quot;HeteroJunction&quot;--Heterogeneous semiconductor-semiconductor interface&quot;MetalOhmicInterface&quot;--Semiconductor-conductor interface&quot;SolderPad&quot;--Conductor-insulator interface infinite_recombination--Only available when interface_type is &quot;MetalOhmicInterface&quot;. The surface recombination velocity of holes and electrons will be available when infinite_recombination is Falsevelocity_hole, velocity_electron--Surface recombination velocity of holes and electrons. Available when interface_type is &quot;MetalOhmicInterface&quot; or &quot;InsulatorInterface&quot;domain_1, domain_2--Names of the two structures at the interface. They must be set explicitly when surface_type is &quot;domain_domain&quot;material_1, material_2--The two materials at the interface. They must be set explicitly when surface_type is &quot;material_material&quot;  "},{"title":"5. How to simulate 3dB bandwidth of photodetector​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#5-how-to-simulate-3db-bandwidth-of-photodetector","content":"The OEDevice solver doesn’t support simulations for the small signal of optical generation currently. Therefore, the frequency response of photo detector can only be obtained by transient simulation.  "},{"title":"5.1 Introduction for obtaining frequency response through transient simulation​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#51-introduction-for-obtaining-frequency-response-through-transient-simulation","content":"First, obtain current-time (I-t) curve after applying optical generation in transient simulation. And then postprocess the I-t curve to get the frequency response. Note: Please take the chapter “3.2 Transient boundary condition” above as reference for transient simulation setup;Optical generation is applied at one time point, and keeps until the photo current goes stable. That is, the dependency of optical generation rate on time is a step function and the I-t curve is the step response of photo current;The transient time ranges from the start of optical generation applying, to the time the photo current goes stable;At the beginning when optical generation is turned on, the photo current ramps up very rapidly, so small time step is needed during the period. When photo current varies slowly, the time step can be increased appropriately to shorten the simulation time;The high field mobility model of the material can be applied for a more accurate result of bandwidth;It is often desirable to set up the convergence control parameters to enhance the convergence of transient simulations.  "},{"title":"5.2 Comparison between transient simulation and small signal simulation​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#52-comparison-between-transient-simulation-and-small-signal-simulation","content":"Transient simulation is fully nonlinear and can capture all the effects generated by a signal. In contrast, small-signal simulation is a linear approximation performed on a steady-state result. Consequently, all nonlinear effects caused by large signals are lost in this mode. During small-signal simulation, the accuracy increases as the signal amplitude decreases. However, the accuracy of transient simulation is not affected by the signal amplitude. With appropriate settings, the accuracy of transient simulation can be higher than that of small-signal simulation.  "},{"title":"6. How to set up materials​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#6-how-to-set-up-materials","content":" "},{"title":"6.1 Material setup​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#61-material-setup","content":"When performing optical and electrical simulations, it usually takes two steps to set up a material. First, add an electrical material through add_lib function. The format of the function is mt.add_lib(name, data, order, override)  add_lib() parameters: name--Custom material namedata--Material data, requiring one of the built-in materials in the electrical material library, namely mo.OE_Materialorder--mesh_order of the material, default to be 2override--Override the default electronic parameters by custom values. It's empty by default, which means default models and parameters are applied  Second, use the set_optical_material function to set the optical property for the material. The format of set_optical_material is set_optical_material(data)  set_optical_material() parameters： data--Optical material property，which can be one of the built-in materials in the optical material library mo.Material, or be from the custom optical material.  Example of material setup​ mt.add_lib(name=&quot;mat_ge&quot;, data=mo.OE_Material.Ge, order=2, override=elec_Ge_properties) # elec_Ge_properties is a variable storing the modified electronic parameters for Germanium mt[&quot;mat_ge&quot;].set_optical_material(data=mo.Material.Ge_Palik)   Example of using custom optical material properties​ mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_nondispersion(name=&quot;mat_sio2_op&quot;, data=[(1.444, 0)], order=1) mt[&quot;mat_sio2&quot;].set_optical_material(data=mt[&quot;mat_sio2_op&quot;].passive_material)  Note: Although the electrical and optical material properties are bound together through a two-step setting, in reality, there is no inherent connection between them. For instance, it is possible to set both the electrical properties of SiO2 and the optical properties of Si for the same material. The simulation will not generate errors or warnings in such cases, so users need to determine by themselves whether the material settings align with the physics. The FDTD simulation currently doesn't support metal materials. Therefore, the optical property of metal materials should be set to mo.Material.PEC and the material name should also be &quot;pec&quot;.  "},{"title":"6.2 Electronic parameters of materials​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#62-electronic-parameters-of-materials","content":"Semiconductor Si and Ge support basic，band，mobility，velocity saturation and high field setting. Taking Ge as an example, the variable elec_Ge_properties below can be used to override its default electronic parameters. elec_Ge_properties = {&quot;model&quot;: {&quot;high_field&quot;: True, &quot;mobility_force&quot;: &quot;EQF&quot;}, &quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.5-0.65969/2.0, &quot;permitti&quot;: 16.0}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Masetti&quot;, &quot;Masetti&quot;: {&quot;pc_e&quot;: 0, &quot;mu_min1_e&quot;: 850, &quot;mu_min2_e&quot;: 850, &quot;mu1_e&quot;: 0, &quot;mumax_e&quot;: 3900, &quot;cr_e&quot;: 2.6e17, &quot;alpha_e&quot;: 0.56, &quot;pc_h&quot;: 0, &quot;mu_min1_h&quot;: 300, &quot;mu_min2_h&quot;: 300, &quot;mu1_h&quot;: 0, &quot;mumax_h&quot;: 1800, &quot;cr_h&quot;: 1e17, &quot;alpha_h&quot;: 1}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;nc300&quot;: 1.1372e+19, &quot;nv300&quot;: 3.9189e+18, # Bandgap &quot;eg300&quot;: 0.65969, &quot;chi300&quot;: 4.5-0.65969/2.0, # Bandgap Narrowing &quot;v0_bgn&quot;: 0, # Auger Recombination &quot;augan&quot;: 1e-30, &quot;augap&quot;: 1e-30, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 1.5e-9, &quot;taupmax&quot;: 1.5e-9, &quot;nsrhn&quot;: 7.1e15, &quot;nsrhp&quot;: 7.1e15, # Radiative Recombination &quot;c_direct&quot;: 6.41e-14}, &quot;print&quot;: 1}, &quot;vsat&quot;: {&quot;model&quot;: &quot;Canali&quot;, &quot;Canali&quot;: {&quot;beta0n&quot;: 2, &quot;beta0p&quot;: 1, &quot;betaexpn&quot;: 0, &quot;betaexpp&quot;: 0, &quot;alpha&quot;: 0, &quot;vsatn0&quot;: 6e6, &quot;vsatp0&quot;: 5.4e6, &quot;vsatn_exp&quot;: 0, &quot;vsatp_exp&quot;: 0}, &quot;print&quot;: 1}}  Description: basic--Set the permittivity and affinity band--Set models and parameters of the band and the recombination mobility--Set the model and parameters of mobility model--Set the switch of high field mobility model and Fermi-Dirac statistics model vsat--Set the model and parameters of velocity saturation For the detailed introduction about electronic parameters, please refer to the document examples/active_demo/Physics_Model_in_OEDevice.pdf.  "},{"title":"7. How to set up OEDevice solver​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#7-how-to-set-up-oedevice-solver","content":"The OEDevice solver is added and set up through simu.add function. The format of the function is simu.add(name, type, property)  simu.add() parameters: name--Name of the solvertype--Type of the solver. For active device simulation, the type of carrier transport solver is &quot;OEDevice&quot;property--Other properties  Property list of OEDevice solver: \tdefault\ttype\tnotesgeneral.norm_length\t1.0\tfloat general.solver_mode\tsteady_state\tstring\tSelections are ['steady_state', 'transient', 'SSAC']. general.temperature_dependence\tIsothermal\tstring\tSelections are ['Isothermal']. general.simulation_temperature\t300\tfloat advanced.non_linear_solver\tNewton\tstring\tSelections are ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', 'LU', 'BCGS']. advanced.use_quasi_fermi\tdisabled\tstring\tSelections are ['disabled', 'enabled']. advanced.damping\tnone\tstring\tSelections are ['none', 'potential']. advanced.potential_update\t1.0\tfloat advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. advanced.thread_count\t4\tinteger advanced.max_iterations\t30\tinteger advanced.use_global_max_iterations\ttrue\tbool advanced.poisson_max_iterations\t30\tinteger advanced.ddm_max_iterations\t30\tinteger advanced.relative_tolerance\t1.0e-5\tfloat advanced.tolerance_relax\t1.0e+5\tfloat advanced.divergence_factor\t1.0e+25\tfloat genrate.genrate_path string genrate.source_fraction float genrate.coordinate_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float geometry.z_min float geometry.z_max float small_signal_ac.perturbation_amplitude\t0.001\tfloat small_signal_ac.frequency_spacing\tsingle\tstring\tSelections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat small_signal_ac.start_frequency\t1.0e+06\tfloat small_signal_ac.stop_frequency\t1.0e+09\tfloat small_signal_ac.frequency_interval\t9.9999e+10\tfloat small_signal_ac.num_frequency_points\t2\tinteger small_signal_ac.log_start_frequency\t1.0e+06\tfloat small_signal_ac.log_stop_frequency\t1.0e+10\tfloat small_signal_ac.log_num_frequency_points\t2\tinteger\t Description: geometry： dimension--Set the dimension of the simulation region. Only 2D simulation is supportd currently. When it's set to &quot;2d_x_normal&quot;, the simulation is on the yz plane. Similarly for the rest general: norm_length--Set the length in the third dimension, default to be 1solver_mode--Set the simulation mode. Steady state, transient and SSAC simulations are supportedtemperature--Set the simulation temperaturetemperature_dependence--Set the type of the temperature dependence. Only &quot;Isothermal&quot; is supported currently genrate: genrate_path--Set the absolute path of the optical generation rate file (gfile) When it's set to &quot;&quot; (by default), and empty string , no optical generation rate will be appliedWhen it's not empty, the gfile at the path will be imported to apply the optical generation rate coordinate_unit--Set the coordinate unit in the gfile field_length_unit--Set the length unit in the generation rate unit in the gfile source_fraction--Set the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport small_signal_ac: perturbation_amplitude--Set the voltage amplitude of the small signal frequency_spacing--Set the spacing type of the frequency When it's set to &quot;single&quot;, the frequency point is singleWhen it's set to &quot;linear&quot;, the frequency points are uniformly sampledWhen it's set to &quot;log&quot;，the frequency points are uniformly sampled base on the logarithm of frequency frequency--Set the value of the single frequency start_frequency--Set the start frequency of linear spacing stop_frequency--Set the stop frequency of linear spacing frequency_interval--Set the frequency interval of linear spacing num_frequency_points--Set the number of frequency points of linear spacing log_start_frequency--Set the start frequency of logarithmic spacing log_stop_frequency--Set the stop frequency of logarithmic spacing log_num_frequency_points--Set the number of frequency points of logarithmic spacing advanced: non_linear_solver--Set the non-linear solver, only Newton method is supported currentlylinear_solver--Set the linear solver. Options are &quot;MUMPS&quot;, &quot;LU&quot;, &quot;BCGS&quot;. MUMPS and LU are direct linear solvers which usually give the exact solution. However, MUMPS supports parallel computation while LU doesn't. ；&quot;BCGS&quot; is a Krylov subspace (KSP) iterative solver, which also supports parallel computation and is more efficient but can only give approximate results.use_quasi_fermi--Whether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. &quot;enabled&quot; means True, and &quot;disabled&quot; means Falsedamping--Set the nonlinear update damping scheme. &quot;potential&quot; means the damping is based on the potential variationpotential_update--Set the threshold potential for potential damping. The large value will reduce the strength of damping effectmulti_threads: When it's set to &quot;let_solver_choose&quot;, the solver will determine the number of threads to use. The default maximum number of threads is 4When it's set to &quot;set_thread_count&quot;, the number of threads is set by the user to thread_count thread_count--Custom number of threadsmax_iterations--Set global maximum number of iterations, available when use_global_max_iterations is Trueuse_global_max_iterations--Whether to use global max iterations during the initialization of solving the Poisson equations and the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, default to be Truepoisson_max_iterations--Set the max iterations during the initialization of solving the Poisson equations, available when use_global_max_iterations is Falseddm_max_iterations--Set the max iterations during the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, available when use_global_max_iterations is Falserelative_tolerance--Set the relative update tolerancetolerance_relax--Set the tolerance relaxation factor for convergence on relative tolerance criteriadivergence_factor--Nonlinear solver fault with divergence when each individual function norm exceeds the threshold as its absolute tolerance multiply by this factor  "},{"title":"8. How to set up electrical monitors​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#8-how-to-set-up-electrical-monitors","content":"Electrical monitors are added and set up through mn.add function. The format is mn.add(name, type, property)  mn.add() parameters: name--Monitor nametype--Monitor type. Options are &quot;charge_monitor&quot;, &quot;electric_monitor&quot;and &quot;band_monitor&quot;, which are for recording carrier concentration, electric field and potential, band structure respectivelyproperty--Other properties  Property list of electrical monitors: \tdefault\ttype\tnotesgeometry.monitor_type\tpoint\tstring\tSelections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t0\tinteger\t Description: geometry: monitor_type--Set the dimension type of the monitor. For electrical monitors, only 1D type and 2D type are available currently When it's charge_monitor or electric_monitor, Options &quot;linear_x&quot;, &quot;linear_y&quot;, &quot;linear_z&quot;, &quot;2d_x_normal&quot;, &quot;2d_y_normal&quot;, &quot;2d_z_normal&quot; are available. &quot;linear_x&quot; means the monitor is of 1D type and is along the x-direction, so the y_span and z_span should be 0. &quot;2d_x_normal&quot; means the monitor is of 2D type and is in the yz plane, so the x_span should be 0. Similarly for the rest interpolate_accuracy--Set the accuracy of the rectangular grid for extracting the monitor result. Its value ranges from 1 to 10, where 1 means the grid size is 10nm, and 10 means the grid size is 1nm, and the grid size varies uniformly with the variation in interpolate_accuracy.  Examples of add electrical monitors​ mn.add(name=&quot;electric_2d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y_min&quot;: -1, &quot;y_max&quot;: 1, &quot;z_min&quot;: -1, &quot;z_max&quot;: 1, &quot;interpolate_accuracy&quot;: 4}}) mn.add(name=&quot;electric_1d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_z&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: -1, &quot;z_max&quot;: 1, &quot;interpolate_accuracy&quot;: 4}}) mn.add(name=&quot;band_1d&quot;, type=&quot;band_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_x&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 2, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: 0, &quot;z_max&quot;: 0, &quot;interpolate_accuracy&quot;: 4}})   "},{"title":"9. How to set up eletrical local mesh​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#9-how-to-set-up-eletrical-local-mesh","content":" "},{"title":"9.1 Electrical local mesh in a rectangle region​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#91-electrical-local-mesh-in-a-rectangle-region","content":"Electrical local mesh in a rectangle region is added and set up through add_emesh function. The format is st.add_emesh(name, property)  add_emesh() parameters: name--Custom nameproperty--Other properties Property list of electrical local mesh in a rectangle region: \tdefault\ttype\tnotesx float x_span float\tRestrained by condition: &gt;=0. x_min float x_max float y float y_span float\tRestrained by condition: &gt;=0. y_min float y_max float z float z_span float\tRestrained by condition: &gt;=0. z_min float z_max float mesh_size float\tmax size of electrical simulation mesh Description: mesh_size--Set the max size of electrical mesh grid in the region Note: When the simulation region is in the xy plane, only the parameters in the x, y direction are effective, and parameters in the z direction will be ignored. Similarly for the rest.  Example of electrical local mesh in a region setting​ st.add_emesh(name=&quot;local_mesh&quot;, property={ &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1, &quot;mesh_size&quot;: 0.01})   "},{"title":"9.2 Electrical local mesh along a line​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#92-electrical-local-mesh-along-a-line","content":"Electrical local mesh along a line is added and set up through add_emesh_alone_line function. The format is st.add_emesh_alone_line(name, property)  add_emesh_alone_line() parameters: name--Custom nameproperty--Other properties Property list of electrical local mesh along a line: \tdefault\ttype\tnotesstart_x\t0\tfloat start_y\t0\tfloat\tRestrained by condition: &gt;=0. start_z\t0\tfloat end_x\t1\tfloat end_y\t1\tfloat end_z\t1\tfloat\tRestrained by condition: &gt;=0. mesh_size\t0.01\tfloat\t Description: start_x--Set x coordinate of the start point. Similarly for the restmesh_size--Set the max size of electrical mesh grid in the range Note: When the simulation region is in the xy plane, besides start_x, start_y, end_x and end_y, it is also required to set the start_z and end_z, which should both be the same as the z coordinate of the plane. Similarly for the rest.  Example of electrical local mesh along a line setting​ st.add_emesh_along_line(name=&quot;local_mesh_along_line&quot;, property={ &quot;start_x&quot;: 0, &quot;start_y&quot;: -1, &quot;start_z&quot;: -1, &quot;end_x&quot;: 0, &quot;end_y&quot;: 1, &quot;end_z&quot;: 1, &quot;mesh_size&quot;: 0.01})   "},{"title":"10. How to extract electrical result​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#10-how-to-extract-electrical-result","content":"The simulation results are extracted by the extract function in SDK.  "},{"title":"10.1 Extract generation rate​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#101-extract-generation-rate","content":"Generation Rate is extracted from result_afdtd (result of AFDTD simulation). The format is result_generate = result_afdtd.run_generation_rate_analysis(name, monitor, average_dimension, light_power, coordinate_unit, field_length_unit) result_generate.extract(data, export_csv, show, log, savepath)  result_afdtd.run_generation_rate_analysis() parameters: name--Custom namemonitor--Name of the power_monitor for calculating optical generation rate. The power_monitor is required to be of 3D typeaverage_dimension--Set the direction to take the average of the optical generate ratelight_power--Set the power of the light source, measured in W. The optical generation rate will be scaled based on the powercoordinate_unit--Set the coordinate unit in the optical generation rate file (gfile). Options are &quot;m&quot;, &quot;cm&quot;, &quot;um&quot; and &quot;nm&quot;field_length_unit--Set the length unit in the generation rate unit in the optical generation rate file (gfile). Options are &quot;m&quot;, &quot;cm&quot;, &quot;um&quot; and &quot;nm&quot;. If it's set to &quot;m&quot;, the generation rate unit in the gfile will be /m^3/s. Similarly for the rest  result_genrate.extract() parameters： data--Type of the result When data is set to &quot;generation_rate&quot;, besides an image file and a csv file, the result files also include a text file in .gfile format. The coordinate unit in the csv and the image file is um, and the generation rate unit in the two files is /cm^3/s. These units can't be modified when extracting the result. However, the units in the gfile are controlled by coordinate_unit、field_length_unit. And only the gfile can be imported to the OEDevice solverWhen data is set to &quot;pabs_total&quot;, the total absorption power is extracted export_csv--Whether to export csv file show--Whether to show the plot in a popup window log--Whether to apply a logarithmic normalization in the intensity plot savepath--The save path of the result extraction  Example of extracting generation rate​ result_generate = result_afdtd.run_generation_rate_analysis(name='genrate', monitor=3D_power_monitor_name, average_dimension='x', light_power=1, coordinate_unit='m', field_length_unit='m') result_generate.extract(data='generation_rate', export_csv=True, show=False, log=False, savepath=savepath)   "},{"title":"10.2 Extract electrode result​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#102-extract-electrode-result","content":"The results of electrode are extracted from result_oedevice (result of OEDevice simulation). The format is result_oedevice.extract(data, electrode, operation, export_csv, show, savepath)  Extraction of electrode result parameters: data--Type of result When it's steady state simulation or SSAC simulation, options &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot; are available, which means the current at the electrode versus voltage is extracted, with &quot;I&quot; for the total current&quot;In&quot; for the electron current&quot;Ip&quot; for the hole current When it's SSAC simulation, options &quot;Iac&quot; and &quot;C&quot; are available, which means the AC current or capacitance at the electrode versus voltage at different frequency points is extracted, with &quot;Iac&quot; for the total AC current&quot;C&quot; for the capacitance When it's transient simulation, options &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot; are available, which means the current at the electrode versus time is extracted, with &quot;I&quot; for the total current&quot;In&quot; for the electron current&quot;Ip&quot; for the hole current electrode--Name of the electrodeoperation--Options are &quot;real&quot; (by default), &quot;imag&quot;, &quot;abs&quot;, &quot;abs2&quot;. For a result whose value is a real number, this parameter can be omitted. Bur for a result whose value is a complex number, like &quot;Iac&quot;, it must be used to extract the real and imaginary part of the result respectivelyexport_csv--Whether to export csv fileshow--Whether to show the plot in a popup windowsavepath--The save path of the result extraction  Example of extracting electrode result​ result_oedevice.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=savepath) result_oedevice.extract(data=&quot;Iac&quot;, electrode=&quot;cathode&quot;, operation=&quot;real&quot;, export_csv=True, show=False, savepath=savepath)   "},{"title":"10.3 Extract results of electrical monitor​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#103-extract-results-of-electrical-monitor","content":"The electrical monitor result extraction is similar to the electrode result extraction, but a monitor instead of an electrode is required to be specified. The format is result_oedevice.extract(data, monitor, operation, export_csv, show, log, savepath)  Extraction of electrode result parameters: data--Type of result When the monitor is charge_monitor, options &quot;n&quot;, &quot;p&quot; are available, which means the concentration of carriers is extracted, with &quot;n&quot; for the electron&quot;p&quot; for the hole When the monitor is electric_monitor, options &quot;electric_field&quot;, &quot;ex&quot;, &quot;ey&quot;, &quot;ez&quot;, &quot;potential&quot; are available, which means the concentration of carriers is extracted, with &quot;electric_field&quot; for the absolute value of the electric field&quot;ex&quot; for the x component of the electric field&quot;ey&quot; for the y component of the electric field&quot;ez&quot; for the z component of the electric field&quot;potential&quot; for the electrostatic potential When the monitor is band_monitor, options &quot;conduction_band&quot;, &quot;valence_band&quot;, &quot;equasi_fermi&quot;, &quot;hquasi_fermi&quot; are available, which means the band structure is extracted, with &quot;conduction_band&quot; for the conduction band energy level&quot;valence_band&quot; for the valence band energy level&quot;equasi_fermi&quot; for the electron quasi-Fermi potential&quot;hquasi_fermi&quot; for the hole quasi-Fermi potential operation--Options are &quot;real&quot; (by default), &quot;imag&quot;, &quot;abs&quot;, &quot;abs2&quot; export_csv--Whether to export csv file. When the monitor is of 2D type, the result is a distribution in a 2D region, and the plot is an intensity image; When the monitor is of 1D type, the result is a distribution along a 1D range, and the plot is a curve show--Whether to show the plot in a popup window log--Whether to take the logarithm of the result savepath--The save path of the result extraction  Example of extracting electrical monitor result​ result_device.extract(data=&quot;n&quot;, monitor=&quot;charge_2d&quot;, export_csv=True, show=False, log=True, savepath=savepath) result_device.extract(data=&quot;p&quot;, monitor=&quot;charge_1d&quot;, export_csv=True, show=False, log=False, savepath=savepath) result_device.extract(data=&quot;electric_field&quot;, monitor=&quot;electric_2d&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;ex&quot;, monitor=&quot;electric_2d&quot;, operation=&quot;abs&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;potential&quot;, monitor=&quot;electric_1d&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;conduction_band&quot;, monitor=&quot;band_1d&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;hquasi_fermi&quot;, monitor=&quot;band_1d&quot;, export_csv=True, show=False, savepath=savepath)   "},{"title":"10.4 Extract results of modulator analysis​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#104-extract-results-of-modulator-analysis","content":"The results of modulator analysis are extracted from result_afde (result of AFDE). The format is result_afde.extract(data, operation, export_csv, show, savepath)  result_afde.extract() parameters: data--Type of result. Options are &quot;effective_index&quot;, &quot;loss&quot;, which means the effective index or loss versus voltage is extractedoperation--Options are &quot;real&quot; (by default), &quot;imag&quot;, &quot;abs&quot;, &quot;abs2&quot;. For a result whose value is a real number, this parameter can be omitted. Bur for a result whose value is a complex number, like &quot;effective_index&quot;, it must be used to extract the real and imaginary part of the result respectivelyexport_csv--Whether to export csv fileshow--Whether to show the plot in a popup windowsavepath--The save path of the result extraction  Example of extracting modulator analysis result​ result_afde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;real&quot;, show=False, savepath=savepath) result_afde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;imag&quot;, show=False, savepath=savepath) result_afde.extract(data=&quot;loss&quot;, export_csv=True, show=False, savepath=savepath)   "},{"title":"Material","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/1Material","content":"Material In this section, the code instructions aim to assist you in adding the required simulation materials into your simulation project. We can use this module with the code mt = pj.Material() . These instructions enable you to incorporate dispersion/non-dispersion materials and anisotropic materials into the simulation project. Additionally, you have the options to directly access the necessary materials from the Max-Optics material library. 1.1 Add anisotropy material​ Add anisotropy material to a project. add_anisotropy( self, *, name: str, data: List[ Tuple[ float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float], ], color: Optional[str] = None, alpha: Optional[float] = None, fitting: Literal[None, &quot;linear&quot;], order: int = 2, ) Parameters\tDescription name\tThe name of material in the project. data\tMaterial data. Format is [(wavelength, xx index real, xx index imag, yy index real, yy index imag, zz index real, zz index imag), …] or [(wavelength, xx index real, xx index imag, xy index real, xy index imag, …), …]. color\tThe color of materials in the visual model. If it is not set, the color will be automatically calculated based on the refractive index. fitting\tThe fitting mode of material data. order\tThe coverage order of materials when modeling a geometric structure. Example: mt = pj.Material() mt.add_anisotropy(name=&quot;LN&quot;, fitting=None, data=[(wavelength * 1e-6, 2.211, 0, 2.138, 0, 2.211, 0)], order=2 ) 1.2 Add dispersion material​ Add dispersion material to a project. add_dispersion( self, *, name: str, data: List[ Tuple[float, float, float], ], color: Optional[str] = None, alpha: Optional[float] = None, fitting: Literal[None, &quot;linear&quot;], order: int = 2 ) Parameters\tDescription name\tThe name of material in the project. data\tMaterial data. Format is [(wavelength, index real, index imag), …]. color\tThe color of materials in the visual model. If it is not set, the color will be automatically calculated based on the refractive index. fitting\tThe fitting mode of material data. order\tThe coverage order of materials when modeling a geometric structure. Example: mt = pj.Material() mt.add_dispersion(name=&quot;SiO2&quot;, data=[(1.55e-06, 1.444, 0), (1.30e-06, 1.81, 0.227)], order=2 ) 1.3 Add material in Max-Optics material library​ Add material in the Max-Optics material library to a project. add_lib( self, *, name: str, data: Any, override: Optional[dict]=None, color: Optional[str] = None, alpha: Optional[float] = None, order: int = 2 ) Parameters\tDescription name\tThe name of material in the project. data\tAn existing material in the library. override\tOverride. color\tThe color of materials in the visual model. If not set, the color will be automatically calculated based on the index parameters. order\tThe coverage order of materials when modeling a geometric structure. Example: mt = pj.Material() mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) 1.4 Add nondispersion material​ Add non-dispersion material to a project. add_nondispersion( self, *, name: str, data: List[Tuple[float, float]], color: Optional[str] = None, alpha: Optional[float] = None, order: int = 2 ) Parameters\tDescription name\tThe name of material in the project. data\tMaterial data. Format is [(index real, index imag)]. color\tThe color of materials in the visual model. If not set, the color will be automatically calculated based on the refractive index. order\tThe coverage order of materials when modeling a geometric structure. Example: mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=1) ","keywords":""},{"title":"Boundary/Mesh","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/3Boundary","content":"Boundary/Mesh The code provided in this section can be utilized to incorporate boundary and mesh into the current project. 3.1 Boundary​ The following content comprises code explanations and specific examples of boundary conditions in optical simulation. OBoundary( self, *, pml_same_settings: bool = True, property: Union['OBoundarySameSettingsPostProcess', 'OBoundaryNotSameSettingsPostProcess'], ) Parameters\tDescriptionproperty\tThe default property of the optical boundary. pml_same_settings\tTo decide whether using the same pml settings on every directions or not. As demonstrated in the following examples, we also provide support for customizing boundary conditions in different directions. Example: st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_beam/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}, &quot;boundary&quot;: {&quot;x_min&quot;: &quot;PML&quot;, &quot;x_max&quot;: &quot;PML&quot;, &quot;y_min&quot;: &quot;PML&quot;, &quot;y_max&quot;: &quot;PML&quot;, &quot;z_min&quot;: &quot;PML&quot;, &quot;z_max&quot;: &quot;PML&quot;}, &quot;general_pml&quot;: {&quot;pml_same_settings&quot;: True, &quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 0.8, &quot;pml_layer&quot;: 8, &quot;pml_polynomial&quot;: 3}}) Parameters\tDefault\tType\tNotesgeneral_pml.pml_same_settings\ttrue\tbool\tTo decide whether using the same pml settings on every directions or not. general_pml.pml_profile\tstandard\tstring\tTo provide the options of PML profile. general_pml.pml_layer\t-\tinteger\tSet the number of layers after discretizing the PML region. general_pml.pml_kappa\t-\tfloat\tSet the kappa parameter related to the absorption characteristics of the PML region. general_pml.pml_sigma\t-\tfloat\tSet the sigma parameter related to the absorption characteristics of the PML region. general_pml.pml_polynomial\t-\tinteger\tSet the order of the kappa and the sigma parameters. general_pml.pml_alpha\t-\tfloat\tSet the alpha parameter related to the absorption characteristics of the PML region. general_pml.pml_alpha_polynomial\t-\tinteger\tSet the order of the alpha parameter. general_pml.pml_min_layers\t-\tinteger\tSet the minimum number of layers within a reasonable range for the PML layers. general_pml.pml_max_layers\t-\tinteger\tSet themaximum number of layers within a reasonable range for the PML layers. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the boundary. geometry.x_span\t-\tfloat\tThe length in x direction of the boundary. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the boundary. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the boundary. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the boundary. geometry.y_span\t-\tfloat\tThe width in y direction of the boundary. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the boundary. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the boundary. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the boundary. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the boundary. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the boundary. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the boundary. boundary.x_max\t-\tstring\tSet the boundary type in the x+ direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.x_min\t-\tstring\tSet the boundary type in the x- direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.y_max\t-\tstring\tSet the boundary type in the y+ direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.y_min\t-\tstring\tSet the boundary type in the y- direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.z_max\t-\tstring\tSet the boundary type in the z+ direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.z_min\t-\tstring\tSet the boundary type in the z- direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. If you need to customize the boundary conditions for simulation requirements, you can also refer to the table below for modifying boundary conditions in different directions.Taking the x coordinate axis as an example, the parameters invocation is the same for the y/z coordinates. Parameters\tDefault\tType\tNotesgeneral_pml.pml_same_settings\ttrue\tbool\tTo decide whether using the same pml settings on every directions or not. general_pml.x_min_bc.pml_profile\tstandard\tstring\tTo provide the options of PML profile in x- direction. general_pml.x_min_bc.pml_layer\t-\tinteger\tSet the number of layers after discretizing the PML region in x- direction. general_pml.x_min_bc.pml_kappa\t-\tfloat\tSet the kappa parameter related to the absorption characteristics of the PML region in x- direction. general_pml.x_min_bc.pml_sigma\t-\tfloat\tSet the sigma parameter related to the absorption characteristics of the PML region in x- direction. general_pml.x_min_bc.pml_polynomial\t-\tinteger\tSet the order of the kappa and the sigma parameters in x- direction. general_pml.x_min_bc.pml_alpha\t-\tfloat\tSet the alpha parameter related to the absorption characteristics of the PML region in x- direction. general_pml.x_min_bc.pml_alpha_polynomial\t-\tinteger\tSet the order of the alpha parameter in x- direction. general_pml.x_min_bc.pml_min_layers\t-\tinteger\tSet the minimum number of layers within a reasonable range for the PML layers in x- direction. general_pml.x_min_bc.pml_max_layers\t-\tinteger\tSet the maximum number of layers within a reasonable range for the PML layers in x- direction. general_pml.x_max_bc.pml_profile\tstandard\tstring\tTo provide the options of PML profile in x+ direction. general_pml.x_max_bc.pml_layer\t-\tinteger\tSet the number of layers after discretizing the PML region in x+ direction. general_pml.x_max_bc.pml_kappa\t-\tfloat\tSet the kappa parameter related to the absorption characteristics of the PML region in x+ direction. general_pml.x_max_bc.pml_sigma\t-\tfloat\tSet the sigma parameter related to the absorption characteristics of the PML region in x+ direction. general_pml.x_max_bc.pml_polynomial\t-\tinteger\tSet the order of the kappa and the sigma parameters in x+ direction. general_pml.x_max_bc.pml_alpha\t-\tfloat\tSet the alpha parameter related to the absorption characteristics of the PML region in x+ direction. general_pml.x_max_bc.pml_alpha_polynomial\t-\tinteger\tSet the order of the alpha parameter in x+ direction. general_pml.x_max_bc.pml_min_layers\t-\tinteger\tSet the minimum number of layers within a reasonable range for the PML layers in x+ direction. general_pml.x_max_bc.pml_max_layers\t-\tinteger\tSet the maximum number of layers within a reasonable range for the PML layers in x+ direction. 3.2 Mesh​ In this section, we will discuss how to add meshing to the simulation. This step is crucial to ensure the precision and dependability of the simulation outcomes. 3.2.1 Add mesh​ Add sub mesh to the simulation project with the code below (for optical simulation). add_mesh( self, *, name: str, property: PostProcessSubMesh, ) Parameters\tDescriptionname\tThe name of optical mesh in the simulation project. property\tThe property of optical mesh in the simulation project. Example: st.add_mesh(name='sub_mesh', property={'general': {'dx': 0.002, 'dy': 0.002, 'dz': 0.002}, 'geometry': {'x': 0, 'x_span': 6, 'y': 0, 'y_span': 2, 'z': 0, 'z_span': 0.2}}) Parameters\tDefault\tType\tNotesgeneral.override_x_mesh\t-\tbool\tTo set whether to override the mesh in the x direction. general.override_y_mesh\t-\tbool\tTo set whether to override the mesh in the y direction. general.override_z_mesh\t-\tbool\tTo set whether to override the mesh in the z direction. general.dx\t-\tfloat\tThe maximum mesh step in the x direction. Restrained by condition: &gt;0. general.dy\t-\tfloat\tThe maximum mesh step in the y direction. Restrained by condition: &gt;0. general.dz\t-\tfloat\tThe maximum mesh step in the z direction. Restrained by condition: &gt;0. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the mesh. geometry.x_span\t-\tfloat\tThe length in x direction of the mesh. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the mesh. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the mesh. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the mesh. geometry.y_span\t-\tfloat\tThe width in y direction of the mesh. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the mesh. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the mesh. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the mesh. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the mesh. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the mesh. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the mesh. 3.2.2 Add emesh​ In the context of electrical simulation, we present guidelines on how to incorporate meshing to ensure the precision and dependability of the simulation outcomes. The code explanations and a practical example provided below. add_emesh( self, *, name: str, property: Dict[str, Any], ) Parameters\tDescriptionname\tElectric local mesh name. property\tElectric local mesh property. Example: st.add_emesh(name=&quot;EMesh_Local&quot;, property={ &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: oe_y_max, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;mesh_size&quot;: egrid_local}) Parameters\tDefault\tType\tNotesgeometry.x\t-\tfloat\tThe x-coordinate of the center point position of the electrical mesh. geometry.x_span\t-\tfloat\tThe length in x direction of the electrical mesh. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the electrical mesh. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the electrical mesh. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the electrical mesh. geometry.y_span\t-\tfloat\tThe width in y direction of the electrical mesh. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the electrical mesh. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the electrical mesh. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the electrical mesh. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the electrical mesh. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the electrical mesh. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the electrical mesh. mesh_size\t-\tfloat\tThe max size of electrical simulation mesh. 3.2.3 Add emesh along line​ By implementing an electric mesh along line, you can accurately capture intricate electrical phenomena and variations, enhancing the comprehensiveness of your simulation results. add_emesh_along_line( self, *, name: str, property: Dict[str, Any], ) Parameters\tDescriptionname\tThe name of electric mesh along line. property\tThe property of electric mesh along line. Example: st.add_emesh_along_line(name=&quot;EMesh_Ge_SiO2_Interface_Slope_Left&quot;, property={ &quot;start_x&quot;: oe_x_mean, &quot;start_y&quot;: -Ge_y_span_bottom/2, &quot;start_z&quot;: Si_z_span, &quot;end_x&quot;: oe_x_mean, &quot;end_y&quot;: -Ge_y_span_top/2, &quot;end_z&quot;: Si_z_span+Ge_z_span, &quot;mesh_size&quot;: egrid_interface}) Parameters\tDefault\tType\tNotesstart_x\t0\tfloat\tThe minimum value of mesh region in x axis. start_y\t0\tfloat\tThe minimum value of mesh region in y axis. Restrained by condition: &gt;=0. start_z\t0\tfloat\tThe minimum value of mesh region in z axis. end_x\t1\tfloat\tThe maximum value of mesh region in x axis. end_y\t1\tfloat\tThe maximum value of mesh region in y axis. end_z\t1\tfloat\tThe maximum value of mesh region in z axis. Restrained by condition: &gt;=0. mesh_size\t0.01\tfloat\tThe size of the unit grid.","keywords":""},{"title":"Source/Port","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/4Source","content":"Source/Port The subsequent code will exemplify the process of incorporating a light source and port within a simulation project. As of now, the source module accommodates the inclusion of mode source and Gaussian source. Furthermore, our platform extends support for ports into both EME and FDTD simulations. 4.1 Waveform​ Before adding a light source, firstly we define the relevant parameters of the waveform in this section of the project. wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1) wv_struct = wv[waveform_name] Parameters\tDescriptionname\tThe waveform name in the simulation. wavelength_center\tDetermine the center wavelength of the waveform. wavelength_span\tDetermine the wavelength span of the waveform. wavelength_min\tDetermine the minimun wavelength of the waveform. wavelength_max\tDetermine the maximum wavelength of the waveform. frequency_center\tDetermine the center frequency of the waveform. frequency_span\tDetermine the frequency span of the waveform. frequency_min\tDetermine the minimun frequency of the waveform. frequency_max\tDetermine the maximum frequency of the waveform. 4.2 Mode source​ Incorporate a model source into the project by utilizing the provided code with the attribute type=&quot;mode_source&quot;. add( self, *, type: Literal[&quot;mode_source&quot;], name: str, axis: AxisSelection, property: PostProcessModeSource, ) Parameters\tDescriptionname\tThe name of mode source defined in the project. type\tTo decide the type of source. axis\tDetermining the propagation direction of the mode source. Literal[&quot;x_forward&quot;,&quot;y_forward&quot;,&quot;z_forward&quot;,&quot;x_backward&quot;,&quot;y_backward&quot;,&quot;z_backward&quot;]. property\tThe property of mode source. Example: src.add(name='source', type='mode_source', axis='x_forward', property={'general': { # 'amplitude': 1, 'phase': 0, 'mode_index': 0, 'rotations': {'theta': 0, 'phi': 0, 'rotation_offset': 0} 'mode_selection': 'user_select', 'waveform': {'waveform_id_select': wv_struct} }, 'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}}) Parameters\tDefault\tType\tNotesgeneral.inject_axis\tx_axis\tstring\tTo set the inject axis of mode source. Selections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. general.direction\tforward\tstring\tTo set the propagation direction of mode source. Selections are ['forward', 'backward']. general.amplitude\t1.0\tfloat\tTo set the amplitude of mode source. general.phase\t0.0\tfloat\tTo set the initial phase value for the mode source. general.mode_selection\t-\tstring\tTo decide the mode which propagates in the waveguide. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. general.mode_removal.threshold\t-\tfloat\tScreen the mode source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission mode. general.mode_index\t0\tinteger\tUnder the 'user_select' condition, use this parameter to decide the related number of source mode. general.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. general.n\t1.0\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the source mode. general.number_of_trial_modes\t20\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. general.waveform.waveform_id_select\t-\tany\tCall the previously defined wavelength form MO waveform list. general.rotations.theta\t0\tfloat\tSet the theta rotation angle of the mode source. general.rotations.phi\t0\tfloat\tSet the phi rotation angle of the mode source. general.rotations.rotation_offset\t0\tfloat\tSet the rotation offset of the mode source. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the mode source. geometry.x_span\t-\tfloat\tThe length in x direction of the mode source. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the mode source. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the mode source. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the mode source. geometry.y_span\t-\tfloat\tThe width in y direction of the mode source. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the mode source. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the mode source. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the mode source. geometry.z_span\t-\tfloat\tThe height in z direction of the mode source. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the mode source. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the mode source. 4.3 Gaussian source​ Integrate a Gaussian source into the project by applying the code type=&quot;Gaussian_source&quot;. add( self, *, type: Literal[&quot;gaussian_source&quot;], name: str, axis: AxisSelection, property: PostProcessGaussianSource, ) Parameters\tDescriptionname\tThe name of Gaussian source defined in the project. type\tTo decide the type of source. axis\tDetermining the propagation direction of the Gaussian source. Literal[&quot;x_forward&quot;,&quot;y_forward&quot;,&quot;z_forward&quot;,&quot;x_backward&quot;,&quot;y_backward&quot;,&quot;z_backward&quot;]. property\tThe property of Gaussian source. Example: so.add(name='source', type='gaussian_source', axis='z_backward', property={'general': {'angle_theta': 12, 'angle_phi': 0, 'polarization_angle': 90, 'waveform': {'waveform_id_select': wv[waveform_name]}, 'beam_settings': {'calculation_method': 'use_scalar_approximation', # [use_scalar_approximation,use_vector_approximation] 'beam_parameters': 'waist_size_and_position', # [waist_size_and_position,beam_size_and_divergence] 'waist_radius': 5.2, 'distance_from_waist': 1.5, 'beam_radius': 5.2, 'divergence_angle': 5.41444}}, 'geometry': {'x': 4, 'x_span': 20, 'y': 0, 'y_span': 20, 'z': 1.5, 'z_span': 0}}) Parameters\tDefault\tType\tNotesgeneral.inject_axis\tx_axis\tstring\tTo set the inject axis of Gaussian source. Selections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. general.direction\tforward\tstring\tTo set the propagation direction of Gaussian source. Selections are ['forward', 'backward']. general.amplitude\t1.0\tfloat\tTo set the amplitude of Gaussian source. general.phase\t0.0\tfloat\tTo set the initial phase value for the Gaussian source. general.waveform.waveform_id_select\t-\tany\tCall the previously defined wavelength form MO waveform list. general.rotations.theta\t0\tfloat\tSet the theta rotation angle of the Gaussian source. general.rotations.phi\t0\tfloat\tSet the phi rotation angle of the Gaussian source. general.rotations.rotation_offset\t0\tfloat\tSet the rotation offset of the Gaussian source. general.polarization_angle\t0\tfloat\tSet the polarization angle of Gaussian source. general.beam_settings.calculation_method\tuse_scalar_approximation\tstring\tChoose a method for calculating Gaussian source. Selections are ['use_scalar_approximation', 'use_vector_approximation']. general.beam_settings.beam_parameters\twaist_size_and_position\tstring\tChoose a method for determining the relevant parameters of Gaussian source. Selections are ['waist_size_and_position', 'beam_size_and_divergence']. general.beam_settings.waist_radius\t-\tfloat\tThe beam waist radius of the Gaussian source. The corresponding position when the field attenuates to 1/e. general.beam_settings.distance_from_waist\t-\tfloat\tThe distance from the center of the Gaussian source to the beam waist radius. general.beam_settings.beam_radius\t-\tfloat\tThe beam radius of the Gaussian source. general.beam_settings.divergence_angle\t-\tfloat\tThe divergence angle of Gaussian beam. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the Gaussian source. geometry.x_span\t-\tfloat\tThe length in x direction of the Gaussian source. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the Gaussian source. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the Gaussian source. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the Gaussian source. geometry.y_span\t-\tfloat\tThe width in y direction of the Gaussian source. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the Gaussian source. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the Gaussian source. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the Gaussian source. geometry.z_span\t-\tfloat\tThe height in z direction of the Gaussian source. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the Gaussian source. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the Gaussian source. 4.3 FDTD port​ Incorporate a port into the current FDTD simulation project. add( self, *, type: Literal[&quot;fdtd_port&quot;], name: str, property: PostProcessFdtdPort, ) Parameters\tDescriptionname\tThe name of FDTD port source defined in the project. type\tTo decide the type of source. property\tThe property of the FDTD port source. Example: pt = pj.Port(property={'waveform_id': wv_struct, 'source_port': 'port_left'}) pt.add(name='port_left', type='fdtd_port', property={'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'forward', 'mode_selection': 'fundamental', }}}) Parameters\tDefault\tType\tNotesgeometry.x\t-\tfloat\tThe x-coordinate of the center point position of the FDTD port source. geometry.x_span\t-\tfloat\tThe length in x direction of the FDTD port source. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the FDTD port source. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the FDTD port source. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the FDTD port source. geometry.y_span\t-\tfloat\tThe width in y direction of the FDTD port source. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the FDTD port source. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the FDTD port source. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the FDTD port source. geometry.z_span\t-\tfloat\tThe height in z direction of the FDTD port source. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the FDTD port source. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the FDTD port source. modal_properties.general.inject_axis\tx_axis\tstring\tTo set the inject axis of FDTD port source. Selections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. modal_properties.general.direction\tforward\tstring\tTo set the propagation direction of FDTD port source. Selections are ['forward', 'backward']. modal_properties.general.amplitude\t1.0\tfloat\tTo set the amplitude of FDTD port source. modal_properties.general.phase\t0.0\tfloat\tTo set the initial phase value for the FDTD port source. modal_properties.general.mode_selection\t-\tstring\tTo decide the FDTD port mode which propagates in the waveguide. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. modal_properties.general.mode_removal.threshold\t-\tfloat\tScreen the FDTD port source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission FDTD port mode. modal_properties.general.mode_index\t0\tinteger\tUnder the 'user_select' condition, use this parameter to decide the FDTD port source mode. modal_properties.general.search\tmax_index\tstring\tCalculate the FDTD port mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. modal_properties.general.n\t1.0\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the FDTD port source mode. modal_properties.general.number_of_trial_modes\t20\tinteger\tWhen calculating FDTD port mode, determine the calculated number of FDTD port mode around the refractive index. modal_properties.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in bent waveguides. modal_properties.bent_waveguide.radius\t1\tfloat\tSet the waveguide radius for bent waveguides. modal_properties.bent_waveguide.orientation\t20\tfloat\tThe bent direction of the waveguide. modal_properties.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. 4.4 EME port​ Incorporate a port into the current EME simulation project. add( self, *, type: Literal[&quot;eme_port&quot;], name: str, property: PostProcessEmePort, ) Parameters\tDescriptionname\tThe name of EME port source defined in the project. type\tTo decide the type of the EME port source. property\tThe property of the EME port source. Example: pjp = pj.Port(property={&quot;source_port&quot;: &quot;input_te_tm&quot;}) pjp.add(name=&quot;input_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;use_full_simulation_span&quot;: True, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1}, &quot;advanced&quot;: {&quot;offset&quot;: 0.1, &quot;number_of_trial_modes&quot;: number_of_modes}}}) Parameters\tDefault\tType\tNotesgeometry.port_location\t-\tstring\tSet the location type of EME port. Selections are ['left', 'right']. geometry.use_full_simulation_span\ttrue\tbool\tConfirm whether to use full simulation span. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the EME port source. geometry.y_span\t-\tfloat\tThe width in y direction of the EME port source. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the EME port source. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the EME port source. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the EME port source. geometry.z_span\t-\tfloat\tThe height in z direction of the EME port source. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the EME port source. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the EME port source. eme_port.general.mode_selection\t-\tstring\tTo decide the mode which propagates in the waveguide. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. eme_port.general.mode_index\t1\tinteger\tUnder the 'user_select' condition, use this parameter to decide the source mode. eme_port.general.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. Selections are ['near_n', 'max_index']. eme_port.general.n\t1.0\tinteger\tUnder the 'near_n' condition, use this value of refractive index to search the source mode. eme_port.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in bent waveguides. eme_port.bent_waveguide.radius\t1\tfloat\tSet the waveguide radius for curved waveguides. eme_port.bent_waveguide.orientation\t20\tfloat\tBent direction of the waveguide. eme_port.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. eme_port.advanced.offset\t0\tfloat\tSet the offset of EME port position. eme_port.advanced.number_of_trial_modes\t20\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. eme_port.advanced.mode_removal.threshold\t-\tfloat\tScreen the mode source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission mode.","keywords":""},{"title":"Monitor","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/5Mornitor","content":"Monitor This section provides guidance on adding a monitor to your simulation project. We offer a variety of monitors designed to enhance your ability to gather simulation data. The subsequent content will be presented below, offering an introduction to each monitor. 5.1 Profile monitor​ Incorporate a profile monitor into the current project. The profile monitor is solely used for the EME simulation. add( self, *, type: Literal[&quot;profile_monitor&quot;], name: str, property: PostProcessProfileMonitor, ) Parameters\tDescriptionname\tThe name of profile monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of profile monitor. Example: mn = pj.Monitor() mn.add(name=&quot;y_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_y_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) Parameters\tDefault\tType\tNotesgeometry.monitor_type\t-\tstring\tSelect the profile monitor type and the orientation.Selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. geometry.x_resolution\t100\tinteger\tThe resolution of output simulation results in profile monitor. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the profile monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the profile monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the profile monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the profile monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the profile monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the profile monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the profile monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the profile monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the profile monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the profile monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the profile monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the profile monitor. 5.2 Global monitor/Global option​ Integrate a global monitor into the current project. add( self, *, type: Literal[&quot;global_monitor&quot;, &quot;global_option&quot;], name: str, property: PostProcessGlobalMonitor, ) Parameters\tDescriptionname\tThe name of global monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of global monitor. Example: mn = pj.Monitor() mn.add(name='Global Option', type='global_option', property={'frequency_power': { # 'sample_spacing': 'uniform', 'use_wavelength_spacing': True, # ['min_max','center_span'] 'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}}) Parameters\tDefault\tType\tNotesfrequency_power.sample_spacing\tuniform\tstring\tSet the type of frequency interval for the frequency monitor. Selections are ['uniform']. frequency_power.use_wavelength_spacing\ttrue\tbool\tSelect whether to use wavelength as a variable for result output. frequency_power.spacing_type\twavelength\tstring\tThe different spacing type for result output. Selections are ['wavelength', 'frequency']. frequency_power.spacing_limit\tmin_max\tstring\tSelect the way to set wavelength interval or frequency interval.Selections are ['min_max', 'center_span']. frequency_power.wavelength_min\t-\tfloat\tSet the minimum value of the wavelength range. frequency_power.wavelength_max\t-\tfloat\tSet the maximum value of the wavelength range. frequency_power.wavelength_center\t-\tfloat\tSet the center wavelength. frequency_power.wavelength_span\t-\tfloat\tSet the wavelength span. frequency_power.frequency_min\t-\tfloat\tSet the minimum value of the frequency range. frequency_power.frequency_max\t-\tfloat\tSet the maximum value of the frequency range. frequency_power.frequency_center\t-\tfloat\tSet the center value of the frequency range. frequency_power.frequency_span\t-\tfloat\tSet the frequency span. frequency_power.frequency_points\t5\tinteger\tSet the number of points in the frequency range or wavelength range. advanced.min_sampling_per_cycle\t2\tinteger\tSet the minimum sampling number of points within the optical cycle. 5.3 Time monitor​ Incorporate a time monitor into the current project. add( self, *, type: Literal[&quot;time_monitor&quot;], name: str, property: PostProcessTimeMonitor, ) Parameters\tDescriptionname\tThe name of time monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of time monitor. Example: mn = pj.Monitor() mn.add(name='time_monitor1', type='time_monitor', property={'general': { 'stop_method': 'end_of_simulation', 'start_time': 0, 'stop_time': 100, 'number_of_snapshots': 0}, 'geometry': {'monitor_type': 'point', 'x': 0, 'x_span': 0, 'y': 0, 'y_span': 0, 'z': 0, 'z_span': 0}, 'advanced': {'sampling_rate': {'min_sampling_per_cycle': 10}}}) Parameters\tDefault\tType\tNotesgeneral.stop_method\tend_of_simulation\tstring\tSet the method to stop data collection for the time monitor. Selections are ['end_of_simulation', 'choose_stop_time', 'choose_number_of_snapshots']. general.start_time\t0\tfloat\tThe start time for data collection by the time monitor. general.stop_time\t1000\tfloat\tThe stop time for data collection by the time monitor. general.number_of_snapshots\t0\tinteger\tThe number of time snapshots for data collection. geometry.monitor_type string\tThe type and orientation of the time monitor. Selections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the time monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the time monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the time monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the time monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the time monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the time monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the time monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the time monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the time monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the time monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe bottom position of the height of the time monitor in z direction. geometry.z_max\t-\tfloat\tThe top position of the height of the time monitor in z direction. advanced.sampling_rate.min_sampling_per_cycle\t10\tinteger\tSet the minimum sampling number of points within the optical cycle. 5.4 Power monitor​ Incorporate a power monitor into the current project. Additionally, you can utilize the 'mode_expansion' to compute the mode expansion associated with its corresponding relative power monitor. add( self, *, type: Literal[&quot;power_monitor&quot;], name: str, property: PostProcessPowerMonitor, ) Parameters\tDescriptionname\tThe name of power monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of power monitor. 5.4.1 Power monitor​ As demonstrated in the following code, add a power monitor to the current project. mn = pj.Monitor() mn.add(name=&quot;z_normal&quot;, type=&quot;power_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;,&quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_beam/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0}}) 5.4.2 Mode expansion​ As demonstrated code below, add a mode expansion for the related power monitor. mn.add(name='through', type='power_monitor', property={'general': {'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}, }, 'geometry': {'monitor_type': '2d_x_normal', 'x': ports['op_1']['position'][0], 'x_span': 0, 'y': ports['op_1']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'mode_expansion': {&quot;enable&quot;: True, 'direction': 'positive', 'mode_calculation': { 'mode_selection': 'user_select', 'mode_index': [0, 1, 2, 3], 'override_global_monitor_setting': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}}}}) Parameters\tDefault\tType\tNotesgeometry.monitor_type\t-\tstring\tThe type and orientation of the power monitor. Selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the power monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the power monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the power monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the power monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the power monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the power monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the power monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the power monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the power monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the power monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe bottom position of the height of the power monitor in z direction. geometry.z_max\t-\tfloat\tThe top position of the height of the power monitor in z direction. geometry.rotate_settings.theta\t0\tfloat\tThe rotation angle theta of the power monitor. Restrained by condition: &gt;-90,&lt;90. geometry.rotate_settings.phi\t0\tfloat\tThe rotation angle phi of the power monitor. Restrained by condition: &gt;=0,&lt;=360. geometry.rotate_settings.rotation_offset\t0\tfloat\tThe rotation offset of the power monitor.Restrained by condition: &gt;=-1e30,&lt;=1e30.Parameters\tDefault\tType\tNotesmode_expansion.[]monitors_for_expansion.name\t-\tstring\tThe name of the power monitor required for individual mode expansion when called separately. mode_expansion.[]monitors_for_expansion.frequency_monitor\t-\tstring\tThe name of the frequency monitor required for individual mode expansion when called separately. mode_expansion.direction\tpositive\tstring\tSet the direction of the mode expansion. Selections are ['positive', 'negative']. mode_expansion.mode_calculation.mode_selection\t-\tstring\tDecide the mode for mode expansion calculation. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'user_select']. mode_expansion.mode_calculation.mode_index\t-\tlist\tUnder the 'user_select' condition, use this parameter to decide the related number of source mode. mode_expansion.mode_calculation.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. mode_expansion.mode_calculation.n\t1.0\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the mode. mode_expansion.mode_calculation.number_of_trial_modes\t20\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. mode_expansion.mode_calculation.override_global_options\tfalse\tbool\tDecide whether to override the global monitor settings. mode_expansion.mode_calculation.override_global_monitor_setting.sample_spacing\tuniform\tstring\tSet the type of frequency interval. Selections are ['uniform']. mode_expansion.mode_calculation.override_global_monitor_setting.use_wavelength_spacing\ttrue\tbool\tSelect whether to use wavelength as a variable for result output. mode_expansion.mode_calculation.override_global_monitor_setting.spacing_type\twavelength\tstring\tThe different spacing type for result output. Selections are ['wavelength', 'frequency']. mode_expansion.mode_calculation.override_global_monitor_setting.spacing_limit\tmin_max\tstring\tSelect the way to set wavelength interval or frequency interval.Selections are ['min_max', 'center_span']. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_min\t-\tfloat\tSet the minimum value of the wavelength range. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_max\t-\tfloat\tSet the maximum value of the wavelength range. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_center\t-\tfloat\tSet the center wavelength. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_span\t-\tfloat\tSet the wavelength span. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_min\t-\tfloat\tSet the minimum value of the frequency range. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_max\t-\tfloat\tSet the maximum value of the frequency range. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_center\t-\tfloat\tSet the center value of the frequency range. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_span\t-\tfloat\tSet the frequency span. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_points\t-\tinteger\tSet the number of points in the frequency range or wavelength range. mode_expansion.mode_calculation.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in curved waveguides. mode_expansion.mode_calculation.bent_waveguide.radius\t1\tfloat\tSet the waveguide radius for curved waveguides. mode_expansion.mode_calculation.bent_waveguide.orientation\t20\tfloat\tBent direction of the waveguide. mode_expansion.mode_calculation.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. 5.5 Band monitor​ Integrate a band monitor into the current project. add( self, *, type: Literal[&quot;band_monitor&quot;], name: str, property: PostProcessBandMonitor, ) Parameters\tDescriptionname\tThe name of band monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of band monitor. Example: mn = pj.Monitor() mn.add(name=&quot;band_line&quot;, type=&quot;band_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_z&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;interpolate_accuracy&quot;: 9}}) # endregion Parameters\tDefault\tType\tNotesgeneral.record_ec\ttrue\tbool\tThe conduction band edge energy at 300K. general.record_ev\ttrue\tbool\tThe valance band edge energy at 300K. general.record_ei\ttrue\tbool\tThe fermi level for intrinsic doped material. general.record_efn\ttrue\tbool\tThe electron quasi-Fermi energy. general.record_efp\ttrue\tbool\tThe hole quasi-Fermi energy. general.record_evac\ttrue\tbool geometry.monitor_type string\tSet the dimension type of the monitor. For electrical monitors, only 1D type and 2D type are available currently. Selections are ['linear_x', 'linear_y', 'linear_z']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the band monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the band monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the band monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the band monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the band monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the band monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the band monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the band monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the band monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the band monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the band monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the band monitor. geometry.interpolate_accuracy\t1\tinteger\tSet the accuracy of the rectangular grid for extracting the monitor result. Restrained by condition: &gt;=1 &amp;&amp; &lt;= 10. Here 1 means the grid size is 10nm, and 10 means the grid size is 1nm, and the grid size varies uniformly with the variation in 'interpolate_accuracy'. 5.6 Charge monitor​ Incorporate a charge monitor into the current project. add( self, *, type: Literal[&quot;charge_monitor&quot;], name: str, property: PostProcessChargeMonitor, ) Parameters\tDescriptionname\tThe name of charge monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of charge monitor. Example: mn = pj.Monitor() mn.add(name=&quot;np_line_080nm&quot;, type=&quot;charge_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_y&quot;, &quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: -0.4, &quot;y_max&quot;: 0.4, &quot;z&quot;: 0.08, &quot;z_span&quot;: 0, &quot;interpolate_accuracy&quot;: 9}}) Parameters\tDefault\tType\tNotesgeneral.record_electrons\ttrue\tbool\tThe distribution of electron concentration in monitor. general.record_holes\ttrue\tbool\tThe distribution of hole concentration in monitor. general.integrate_total_charge\ttrue\tbool\tAvailable when monitor_type is in ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the charge monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the charge monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the charge monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the charge monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the charge monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the charge monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the charge monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the charge monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the charge monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the charge monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the charge monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the charge monitor. geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10. 5.7 Electric monitor​ Integrate an electric monitor into the current project. add( self, *, type: Literal[&quot;electric_monitor&quot;], name: str, property: PostProcessElectricMonitor, ) Parameters\tDescriptionname\tThe name of electric monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of electric monitor. Example: mn = pj.Monitor() mn.add(name=&quot;electric_2d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: -Ge_y_span_bottom*3/4, &quot;y_max&quot;: Ge_y_span_bottom*3/4, &quot;z_min&quot;: 0, &quot;z_max&quot;: Si_z_span+Ge_z_span, &quot;interpolate_accuracy&quot;: 6}}) Parameters\tDefault\tType\tNotesgeneral.record_electrics_field\ttrue\tbool\tThe distribution of electric field in monitor. general.record_electrostatic_potential\ttrue\tbool\tThe distribution of electric potential in monitor. general.calculate_net_charge\ttrue\tbool\tAvailable when monitor_type is in ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the electric monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the electric monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the electric monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the electric monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the electric monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the electric monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the electric monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the electric monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the electric monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the electric monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the electric monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the electric monitor. geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10.","keywords":""},{"title":"Structure","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/2Structure","content":"Structure The code within the &quot;Structure&quot; section is designed to assist you incorporating the necessary structures during the EO(Electro-Optic) simulation process. st = pj.Structure(mesh_type, mesh_factor, background_material ) Parameters\tDefault\tType\tNotes mesh_type\tcurve_mesh\tstring\tDifferent mesh types for iterative calculations. Selections are ['curve_mesh', 'staircase']. mesh_factor\t1.2\tfloat\tMaximum rate when the mesh changes. background_material\t-\tmaterial\tBackground material You can choose to create geometry models using GDS files. Meanwhile, you can also utilize various methods in this &quot;Structure&quot; module such as Bézier curves, tapering, and circular rings for your simulation project. 2.1 Add geometry​ Add a geometry structure to current project. add_geometry( self, *, name: str, type: str, property: &quot;StructureGeometryPropertyDict&quot; ) Parameters\tDescriptionname\tThe name of a specific geometric structure. type\tThe type of a specific geometric structure. property\tThe property of a specific geometric structure, including the materials, geometric dimensions, and so on. 2.1.1 GDS file/GDS file3D​ The following codes can import the structure in Max-Optics SDK from GDS layout files. Example: st.add_geometry(name=&quot;gds_file&quot;, type=&quot;gds_file&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: { &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}, &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;EXTEND_1&quot;, &quot;layer_name&quot;: (3, 0)}}) Parameters\tDefault\tType\tNotesgeometry.x\t0\tfloat\tThe x-coordinate of the center point position of structures in the imported GDS file. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of structures in the imported GDS file. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of structures in the imported GDS file. geometry.z_span\t-\tfloat\tSetting the height of structures in the imported GDS file. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of structures in the imported GDS file. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of structures in the imported GDS file. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. general.path\t-\tstring\tThe path of the imported GDS file. general.cell_name\t-\tstring\tThe cell name of imported GDS file. general.layer_name\t-\tlist\tThe layer name of imported GDS file. Meanwhile, we also offer support for basic operations to GDS layout modeling using type=&quot;gds_file3D&quot;. The code for this function is provided below: st.add_geometry(name=&quot;gds_file_3D&quot;, type=&quot;gds_file3D&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;EXTEND_1&quot;, &quot;layer_name&quot;: (3, 0)}, &quot;geometry&quot;: {&quot;tilt_angle&quot;: 60,&quot;tilt_location&quot;: &quot;bottom&quot;, &quot;x&quot;: 4*space, &quot;y&quot;: 2*space, &quot;z&quot;: 0.05, &quot;z_span&quot;: 0.1, &quot;mirror_normal_z&quot;: 0,&quot;mirror_plane_z0&quot;: 0,&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}}) Parameters\tDefault\tType\tNotesgeometry.tilt_angle\t90\tfloat\tTilt angle of waveguide sidewall. geometry.tilt_location\ttop\tstring\tTo ensure that the models within the GDS layout are placed at the specified sizes on the different ratio of sidewalls when importing GDS layout. Selections are ['top', 'TOP', 'Top', 'bottom', 'BOTTOM', 'Bottom', 'middle', 'MIDDLE', 'Middle', 'user_defined']. geometry.user_defined\t1\tfloat\tTo decide the ratio of sidewalls when importing GDS layout. geometry.mirror_normal_z\t0\tfloat\tThe posiotion of z-normal plane for mirror symmetry. geometry.mirror_plane_z0\t0\tfloat\tThe center point position of z normal palne. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. general.construct_method\t-\tstring\tThe method around constructing the GDS after choosing to import the GDS file. Selections are ['method1', 'method2'] 2.1.2 Arc waveguide/Arc waveguide 3D​ To establish an arc waveguide within the project, utilize the code type=&quot;ArcWaveguide&quot;. Example: st.add_geometry(name=&quot;arc&quot;, type=&quot;ArcWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;inner_radius&quot;: size-wg_width/2, &quot;outer_radius&quot;: size+wg_width/2, &quot;angle&quot;: 90, &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}}) Parameters\tDefault\tType\tNotesgeometry.inner_radius\t-\tfloat\tThe inner radius of arc waveguide. Restrained by condition: &gt;0. geometry.outer_radius\t-\tfloat\tThe outer radius of arc waveguide. Restrained by condition: &gt;0. geometry.angle\t-\tfloat\tThe angle corresponding to the arc length of an arc waveguide. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of arc waveguide. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of arc waveguide. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of arc waveguide. geometry.z_span\t-\tfloat\tSetting the height of arc waveguide. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of arc waveguide. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of arc waveguide. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. Similarly, we offer support for using code type=&quot;ArcWaveguide3D&quot; to adjust the arc waveguide structure in the height direction. st.add_geometry(name=&quot;arc_3d&quot;, type=&quot;ArcWaveguide3D&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: size, &quot;angle&quot;: 180, &quot;base_height&quot;: wg_height, &quot;top_width&quot;: wg_width_top, &quot;bottom_width&quot;: wg_width, &quot;x&quot;: space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}}) Parameters\tDefault\tType\tNotesgeometry.radius\t-\tfloat\tThe radius of the central width of the arc. Restrained by condition: &gt;0. geometry.angle\t-\tfloat\tThe angle corresponding to the arc length of an arc waveguide. Restrained by condition: &gt;0,&lt;=360. geometry.base_height\t-\tfloat\tThe height of the arc waveguide. Restrained by condition: &gt;0. geometry.top_width\t-\tfloat\tThe top width of the arc waveguide. Restrained by condition: &gt;0. geometry.bottom_width\t-\tfloat\tThe bottom width of the arc waveguide. Restrained by condition: &gt;0. 2.1.3 Bezier curve/ Bezier curve 3D​ Within the project, we can incorporate a Bezier curve structure by employing the code type=&quot;BezierCurve&quot;. Example: st.add_geometry(name=&quot;bezier&quot;, type=&quot;BezierCurve&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 2*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;width&quot;: wg_width, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size/2, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size/2, &quot;point_4_x&quot;: size, &quot;point_4_y&quot;: size}}) Parameters\tDefault\tType\tNotesgeometry.point_1_x\t-\tfloat\tThe x-coordinate of the first point for generating a Bezier curve. geometry.point_1_y\t-\tfloat\tThe y-coordinate of the first point for generating a Bezier curve. geometry.point_2_x\t-\tfloat\tThe x-coordinate of the second point for generating a Bezier curve. geometry.point_2_y\t-\tfloat\tThe y-coordinate of the second point for generating a Bezier curve. geometry.point_3_x\t-\tfloat\tThe x-coordinate of the third point for generating a Béezier curve. geometry.point_3_y\t-\tfloat\tThe y-coordinate of the third point for generating a Béezier curve. geometry.point_4_x\t-\tfloat\tThe x-coordinate of the forth point for generating a Bezier curve. geometry.point_4_y\t-\tfloat\tThe y-coordinate of the forth point for generating a Bezier curve. geometry.width\t-\tfloat\tThe width of the Bezier curve. geometry.x\t-\tfloat\tThe center point x-coordinate the Bezier curve. geometry.y\t-\tfloat\tThe center point y-coordinate the Bezier curve. geometry.z\t-\tfloat\tThe center point z-coordinate the Bezier curve. geometry.z_span\t-\tfloat\tThe thinckness of the Bezier curve. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe bottom position of the height of the Bezier curve in the z-coordinate. geometry.z_max\t-\tfloat\tThe top position of the height of the Bezier curve in the z-coordinate. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. Similarly, we offer support for using code type=&quot;BezierCurve3D&quot; to adjust the Bézier curve structure in the height direction. st.add_geometry(name=&quot;bezier_3d&quot;, type=&quot;BezierCurve3D&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 3*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;base_height&quot;: wg_height, &quot;top_width&quot;: wg_width_top, &quot;bottom_width&quot;: wg_width, &quot;control_points&quot;: [{&quot;x&quot;: 0, &quot;y&quot;: 0}, {&quot;x&quot;: 0, &quot;y&quot;: size/2}, {&quot;x&quot;: size, &quot;y&quot;: size/2}, {&quot;x&quot;: size, &quot;y&quot;: size}]}}) Parameters\tDefault\tType\tNotesgeometry.base_height\t-\tfloat\tThe height of the Bezier curve. Restrained by condition: &gt;0. geometry.top_width\t-\tfloat\tThe top width of the Bezier curve. Restrained by condition: &gt;0. geometry.bottom_width\t-\tfloat\tThe bottom width of the Bezier curve. Restrained by condition: &gt;0. geometry.[]control_points.x\t-\tfloat\tThe x-coordinate of the points for generating a Bezier curve. geometry.[]control_points.y\t-\tfloat\tThe y-coordinate of the points for generating a Bezier curve. 2.1.4 Circle​ Integrate a circular structure into the simulation project by employing the code type=&quot;Circle&quot;. Example: st.add_geometry(name=&quot;circle&quot;, type=&quot;Circle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;radius&quot;: size, &quot;x&quot;: 4*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}}) Parameters\tDefault\tType\tNotesgeometry.radius\t-\tfloat\tThe radius of the circle. Restrained by condition: &gt;0. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of circle. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of circle. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of circle. geometry.z_span\t-\tfloat\tThe thinckness of the circle. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe bottom position of the height of the circle in z-coordinate. geometry.z_max\t-\tfloat\tThe top position of the height of the circle in z-coordinate. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. 2.1.5 Custom polygon​ By utilizing the code type=&quot;CustomPolygon&quot;, it becomes possible to incorporate a custiomized polygon into the project. Example: st.add_geometry(name=&quot;custom_polygon&quot;, type=&quot;CustomPolygon&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;size&quot;: size, &quot;sides&quot;: 6, &quot;x&quot;: 4*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}}) Parameters\tDefault\tType\tNotesgeometry.size\t-\tfloat\tThe side length of the polygon. Restrained by condition: &gt;0. geometry.sides\t-\tinteger\tTo set the number of custom polygon sides. Restrained by condition: &gt;=3. geometry.x\t-\tfloat\tThe center point x-coordinate the custom polygon. geometry.y\t-\tfloat\tThe center point y-coordinate the custom polygon. geometry.z\t-\tfloat\tThe center point z-coordinate the custom polygon. geometry.z_span\t-\tfloat\tThe thinckness of the custom polygon. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the custom polygon. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the custom polygon. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial around the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. 2.1.6 Ellipse​ Incorporate an ellipse into the project by implementing the code type=&quot;Ellipse&quot;. Example: st.add_geometry(name=&quot;ellipse&quot;, type=&quot;Ellipse&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x_radius&quot;: size, &quot;y_radius&quot;: 1.5*size, &quot;x&quot;: 3*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}}) Parameters\tDefault\tType\tNotesgeometry.x_radius\t-\tfloat\tThe length in the x direction of the ellipse. Restrained by condition: &gt;0. geometry.y_radius\t-\tfloat\tThe width in the y direction of the ellipse.Restrained by condition: &gt;0. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the ellipse. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the ellipse. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the ellipse. geometry.z_span\t-\tfloat\tThe thinckness of the ellipse. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the ellipse. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the ellipse. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. 2.1.7 Linear trapezoid​ Integrate a linear trapezoid shape into the project using the code type=&quot;LinearTrapezoid&quot;. Example: st.add_geometry(name=&quot;linear_trapezoid&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size/2, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size, &quot;point_4_x&quot;: size, &quot;point_4_y&quot;: 0, &quot;x&quot;: 2*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}}) Parameters\tDefault\tType\tNotesgeometry.point_1_x\t-\tfloat\tThe x-coordinate of one point when constructing a linear trapezoid structure. geometry.point_1_y\t-\tfloat\tThe y-coordinate of one point when constructing a linear trapezoid structure. geometry.point_2_x\t-\tfloat\tThe x-coordinate of one point when constructing a linear trapezoid structure. geometry.point_2_y\t-\tfloat\tThe y-coordinate of one point when constructing a linear trapezoid structure. geometry.point_3_x\t-\tfloat\tThe x-coordinate of one point when constructing a linear trapezoid structure. geometry.point_3_y\t-\tfloat\tThe y-coordinate of one point when constructing a linear trapezoid structure. geometry.point_4_x\t-\tfloat\tThe x-coordinate of one point when constructing a linear trapezoid structure. geometry.point_4_y\t-\tfloat\tThe y-coordinate of one point when constructing a linear trapezoid structure. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the linear trapezoid. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the linear trapezoid. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the linear trapezoid. geometry.z_span\t-\tfloat\tThe thinckness of the linear trapezoid. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the linear trapezoid. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the linear trapezoid. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. 2.1.8 Pyramid​ Incorporate a pyramid structure into the project by employing the code type=&quot;Pyramid&quot;. Example: st.add_geometry(name=&quot;pyramid&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;x&quot;: space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;theta_x&quot;: 0, &quot;theta_y&quot;: 0, &quot;x_span_bottom&quot;: 2*size, &quot;x_span_top&quot;: size, &quot;y_span_bottom&quot;: 2*size, &quot;y_span_top&quot;: size}}) Parameters\tDefault\tType\tNotesgeometry.x_span_bottom\t-\tfloat\tThe length in the x-direction at the bottom of the pyramid. Restrained by condition: &gt;=0. geometry.y_span_bottom\t-\tfloat\tThe width in the y-direction at the bottom of the pyramid. Restrained by condition: &gt;=0. geometry.x_span_top\t-\tfloat\tThe length in the x-direction at the top of the pyramid. Restrained by condition: &gt;=0. geometry.y_span_top\t-\tfloat\tThe width in the y-direction at the top of the pyramid. Restrained by condition: &gt;=0. geometry.theta_x\t0\tfloat\tThe tilt angle of the top pyramid structure along the x+ axis. geometry.theta_y\t0\tfloat\tThe tilt angle of the top pyramid structure along the y+ axis. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the pyramid. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the pyramid. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the pyramid. geometry.z_span\t-\tfloat\tThe thinckness of the pyramid. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the pyramid. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the pyramid. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. 2.1.9 Analytical waveguide​ Integrate an analytical waveguide structure into the project by implementing the code type='AnalyticalWaveguide'. Example: st.add_geometry(name='taper_symmetric_test', type='AnalyticalWaveguide', property={'geometry': {'x': 0, 'x_span': L, 'y': 0, 'y_span': taper_width, 'z': 0, 'z_span': 0.22, 'equation1': f'{str(A)}*({str(L/2)}-x)^{str(m)}+1.5', 'nonsymmetric': False, 'tilt_location': 'user_defined', 'tilt_angle': 80, 'user_defined': 0.5, 'resolution': 1000}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) Parameters\tDefault\tType\tNotesgeometry.x_span\t-\tfloat\tThe length of the waveguide in the x-direction. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe x-coordinate value of the endpoint for the waveguide length. geometry.x_max\t-\tfloat\tThe x-coordinate value of the endpoint for the waveguide length. geometry.y_span\t-\tfloat\tThe width of the waveguide in the y-direction. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe y-coordinate value of the endpoint for the waveguide width. geometry.y_max\t-\tfloat\tThe y-coordinate value of the endpoint for the waveguide width. geometry.equation1\t-\tstring\tThe customed function 1 used in modeling the analytical waveguide. geometry.equation2\t-\tstring\tWhen the geometry is asymmetric('nonsymmetric': True), the customed function 2 used in modeling the analytical waveguide. geometry.nonsymmetric\tfalse\tbool\tTo Control whether the waveguide is symmetric. geometry.resolution\t10\tinteger\tThe resolution in modeling the analytical waveguide when working with functions. geometry.tilt_angle\t90\tfloat\tTilt angle of the structure sidewall. geometry.tilt_location\ttop\tstring\tDifferent ways of tilting the sidewalls of the waveguide. Selections are ['top', 'TOP', 'Top', 'bottom', 'BOTTOM', 'Bottom', 'middle', 'MIDDLE', 'Middle', 'user_defined']. geometry.user_defined\t1\tfloat\tTo decide the ratio of sidewalls. geometry.x\t0\tfloat\tThe x-coordinate of the center point position of the analytical waveguide. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of the analytical waveguide. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the analytical waveguide. geometry.z_span\t-\tfloat\tSetting the height of the analytical waveguide. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the analytical waveguide. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the analytical waveguide. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. 2.1.10 Rectangle​ Incorporate a rectangle structure into the project by utilizing the code type=&quot;Rectangle&quot;. Example: st.add_geometry(name=&quot;rectangle&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;x&quot;: 0, &quot;x_span&quot;: size, &quot;y&quot;: space, &quot;y_span&quot;: wg_width, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, }}) Parameters\tDefault\tType\tNotesgeometry.x_span float\tThe length of the rectangle in the x-direction. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe x-coordinate value of the endpoint for the rectangle length. geometry.x_max\t-\tfloat\tThe x-coordinate value of the endpoint for the rectangle length. geometry.y_span\t-\tfloat\tThe width of the rectangle in the y-direction. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe y-coordinate value of the endpoint for the rectangle width. geometry.y_max\t-\tfloat\tThe y-coordinate value of the endpoint for the rectangle width. geometry.x\t0\tfloat\tThe x-coordinate of the center point position of the rectangle. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of the rectangle. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the rectangle. geometry.z_span\t-\tfloat\tSetting the height of the rectangle. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the rectangle. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the rectangle. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. 2.1.11 Ring​ Integrate a ring structure into the project by implementing the code type=&quot;Ring&quot; . Example: st.add_geometry(name=&quot;ring&quot;, type=&quot;Ring&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 2*space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;inner_radius&quot;: size-wg_width/2, &quot;outer_radius&quot;: size+wg_width/2,}}) Parameters\tDefault\tType\tNotesgeometry.inner_radius\t-\tfloat\tThe inner radius of the ring. Restrained by condition: &gt;0. geometry.outer_radius\t-\tfloat\tThe outer radius of the ring. Restrained by condition: &gt;0. geometry.x\t0\tfloat\tThe x-coordinate of the center point position of the ring. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of the ring. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the ring. geometry.z_span\t-\tfloat\tSetting the height of the ring. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the ring. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the ring. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. 2.1.12 Sector​ Incorporate a sector structure into the project by employing the code type=&quot;Sector&quot;. Example: st.add_geometry(name=&quot;sector&quot;, type=&quot;Sector&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: size, &quot;angle&quot;: 75, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;x&quot;: space, &quot;y&quot;: 2*space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}}) Parameters\tDefault\tType\tNotesgeometry.radius\t-\tfloat\tThe radius of the sector. Restrained by condition: &gt;0. geometry.angle\t-\tfloat\tThe angle of the sector. geometry.x\t0\tfloat\tThe x-coordinate of the center point position of the sector. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of the sector. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the sector. geometry.z_span\t-\tfloat\tSetting the height of the sector. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the sector. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the sector. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. 2.1.13 Triangle​ Integrate a triangle structure into the project by implementing the code type=&quot;Triangle&quot;. Example: st.add_geometry(name=&quot;triangle&quot;, type=&quot;Triangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size, &quot;x&quot;: 2*space, &quot;y&quot;: 2*space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}}) Parameters\tDefault\tType\tNotesgeometry.point_1_x\t-\tfloat\tThe x-coordinate of endpoint when constructing a triangle. geometry.point_1_y\t-\tfloat\tThe y-coordinate of endpoint when constructing a triangle. geometry.point_2_x\t-\tfloat\tThe x-coordinate of endpoint when constructing a triangle. geometry.point_2_y\t-\tfloat\tThe y-coordinate of endpoint when constructing a triangle. geometry.point_3_x\t-\tfloat\tThe x-coordinate of endpoint when constructing a triangle. geometry.point_3_y\t-\tfloat\tThe y-coordinate of endpoint when constructing a triangle. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the triangle. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the triangle. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the triangle. geometry.z_span\t-\tfloat\tThe thinckness of the triangle. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the triangle. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the triangle. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. 2.2 Add doping​ When participating in optoelectronic simulation, you have the option to utilize the provided code for introducing doping into the simulation structure. Our platform offers assistance in importing doping data from files and also allows for the customization of doping regions according to your requirements. add_doping( self, *, name: str, type: &quot;StructureDopingTypeSelection&quot;, property: &quot;StructureDopingPropertyDict&quot; ) Parameters\tDescriptionname\tTo set the name of doping in simulation type\tThe method type of setting up doping. Selections are ['type', 'n', 'p']. property\tThe property of doping. 2.2.1 Function doping​ When type is set to &quot;n&quot; or &quot;p&quot;, function doping is applied. In this case, type also means the doping species, with &quot;n&quot; for donor and &quot;p&quot; for acceptor. You can configure parameters related to importing doping files by adjusting settings under the property.general sections. Example: st.add_doping(name=&quot;Uniform&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_uniform_x_center, &quot;x_span&quot;: p_uniform_x_span, &quot;y&quot;: p_uniform_y_center, &quot;y_span&quot;: p_uniform_y_span, &quot;z&quot;: p_uniform_z_center, &quot;z_span&quot;: p_uniform_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: p_uniform_con}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat_si&quot;]]}}) Parameters\tDefault\tType\tNotesgeometry.x\t-\tfloat\tThe x-coordinate of the center point position of doping box. geometry.x_span\t-\tfloat\tThe length in x direction of the doping. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data doping box. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of doping box. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of doping box. geometry.y_span\t-\tfloat\tThe width in y direction of the doping. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of doping box. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of doping box. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of doping box. geometry.z_span\t-\tfloat\tThe thinckness in z direction of doping box. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of doping box. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of doping box. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. general.distribution_function\t-\tstr\tTo set the type of distribution function for doping region. Selections are ['constant', 'gaussian']. When it's set to 'constant', constant doping is applied and only 'concentration' is required. When it's set to 'gaussian', Gaussian function doping is applied, and 'concentration', 'ref_concentration', 'junction_width', 'source_face' are required. general.concentration\t-\tfloat\tTo set the doping concentration in non-diffusion area. general.source_face\t-\tstr\tTo set the doping source surface. Available when distribution_function is 'gaussian'. Selections are ['low_x', 'low_y','low_z'].'lower_x' means the source face is 'x=x_min'. Similarly for the rest. There is no diffusion area on the edge of source face. As for the other edges, there is a diffusion area respectively within the doping box. general.junction_width\t-\tfloat\tTo set the junction width. Available when distribution_function is 'gaussian' general.ref_concentration\t-\tfloat\tConcentration on the edge of diffusion area (edge of doping box). Available when distribution_function is 'gaussian'. volume.volume_type\t'all'\tstr\tThe default of 'all' means the doping is applied to all the (semiconductor) structures, restricted by the doping box. Selections are ['all', 'material', 'region'] volume.material_list\t-\tlist\tIt means the doping is applied to the structures of the specified materials and restricted by the doping box. Available when volume_type is 'material'. volume.region_list\t-\tlist\tIt means the doping is applied to the specified structures and restricted by the doping box. Available when volume_type is 'region' 2.2.2 Imported doping​ When type is set to 'ile', doping is imported from a file. Example: st.add_doping(name=&quot;import_n&quot;, type=&quot;file&quot;, property={ &quot;general&quot;: {&quot;format&quot;: &quot;DOP&quot;, &quot;file_path&quot;: n_dop_file, &quot;species&quot;: &quot;n&quot;}}) Parameters\tDefault Type Notesgeneral.format\t-\tstr\tSet the format of doping file. Only &quot;DOP&quot; is supported currently. Selections are ['DOP']. When it's set to &quot;DOP&quot;, the doping file is a text file that stores a doping profile in rectangular grid. There are three columns in the file, which are the first dimension coordinate [um], the second dimension coordinate [um] and the doping concentration [cm^-3] respectively. Doping concentration should be non-negative. general.file_path\t-\tstr\tThe absolute path of the doping file general.species\t-\tstr\tTo set the doing species. Selections are ['n', 'p']. volume.volume_type\t'all'\tstr\tTo set a list of regions or materials for doping. Selections are ['all', 'material', 'region']. volume.material_list\t-\tlist\tAvailable when volume_type is 'material' volume.region_list\t-\tlist\tAvailable when volume_type is 'region' 2.3 Add electrode​ In this section, we will demonstrate how to integrate electrode structures into optoelectronic simulations using the provided code. Currently, the platform allows configuring both steady-state and transient voltages for the electrodes. Detailed code descriptions and specific examples are provided below for reference. add_electrode( self, *, name: str, property: StructureElectrodeProperty, ) Parameters Description name\tTo set the name of eelectrode in simulation. property\tTo set the property of electrode in simulation. 2.3.1 Steady state​ When the property bc_mode is set to &quot;steady_state&quot;, the steady state boundary condition is applied. Example: st = pj.Structure() st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) Parameters\tDefault\tType\tNotesforce_ohmic\ttrue\tbool\tWhether the electrode is ohmic, default to be True. Currently only ohmic contact is supported, so force_ohmic can't be set to False. bc_mode\tsteady_state\tstring\tTo set the type of electircal boundary condition. Selections are ['steady_state',transient]. apply_AC_small_signal\tnone\tstring\tDetermining whether to apply the small-signal alternating current. Selections are ['none', 'All']. When it's set to &quot;none&quot;, no AC small signal is applied at each sweeping voltage. When it's set to &quot;All&quot;, the AC small signal is applied after steady state simulation at each sweeping voltage sweep_type\tsingle\tstring\tTo set the voltage type of the electrode. Selections are ['single', 'range', 'value']. v_step_max\t0.5\tfloat\tThe maxium step of voltage value. voltage\t0\tfloat\tThe value of voltage. Available when sweep_type is 'single' range_start\t0\tfloat\tThe start value of a voltage range. Available when sweep_type is 'range' range_stop\t1\tfloat\tThe stop value of a voltage range. Available when sweep_type is 'range' range_interval\t1\tfloat\tThe interval value of a voltage range. Available when sweep_type is 'range' range_num_points\t2\tinteger\tThe The number of points within the voltage range. Available when sweep_type is 'range' []sweep_value_table.index\t-\tinteger\tThe index table of voltage values. Available when sweep_type is 'value'. []sweep_value_table.number\t-\tfloat\tThe value table of voltage. Available when sweep_type is 'value'. surface_type\tsolid\tstring\tTo set the surface type of electrode. Currently only 'solid' is supported, meaning that all the surfaces of a structure are selected. solid\t-\tstring\tName of the structure to be set as an electrode. Available when surface_type is set to 'solid'. 2.3.2 SSAC (Small signal alternating current)​ When solving the frequency response of optical signal for the device, transient simulation should be performed. In this case, the bc_mode of the corresponding electrode should be set to &quot;transient&quot;, and the solver_mode of OEDevice solver should be set to &quot;transient&quot;, too. In most of other cases, steady state or SSAC simulation is needed, the 'bc_mode' of electrodes should be 'steady_state'. When solving capacitance and resistance with respect to frequency, SSAC simulation is required. The solver_mode of OEDevice solver should be set to &quot;SSAC&quot;, and the apply_AC_small_signal of the corresponding electrode should be set to &quot;All&quot;. When running steady state simulation, just set the solver_mode of OEDevice solver to 'steady_state'. Example: st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;All&quot;}) 2.3.3 Transient​ When the property bc_mode is set to &quot;transient&quot;, the transient boundary condition is applied. Example: st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: tcad_vbias, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 2.001e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 30e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.001e-12, &quot;time_stop&quot;: 2.01e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 60e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.01e-12, &quot;time_stop&quot;: 2.03e-12, &quot;initial_step&quot;: 60e-18, &quot;max_step&quot;: 2e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.03e-12, &quot;time_stop&quot;: 10e-12, &quot;initial_step&quot;: 2e-15, &quot;max_step&quot;: 50e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 10e-12, &quot;time_stop&quot;: 500e-12, &quot;initial_step&quot;: 50e-15, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}]}) Parameters\tDefault\ttype\tNotesforce_ohmic\ttrue\tbool bc_mode\t-\tstring\tSelections are ['transient']. voltage\t0\tfloat\tSet the voltage that is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation. v_step_max\t-\tstring\tSet the max step of the voltage from the equilibrium state to steady state at the bias of voltage. []time_table.time_start\t-\tfloat\tSet the start time point of the range. The value of 0 represents the steady state of the earlier simulation. []time_table.time_stop\t-\tfloat\tSet the stop time point of the range. []time_table.initial_step\t-\tfloat\tSet the initial time step of the range []time_table.max_step\t-\tfloat\tSet the max time step of the range []time_table.optical.enabled\t0\tinteger\tWhether to apply optical generation rate during the time range. The value of 1 means True, and 0 means False. Selections are [0, 1]. []time_table.optical.envelop\t-\tinteger\tThe envelop of the scaling factor of the light power during the time range. When it's set to 0, the envelop is uniform. Selections are [0]. []time_table.optical.source_fraction\t-\tfloat\tWhen envelop is set to0, this value is the scaling factor of the light power during the time range. surface_type\tsolid\tstring\tSelections are ['solid']. solid\t-\tstring\tAvailable when surface_type is set to 'solid'. 2.4 Add surface recombination​ While conducting optoelectronic simulations, you can incorporate surface recombination into the simulation structure using the following code. add_surface_recombination( self, *, name: str, property: AddSurfaceRecombination, ) Parameters\tDescriptionname\tTo set the name of surface recombination in simulation. property\tTo set the property of surface recombination in simulation. Example: st.add_surface_recombination(name=&quot;Cathode_Si&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;MetalOhmicInterface&quot;, &quot;domain_1&quot;: &quot;Cathode&quot;, &quot;domain_2&quot;: &quot;Si_base&quot;, &quot;infinite_recombination&quot;: False, &quot;velocity_electron&quot;: 1e7, &quot;velocity_hole&quot;: 1e7}) Parameters\tDefault\tType\tNotessurface_type\tdomain_domain\tstring\tTo set the type for calculating surface recombination. Selections are ['domain_domain', 'material_material']. interface_type\tnull\tstring\tTo set the interface type of surface recombination. Selections are ['null', 'InsulatorInterface', 'HomoJunction', 'HeteroJunction', 'MetalOhmicInterface', 'SolderPad']. 'InsulatorInterface' is interface between semiconductor and insulator, 'HomoJunction' means the interface between homogeneous semiconductor and semiconductor,'HeteroJunction' means the interface between heterogeneous semiconductor and semiconductor, 'MetalOhmicInterface' means the interface between semiconductor and conductor, 'SolderPad' means the interface between conductor and insulator. infinite_recombination\ttrue\tbool\tOnly available when interface_type is &quot;MetalOhmicInterface&quot;. The surface recombination velocity of holes and electrons will be available when infinite_recombination is False. velocity_hole\t0\tfloat\tTo define surface recombination velocity of holes. Available when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' velocity_electron\t0\tfloat\tTo define surface recombination velocity of electron. Available when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' domain_1\t-\tstring\tThe region 1 for surface recombination. Available when surface_type is 'domain_domain' domain_2\t-\tstring\tThe region 2 for surface recombination. Available when surface_type is 'domain_domain' material_1\t-\tmaterial\tThe material 1 for surface recombination. Available when surface_type is 'material_material' material_2\t-\tmaterial\tThe material 2 for surface recombination. Available when surface_type is 'material_material'","keywords":""},{"title":"Preview","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/7Preview","content":"Preview In this section, we currently offer the capability to provide an advanced preview of structural models, refractive index and doping profile. This preview serves to validate the structues before initiating the formal simulation, thereby assisting in verifying the accuracy of the structures. Consequently, it leads to reduced simulation time and an overall enhancement of simulation efficiency. 7.1 Run index​ The code contained in this module enables a preview of the refractive index images with various structures. run_index( self, *, property: RunIndex, name: str, export_csv: bool = False, show: bool = False, savepath: str = 'a', export_n: bool = True, export_c: bool = False, max_index: Optional[int] = None, max_sigma: Optional[int] = None, ) Parameters\tDescriptionproperty\tTo set the properties of index monitor. name\tThe name of index monitor in the simulation. export_csv\tDecide whether to export the data as csv format or not. The default is False. show\tDecide whether to show index preview figure or not. The default is False. savepath\tDefine the save path for the csv data and the picture. The default is 'a'. export_n\tDecide whether to export the real part of index ,such as nx, ny, nz... . The default is True. export_c\tDecide whether to export the imaginary part of index, such as σx, σy, σz... . The default is False. max_index\tThe maximum index of heatmap colorbar. The default is None. max_sigma\tThe maximum sigma of heatmap colorbar.The default is None. Example: simu[simu_name].run_index(name=f'{simu_name}_x_0', savepath=f'{plot_path}{k}IndexPreview_x=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 2}}) Parameters\tDefault\tType\tNotesgeometry.monitor_type\t-\tstring\tSet the orientation of the index monitor. The selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the index monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the index monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the index monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the index monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the index monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the index monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the index monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the index monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the index monitor. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the index monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the index monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the index monitor. 7.2 Structure show and show 3D​ This portion of the code is primarily intended for show structure. Please note that this method becomes invalid if the current structure manager contains Pyramid or Arc-Waveguide 3D type geometries. structure_show( self, *, mode=&quot;XY&quot;, show: bool, savepath: str, fig_type: Literal[&quot;png&quot;, &quot;svg&quot;] = &quot;png&quot;, simulation_name: Optional[str] = None, disabled_components: Tuple[ Literal[ &quot;materials&quot;, &quot;helpers&quot;, &quot;box&quot;, &quot;box.coordinate&quot;, &quot;box.cavity&quot;, &quot;ModeSource&quot;, &quot;PowerMonitor&quot;, &quot;ProfileMonitor&quot;, &quot;FDTDPortGroup&quot;, ], ... ] = tuple(), xyratio=(1, 1), celldisplay=False ) Parameters\tDescriptionmode\tSpecify the orientation of the structure preview function. show\tDecide whether to show directly the preview of structure directly in the related software.If set to False, the picture will be saved instead. savepath\tDecide the save path of the preivew picture. fig_type\tDecide the suffix(type) of the preivew picture. simulation_name\tThe simulation name. disabled_components\tDisable the components from showing. xyratioZoom multiplier of x and y direction.\tZoom multiplier of x and y direction. celldisplay\tWhether to show eme cells. Show 3D structure in a pop up windows. show3d(self, show_with: Literal[&quot;webviewer&quot;, &quot;matplotlib&quot;，&quot;local_gui&quot;] = &quot;webviewer&quot;) Parameters\tDescriptionshow_with\tChoose the type of display. The selection are &quot;webviewer&quot;, &quot;matplotlib&quot;，&quot;local_gui&quot;. The &quot;webviewer&quot; will start a server and toggle a browser windows. &quot;matplotlib&quot; will toggle a Axes3D windows. Default as &quot;webviewer&quot;. Example: st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}{kL[0]}{simu_name}', simulation_name=simu_name) simu[simu_name].show3d(show_with=&quot;local_gui&quot;) 7.3 Run doping​ The code within this module enables the preview of doping results for the respective structures. run_doping( self, name: str, property: RunDopingPostProcess, norm: str, scale: str, superimpose: bool, show: bool, material_list: list, cmin: float, savepath: str ) Parameters\tDescriptionproperty\tThe properties of doping preview. name\tThe name of doping preview. show\tDecide whether to show directly the preview of structure directly in the related software.If set to False, the picture will be saved instead. savepath\tThe save path for picture. norm\tThe normalization of colorbar. Selections are ['linear', 'log']. Default as 'linear'. scale\tThe type of pcture scale. Selections are ['equal', 'auto']. Default as 'equal'. superimpose\tSuperimpose doping on structure or not. Default as True. material_list\tSpecified material type list. Default as []. region_list\tSpecified region name list. Default as []. Superior to material_list when not empty. cmax\tMaximum concentration of heatmap colorbar. Default as None. cmin\tMinimum concentration of heatmap colorbar. Default as None. Example: simu[&quot;preview_oedevice&quot;].run_doping(name=&quot;x_in&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}}, norm=&quot;log&quot;, scale=&quot;equal&quot;, superimpose=False, show=False, material_list=[&quot;Ge&quot;, &quot;Si&quot;], cmin=8e5, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;doping_x_in&quot;) Parameters\tDefault\tType\tNotesgeometry.dimension string\tSet the orientation of the doping region. The selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the doping region. geometry.x_span\t-\tfloat\tThe length in x direction of the doping region. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the doping region. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the doping region. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the doping region. geometry.y_span\t-\tfloat\tThe width in y direction of the doping region. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the doping region. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the doping region. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the doping region. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the doping region. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the doping region. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the doping region.","keywords":""},{"title":"Simulation","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/6Simulation","content":"Simulation In the forthcoming code segment, we will showcase examples of simulation, accompanied by their parameter lists. This will aid you in achieving a simulation project. Our platform will offer support for a variety of simulation modules, encompassing both optical and electrical simulation. These may include FDE, FDTD, OEDevice modules, ensuring an expansive electro-optical simulation capabilities. add( self, *, name: str, type: &quot;SimulationTypeSelection&quot;, property: Any, **kwargs, ) Parameters\tDescriptionname\tThe name of simulation defined in the project. type\tTo decide the type of simulation. location\tThe method of running simulation, choose either cloud or local. property\tThe property of simulation defined. **kwargs\tOther simulation parameters. &quot;source_name&quot; is needed for &quot;mode_selection:user_select&quot; type simulation. 6.1 FDE​ Incorporate a FDE solver into the current project using the code type='FDE'. add( self, *, name: str, type: Literal[&quot;FDE&quot;], property: FdePostProcess, ) Example: simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={ # 'general': {'solver_type': '2d_x_normal'}, # default is '2d_x_normal' ['2d_x_normal','2d_y_normal','2d_z_normal'] 'mesh_settings': { 'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'search': 'max_index', # ['near_n','max_index'] # 'n': 2, 'calculate_group_index': False, 'mode_removal': {'threshold': 0.02}, # 'bent_waveguide': {'bent_waveguide': False, 'radius': 1, 'orientation': 0, 'location': 'simulation_center'} }, &quot;frequency_analysis&quot;: { &quot;frequency_analysis&quot;: run_options.run_frequency_sweep, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 2.7, &quot;detailed_dispersion_calculation&quot;: False }}}) Parameters\tDefault\tType\tNotesgeneral.solver_type\t2d_x_normal\tstring\tTo decide the type of simulation. Selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. mesh_settings.global_mesh_uniform_grid.dx\t0.02\tfloat\tThe global mesh step in the x direction. mesh_settings.global_mesh_uniform_grid.dy\t0.02\tfloat\tThe global mesh step in the y direction. mesh_settings.global_mesh_uniform_grid.dz\t0.02\tfloat\tThe global mesh step in the z direction. mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat\tThe minimum mesh step in the simulation ragion. thread_setting.thread\t4\tinteger\tDetermine the number of cores required to run the simulation on the local computer. fde_analysis.modal_analysis.mesh_structure\tfalse\tbool\tConfirm whether to generate a refractive index diagram for the structure. fde_analysis.modal_analysis.calculate_modes\tfalse\tbool\tDetermine whether to calculate the modes. fde_analysis.modal_analysis.wavelength\t1.55\tfloat\tThe mode wavelength for FDE calculation. fde_analysis.modal_analysis.wavelength_offset\t0.002\tfloat\tThe mode wavelength offset for FDE calculation. fde_analysis.modal_analysis.number_of_trial_modes\t5\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. fde_analysis.modal_analysis.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. fde_analysis.modal_analysis.n\t1\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the source mode. fde_analysis.modal_analysis.calculate_group_index\tfalse\tbool\tDetermine whether to calculate the group refractive index. fde_analysis.modal_analysis.mode_removal.threshold\t-\tfloat\tScreen the FDTD port source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission FDTD port mode. fde_analysis.frequency_analysis.frequency_analysis\tfalse\tbool\tDetermine whether to invoke frequency analysis. fde_analysis.frequency_analysis.start_wavelength\t-\tfloat\tSet the start frequency of the frequency analysis. fde_analysis.frequency_analysis.stop_wavelength\t-\tfloat\tSet the stop frequency of the frequency analysis. fde_analysis.frequency_analysis.number_of_points\t10\tinteger\tSet the number of points in the frequency analysis fde_analysis.frequency_analysis.effective_index\t1.0\tfloat\tTo search the mode near this refractive index. fde_analysis.frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\tDetermine whether to calculate the dispersion of structure. 6.1.1 Mode selection​ For quick previewing structure index or getting convinent mode calculation, we integrate a FDE mode selection into the FDTD simulation project. add( self, *, name: str, simulation_name: str, source_name: str = &quot;&quot;, cell_group_index: int = 0, type: Literal[&quot;mode_selection:user_select&quot;], property: ModeSelectionUserSelectPostProcess, ) Example: simu = pj.Simulation() simu.add(name=simu_name+'_cal_mode', simulation_name=simu_name, source_name='source', type='mode_selection:user_select', property={'modal_analysis': {'calculate_modes': True, 'mesh_structure': True, 'wavelength': wavelength, 'number_of_trial_modes': 20, 'search': 'max_index', 'calculate_group_index': True }}) src_res = simu[f'{simu_name}_cal_mode'].run() src_res.extract(data='calculate_modes', savepath=f'{plot_path}{kL[2]}_Preview_SourceMode', attribute='E', mode=0, real=True, imag=True, **export_options, show=False) Parameters\tDefault\tType\tNotesmodal_analysis.mesh_structure\tfalse\tbool\tConfirm whether to generate a refractive index diagram for the structure. modal_analysis.calculate_modes\tfalse\tbool\tConfirm whether to calculate the mode for the structure. modal_analysis.wavelength\t1.55\tfloat\tThe mode wavelength for FDE calculation. modal_analysis.wavelength_offset\t0.002\tfloat\tThe mode wavelength offset for FDE calculation. modal_analysis.number_of_trial_modes\t20\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. modal_analysis.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. modal_analysis.n\t1\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the source mode. modal_analysis.calculate_group_index\tfalse\tbool\tDetermine whether to calculate the group refractive index. modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in bent waveguides. modal_analysis.bent_waveguide.radius\t1.0\tfloat\tSet the waveguide radius for bent waveguides. modal_analysis.bent_waveguide.orientation\t0.0\tfloat\tThe bent direction of the waveguide. modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. modal_analysis.mode_removal.threshold\t-\tfloat\tScreen the FDTD port source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission FDTD port mode. frequency_analysis.frequency_analysis\tfalse\tbool\tDetermine whether to invoke frequency analysis. frequency_analysis.start_wavelength\t1.55\tfloat\tSet the start frequency of the frequency analysis. frequency_analysis.stop_wavelength\t1.49896\tfloat\tSet the stop frequency of the frequency analysis. frequency_analysis.number_of_points\t10\tinteger\tSet the number of points in the frequency analysis frequency_analysis.effective_index\t1.0\tfloat\tTo search the mode near this refractive index. frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\tDetermine whether to calculate the dispersion of structure. 6.1.2 Beam overlap​ Calculating beam overlap involves a two-step process within the FDE module. Firstly, it's necessary to acquire the FDE beam results and extract the relevant data. run_fde_beam_and_extract(self, *, property, export_csv=False, show=False, savepath=&quot;&quot;) Parameters\tDescriptionproperty\tSet the property of beam to calculate overlap. export_csv\tWhether to save a file as csv format, defaults to False. show\tWhether to show figure or not, defaults as False savepath\tThe save path of heatmap and csv. Subsequently, we can execute the FDE overlap function and extract the result. run_fde_overlap_and_extract(self, *, property, savepath=&quot;a&quot;, export_csv=False) Parameters\tDescriptionproperty\tSet the property of overlap calculation. savepath\tSave path of csv, defaults to &quot;a&quot;. export_csv\tWhether to export csv, defaults to False. Example: beam_res = simu[simu_name].run_fde_beam_and_extract( property={ &quot;define_gaussian_beam_by&quot;: &quot;waist_size_and_position&quot;, # [waist_size_and_position,beam_size_and_divergence], &quot;waist_radius&quot;: 10, &quot;distance_from_waist&quot;: 0, &quot;refractive_index&quot;: 1, &quot;theta&quot;: 0, &quot;phi&quot;: 0, &quot;polarization_angle&quot;: 0, &quot;sample_span&quot;: 10, &quot;sample_resolution&quot;: 200}, savepath=plot_path + 'beam_heatmap') overlap_res = simu[simu_name].run_fde_overlap_and_extract( property={&quot;add_global_mode&quot;: {&quot;task_path&quot;: beam_res.task_path, &quot;mode&quot;: 0}, &quot;mode&quot;: 0, &quot;optimize_position&quot;: True}, export_csv=True, savepath=plot_path + 'overlap') 6.1.3 Bent Waveguide FDE simulation​ Calculating the mode of a bent waveguide within the FDE module. simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={'general': {'solver_type': '2d_x_normal'}, 'mesh_settings': {'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}}, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'calculate_group_index': True, 'bent_waveguide': {'bent_waveguide': True, 'radius': 5.25, 'orientation': 0, 'location': 'simulation_center'}}}}) Parameters\tDefault\tType\tNotesfde_analysis.modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in bent waveguides. fde_analysis.modal_analysis.bent_waveguide.radius\t0.0\tfloat\tSet the waveguide radius for bent waveguides. fde_analysis.modal_analysis.bent_waveguide.orientation\t0.0\tfloat\tThe bent direction of the waveguide. fde_analysis.modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. 6.1.4 Far field​ To compute the far-field pattern within the FDE module. simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={'general': {'solver_type': '2d_z_normal'}, 'mesh_settings': {'global_mesh_uniform_grid': {'dx': grid, 'dy': grid}}, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'far_field_settings': [{'calculate': run_options.run_far_field, 'mode_selection': 0, 'material_index': 3.7, 'farfield_filter': 0, 'projection_distance': 8000, 'points_in_x': 50, 'points_in_y': 50, 'farfield_x_span': 40, 'farfield_y_span': 40, 'farfield_x': 0, 'farfield_y': 0}]}}}) Parameters\tDefault\tType\tNotesfde_analysis.modal_analysis.[]far_field_settings.calculate\ttrue\tbool\tDetermine whether to calculate the far field. fde_analysis.modal_analysis.[]far_field_settings.mode_selection\t-\tinteger\tSelect the mode for which far-field calculation is needed. fde_analysis.modal_analysis.[]far_field_settings.projection_method\tplanar\tstring\tSpecify the projection type for calculating the far-field.Selections are ['planar']. fde_analysis.modal_analysis.[]far_field_settings.farfield_filter\t0\tfloat\tConfigure this parameter to filter near field data for eliminating high frequency ripples in the results. Its value ranging from 0 to 1. fde_analysis.modal_analysis.[]far_field_settings.material_index\t1.4\tfloat\tSet the material refractive index for projection. fde_analysis.modal_analysis.[]far_field_settings.projection_distance\t4430.65\tfloat\tThe distance for far-field projection calculation. fde_analysis.modal_analysis.[]far_field_settings.points_in_x\t50\tfloat\tIn x direction, the number of points in the far field. fde_analysis.modal_analysis.[]far_field_settings.points_in_y\t50\tfloat\tIn y direction, the number of points in the far field. fde_analysis.modal_analysis.[]far_field_settings.farfield_x\t0\tfloat\tIn x direction, the position of far field center point. fde_analysis.modal_analysis.[]far_field_settings.farfield_x_span\t26.1834\tfloat\tIn x direction, the span of far field range. fde_analysis.modal_analysis.[]far_field_settings.farfield_y\t0\tfloat\tIn y direction, the position of far field center point. fde_analysis.modal_analysis.[]far_field_settings.farfield_y_span\t18.1231\tfloat\tIn y direction, the span of far field range. 6.2 EME​ Incorporate an EME solver into the current project using the code type='EME'. add( self, *, name: str, type: Literal[&quot;EME&quot;], property: EmePostProcess, ) Example: simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 200, &quot;cell_number&quot;: 30, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 3, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_3&quot;, &quot;start&quot;: 50, &quot;stop&quot;: 250, &quot;number_of_points&quot;: 5}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) Parameters\tDefault\tType\tNotesgeneral.wavelength\t-\tfloat\tSpecify the wavelength for EME simulation. general.wavelength_offset\t0.002\tfloat\tSet the offset of wavelength in EME simulation. general.use_wavelength_sweep\tfalse\tbool\tConfirm whether to invoke wavelength sweep. eme_setup.cell_geometry.energy_conservation\tmake_passive\tstring\tSet the type of energy conservation when calculating the S matrix. Selections are ['none', 'make_passive']. eme_setup.cell_geometry.display_cells\tfalse\tbool\tConfirm whether to generate a preview of the EME cell when generating a structure preview. eme_setup.cell_geometry.display_groups\tfalse\tbool\tConfirm whether to generate a preview of the EME cell groups when generating a structure preview. eme_setup.cell_geometry.[]cell_group_definition.span\t-\tfloat\tSet the span of the cell group in EME simulation. eme_setup.cell_geometry.[]cell_group_definition.cell_number\t-\tinteger\tSet the number of the cell in EME simulation. eme_setup.cell_geometry.[]cell_group_definition.number_of_modes\t-\tinteger\tSet the number of the modes calculated in EME simulation. eme_setup.cell_geometry.[]cell_group_definition.sc\tnone\tstring\tSet the subcell method in EME simulation. Selections are ['none', 'sub_cell', 'sc']. eme_setup.cell_geometry.[]cell_group_definition.search\tmax_index\tstring\tCalculate the modes based on the maximum refractive index or user defined refractive index in the EME simulation. Selections are ['near_n', 'max_index']. eme_setup.cell_geometry.[]cell_group_definition.n\t1.0\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the modes in EME simulation. transverse_mesh_setting.global_mesh_uniform_grid.dx\t0.02\tfloat\tSet the global mesh grid of EME simulation region in x coordinate. transverse_mesh_setting.global_mesh_uniform_grid.dy\t0.02\tfloat\tSet the global mesh grid of EME simulation region in y coordinate. transverse_mesh_setting.global_mesh_uniform_grid.dz\t0.02\tfloat\tSet the global mesh grid of EME simulation region in z coordinate. transverse_mesh_setting.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat\tSet the minimum mesh step in EME simulation. advanced.eme_settings.max_stored_modes\t1000\tinteger\tThe maximum number of modes for EME simulation in each cell. thread_settings.thread\t4\tinteger\tDetermine the number of cores required to run the simulation on the local computer. eme_analysis.eme_propagate\tfalse\tbool\tDetermine whether to calculate the propogation fields and the s matrix. eme_analysis.periodicity.periodicity\tfalse\tbool\tSpecify whether to use periodicity to simplify structure in the EME simulation. eme_analysis.periodicity.[]periodic_group_definition.start_cell_group\t-\tinteger\tSet the start cell number for periodic structure. eme_analysis.periodicity.[]periodic_group_definition.end_cell_group\t-\tinteger\tSet the end cell number for periodic structure. eme_analysis.periodicity.[]periodic_group_definition.periods\t-\tinteger\tSet the repetition number of cells in the periodic structure. 6.2.1 EME CellGroup Custom Setting​ This section provides guidance on configuring a customized EME cell group according to your specifications. Example: simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: {&quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2.5, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: 30, &quot;sc&quot;: sc_method, &quot;search&quot;: &quot;max_index&quot;}, {&quot;span&quot;: 5.2, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: 50, &quot;sc&quot;: sc_method, &quot;search&quot;: &quot;max_index&quot;, &quot;n&quot;: 1.5}, {&quot;span&quot;: 2.5, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: 30, &quot;sc&quot;: sc_method, &quot;search&quot;: &quot;max_index&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_2&quot;, &quot;start&quot;: 41, &quot;stop&quot;: 61, &quot;number_of_points&quot;: 11}, &quot;wavelength_sweep&quot;: {&quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: wavelength - 0.05, &quot;stop&quot;: wavelength + 0.05, &quot;number_of_wavelength_points&quot;: 11}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) 6.2.2 EME Periodic Structure​ This section can guide you in configuring an EME periodic structure. Example: simu = pj.Simulation() simu.add(name=simu_name, type='EME', property={ 'general': {'wavelength': wavelength}, 'eme_setup': {'cell_geometry': { 'cell_group_definition': [ {'span': EME_marg, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}, {'span': wb, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}, {'span': ws, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}, {'span': EME_marg, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}]}}, 'transverse_mesh_setting': {'global_mesh_uniform_grid': {'dx':grid, 'dy': grid, 'dz': grid} }, 'eme_analysis': { 'eme_propagate': run_options.run, 'periodicity': {'periodicity': True, 'periodic_group_definition': [{'start_cell_group': 1, 'end_cell_group': 2, 'periods': grating_periods}]} }}) 6.2.3 EME propagation Sweep​ Example: simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 200, &quot;cell_number&quot;: 30, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 3, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_3&quot;, &quot;start&quot;: 50, &quot;stop&quot;: 250, &quot;number_of_points&quot;: 5}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) Parameters\tDefault\tType\tNoteseme_analysis.propagation_sweep.propagation_sweep\tfalse\tbool\tDetermine whether to sweep the length of structure for propagating in EME simulation. eme_analysis.propagation_sweep.parameter\tgroup_span_1\tstring\tSelect the cell group corresponding to the structure for which propagation sweep is needed. eme_analysis.propagation_sweep.start\t0\tfloat\tSet the starting length of the structure for propagation sweep. eme_analysis.propagation_sweep.stop\t1\tfloat\tSet the stopping length of the structure for propagation sweep. eme_analysis.propagation_sweep.number_of_points\t3\tinteger\tSet the number of points for propagation sweep. 6.2.4 EME wavelength Sweep​ Example: simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: L-1, &quot;cell_number&quot;: 10, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, ]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: global_mesh_grid, &quot;dz&quot;: global_mesh_grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;wavelength_sweep&quot;: { &quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: wavelength_start, &quot;stop&quot;: wavelength_stop, &quot;number_of_wavelength_points&quot;: wavelength_points}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) Parameters\tDefault\tType\tNoteseme_analysis.wavelength_sweep.wavelength_sweep\tfalse\tbool\tDecide whether to sweep the wavelength in EME simulaiton. eme_analysis.wavelength_sweep.start\t1.5\tfloat\tSet the starting wavelength in EME simulaiton. eme_analysis.wavelength_sweep.stop\t1.6\tfloat\tSet the stopping wavelength in EME simulaiton. eme_analysis.wavelength_sweep.number_of_wavelength_points\t3\tinteger\tSet the number of points in wavelength range. eme_analysis.select_source.phase\t0\tfloat\tSet the phase of selected source in EME simulation. eme_analysis.select_source.select_mode\t-\tstring\tSet the type of mode propagating in the EME simulation. 6.3 FDTD​ Incorporate an FDTD solver into the current project using the code type='FDTD'. add( self, *, name: str, type: Literal[&quot;FDTD&quot;], property: FdtdPostProcess, ) Example: simu = pj.Simulation() simu.add(name=simu_name, type='FDTD', property={'general': {'simulation_time': 10000, }, 'mesh_settings': {'mesh_type': 'auto_non_uniform', 'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}, 'minimum_mesh_step_settings': {'min_mesh_step': 1e-4}}, # 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-4, 'down_sample_time': 200}}, # 'thread_setting': {'thread': 4} }) Parameters\tDefault\tType\tNotesgeneral.dimension\t3d\tstring\tDetermine the dimension type of the FDTD simulation. Selections are ['3d']. general.using_optical_path_estimate_time\tfalse\tbool\tChoose whether to use the time evaluated by system running the FDTD simulation. general.simulation_time\t1000\tinteger\tSet the simulation time in FDTD simulation. mesh_settings.mesh_type\tauto_non_uniform\tstring\tDecide the type of mesh in FDTD simulation. Selections are ['auto_non_uniform', 'uniform']. mesh_settings.mesh_accuracy.cells_per_wavelength\t15\tinteger\tUnder the 'auto_non_uniform' condition, this parameter helps to set the mesh accuarcy by using cell number in per wavelength. mesh_settings.mesh_step_settings.dx\t0.1\tfloat\tUnder the 'uniform' condition, this parameter helps to set the mesh accuarcy by using cell length in x coordinent. mesh_settings.mesh_step_settings.dy\t0.1\tfloat\tUnder the 'uniform' condition, this parameter helps to set the mesh accuarcy by using cell length in y coordinent. mesh_settings.mesh_step_settings.dz\t0.1\tfloat\tUnder the 'uniform' condition, this parameter helps to set the mesh accuarcy by using cell length in z coordinent. mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat\tUnder the 'auto_non_uniform' condition, this parameter helps to set the minimum mesh step. advanced_options.auto_shutoff.use_early_shutoff\ttrue\tbool\tDecide whether to use early shutoff. advanced_options.auto_shutoff.auto_shutoff_min\t1.0e-4\tfloat\tControl the simulation shutoff based on the ratio of energy to the maximum input energy. advanced_options.auto_shutoff.down_sample_time\t100\tfloat\tInspect the auto shutoff conditions every down sample time. advanced_options.live_slice_filed_display_settings.show_field\tfalse\tbool\tDecide whether to gennerate the electric intensity filed image for the results. advanced_options.live_slice_filed_display_settings.select_field_section\t2d_z_normal\tstring\tDecide the type of the field image. Selections are ['2d_y_normal', '2d_z_normal']. advanced_options.live_slice_filed_display_settings.select_component\tex\tstring\tDecide the field component to show in the image. Selections are ['ex', 'ey', 'ez']. advanced_options.live_slice_filed_display_settings.time_interval\t200\tfloat\tSet the time interval for displaying image. advanced_options.live_slice_filed_display_settings.position\t0\tfloat\tSet the center position of the field image. thread_setting.thread\t4\tinteger\tDetermine the number of cores required to run the simulation on the local computer. 6.3.1 Far field​ This section can assist you in computing the far-field pattern within the FDTD module. fdtd_res = simu[simu_name].run() ff_res = fdtd_res.calculate( monitor_name=&quot;through&quot;, property={&quot;wavelength&quot;: 1.31, &quot;far_field_settings&quot;: { &quot;general&quot;: {&quot;projection_direction&quot;: &quot;forward&quot;, &quot;material_index&quot;: 1, &quot;far_field_filter&quot;: 0, &quot;resolution&quot;: {&quot;horizontal_points&quot;: 100, &quot;vertical_points&quot;: 100}}}}) 6.3.2 FDTD smatrix sweep​ When we use the FDTD port as the input source, we can assist you in computing the smatrix sweep within the FDTD module. # region --- Port --- pt = pj.Port(property={'waveform_id': wv[waveform_name], 'source_port': 'left_port'}) pt.add(name='left_port', type='fdtd_port', property={'geometry': {'x': -wg_length / 2 + span, 'x_span': 0, 'y': 0, 'y_span': port_width, 'z': 0, 'z_span': port_height}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'forward', 'mode_selection': 'fundamental'}}}) if run_options.matrix_sweep: pt.add(name='right_port', type='fdtd_port', property={'geometry': {'x': wg_length / 2 - span, 'x_span': 0, 'y': 0, 'y_span': port_width, 'z': 0, 'z_span': port_height}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'backward', 'mode_selection': 'fundamental'}}}) # endregion # region --- Simulation --- simu = pj.Simulation() simu.add(name='fdtd', type='FDTD', property={'general': {'simulation_time': 1000}, 'mesh_settings': {'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}}}) if run_options.matrix_sweep: smatrix_res = simu.add(name='matrix_sweep', type='FDTD:smatrix', property={'simulation_name': 'fdtd', 's_matrix_setup': [{'port': 'left_port', 'active': True}, {'port': 'right_port', 'active': True}]}) # endregion 6.4 Sweep:FDTD/FDE/EME​ Integrate a sweep module into the current project add( self, *, name: str, type: Literal[&quot;FDTD:sweep&quot;, &quot;FDE:sweep&quot;, &quot;EME:sweep&quot;], property: AnyParameterSweepPostProcess, ) An example of FDTD sweep is presented in the following code. Example: simu = pj.Simulation() simu.add(type='FDTD:sweep', name='FDTDSweep', property={ 'simulation_name': simu_name, 'sweep_type': 'values', 'parameters': [{ 'variable': gap, 'values': [0.45, 0.55, 0.65], }], 'result': [ {'name': resultL[0], 'result': 'through', 'component': 'T'}, {'name': resultL[1], 'result': 'cross', 'component': 'T'}, {'name': resultL[2], 'result': 'through_me', 'component': 'T_forward'}, {'name': resultL[3], 'result': 'cross_me', 'component': 'T_forward'} ] }) A FDE sweep is provided in the subsequent code example. simu = pj.Simulation() simu.add(type=&quot;FDE:sweep&quot;, name=&quot;FDESweep&quot;, property={ &quot;simulation_name&quot;: simu_name, &quot;sweep_type&quot;: &quot;values&quot;, &quot;parameters&quot;: [{&quot;variable&quot;: width, &quot;values&quot;: [0.5, 0.7, 0.9]}], &quot;result&quot;: [{&quot;name&quot;: result[0], &quot;component&quot;: &quot;mode2:neff&quot;, &quot;result&quot;: &quot;FDE:Structure Sweep&quot;}, {&quot;name&quot;: result[1], &quot;component&quot;: &quot;mode1:neff&quot;, &quot;result&quot;: &quot;FDE:Structure Sweep&quot;}, {&quot;name&quot;: result[2], &quot;component&quot;: &quot;mode1:loss&quot;, &quot;result&quot;: &quot;FDE:Structure Sweep&quot;}, ] }) An example of EME sweep is presented in the following code. simu = pj.Simulation() simu.add( type='EME:sweep', name='EMESweep', property={ 'simulation_name': simu_name, 'parameters': [ {'variable': gap, 'number_of_points': 3, 'start': 0.45, 'stop': 0.65} ], # 'sweep_type': 'values', # 'parameters': [ { 'variable': gap, 'values': [0.45, 0.55, 0.65] } ], 'result': [ {'name': 'SMatrix', 'component': 'S', 'result': 'S-Matrix'} ] }, ) Parameters\tDefault\tType\tNotessimulation_name\t-\tstring\tSet the sweep name in the simulation. sweep_type\tranges\tstring\tSet the type of valuse to sweep parameters in the simulation. Selections are ['ranges', 'values']. []parameters.variable float\tInvoke the specific variable for sweep. []parameters.start float\tUnder the 'ranges' circumstances, we can decide the initial value of the variable. []parameters.stop float\tUnder the 'ranges' circumstances, we can decide the stopping value of the variable. []parameters.number_of_points integer\tDecide the number of points in the range of variable. []parameters.values list\tUnder the 'values' circumstances, we can give the value of the variable. []result.name string\tSet the name in the sweep function. []result.result string\tGet the related results. []result.component string\tInvoke the related componet in results. 6.5 OEDevice​ Incorporate an OEDevice(Optic Eletrical Devices) solver into the current project using the code type='OEDevice'. add( self, *, name: str, type: Literal[&quot;OEDevice&quot;], property: OeDevicePostProcess, ) Example: simu = pj.Simulation() simu.add(name=&quot;preview_fdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}}) simu.add(name=&quot;preview_oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: &quot;&quot;, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}}) Parameters\tDefault\tType\tNotesgeneral.simulation_region\tDevice_Region\tstring\tSelections are ['Device_Region']. general.norm_length\t1\tfloat\tSpecifies a length to represent the un-simulated dimension for 2D simulations. general.solver_mode\tsteady_state\tstring\tTo set the simulation mode. Selections are ['steady_state', 'transient', 'SSAC']. general.temperature_dependence\tIsothermal\tstring\tTo set the type of temperature dependence. Selection only is ['Isothermal']. general.simulation_temperature\t300\tfloat\tTo set the simulation temperature. advanced.non_linear_solver\tNewton\tstring\tSet the iteration method of Netwon to solve the entire non-linear algebraic system. Selection is ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', ' LU', ' BCGS']. 'MUMPS' and 'LU' are direct linear solvers which usually give the exact solution. However, 'MUMPS' supports parallel computation while LU doesn't. ；'BCGS' is a Krylov subspace (KSP) iterative solver, which also supports parallel computation and is more efficient but can only give approximate results. advanced.use_quasi_fermi\tdisabled\tstring\tWhether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. Selections are ['disabled', ' enabled']. advanced.damping\tnone\tstring\tSet the nonlinear update damping scheme. Selections are ['none', ' potential']. advanced.potential_update\t1\tinteger\tSet the threshold potential for potential damping. The large value will reduce the strength of damping effect advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. When it's set to 'let_solver_choose', the solver will determine the number of threads to use. The default maximum number of threads is 4. When it's set to 'set_thread_count', the number of threads is set by the user to 'thread_count'. advanced.thread_count\t4\tinteger\tCustom number of threads. advanced.max_iterations\t30\tinteger\tSet global maximum number of iterations, available when 'use_global_max_iterations' is True. advanced.use_global_max_iterations\tfalse\tinteger\tSelections are ['false', 'true'].Whether to use global max iterations during the initialization of solving the Poisson equations and the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, default to be 'True'. advanced.poisson_max_iterations\t30\tinteger\tSet the max iterations during the initialization of solving the Poisson equations, available when 'use_global_max_iterations' is 'False'. advanced.ddm_max_iterations\t30\tinteger\tSet the max iterations during the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, available when 'use_global_max_iterations' is 'False'. advanced.relative_tolerance\t1.0e-5\tfloat\tSet the relative update tolerance. advanced.tolerance_relax\t1.0e+5\tfloat\tSet the tolerance relaxation factor for convergence on relative tolerance criteria. advanced.divergence_factor\t1.0e+25\tfloat\tNonlinear solver fault with divergence when each individual function norm exceeds the threshold as its absolute tolerance multiply by this factor. genrate.genrate_path string\tSet the absolute path of the optical generation rate file (gfile) genrate.source_fraction float\tSet the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport. genrate.coordinate_unit\tm\tstring\tSet the coordinate unit in the gfile. Selections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the OEDevice. geometry.x_span\t-\tfloat\tThe length in x direction of the OEDevice. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the OEDevice. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the OEDevice. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the OEDevice. geometry.y_span\t-\tfloat\tThe width in y direction of the OEDevice. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the OEDevice. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the OEDevice. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the OEDevice. geometry.z_span\t-\tfloat\tThe height in z direction of the OEDevice. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the OEDevice. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the OEDevice. small_signal_ac.perturbation_amplitude\t0.001\tfloat\tSet the voltage amplitude of the small signal. small_signal_ac.frequency_spacing\tsingle\tstring\tSet the spacing type of the frequency. Selections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat\tSet the value of the single frequency. small_signal_ac.start_frequency\t1.0e+06\tfloat\tSet the start frequency of linear spacing. small_signal_ac.stop_frequency\t1.0e+09\tfloat\tSet the stop frequency of linear spacing. small_signal_ac.frequency_interval\t9.9999e+10\tfloat\tSet the frequency interval of linear spacing. small_signal_ac.num_frequency_points\t2\tinteger\tSet the number of frequency points of linear spacing. small_signal_ac.log_start_frequency\t1.0e+06\tfloat\tSet the start frequency of logarithmic spacing. small_signal_ac.log_stop_frequency\t1.0e+10\tfloat\tSet the stop frequency of logarithmic spacing. small_signal_ac.log_num_frequency_points\t2\tinteger\tSet the number of frequency points of logarithmic spacing. 6.6 AFDTD​ Incorporate an AFDTD(Active Finite-Difference Time-Domain) solver into the current project using the code type='AFDTD'. add( self, *, name: str, type: Literal[&quot;AFDTD&quot;], property: FdtdPostProcess, ) Example: simu = pj.Simulation() simu.add(name=&quot;preview_fdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}}) Parameters\tDefault\tType\tNotesextra.fdtd_port_group.source_port string\tTo extra data of source port from the result of FDTD simulation. general.dimension\t3d\tstring\tSelections are ['3d']. general.using_optical_path_estimate_time\tfalse\tbool general.simulation_time\t1000\tinteger\tTo set the simulation time for transient simulation. mesh_settings.mesh_type\tauto_non_uniform\tstring\tSelections are ['auto_non_uniform', 'uniform']. mesh_settings.mesh_accuracy.cells_per_wavelength\t15\tinteger\tSet the mesh accuracy for region of FDTD simulation. mesh_settings.mesh_step_settings.dx\t0.1\tfloat\tSet the miniimum of spacing between mesh step centers in x direction. mesh_settings.mesh_step_settings.dy\t0.1\tfloat\tSet the miniimum of spacing between mesh step centers in y direction. mesh_settings.mesh_step_settings.dz\t0.1\tfloat\tSet the miniimum of spacing between mesh step centers in z direction. mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat\tSet the minimum vale of mesh step. advanced_options.auto_shutoff.use_early_shutoff\ttrue\tbool\tDecide whether to use early shutoff. advanced_options.auto_shutoff.auto_shutoff_min\t1.0e-4\tfloat\tControl the simulation shutoff based on the ratio of energy to the maximum input energy. advanced_options.auto_shutoff.down_sample_time\t100\tfloat\tInspect the auto shutoff conditions every down sample time. advanced_options.live_slice_filed_display_settings.show_field\tfalse\tbool\tDecide whether to gennerate the electric intensity filed image for the results. advanced_options.live_slice_filed_display_settings.select_field_section\t2d_z_normal\tstring\tSelections are ['2d_y_normal', '2d_z_normal']. advanced_options.live_slice_filed_display_settings.select_component\tex\tstring\tSelections are ['ex', 'ey', 'ez']. advanced_options.live_slice_filed_display_settings.time_interval\t200\tfloat\tSet the time interval for displaying image. advanced_options.live_slice_filed_display_settings.position\t0\tfloat\tSet the center position of the field image. thread_setting.thread\t4\tinteger\tDetermine the number of cores required to run the simulation on the local computer. 6.7 AFDE​ Integrate an AFDE(Active Finite Difference Eigenmode) solver into the current project using the code type='AFDE'. add( self, *, name: str, type: Literal[&quot;AFDE&quot;], property: AfdePostProcess, ) Example: simu = pj.Simulation() simu.add(name=&quot;preview_fde&quot;, type=&quot;AFDE&quot;, property={ &quot;mesh_settings&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: ogrid_global_y, &quot;dz&quot;: ogrid_global_z}}, &quot;fde_analysis&quot;: {&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: False, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength}, &quot;modulator_analysis&quot;: {&quot;modulator_analysis&quot;: True, &quot;wavelength&quot;: wavelength, &quot;np_path&quot;: &quot;&quot;}}, &quot;other&quot;: {**Si_index_vs_doping}}) Parameters\tDefault\tType\tNotesgeneral.solver_type\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. mesh_settings.global_mesh_uniform_grid.dx\t0.02\tfloat\tThe global mesh step in the x direction. mesh_settings.global_mesh_uniform_grid.dy\t0.02\tfloat\tThe global mesh step in the y direction. mesh_settings.global_mesh_uniform_grid.dz\t0.02\tfloat\tThe global mesh step in the z direction. mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat\tSet the minimum vale of mesh step. thread_setting.thread\t4\tinteger\tDetermine the number of cores required to run the simulation on the local computer. fde_analysis.modal_analysis.mesh_structure\tfalse\tbool\tConfirm whether to generate a refractive index diagram for the structure. fde_analysis.modal_analysis.calculate_modes\tfalse\tbool\tDetermine whether to calculate the modes. fde_analysis.modal_analysis.[]far_field_settings.calculate\ttrue\tbool\tDetermine whether to calculate the far field. fde_analysis.modal_analysis.[]far_field_settings.mode_selection integer\tSelect the mode for which far-field calculation is needed. fde_analysis.modal_analysis.[]far_field_settings.projection_method\tplanar\tstring\tSelections are ['planar']. fde_analysis.modal_analysis.[]far_field_settings.farfield_filter\t0\tfloat\tConfigure this parameter to filter near field data for eliminating high frequency ripples in the results. Its value ranging from 0 to 1. fde_analysis.modal_analysis.[]far_field_settings.material_index\t1.4\tfloat\tSet the material refractive index for projection. fde_analysis.modal_analysis.[]far_field_settings.projection_distance\t4430.65\tfloat\tThe distance for far-field projection calculation. fde_analysis.modal_analysis.[]far_field_settings.points_in_x\t50\tfloat\tIn x direction, the number of points in the far field. fde_analysis.modal_analysis.[]far_field_settings.points_in_y\t50\tfloat\tIn y direction, the number of points in the far field. fde_analysis.modal_analysis.[]far_field_settings.farfield_x\t0\tfloat\tIn x direction, the position of far field center point. fde_analysis.modal_analysis.[]far_field_settings.farfield_x_span\t26.1834\tfloat\tIn x direction, the span of far field range. fde_analysis.modal_analysis.[]far_field_settings.farfield_y\t0\tfloat\tIn y direction, the position of far field center point. fde_analysis.modal_analysis.[]far_field_settings.farfield_y_span\t18.1231\tfloat\tIn y direction, the span of far field range. fde_analysis.modal_analysis.wavelength\t1.55\tfloat\tThe mode wavelength for FDE calculation. fde_analysis.modal_analysis.wavelength_offset\t0.002\tfloat\tThe mode wavelength offset for FDE calculation. fde_analysis.modal_analysis.number_of_trial_modes\t5\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. fde_analysis.modal_analysis.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. fde_analysis.modal_analysis.n\t1\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the source mode. fde_analysis.modal_analysis.calculate_group_index\tfalse\tbool\tDetermine whether to calculate the group refractive index. fde_analysis.modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in bent waveguides. fde_analysis.modal_analysis.bent_waveguide.radius\t0.0\tfloat\tSet the waveguide radius for bent waveguides. fde_analysis.modal_analysis.bent_waveguide.orientation\t0.0\tfloat\tThe bent direction of the waveguide. fde_analysis.modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. fde_analysis.modal_analysis.mode_removal.threshold\t-\tfloat\tScreen the FDTD port source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission FDTD port mode. fde_analysis.frequency_analysis.frequency_analysis\tfalse\tbool\tDetermine whether to invoke frequency analysis. fde_analysis.frequency_analysis.start_wavelength\t-\tfloat\tSet the start frequency of the frequency analysis. fde_analysis.frequency_analysis.stop_wavelength\t-\tfloat\tSet the stop frequency of the frequency analysis. fde_analysis.frequency_analysis.number_of_points\t10\tinteger\tSet the number of points in the frequency analysis fde_analysis.frequency_analysis.effective_index\t1.0\tfloat\tTo search the mode near this refractive index. fde_analysis.frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\tDetermine whether to calculate the dispersion of structure.","keywords":""},{"title":"Extract result","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/8Extract","content":"","keywords":""},{"title":"8.1 FDE​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#81-fde","content":"In this section, we will provide examples for extracting simulation result data from FDE simulation, along with a description table of parameters. "},{"title":"8.1.1 Calculate mode result​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#811-calculate-mode-result","content":"Get the result of calculated mode. extract( self, *, # target - intensity data: Literal['calculate_modes'], attribute: PowerAttributes/ModeAttributes/OtherAttributes export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', mode: int, )  Example: result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_mode{m}', attribute='E', mode=m, real=True, imag=True, **export_options, show=False)  "},{"title":"8.1.2 Far-field FDE result​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#812-far-field-fde-result","content":"Get the result of calculated far-field FDE. extract( self, *, # target - table data: Literal['farfield_fde'], attribute: PowerAttributes, show=False, export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = 'a', mode: int, )  Example: fde_res.extract(data='farfield_fde', savepath=f'{plot_path}05_{simu_name}_far_field', attribute='E', mode=0, export_csv=True)  "},{"title":"8.1.3 Mesh structure result​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#813-mesh-structure-result","content":"To extract the result of meshing structure. extract( self, *, data: Literal['mesh_structure'], savepath:Any = 'a', target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, )  Example: simu.add(name=simu_name+&quot;_cal_mode&quot;, type=&quot;mode_selection:user_select&quot;, simulation_name=simu_name, source_name=&quot;source&quot;, property={&quot;modal_analysis&quot;: {&quot;mesh_structure&quot;: True, &quot;calculate_modes&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: 10, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True}})  "},{"title":"8.1.4 Frequency analysis result​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#814-frequency-analysis-result","content":"To extract the result of frequency analysis. extract( self, *, target: Literal['line'] = 'line', data: Literal['frequency_analysis'], attribute: Literal['neff', 'group_index', 'loss', 'polarization'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None )  Example: result_fde.extract(data=&quot;frequency_analysis&quot;, savepath=f'{plot_path}{k}_freq_sweep_neff', attribute=&quot;neff&quot;, real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"8.2 EME​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#82-eme","content":"To extract the relevant data of EME module. "},{"title":"8.2.1 EME propagate:facet data​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#821-eme-propagatefacet-data","content":"Get the result of calculated facet data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:facet_data', ], export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = 'a', )  Example: eme_res.extract(data='eme_propagate:facet_data', savepath=plot_path, real=True, imag=True, export_csv=True)  "},{"title":"8.2.2 EME propagate:monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#822-eme-propagatemonitor","content":"Get the result of monitor data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:monitor', ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract( data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_y_normal&quot;, monitor_name=&quot;y_normal&quot;, attribute=&quot;E&quot;, export_csv=True)  "},{"title":"8.2.3 Propagation sweep:monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#823-propagation-sweepmonitor","content":"Get the result of monitor data of propagation sweep. extract( self, *, data: Literal[ 'propagation_sweep:monitor', ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True)  "},{"title":"8.2.4 Wavelength sweep:monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#824-wavelength-sweepmonitor","content":"Get the result of monitor data of wavelength sweep. extract( self, *, data: Literal[ 'wavelength_sweep:monitor', ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True)  "},{"title":"8.2.5 EME propagate:smatrix​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#825-eme-propagatesmatrix","content":"Get the result of smatrix data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:smatrix', ], target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True)  "},{"title":"8.2.6 EME propagate:port mode infomation​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#826-eme-propagateport-mode-infomation","content":"Get the result of port mode data of EME propagation. extract( self, *, # target - intensity data: Literal['eme_propagate:port_mode_info'], target: Literal['intensity'] = 'intensity', attribute: Literal['E', 'H'], port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, )  Example: eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True)  "},{"title":"8.2.7 EME propagate:port mesh structure​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#827-eme-propagateport-mesh-structure","content":"Get the result of port mesh structure data of EME propagation. extract( self, *, # target - intensity data: Literal['eme_propagate:port_mesh_structure'], port_name: str, target: Literal['line', 'intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data='eme_propagate:port_mesh_structure', savepath=f'{plot_path}{kL[3]}_eme_structure_{port_name}', port_name=port_name, target='intensity', # plot_x='y', plot_y='z', export_csv=False, show=False )  "},{"title":"8.2.8 EME propagate:cell mesh structure​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#828-eme-propagatecell-mesh-structure","content":"Get the result of cell mesh structure data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:cell_mesh_structure', ], target: Literal[&quot;intensity&quot;, &quot;line&quot;], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data='eme_propagate:cell_mesh_structure', savepath=f'{plot_path}{kL[4]}_eme_c{cell_index}_index', cell_params='c' + str(cell_index), target='intensity', plot_x='y', plot_y='z', # export_csv=False, show=False )  "},{"title":"8.2.9 EME propagate:port overlap​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#829-eme-propagateport-overlap","content":"Get the result of port overlap data of EME propagation. def extract( self, *, data: Literal[ 'eme_propagate:port_overlap', ], target: Literal['line'] = 'line', port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  "},{"title":"8.2.10 EME propagate:cell mode information​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#8210-eme-propagatecell-mode-information","content":"Get the result of cell mode information of EME propagation. extract( self, *, target: Literal['intensity'] = 'intensity', data: Literal[ 'eme_propagate:cell_mode_info', ], attribute: Literal['E', 'H'], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, )  "},{"title":"8.2.11 EME propagate:propagation field​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#8211-eme-propagatepropagation-field","content":"Get the result of propagation field of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:prop_field', ], # target: intensity&quot;, attribute:PowerAttributes, cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  "},{"title":"8.2.12 EME propagate:internal S​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#8212-eme-propagateinternal-s","content":"Get the result of internal S data of EME propagation. extract( self, *, data: Literal[ &quot;eme_propagate:internal_s&quot;, ], target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  "},{"title":"8.2.13 EME propagate:cell p matrix/cell overlap/cell S/propagation S​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#8213-eme-propagatecell-p-matrixcell-overlapcell-spropagation-s","content":"Get the result of cell p matrix/cell overlap/cell S/propagation S data of EME propagation.  def extract( self, *, data: Literal[ &quot;eme_propagate:cell_p_matrix&quot;, &quot;eme_propagate:cell_overlap&quot;, &quot;eme_propagate:cell_s&quot;, &quot;eme_propagate:prop_s&quot;, ], target: Literal['intensity'] = 'intensity', cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  "},{"title":"8.3 FDTD​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#83-fdtd","content":"To extract the relevant data of FDTD module. "},{"title":"8.3.1 FDTD:power monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#831-fdtdpower-monitor","content":"Get the result of power monitor data of FDTD. extract( self, *, data: Literal['fdtd:power_monitor'], target: Literal['intensity', 'line'], attribute: Union[PowerAttributes, Literal[&quot;T&quot;]], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, wavelength: Optional[Any] = None, )  Example: fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[6]}_TransVsLambda_power', monitor_name='through', target='line', plot_x='wavelength', attribute='T', real=True, imag=False, export_csv=True, export_mat=True, show=False)  "},{"title":"8.3.2 FDTD:time monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#832-fdtdtime-monitor","content":"Get the result of FDTD time monitor data. extract( self, *, data: Literal['fdtd:time_monitor'], target: Literal['intensity', 'line'], attribute: Union[PowerAttributes, Literal[&quot;T&quot;]], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, wavelength: Optional[Any] = None, )  Example: fdtd_res.extract(data='fdtd:time_monitor', savepath=f'{plot_path}{kL[6]}_TransVstime', monitor_name='through', target='line', plot_x='time(fs)', attribute='E', real=True, imag=False, export_csv=True, export_mat=True, show=False)  "},{"title":"8.3.3 FDTD:mode expansion​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#833-fdtdmode-expansion","content":"Get the result of FDTD mode expansion data. extract( self, *, data: Literal['fdtd:mode_expansion'], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: ModeAttributes, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, mode: Optional[Any] = None, wavelength: Optional[Any] = None, monitor_name: str, mode_expansion_name: str, )  Example: fdtd_res.extract(data='fdtd:mode_expansion', savepath=f'{plot_path}{kL[5]}_TransVsLambda_mode=0', monitor_name='through', target='line', plot_x='wavelength', mode=0, attribute='T_forward', real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"8.3.4 FDTD:port mode information​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#834-fdtdport-mode-information","content":"Get the result of FDTD port mode information. extract( self, *, data: Literal['fdtd:port_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', port_name: str, mode: Any = None, plot_x: OptStr=None, plot_y: OptStr=None, )  Example: fdtd_res.extract(data='fdtd:port_mode_info', savepath=f'{plot_path}{kL[3]}_left_port_mode', port_name='left_port', target='intensity', attribute='E', mode=0, export_csv=True)  "},{"title":"8.3.5 FDTD:mode source information​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#835-fdtdmode-source-information","content":"Get the result of FDTD mode source information. extract( self, *, data: Literal['fdtd:mode_source_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', source_name: str, mode: Any = None, plot_x: OptStr=None, plot_y: OptStr=None, )  Example: fdtd_res.extract(data='fdtd:mode_source_mode_info', savepath=f'{plot_path}{kL[2]}_source_modeprofile', source_name='source', target='intensity', attribute='E', mode=0, real=True, imag=True, **export_options, show=False)  "},{"title":"8.3.6 FDTD:mode expansion information​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#836-fdtdmode-expansion-information","content":"Get the result of FDTD mode expansion information. extract( self, *, data: Literal['fdtd:mode_expansion_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', monitor_name: str, mode_expansion_name: str, plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, wavelength: Any = None, )  Example: fdtd_res.extract(data='fdtd:mode_expansion_mode_info', savepath=f'{plot_path}{kL[3]}_me_throughmode_info', monitor_name='through', target='intensity', attribute='E', mode=0, wavelength=f'{wavelength}', real=True, imag=True, **export_options, show=False)  "},{"title":"8.4 Sweep​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#84-sweep","content":"To extract the relevant data of sweep function. 8.4.1 parameter sweep​ Get the result of sweep data. extract( self, *, data: Literal['sweep'], target: Literal['intensity', 'line'], attribute: str, monitor_name: Optional[str] = None, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, **kwargs, ) Example: swp_res.extract(data='sweep', target='line', attribute='S', plot_x='sweep_gap', savepath=f'{plot_path}/01 S', export_csv=True) swp_res.extract(data='mode_expansion', target='line', attribute='T_forward', plot_x='sweep_gap', monitor_name='through', savepath=f'{plot_path}/03 {resultL[2]}', export_csv=True, ) 8.4.2 smatrix sweep​ Get the result of smatrix sweep data. extract( self, *, data: Literal['smatrix_sweep'], target: Literal['intensity', 'line'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, ) Example: smatrix_res.extract(data='smatrix_sweep', savepath=f'{plot_path}{kL[8]}_smatrix_sweep', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"Material","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/1Material","content":"","keywords":""},{"title":"1 Standard Material Database​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#1-standard-material-database","content":"The standard material database includes two parts, one is material list, and another is material property plot. The material list includes a number of common materials, when creating a new simulation, the standard database will be loaded. And the materials in the standard material database can be imported into “User” and “Project” material database. The default materials cannot be edited directly.  "},{"title":"1.1 Material List​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#11-material-list","content":" ID : IDName : Material NameMesh Oder: Decides how overlapping objects are meshed in the simulation.Color : Material ColorType : Types of material, three types are included, there are Lossy material, Lossless material and List data as follows. Lossy Material : Lossy MaterialLossless Material : Lossless Material (insulating material)List Data : Materials whose dielectric permittivity changes with wavelength settings, displayed in tabular form. Last Modified :Last modified timeImport: Import materials to user or project database.Export: Export materials according to user needs. "},{"title":"1.2 Materials in the Standard Material Database​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#12-materials-in-the-standard-material-database","content":"The following materials are included in the standard material database. ID\tName\tMesh Order\tType1\tAir\t2\tLossless Material 2\tAl (Aluminium) - Palik\t2\tList Data 3\tAl (Aluminium) - CRC\t2\tList Data 4\tAu (Gold) - CRC\t2\tList Data 5\tAu (Gold) - Johnson and Christy\t2\tList Data 6\tAu (Gold) - Palik\t2\tList Data 7\tGe (Germanium) - CRC\t2\tList Data 8\tGe (Germanium) - Palik\t2\tList Data 9\tSi (Silicon) - Palik\t2\tList Data 10\tSiO2 (Glass) - Palik\t2\tList Data 11\tSi3N4 (Silicon Nitride) - Kischkat\t2\tList Data 12\tSi3N4 (Silicon Nitride) - Phillip\t2\tList Data 13\tAg (Silver) - CRC\t2\tList Data 14\tPt (Platinum) - Palik\t2\tList Data 15\tTa (Tantalum) - CRC\t2\tList Data 16\tTiN - Palik\t2\tList Data 17\tCu (Copper) - Palik\t2\tList Data 18\tFe (Iron) - CRC\t2\tList Data 19\tW (Tungsten) - CRC\t2\tList Data 20\tTi (Titanium) - Palik\t2\tList Data 21\tTi (Titanium) - CRC\t2\tList Data 22\tSn (Tin) - Palik\t2\tList Data 23\tH2O (Water) - Palik\t2\tList Data 24\tCr (Chromium) - CRC\t2\tList Data 25\tPd (Palladium) - Palik\t2\tList Data 26\tInAs - Palik\t2\tList Data 27\tAg (Silver) - Palik (1-10um)\t2\tList Data 28\tAg (Silver) - Johnson and Christy\t2\tList Data 29\tW (Tungsten) - Palik\t2\tList Data 30\tFe (Iron) - Palik\t2\tList Data 31\tCr (Chromium) - Palik\t2\tList Data 32\tAl2O3 - Palik\t2\tList Data 33\tIn (Indium) - Palik\t2\tList Data 34\tCu (Copper) - CRC\t2\tList Data 35\tNi (Nickel) - CRC\t2\tList Data 36\tV (Vanadium) - CRC\t2\tList Data 37\tInP - Palik\t2\tList Data 38\tGaAs - Palik\t2\tList Data 39\tNi (Nickel) - Palik\t2\tList Data 40\tRh (Rhodium) - Palik\t2\tList Data 41\tAg (Silver) - Palik (0-2um)\t2\tList Data "},{"title":"1.3 Material Properties:​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#13-material-properties","content":" Plot : User can view each material property in this plot area via clicking a certain material in material list, also can view properties they are interested in via two options in the bottom of plot. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index) &amp; Im(refractive index), “εr′,εr″”-Re(relative permittivity) &amp; Im(relative permittivity), ε’,σ-Re(relative permittivity) &amp; Im(relative permittivity). 1.1.3.1 Material Data &amp; Model Fitting​ Material Data tab: User can view each material property in this list via double clicking a certain material in material list. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index) &amp; Im(refractive index), and “εr′,εr″”-Re(relative permittivity) &amp; Im(relative permittivity). 1. Material Data  2. Model Fitting: (Currently, the model fitting feature is not available and is still in the development process.) "},{"title":"2 User Material Database​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#2-user-material-database","content":"The User material database, a database that stores materials used by user. The user material database includes two parts, one is material list, and another is material property plot. User can copy or delete a selected material, The materials in the “User” material database can be imported to the “Project” material database. And users also can export materials according to their needs.  "},{"title":"2.1 Material List​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#21-material-list","content":"ID : IDName : Material NameMesh Oder: Decides how overlapping objects are meshed in the simulation.Color : Material ColorType : Types of material, three types are included, there are Lossy material, Lossless material and List data as follows. Lossy Material : Lossy MaterialLossless Material : Lossless Material (insulating material)List Data : Materials whose dielectric permittivity changes with wavelength settings, displayed in tabular form. Last Modified :Last modified timeImport: Import materials to user or project database.Export: Export materials according to user needs. "},{"title":"2.2 Material Properties​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#22-material-properties","content":" Plot : User can view each material property in this plot area via clicking a certain material in material list, also can view properties they are interested in via two options in the bottom of plot. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index)&amp;Im(refractive index), “εr′,εr″”-Re(relative permittivity)&amp;Im(relative permittivity), ε’,σ-Re(relative permittivity)&amp;Im(relative permittivity). 2.2.1 Material Data &amp; Model Fitting​ Material Data Tab: User can view each material property in this list via double clicking a certain material in material list. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index)&amp;Im(refractive index), and “εr′,εr″”-Re(relative permittivity)&amp;Im(relative permittivity). Anisotropy : Two options in this drop-down menu, “None” and “Diagonal”, when diagonal option is checked, user can create FDTD, FDE, or EME anisotropic optical material in the “User Material Database” window. Solver physics :Anisotropic materials react to electric field with directional dependent electric displacement. Permittivity can be represented by a 9 element tensor εij\\varepsilon_{ij}εij​. Di=εijEjD_i = \\varepsilon_{ij}E_jDi​=εij​Ej​ In general, this tensor can be diagnonalized by a proper choice of coordinate system, e.g. in principle dielectric axes. So it is simplified to ε=[εx000εy000εz]\\varepsilon =\\begin{bmatrix} \\varepsilon_x &amp; 0 &amp; 0\\\\ 0 &amp; \\varepsilon_y &amp; 0\\\\ 0 &amp; 0 &amp; \\varepsilon_z \\end{bmatrix}ε=​εx​00​0εy​0​00εz​​​ Diagonal anisotropic materials:To define an anisotropic material, set the Anisotropy field in the material database to Diagonal and assign the parameters for each diagonal component. 3 Project Material Database​ The project material database stores project materials. The database would inherit materials from the project automatically, which may contain standard materials and user materials in the project. And the materials in the standard and user material database can be imported to project material database. Users also can add, delete and export materials according to their needs. "},{"title":"Waveform","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/2Waveform","content":"Waveform Features Description: Global waveforms settings include two parts, one is standard waveform list, and another is project waveform list. There are three default materials in the standard waveform list, includes Waveform_1550, Waveform_1310 and Visible_Light. The default waveforms in the standard waveform list cannot be edited directly, user can add, or copy one of waveforms from the standard waveform list. User only can delete newly added or copied waveforms in the standard waveform list. The waveforms in the project waveform list inherit form projects built by user, user can add new waveform or delete selected waveforms in the project waveform list. Select one Waveform (e.g., Waveform1) in Waveform list, then edit the selected waveform in the left-down Waveforms window, at the same time, signal vs time image will display in the right-down window. Signal Vs Time: The range of time can be zoom in via dragging the two ends of bottom bar. You can add, delete, or copy a certain waveform in the list.You can set Frequency/wavelength or Time domain in the drop-down menu, at the same time, signal and time image will be changed as well.If the “set frequency/wavelength” option was chosen, “set time domain” option will be disabled, this section makes it possible to either set the frequency or the wavelength and choose to either set the center and span or the minimum and maximum frequencies of the source.For single frequency simulations, simply sets both the min and max wavelengths to the same value.If the “set time domain ” option was chosen, “set frequency/wavelength” option will be disabled.Broadband: The broadband source, which contains a much wider spectrum, consists of a chirped optical carrier with a Gaussian envelope. Frequency: The center frequency of the optical carrier. The value currently is default.Pulse Length: The half-width at -109 dB power temporal duration of the pulse. Offset: The time dealy form the start of simulation to the peak of the waveform. The value currently is default.Bandwidth：source band width setting.Optimize for short pulse: Enabled, this is the default setting for FDTD, meaning a very short pulse will be used in most simulations.","keywords":""},{"title":"Structure","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/3Structure","content":"Structure Features Description: Add or Edit Structures. 1 Structures​ There are Triangle, Rectangle, Circle, Ring, Polygon, Sector, Ellipse, ArcWaveguide, ArcWaveguide3D, Linear Trapezoid, Pyramid and Bezier ArcWaveguide 3D. All structures support 3d modeling, and meet X, Y, Z direction rotation. 1.1 Triangle​ 1.2 Rectangle​ 1.3 Circle​ 1.4 Ring​ 1.5 Polygon​ 1.6 Sector​ 1.7 Ellipse​ 1.8 Arc Waveguide​ 1.9 Arc Waveguide 3D​ 1.10 Linear Trapezoid​ 1.11 Pyramid​ 1.12 Bezier 3D Waveguide​ Notes: Material Data Tab: User can view each material property via double clicking a certain material in material drop-down menu. Material properties include wavelength, frequency and Re (Index/permittivity), Im (Index/permittivity). 2 Work Flows:​ 2.1 Add method:​ Click “Structures” button and select one structure from drop-down menu 2.2 Edit Structure pop-up window methods:​ Edit pop-up window directly after each time structure adding; Left single click object in the “Object Tree”; Right single click object in the “Object Tree”, and select “Edit” in the drop-down menu; __Transform**: Allow user to operate the object via the four features, include translate, scale, rotate and mirror. Select “Edit Properties” tool in the shortcut bar. ","keywords":""},{"title":"FDE Solver","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/4Simulation/1FDE","content":"FDE Solver Solver Physics: The FDE solver employs finite-difference techniques to compute the spatial characteristics and frequency dependence of modes. By solving the Maxwell's equations on a cross-sectional mesh of the waveguide, the solver determines the mode field profiles, effective index, and loss values. The simulation example for the z-normal eigenmode solver features the following vector fields: E(x,y)ei(−ωt+βz)E (x,y)e^{i(-\\omega t+\\beta z)}E(x,y)ei(−ωt+βz) H(x,y)ei(−ωt+βz)H (x,y)e^{i(-\\omega t+\\beta z)}H(x,y)ei(−ωt+βz) The propagation constant is denoted by β, and ω represents the angular frequency. Based on these parameters, the modal effective index and loss are defined as follows: neff=cβωn_{eff}= \\frac{c\\beta}{\\omega } neff​=ωcβ​ To identify the modes, the Eigensolver solves Maxwell's equations on a cross-sectional waveguide mesh. The finite-difference algorithm, which can handle complex waveguide geometries, is currently employed for meshing purposes. After the meshing process, the equations are reformulated into a matrix eigenvalue problem, which is solved using sparse matrix techniques. This approach enables the effective index and mode profiles of the waveguide modes to be determined. Features Description: Add or edit FDE simulation area and boundary conditions. 1 Tool bar​ In this example, we show how to use Max-Optics local passive to run FDE and view the simulation result. 1.1 General tab​ 1)Solver Type: Chooses either a 2D X/Y/Z normal. (Default: 2D X normal) 2)Background Material: The combo box allow user to set the background material from drop down menu. Project, object defined dielectric, and go to material library can be operated. Project: The background material inherits from the project’s material setting. Object Defined Dielectric: The object-defined dielectric material, a default setting if user forgets to set background material, is defined for the current object background material setting, and once the user chooses this option, he does not need to set any material from the standard, user, or project material database. And the object-defined dielectric will not be loaded into any material database. Go to Material Library: If selected, user can go to standard material database to set background material according to needs. And the selected material relative property from standard material database will be displayed in the material data list. Index: specify background index manually in stead of choosing form library. (Default :1). 1.2 Geometry tab​ 1)X, Y, Z: The center of the simulation region. 2)X Min, X Max: minimal and maximal.in x direction 3)Y Min, Y Max: minimal and maximal.in y direction. 4)Z Min, Z Max: minimal and maximal.in z direction 5)X Span, Y Span, Z Span: X, Y, Z span of the simulation region. (Notes: The availability is based on the solver type.) 1.3 Mesh setting tab​ 1)Mesh Definition: There is one option: global uniform mesh step, which means all the mesh steps are uniform in the simulation region. 2)Define X Mesh/ Define Y Mesh/ Define Z Mesh: Maximum mesh step. 3)Mesh Refinement: Mesh refinement can give sub-cell accuracy for a simulation. ①Staircase: The material at each position of the Yee cell is defined as the material occupies majority space of the cell. Resulting a “staircase” like permitivity mesh. ②Curve Mesh:Effective permittivities can be derived via a contour path recipe, which effectively takes the dielectric interface shapes, as well as material weight inside a cell into account. 4)DX/DY/DZ: Maximum mesh step settings. The default setting is 0.02 μm. 5)Mesh Grading: In the case of a non-uniform mesh, Mesh Grading specifies the maximum ratio at which a neighboring grid can be enlarged or reduced. For instance, if dx(k+1) = c*dx(k), then 1/(GRADING FACTOR) &lt;= c &lt;= GRADING FACTOR. It is recommended that 1 &lt;= GRADING FACTOR &lt;= sqrt(2). (Default: 1.2) Minimum Mesh Step Settings: This indicates the minimum mesh step for the whole region managed by the solver (including also the mesh override regions). (Default: 0.0001μm) 1.4 Boundary conditions tab​ 1)PML: The electromagnetic waves indicent upon a perfectly matched layer (PML) boundary will all be absorbed without any reflection at all frequencies and omni direction, i.e., a PML mimics in essence an ideally open (or reflectionless) boundary. In contrast to conventional boundary conditions, a PML boundary occupies a finite volume surrounding the simulation region and hence possesses only a finite thickness, and the process of light absorption takes place inside this thickness span. ①LAYERS: specify the number of layers PML regions are to be divided. ②KAPPA, SIGMA, ALPHA : Kappa and sigma are used for controlling the absorption performance of PML boundaries according to the simulation needs. As can be found in the reference, kappa is unitless by definition, while sigma requires normalization before being entered into the PML settings table as a unitless value. Specifically, kappa and sigma are both evaluated through polynomial variations with respect to their geometric positions inside the PML regions. ③PML Polynomial: This determines the degree of the polynomial utilized to grade kappa and sigma. 2)PEC: Metal boundary conditions are used to specify boundaries that behave as a Perfect Electric Conductor (PEC), Metal boundaries are perfectly reflecting, allowing no energy to escape the simulation volume along that boundary. 3)PMC: Perfect Magnetic Conductor (PMC) boundary conditions are introduced to be the magnetic correspondence of the metal (PEC) boundaries. 4)Symmetry/Anti-symmetry: When investigating a system that exhibits one or more axes/planes of symmetry, the symmetric/anti-symmetric boundary conditions are frequently employed, for both the structure and the source. For the electric field, symmetric boundaries serve as mirrors and anti-symmetric boundaries serve as anti-mirrors---whereas for the magnetic field, the story is exactly the opposite. For a desired vector symmetry of the solution, the choice between the symmetric or anti-symmetric boundary conditions is often of pivotal importance. Note that the sources and the boundary conditions must use the same type of symmetry for the results to be meaningful. 5)Periodic: Periodic BCs allow you to analyze the whole system by studying only one unit cell if the interested system is somewhat spatially periodic, and they are easily enabled by setting the simulation span identical to the length of one unit cell, plus choosing then &quot;Periodic BCs&quot; for that boundary. Upon doing so, the EM fields at one side of the unit cell (which is subjected to Periodic BCs) are always duplicated accordingly at the other side during the entire simulation. Notes: It is crucial to keep in mind that when employing Periodic Boundary Conditions (PBCs), both the physical structure and the electromagnetic (EM) fields in the system must be periodic. Neglecting this key aspect often leads to errors, such as utilizing PBCs in systems with a periodic structure but non-periodic EM fields. 1.5 Advanced tab​ 1)Dispersion Settings: Sets dispersion. Fractional Offset for Group Delay: Numerically, the group delay of the device is computed by means of a finite-difference approximation of diffentiating the phase with respect to frequency. The “fractional offset for group delay” refers to the fractional amount of the frequency used in the step size of finite difference. If this setting is too small, the phase change may be severely affected by noise, whereas a too large setting could result in an unrealistic group delay since the phase may change by more than 2π. For rather long devices (10000+ wavelengths) in which the phase varies quickly with frequency, the user is encouraged to reduce this setting from the default value. Otherwise the default setting is generally recommended. (Default:0.0001 μm) ng=neff−λΔneffλoffsetn_{g}=n_{eff} -\\lambda \\frac{\\Delta n_{eff}}{\\lambda_{offset} } ng​=neff​−λλoffset​Δneff​​ 1.6 Thread Settings tab​ 1)Thread：Through thread setting can improve running effects, which makes simulation significantly faster than prior. (Default: 4) 2 Simulation Cases​ In this example, we show how to use Max-Optics local passive to run FDE and view the simulation result. Work Flow 2.1 Modeling​ Material database settings: Press on &quot;Material&quot; button, the material database window will bring out, and import new materials from standard material database or user material database into project material database according to user needs.( when import success a prompt information will pop out informs that “Import Success. Success: 1/1, Fail: 0/1 (duplicated).”) Material work flows: Add a rectangle: Press arrow on the “Structures” button, and select a Rectangle from the drop-down menu. Set the properties of the rectangle according to the following table. Menu bar-&gt;Structures-&gt;Rectangle-&gt;Geometry-&gt;Material 2.2 Add FDE​ Press arrow on the “Simulation” button, and select the FDE from the drop-down menu, and set the properties according to the following table. Notes: For other settings like “boundary conditions”, “advanced” and “thread setting “are adopted by default, additionally, before simulation, please press “File” button, and select “Save” from drop-down menu, manually. (File -&gt; Save) 2.3 Run​ Press arrow on the “Run” button in the menu bar and select “Run FDE” from drop-down menu.After pressing “Run FDE” button, a FDE Analysis window will pop out, and You can choose modal analysis or frequency analysis to calculate. After pressing the “Calculate Modes” button, the simulation process will display on the right side Task Tree bar. 2.4 Result view​ Press “OK” button after simulation finishing, and view the result in the Result View. Notes: If you want to change a certain parameter (e.g., the wavelength value) and simulation again you can change wavelength value in the modal analysis window and press “Calculate modes” directly without modeling again After setting the wavelength value to 1.56um, press the “Calculate Modes” button. You can view the simulation result in the Result View, when wavelength value equals to 1.56um. You also can view other plot image via Mode plot options. If You want to get frequency analysis result, you can switch to “Frequency Analysis” tab, and set the relative parameters in the“Frequency Analysis” window. Then press the “Frequency Analysis” button. Press “OK” button after simulation finishing, and view the result in the Result View. After running, the result will be saved in Task Tree automatically You also can view the result in Result View via clicking the FDE result item.","keywords":""},{"title":"FDTD Solver","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/4Simulation/2FDTD","content":"FDTD Solver Solver Physics: The numerical method of computational electrodynamics that provides approximate solutions to the system of Maxwell's equations is known as Finite-Difference Time-Domain (FDTD). It is also referred to as Yee's method, named after Kane S. Yee, a Chinese-American applied mathematician. As a time-domain method, FDTD handles nonlinear material properties in a rather natural way and can cover a wide frequency range by running only a single simulation. Features Description: Adds or sets FDTD simulation region and boundary conditions. Notes : When FDTD solver is selected, user cannot add FDE solver and EME solver at the same time. 1 Tool bar​ 1.1 General tab​ 1)Dimension: Number of dimensions of the simulation region. (Default: 3D) 2)Using Optical Path Estimate Time: It is the switch button that the estimation of simulation time based on optical path. 3)Estimate Time: Estimated simulation time. (when “Using Optical Path Estimate Time” is enabled, it is displayed and non-editable. 4)Simulation Time: Simulation time indicates the maximum duration of the simulation to be implemented. In reality the simulation may end earlier when some of the auto-shutoff conditions are satisfied before running till this maximum simulation time. (Default: 1000 fs) 5)Background Material: The combo box allows user to set the background material from drop down menu. “Project”, “Object Defined Dielectric”, and “Go to Material Library” can be operated. 6)Project: The “Background Material” can be selected from the “Project” sublist in the “Material Database” based upon the needs. 7)Object Defined Dielectric: The object-defined dielectric material, a default setting if user forgets to set background material, is defined for the current object background material setting, and once the user chooses this option, he does not need to set any material from the standard, user, or project material database. And the object-defined dielectric will not be loaded into any material database. Go to Material Library: If selected, user can go to standard material database to set background material according to needs. And the selected material relative property from standard material database will be displayed in the material data list. 8)Index: The refractive index of the surrounding, background medium in the simulation region.（Default: 1) 1.2 Geometry tab:​ 1)X, Y, Z: The center position of the simulation region. 2)X Min, X Max: X min, X max position. 3)Y Min, Y Max: Y min, Y max position. 4)Z Min, Z Max: Z min, Z max position. 5)X Span, Y Span, Z Span: X, Y, Z span of the simulation region. 1.3 Mesh Settings tab:​ 1) Mesh Type:Two types of mesh generation algorithms are available, as described below; ① Auto non-uniform (Default) A non-uniform mesh is automatically generated based on the mesh accuracy slider bar. ② Uniform A uniform mesh is applied to the entire simulation volume, regardless of any material properties. If a mesh override region is used in conjunction with this option, the override region will force the mesh size everywhere, not just within the override region (the mesh is uniform). 2) Mesh Accuracy: Sets cells per wavelength. The default set is 15. 3) Minimum Mesh Step Settings: Set the absolute minimum mesh size for the entire solver region. 4) Mesh Refinement: Mesh refinement can give sub-cell accuracy for a simulation. ① Staircase: The material at each position of the Yee cell is evaluated to determine which material it is in, and the E field at that location uses only that single material property. The resulting discretized structure is unable to account for structure variations that occur within any single Yee cell, resulting in a &quot;staircase&quot; permittivity mesh that coincides with the Cartesian mesh furthermore, any layers are effectively moved to the nearest E field position on the Yee cell, meaning that layer thickness cannot be resolved to better than dx. ② Curve Mesh: Effective permittivities are derived using a contour path approach that accounts for the boundary conditions of the electromagnetic field at dielectric interfaces. 5) Grading: Grading factor, determines the maximum ratio of the neighboring spatial steps. 1.4 Boundary Conditions tab:​ 1) PML: Perfectly matched layer (PML) boundaries absorb electromagnetic waves incident upon them. They essentially model open (or reflectionless) boundaries. 2) PEC: PEC boundary conditions are used to specify boundaries that behave as a Perfect Electric Conductor (PEC). Metal boundaries are perfectly reflecting, allowing no energy to escape the simulation volume along that boundary. 3) PML settings: When the state of the Same Settings on All Boundary Conditions is on, all PML boundaries share the same profile based on the properties listed in the table, including “Layers”, “Kappa”, “Sigma”, “Polynomial”, “Alpha”, “Alpha Polynomial”, “Min Layers”, and “Max Layers”; otherwise, each PML boundary can be set individually. 4) X/Y/Z min/ max PML: These fields describe the boundary conditions to be applied along the perimeter of the simulation region. 1.5 Advanced Options tab:​ 1) Auto Shutoff : Stops the simulation when the energy in the simulation goes below the “Auto Shutoff Min” when the “Use Early Shutoff ” state is on , you can set min auto shutoff (Default: 1e-4) and down sample time (Default: 200) 2)Down sample time: The time step down sampling. (It is default: 200, and 10 &lt;= it &lt;= 1000) 3)Live Slice Field Display Settings ① Show Field: Real-time filed slice display switch. (Default: on) ② Select Field Section: Combo box allows you to choose from a list of 2D planes normal to the axes for field display. ( 2D Z Normal by default） ③ Select Component：Combo box allows you to choose from a list of the existing field components ( Ex by default) ④ Time Interval: The time step down sampling (200 fs by default) ⑤ Position: The position of slice (0 μm by default) 1.6 Thread Settings tab:​ 1) Thread：Through thread setting can improve running effects, which makes simulation significantly faster than prior. (Default: 4) 2 Simulation Cases:​ Objectives:In this example, we show how to use Max-Optics to run FDTD and view the simulation result. Works Flow: 2.1 Modeling​ 2.1.1 Material database settings​ Press on &quot;Material&quot; button, the material database window will bring out, and import new materials from standard material database or user material database into project material database according to user needs.( when import success a prompt information will pop out informs that Import Success. Success: 1/1, Fail: 0/1 (duplicated)). Material work flows: 2.1.2 Add a rectangle​ Press arrow on the “Structures” button, and select a Rectangle from the drop-down menu. Set the properties of the substrate rectangle according to the following table. Menu bar-&gt;Structures-&gt;Rectangle-&gt;Geometry-&gt;Material 2.1.3 Waveforms setting​ Press arrow on the “Waveforms” button in the menu bar, then add the waveform with name: ”Waveform0” under the project waveform and set the properties in Waveforms dialog box. 2.2 Add FDTD​ Press arrow on the “Simulation” button in the menu bar, and select “FDTD” from the drop-down menu, and set the properties according to the following table. 2.3 Add Mode Source​ Press arrow on the “Mode Source” button in the menu bar, and select “Mode Source” from the drop-down menu. Set the properties of mode source according to the following table 2.4 Add Power Monitor​ Press arrow on the “Monitor” button in the menu bar, and select “Frequency-Domain Field and Power” from the drop-down menu. Set the properties of power monitor according to the following table. Notes: Before simulation, please press “File” button, and select “Save” from drop-down manual, manually. (File -&gt; Save) 2.5 Run​ Press arrow on the “Run” button in the menu bar and select “Run FDTD” from drop-down menu. 2.6 Result View​ You can check the simulation result via clicking items in the “Result View”. 2.6.1 FDTD Monitor-&gt;Power Monitor-&gt;Image tab​ 2.6.2 FDTD Monitor-&gt; Power Monitor-&gt;Line tab​ In these windows, you can view different plot types, and they are interested in via settings in relative sections. ","keywords":""},{"title":"Mesh","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/4Simulation/4Mesh","content":"Mesh Feature Description: Mesh region setting. 1 General tab​ 1)Override X/Y/Z mesh: When “Override X/Y/Z mesh” button state is on, you can set dx/dy/dz mesh override region. The smaller the value of dx/dy/dz, the better accuracy you will get. 2 Geometry tab​ 1)X, Y, Z: The center position of the simulation region. 2)X Min, X Max: X min, X max position. 3)Y Min, Y Max: Y min, Y max position. 4)Z Min, Z Max: Z min, Z max position. 5)X Span, Y Span, Z Span: X, Y, Z span of the simulation region.","keywords":""},{"title":"EME Solver","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/4Simulation/3EME","content":"EME Solver Solver Physics: As an attractive substitute to FDTD-based techniques for numerical solutions of Maxwell's equations, the EME method operates in the frequency domain and is highly dept at dealing with scenarios involving long propagation distances. The EME method comprises two significant steps: ①　In the first step of the EME method, the electromagnetic fields are decomposed into a series of eigenmodes using a modal approach. To compute these modes, the geometry is partitioned into several cells, and the modes at the interfaces between adjacent cells are calculated. The next step involves constructing scattering matrices for each section by matching the tangential E and H fields at the cell boundaries. This is the most computationally intensive stage of the EME calculation, and it employs the FDE solver; ②　After completing the first two steps, the simulation enters the analysis mode, allowing for the bi-directional propagation of the solution for each section to compute the S matrix of the entire device. If needed, the internal fields can be reconstructed as well. This stage can be executed expeditiously. Furthermore, once in analysis mode, the propagation distance of each section can be altered as desired, without the need to repeat step 1. This is why the EME method is highly efficient when scanning the lengths of devices. Feature Description: Adds or sets EME simulation area and boundary conditions. 1 Tool bar​ 1.1 General tab​ 1)Algorithm: The type of mesh algorithm used (Currently，it is not available ). 2)Solver Type: “3D X Property” is currently the option, two-dimensional solver is not available present. 3)Background Material : The combo box allow user to set the background material from drop down menu. Project, object defined dielectric, and go to material library can be operated. ①Project: The background material inherits from the project’s material setting. ②Object Defined Dielectric: The object-defined dielectric material, a default setting if user forgets to set background material, is defined for the current object background material setting, and once the user chooses this option, he does not need to set any material from the standard, user, or project material database. And the object-defined dielectric will not be loaded into any material database. ③Go to Material Library: If selected, user can go to standard material database to set background material according to needs. And the selected material relative property from standard material database will be displayed in the material data list. ④Index: This refers to the refractive index of the ambient background medium inside the simulation window (Default: 1) 4)Set frequency/wavelength: Sets the frequency (Default: 193.414 THz) or wavelength (Default:1.55 μm) to calculate. 5)Use Wavelength Sweep off/on: If checked, the wavelength sweep function is on, which used for wavelength sweep in EME analysis window. 1.2 EME Setup tab​ 1)Y, Z: The center position of the simulation region. 2)Y Min, Y Max: Y min, Y max position. 3)Z Min, Z Max: Z min, Z max position. 4)Y Span, Z Span: Y, Z span of the simulation region. 5)Cell geometry： ①X Min: Minimum x position of solver region. The first cell group starts from this position. ②Energy Conversation: This admits you to choose the energy conservation type for the Page S-matrix. The Page S-matrix is calculated at every Page of the neighboring cells accounting for the modes at the left- and right- hand sides of the Page. Two options “None” and “Make Passive” are available. -&gt;None: Energy conservation is not applied. -&gt;Make passive: Nothing is done when the norm of the Page S-matrix is less than or equal to 1; otherwise the norm is mandatorily altered to be identical to 1. ③Unified Mode Settings: When the switch is on, the user can modify only the first line of &quot;Number of Modes&quot;, the values in other lines of &quot;Number of Modes&quot; are forced to be identical to the first line in the Cell Group Definition. If the switch is off, everything in &quot;Number of Modes&quot; can be modified as freely as the user wishes. ④Cell Group Definition: This enables you to specify the span of every cell group, the number of cells in every cell group, which sub-cell method to employ (None or Sub Cell), and the number of modes to be solved for each cell. Besides, it displays the cell range of the group, as well as the begin and end positions of the cell group. -&gt;Number of Modes:This value cannot be beyond the maximum amount of stord modes. Otherwise, it will be mandatorily altered to be identical to the latter. -&gt;Delete button: Clears the custom settings for the selected cell group. -&gt;Add button: Allow you to make custom settings for the selected cell group. ⑤Display Groups: Displays cell boundaries in the CAD. ⑥Periodicity tab： ①Periodicity Group Definition: This defines cell regions with periodic features and specifies the number of periods in each of them. The &quot;start cell group&quot; and the &quot;end cell group&quot; refer to the sequential numbers from &quot;cell group definition&quot;. 1.3 Transverse mesh settings tab​ Since the propagation in the EME solver is along the x-direction, the mesh settings are applicable merely along the y and/or z axes, depending on the solver type (3DX2D). 1)Mesh definition: Currently there is only the option of global uniform mesh step, meaning that the mesh steps are uniform throughout the entire simulation volume. 2)Define Y Mesh/ Define Z Mesh: Maximum mesh step. 3)Mesh Refinement: Select an approach to calculate refined mesh properties ①Staircase: Any point inside a Yee cell might be evaluated to determine of which material it is consisted, and the properties for that single material are used for depicting the E field at that point. As a consequence, the discretized structure hardly accounts for structure variations that arises inside a single Yee cell, therefore leading to a ``Staircase'' permittivity grid which agrees exactly with the Cartesian grid. Besides, all layers are effectively shifted to the closest E field position inside the Yee cell, implying that there is no way for the thickness to be resolved as finer than dx. ②Curve Mesh: Effective permittivities can be derived via a contour path recipe, which effectively takes the dielectric interface shapes, as well as material weight inside a cell into account. 4)Mesh Grading: In the case of a non-uniform mesh, Mesh Grading specifies the maximum ratio at which a neighboring grid can be enlarged or reduced. For instance, if dx(k+1) = c*dx(k), then 1/(GRADING FACTOR) &lt;= c &lt;= GRADING FACTOR. It is recommended that 1 &lt;= GRADING FACTOR &lt;= sqrt(2). (Default: 1.2) 5)DY/DZ: Maximum mesh step settings . The default setting is 0.02 μm. 6)Minimum mesh step settings: This indicates the minimum mesh step for the whole region managed by the solver (including also the mesh override regions). (Default: 0.0001μm). 2 Simulation Cases:​ Objectives: In this example, we show how to use Max-Optics to run EME and view the simulation result. Works Flow: 2.1 Modeling​ 2.1.1 Material database settings​ Press on &quot;Material&quot; button, the material database window will bring out, and import new materials from standard material database or user material database into project material database according to user needs.( when import success a prompt information will pop out informs that Import Success. Success: 1/1, Fail: 0/1 (duplicated). Material work flows: 2.1.2 Add a rectangle​ Press arrow on the “Structures” button, and select a Rectangle from the drop-down menu. Set the properties of the substrate rectangle according to the following table. Menu bar-&gt;Structures-&gt;Rectangle-&gt;Geometry-&gt;Material 2.2 Add EME​ Press arrow on the “Simulation” button, and select the “EME” from the drop-down menu, and set the properties according to the following table. General Tab EME Setup Tab Transverse Mesh Setting Tab 2.3 Add EME Port​ Geometry Tab of EME Port 1(Left) Geometry Tab of EME Port 2(Right) 2.4 Add Monitor (EME Profile monitor)​ Press arrow on the “Monitor” button and select “EME Profile Monitor” from drop-down manual. And set the properties according to the following table Geometry Tab of Profile Monitor Notes: Before simulation, please press “File” button, and select “Save” from drop-down manual, manually. (File -&gt; Save) 2.5 Run &amp; Result View​ Press arrow on the “Run” button and select “Run EME” from drop-down menu. After running, the “EME Analysis” window will pop out, in this window, you can run “EME Propagate”, “Propagation Sweep” and “Wavelength Sweep” via press buttons respectively. ① EME propagate Press arrow on the “EME propagate” button, and you can view the EME propagate result via clicking EME result in Result View. You can view different plot types via “Scalar Operation” options, and in attributes list, you can choose parameter which is interested in to view ② Run Propagation sweep Press arrow on the “Propagation Sweep” button, and after running, “EME Propagation Sweep” window will pop out, you can view the result about Propagation Sweep. User can view different view via clicking options in S11, S12, S21 or S22 port box. ③ Run Wavelength Sweep Press arrow on the “Wavelength Sweep” button, and after running, “EME Wavelength Sweep” window will pop out, you can view the result about Wavelength Sweep. You can view different results via the options in S11/S12/S21/S22 Port box. ④ Matrix Index Mapping Show the information about the mode corresponding to the port. ⑤ zbf Export The EME port and EME cell results support exporting mode information in a zbf format file. Works flows: Result View-&gt;EME port/EME Cell-&gt;Mode Fields-&gt;Export -&gt;OK 3 Notes​ The simulation cases involved in the manual are only limited to guiding user how to use Max-Optics Studio silicon-based passive product running simulation, not for other purposes; The screenshot pictures are gained, under Hardware environment: Name: LAPTOP-MHBJS336 (MateB ook 14), Windows11, and software environment: Google browser, version:108.0.5359.125.","keywords":""},{"title":"Source","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/5Source","content":"Source 1 Mode Source​ Feature Description:The mode source is used to inject a guided mode into the simulation region in FDTD. You could add and set mode source here. 1.1 General tab​ 1 ) Injection Axis: This field specifies the axis for the mode source propagation. Three options are available: “X-Axis”, “Y-Axis”, and “Z-Axis”. 2 ) Direction: This field indicates the direction of mode source propagation. Two options are available: “Forward” means the propagation is along a positive direction, while “Backward” means the propagation is along a negative direction. 3 ) Amplitude: This field specifies the amplitude of the mode source. See the section ``Units and normalization section''. (Default value: 1) 4 ) Phase: This field refers to the phase value (in units of degrees) of the mode source. It makes sense only when there exist relative phase differences among multiple sources of radiation. 5 ) Rotations: ① Theta: This refers to the angle of propagation measured by degrees, with respect to the incident axis of the source in a 3D simulation. In a 2D simulation, it is the angle of propagation measured by degrees revolved around the global Z-axis in compliance with the right-hand rule, that is, the angle of propagation in the XY plane. ② Phi: This refers to the angle of propagation measured by degrees revolved around the incident axis of the source in compliance with the right-hand rule in a 3D simulation. In a 2D simulation, this value does not take effect. ③ Rotation Offset: A rotation offset can be endowed to the plane upon which the mode is computed. This guarantees that mode sources at an angle do not interfere with structures not belonging to the waveguide/fiber. 6 ) Mode selection: Defines whether to inject fundamental mode or other user-selected modes chosen via the &quot;Select Mode&quot; button. Currently, mode selection options are “Fundamental Mode”, “Fundamental TE Mode”, “Fundamental TM Mode”, “User Select” and “User Import”. Works flow: User Select -&gt; “Select Mode” window: 1.1.2 Modal analysis tab​ In this section you can set “Frequency”, “Wavelength”, “Number of Trial Modes”, “Search”, and also can set bent waveguide via selecting “Calculate Group Index” and “Bent Wave guide”. 1) Number of Trial Modes: This specifies the number of modes to search for a fundamental mode. The modes eventually found by the solver may depend on that. If one uses a too small number, the expected modes could be missing. Usually, setting this number to 100 suffices to guarantee no physical modes would have been missed. However, users who are interested in higher order modes should set an even larger value, since in such cases more than 100 modes may be present. 2) Search: The user can specify an index to search around or a range of indices to sweep for finding modes of interest. The specified value indicates the magnitude of the index (which is complex) rather than just its real part. ① Max index: By checking this option, the FDTD calculation automatically admits the maximum index mode (Default: 1). ② Near N: If unchecked, the user can set the value of N in the following box according to the need. If the selected value is not within the range of the mode index value, the nearest value from the user’s setting will be adopted instead for selecting the FDTD mode. 3) Mesh Structure: User can view structure and material information about mesh. When click the button, result view will be shown, and attribute drop-down list includes: Index X, Index Y, Index Z. 4) Plot area: The plot area where the simulation data is plotted. 5) Mode list: Mode list where the “ID”, “Effective Index”, “Group Index”, “Wavelength”, “Loss”, and “TE Polarization Fraction” are shown. How many modes will be shown, will according to the “Number of Trail Modes” setting. 6) Mode Plot options: The mode plot options are used to specify which data to plot in the plot window, also can be used to modify the current mode plot options. 7) Export: The export button supports users exporting the data file they are interested in. Notes: For detailed information please refer to Chapter 2.7.6.1.2.Mode Plot Window 1.1.3 Boundary conditions tab​ In this section, you can set mode source simulation region’s boundary conditions and six types can be chosen: PEC, PML, PMC, Symmetric, Periodic and Anti-Symmetric. (Default: PEC) 1.2 Geometry tab​ 1) X，X Span/ Y, Y Span, Z/ Z span: The geometry tab contains options to change the size and location of the sources. 2 Gaussian source：​ Feature Description: The gaussian source is used to inject a gaussian source into the simulation region in FDTD. You could add and set gaussian source here. 2.1 General tab​ 1) Injection Axis: This field specifies the axis for the gaussian source propagation. Three options are available: “X-Axis”, “Y-Axis”, and “Z-Axis”. 2) Direction: This field indicates the direction of gaussian source propagation. Two options are available: “Forward” means the propagation is along a positive direction, while “Backward” means the propagation is along a negative direction. 3) Angle Theta: This refers to the angle of propagation measured by degrees, with respect to the incident axis of the source in a 3D simulation. In a 2D simulation, it is the angle of propagation in degrees revolved around the global Z-axis in compliance with the right-hand rule, that is, the angle of propagation in the XY plane. 4) Angle Phi: For 3D simulations, Phi corresponds to the angle of propagation (measured by degrees) revolved around the axis of source injection in compliance with the right-hand rule. This value has no meaning for 2D simulations. 5) Amplitude: This field specifies the source amplitude. (Default value: 1) 6) Phase: This field refers to the phase value (in units of degrees) of the point source. It makes sense only when there exist relative phase differences among multiple sources of radiation. 7) Polarization Angle: For an injective electric field, the polarization angle is meant to be its orientation, measured with respect to the plane formed by the vector of propagating direction and the normal of the injection plane. Radiation with a vanishing polarization angle is P-polarized regardless of the direction of propagation, while radiation with a polarization angle of 90 degrees is S-polarized. 2.2 Waveform Tab​ 1) Waveform ID select: Allows you to choose the waveform id from a list of the existing waveforms. Three types options of for waveforms provided by default, which include Waveform_1550, Waveform_1310, and Visible_Light. Waveform List:The waveform information of “ID”, “Name”, “Center”, “Span”, “Start” and “Stop” are included in waveform list. 2.3 Beam Settings Tab​ 1) Calculation Method: You can select “Use Scalar Approximation” or “Use Vector Approximation” for calculation. (Default: Use Scalar Approximation) 2) Beam Parameters: The user can choose either “Waist Size and Position” or “Beam Size and Divergence” to define a scalar beam. (Default: Waist Size and Position) 3) Waist Radius W0: The user can input the value of waist radius (measured by μm; Default: 1.01818) within the range [1e-30,1e30]. The setting Beam Parameters=”Waist Size and Position” enables the user to modify the value. 4) Distance From Waist: This distance is positive if the beam is divergent, or negative provided the beam is convergent. The setting Beam Parameters=”Waist Size and Position” enables the user to modify the value. 5) Beam Radius Wz: The user can input the value (measured by μm; Default: calculated value) within the range [1e-30,1e30]. The setting Beam Parameters=”Beam Size and Divergence” enables the user to modify the value. 6) Divergence Angle: This refers to the angle of radiation spreading into the far field as measured. Positive/Negative angles correspond to diverging/converging beams, respectively. The user can input the value within the range of (-90,90). The value can be editted if Beam Parameters=”Beam Size and Divergence”. 2.4 Geometry tab​ 1) X，X Span/ Y, Y Span, Z/ Z span: The geometry tab contains options to change the size and location of the sources.","keywords":""},{"title":"Monitor","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/7Monitor","content":"","keywords":""},{"title":"1 Reflective index monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#1-reflective-index-monitor","content":"Feature Description: Index monitors store the values of n and k as functions of frequency/wavelength in a simulation. In future, the index monitor will also be able to record the temporal profiles of physical properties for nonlinear media. 1.1 Geometry tab​ 1)Monitor type: The monitor type and orientation, this option will control the availability of spatial settings below. 2)X, Y, Z: The center position of the simulation region. 3)X Min, X Max: X min, X max position. 4)Y Min, Y Max: Y min, Y max position. 5)Z Min, Z Max: Z min, Z max position. 6)X Span, Y Span, Z Span: X, Y, Z span of the simulation region. 1.2 Mesh Settings tab​ 1)Mesh Definition: Number of mesh cells or Maximum mesh step, the two options allow user to set the number or step of defined mesh . 2)Define X Mesh/ Define Y Mesh/ Define Z Mesh: Number of mesh cells and Maximum mesh. 3)Maximum Mesh Step Settings dx/ dy/ dz: Maximum mesh step settings. The default setting is 0.02 μm. 4)Minimum mesh step settings: Sets the minimum mesh step for the entire solver region including the mesh override regions. The default setting is 0.0001μm. 5)Number of Mesh Cells without Override Regions: This value specifies the number of mesh cells without override regions. Mesh Cells X/Y/Z: Sets the number of mesh cells.(Default: 50) 6)Mesh Refinement: Mesh refinement can give sub-cell accuracy for a simulation. Staircase: Any point inside a Yee cell might be evaluated to determine of which material it is consisted, and the properties for that single material are used for depicting the E field at that point. As a consequence, the discretized structure hardly accounts for structure variations that arises inside a single Yee cell, therefore leading to a ``Staircase'' permittivity grid which agrees exactly with the Cartesian grid. Besides, all layers are effectively shifted to the closest E field position inside the Yee cell, implying that there is no way for the thickness to be resolved as finer than dx. Curve Mesh: Effective permittivities can be derived via a contour path recipe, which effectively takes the dielectric interface shapes, as well as material weight inside a cell into account. Mesh Grading: In the case of a non-uniform mesh, Mesh Grading specifies the maximum ratio at which a neighboring grid can be enlarged or reduced. For instance, if dx(k+1) = c*dx(k), then 1/(GRADING FACTOR) &lt;= c &lt;= GRADING FACTOR. It is recommended that 1 &lt;= GRADING FACTOR &lt;= sqrt(2). (Default: 1.2) 2 Frequency-domain field and power monitor​ Feature Description:Frequency domain field monitors work in the frequency domain and extract the field profiles across some spatial regions of the FDTD simulation. Notes:Before adding the Frequency-domain field and power monitor, Mode Source must be added. 2.1 General tab​ 1 ) Override Global Options: This is a toggle for overriding the global monitor settings. Checking this option enables the user to specify the frequency spans and number of points at which frequency-domain data will be collected. Otherwise the following options should be specified from the global monitor settings. 2 ) Sample Spacing: The sampling frequency or wavelength is determined somehow based on this choice parameter. Only the &quot;uniform&quot; option is available at present. 3 ) Use Source Limits: If the “Use Source Limits” state is turned on, the settings for “Spacing Type”, “Spacing Limit”, “Wavelength Min/Max” are disabled. Otherwise, the user can change the above settings in this section. 4 ) Frequency Points: Sets to choose the number of frequency points at which to record data. (Default: 5) 2.2 Geometry Tab​ 1 ) Monitor Type: The monitor type and orientation, this option will control the available of spatial setting below, Point, Linear X/Y/Z, 2D X-Normal/2D Y-Normal/2D Z-Normal, 3D are included. ( Default: 2D X-normal) 2 ) X/X Span; Y/Y Span; Z/Z Span: ① X, Y, Z: The center position of the simulation region. ② X Min, X Max: X min, X max position. ③ Y Min, Y Max: Y min, Y max position. ④ Z Min, Z Max: Z min, Z max position. ⑤ X SPAN, Y SPAN, Z SPAN: X, Y, Z span of the simulation region. 2.3 Data to Record tab​ 1 ) Fields &amp; Poynting vector and power: Output quantities EX, EY, EZ, HX, HY, HZ, PX, PY, PZ: The user can select from the field components (EX, EY, EZ, HX, HY, HZ) or the Poynting vector (PX, PY, PZ) those ones he/she wishes to measure. For 3D simulations, only part of the components are non-vanishing (i.e., for TE simulations only EX, EY, and HZ will make sense). However to facilitate fast switches between TE and TM simulations, all the field quantities will remain active.(2D simulation is inavailable at present). 2 ) Output Power: The user can check this option to compute the power as an integral over the monitor surface, and it is for surface minitors (3D simultion) and line monitors (2D simulation) only. Once the simulation comes to end, this uses much less memory and is therefore rather appropriate for large parallel computations where only the integrated power over a surface is requested by the user. (2D FDTD is inavailable at present). 2.4 Advanced tab​ 1 ) Sampling Frequency ① Min Sampling Per Cycle: This parameter suggests the realistic minimum amount of samplings for each optical cycle. Default value is 2 (the Nyqusit limit) for sake of the optimum efficiency. ② Desired Sampling: This converts the minimum sampling points in each optical cycle into an actual rate of sampling measured by Hz. ③ Nyquist Limit: The Nyquist limit of sampling is determined in accordance with the maximum frequencies that may arise in the simulation region. ④ Actual Sampling: The actual rate of sampling is identical to the rate that is actually employed for the discrete Fourier transform (DFT), by appropriately taking the desired sampling rate, the Nyquist limit, and the time step dt into account ⑤ Down Sample Time: This specifies the time for step down sampling. 2.5 Mode Expansion tab​ Feature Description: The user can use the Mode expansion monitor simulation objects to extract the fractional amount of power transmitted into any mode(s) of a non-absorbing waveguide or fiber. The Mode Expansion tab contains two main sections. The &quot;Mode calculation&quot; section allows you to select a mode (or a set of modes) to expand the input profile. The &quot;Monitors for Expansion&quot; section allows you to choose a field profile from an arbitrary monitor in the simulation to expand. 1 ) Enable: If the status of the button is on, allows user to set the “Mode calculation” and “Monitors for Expansion”. (Default: off ) 2 ) Direction: Direction of the Mode expansion monitor. Two options Negative and Positive are available. (Default value: Positive) 3 ) Mode Calculation: ① Mode Selection: Allow you to select the modes for the mode expansion calculation, and user select, “Fundamental Mode”, “Fundamental TE Mode” and “Fundamental TM Mode” are included. (Default: User Select) ② Override Global Monitor Settings: -&gt;Sample spacing: The sampling frequency or wavelength is determined somehow based on this combo-choice parameter. -&gt;Use wavelength spacing: As a default setting, data is recorded at certain spatially discretized points depending on the involved wavelengths -&gt;Use source limits: When checked, the source limits are used by the monitors. Otherwise one uses the pull down menus and their underlying boxes to specify the frequencies/wavelengths at which to collect data. ③ Frequency Points: Sets to choose the number of frequency points at which to record data. (Default: 5) 1 ) Monitors for Expansion: After the modes have been selected, the next step is to choose the monitor with the input field profile. The &quot;Add &quot; and &quot; Remove &quot; buttons on the side can be used to add/remove monitors, and You can choose the desired monitor from the monitor drop down list. 4 ) Bent Waveguide: Upon checking this option, the user can define a bent waveguide.. ① Radius: Radius of the bent waveguide. (Default value: 1.000e+6 μm) ② Orientation: Orientation of the bent waveguide ③ Location: Loaction of the bent waveguide. (at Simulation Center by default) 5 ) Rotations: ① Theta: This refers to the angle of propagation measured by degrees, with respect to the incident axis of the source in a 3D simulation. In a 2D simulation, it is the angle of propagation measured by degrees revolved around the global Z-axis in compliance with the right-hand rule, that is, the angle of propagation in the XY plane. ② Phi: This refers to the angle of propagation measured by degrees revolved around the incident axis of the source in compliance with the right-hand rule in a 3D simulation. In a 2D simulation, this value does not take effect. ③ Rotation Offset: A rotation offset can be endowed to the plane upon which the mode is computed. This guarantees that mode sources at an angle do not interfere with structures not belonging to the waveguide/fiber. 2.6 FDTD Far Field​ Feature Description: The FDTD far field function is used for calculating the EM fields in the far field region of the selected “Frequency-Domain Field and Power Monitor” through adopting a systematic near-to-far-field (NTFF) transformation without the necessity of extending the simulation region to the actual far field area. After a single FDTD simulation, the frequency-domain field data of the selected monitor can be accurately and efficiently projected to the far field region defined by a hemisphere with a radius of 1 meter which is positioned 1 meter away from the center of the monitor. Work flow: Result view-&gt; Power monitor-&gt;Calculate-&gt; Far Filed Settings-&gt; OK 2.6.1 Select Frequency​ 1 ) Frequency: allows user to select the frequency based on the power monitor calculation results to project. 2 ) Wavelength: allows user to select the wavelength based on the power monitor calculation results to project. Click the “Far Failed Setting” button from the bottom left corner of the Select Frequency window an additional window will pop out. 2.6.2 General Tab​ 1 ) Projection Direction: Forward and backward projection direction can be set. Forward will project towards the positive axis direction and backward will project to negative axis direction. 2 ) Material index: The refractive index of the medium to use for projection. 3 ) Far Field Filter: Sets the far filter alpha parameter. 4 ) Resolution: Sets the number of points in the far field to project to for 2D simulations. After clicking the “OK ” button, the visualizer window will show up, user can check two types of far-field plot results via the “Draw” option box, one is a standard plot another is the polar plot. 2.6.3 Standard plot visualizer​ Drawing: Drawing the far fields (Default:Standard Plot) Equal Scale: If checked, the result image will be shown in equal scale. Mesh Grid: Mesh grid display settings Attribute: Allow users to choose the attribute their interested in to plot, includes E, H, Energy density, Ex, Ey, Ez, Hx, and Hy. (Default: E) Scalar Operation: A combo box allow user to choose the operation their interested in to plot, includes amplitude, phase, real, and imaginary. (Default: Amplitude) Custom Range: If checked, allow user to custom range to plot via the following options settings, includes horizontal (min/max), vertical (min/max), slice (x), mode (default: 1), color bar (min/max) and scale (Linear/ log). Data List: The result data of far field projection will be loaded here after running the far field projection. ① Name: The FDTD far field name. ② Line Color: User can customize the line’s color interested in. ③ View Data: Allows user to view the data of far field , after pressing the button a FDTD Far Field data table will pop out. Add: Add the far field result to plot. Copy: Copy a far field result data in the list to plot. Remove: Remove the selected result data. Export: Export the selected far field result data. The export button supports users exporting the data file they are interested in. Two types of files with two formats can be exported, one is the “export graph data” (.csv/.mat), and another is “export monitor data (CSV/mat/zbf). 2.6.4 Polar Plot Visualizer​ 3 Field time monitor​ Feature Description: These monitors collect time-domain data for field components over the entire simulation course. Point, line or area monitors can be set and used for collecting such information over various spatial scales inside the simulation regions. 3.1 General Tab​ The general tab for the time domain monitor includes options to edit the amount of data, and time period over which data is collected. 1)Stop Method: “End of Simulation”, “Choose Stop Time” and “Choose Number of Snapshots”. 2)Start Time: The time to switch on recording. 3)Stop Time: The time to end recording. 4)Number of Snapshots: The number of timesteps to be recorded. 3.2 Geometry tab​ 1)Monitor Type: The monitor type and orientation, this option will control the available of spatial setting below , “Point”, “Linear X”, “Linear Y”, “Linear Z”, “2D X-Normal”, “2D Y-Normal”, “2D Z-Normal”,3D are included. (Default: Point) 2)X,Y,Z: The center position of the simulation region. 3)X Min/X Max: X min, X max position. 4)Y Min/ Y Max: Y min, Y max position. 5)Z Min/ Z Max: Z min, Z max position. 6)X Span/ Y Span / Z Span: X, Y, Z span of the simulation region. 3.3 Data to Record tab​ 1 ) Fields &amp; Poynting vector and power: Output quantities EX, EY, EZ, HX, HY, HZ, PX, PY, PZ: The user can select from the field components (EX, EY, EZ, HX, HY, HZ) or the Poynting vector (PX, PY, PZ) those ones he/she wishes to measure. For 3D simulations, only part of the components are non-vanishing (i.e., for TE simulations only EX, EY, and HZ will make sense). However to facilitate fast switches between TE and TM simulations, all the field quantities will remain active.(2D simulation is not available) 3.4 Advanced tab​ Sampling rate: 1 ) Min Sampling Per Cycle: This parameter indicates the realistic minimum amount of samplings in each optical cycle. Default value is 10. 2 ) Sampling Rate: The actual rate of sampling measured by THz. 3 ) Down Sample Time: This specifies the time for step down sampling. 4 EME Profile Monitor​ Feature description: EME profile monitors work in the frequency domain to extract field profiles from the simulation results produced by an EME solver over some spatial regions. 4.1 Geometry tab​ 1 ) Monitor Type: This option specifies the monitor type and orientation, and will affect the availability of the spatial settings below. 2 ) X, Y, Z: The center position of the simulation region. 3 ) X Min, X Max: X min, X max position. 4 ) Y Min, Y Max: Y min, Y max position. 5 ) Z Min, Z Max: Z min, Z max position. 6 ) X Span, Y Span, Z Span: X, Y, Z span of the simulation region. 7 ) X Resolution: The number of mesh steps along propagation direction. 5 Global Option (FDTD)​ Feature description: The global monitor settings, the parameter in this window will be adopted in other monitors if your override global options is unchecked. Notes: Monitors with override global option tab include profile and power monitor, reflective monitor and mode expansion. 5.1 Frequency power tab​ 1 ) Sample Spacing: The parameter determines how the sample frequency/wavelength will be selected, currently the option is “uniform”. 2 ) Use Wavelength Spacing: Data is recorded at certain spaced points with respect to frequency. Selecting this option spaces data at certain spaced points with respect to wavelength. 3 ) Use Source Limits: When checked these monitors use the source limits. When unchecked, the frequencies/wavelengths at which to record data can be set using the pull down menus and boxes below them. 4 ) Spacing Type: Set spacing type, the options are wavelength and frequency. 5 ) Spacing Limit: Set spacing limits, you can set min/max of wavelength and center/span of wavelength. When the use source limits option is checked, this option will be disabled. 6 ) Frequency Points: Set to choose the number of frequency points at which to record data (Default 5). 5.2 Advanced tab​ 1 ) Min Sampling Per Cycle: This parameter suggests the realistic minimum amount of samplings for each optical cycle. Default value is 2 (the Nyqusit limit) for sake of the optimum efficiency. 2 ) Desired Sampling: This converts the minimum sampling points in each optical cycle into an actual rate of sampling measured by Hz. 3 ) Nyquist Limit: The Nyquist limit of sampling is determined in accordance with the maximum frequencies that may arise in the simulation region. 4 ) Actual Sampling: The actual rate of sampling is identical to the rate that is actually employed for the discrete Fourier transform (DFT), by appropriately taking the desired sampling rate, the Nyquist limit, and the time step dt into account. 5 ) Down Sample Time: This specifies the time for step down sampling. "},{"title":"Port","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/6Port","content":"","keywords":""},{"title":"1 FDTD Port​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#1-fdtd-port","content":"Feature description:Ports are usually viewed as a combination of mode source, field monitor and mode expansion monitor. Ports can be used either separately or together with the S-parameter sweep tool to compute the S-parameters for a device by means of the mode expansion method. Notes:Press the &quot;Port&quot; button in the menu bar, and select &quot;FDTD Port&quot; from the drop-down menu to add a port. Note that the prerequisite is that an FDTD simulation region must be already there. Upon adding a port, a port group named “Ports” is automatically generated as the child of the “Object Tree” , and all port objects are enclosed in this group. In particular, the port hierarchy is arranged in such a manner that ports cannot be moved outside the “Ports group”, and other objects are not allowed to be moved into the group. 1.1 FDTD Port Group tab​ 1) Source Port:This option enables you to choose one from a list of the existing ports as the source port. 2) Source Mode:The mode of each port can be selected through “Mode Selection” in its “Modal Properties” tab, after which the mode number is recorded in “Source Mode” automatically 3) Waveform Name:Waveform name is identified by “Waveform ID”. 1.2 The Geometry tab of FDTD Port​ 1) X,Y,Z:The center position of the simulation region. 2) X Min, X Max:X min, X max position. 3) Y Min, Y Max:Y min, Y max position. 4) Z Min, Z Max:Z min, Z max position. 5) X Span, Y SP, Z Span:X, Y, Z span of the simulation region. 1.3 The Modal properties tab of FDTD port tab​ 1) Injection Axis:This indicates the axis of propagation. The geometry parameters that will work under the &quot;Geometry&quot; tab may depend on this setting (For instance, if the incident wave is along the x-axis, the port object possesses accordingly a 2D x-normal geometry). 2) Direction:This field indicates the direction of source propagation. Forward means the propagation is along a positive direction, while Backward means the propagation is along a negative direction. 3) Amplitude:&quot;Amplitude&quot; specifies the peak magnitude of electric field measured by V/m in the beam sources. (Default :1) 4) Phase:This refers to the phase of the source measured by degrees. 5) Mode Selection:This enables the user to select the modes used in the mode expansion computations. The eigenmode solver, with which the user may compute and visualize the supported modes (See “Mode Analysis”), is launched by checking the &quot;User Select&quot; option---this option can also be used to select the desired mode among multiple ones. Besides, the eigenmode solver offers a toolkit of frequency analysis. (See &quot;Frequency Analysis&quot;) 6) Bent Waveguide:Selecting this option enables the bent waveguide solver to work with the following settings:. ① Bend Radius:This specifies the bend radius in units of um counted from the center of the port region. (Default value: 1.000e+6 um) ② Bend Orientation: This specifies the orientation of the cylindrical coordinates employed for the computation of modes.Orientation of the cylindrical coordinate system used for calculating modes. ③ Bend Location: This option specifies the location of bend. (Note that only the simulation center is supported at present) 1.4 Mode Analysis window​ 1.5 Frequency Analysis window​ 1) Track Selected Mode: By checking this box, the selected mode from the list will be tracked. ① Start / Stop Frequency (THz): The beginning and final frequencies at which the modes will be solved for. The start frequency value defaults to the one for initial computations of modes inside the Modal Analysis tab, whenever a particular mode is being tracked. ② Start / Stop Wavelength (μm): The beginning and final wavelengths at which the modes will be solved for. The start wavelength value defaults to the one for initial computations of modes inside the Modal Analysis tab, whenever a particular mode is being tracked. ③ Number of Points: The number of sampling frequencies/wavelengths to be included in the sweep. ④ Number of Trial Modes: This number specifies the maximum amount of modes to be swept. To track a single mode, this number is recommended to be about 3 in order to reduce the computation time to its minimum (this number will need to be raised a little bit in case there are discontinuities in the sweep data). When “Track Selected Mode” is not selected, this number determines the maximum amount of modes to be swept over the domain of frequency/wavelength within our attention scope. ⑤ Effective index: This parameter indicates the effective index value around which the modes will be solved for. It takes effect only when the selected modes are not being tracked. (Default: 1) ⑥ Detailed Dispersion Calculation: Mode properties at extra frequencies are computed for collecting more accurate dispersion data over the domain of frequency/ wavelength within our attention scope. This produces more precise results with extra cost of time. 2) Bent Waveguide: Check this option to enable sweeping a waveguide with a bend inside. ① Bend Radius: The curvature radius of the waveguide bend. ② Bend Orientation: The orientation of the waveguide bend ③ Bend Location: The location of the waveguide bend. 3) Plot area: The plot area where the simulation data is plotted in line or image. Mode list: Mode list where the “ID”, “Effective Index”, “Group Index”, “Wavelength”, “Loss”, and “TE Polarization Fraction” are shown. How many modes will be shown, will according to the “Number of Trial Modes” setting. 4) Frequency Plot : The frequency plot options are used to specify which data to plot in the plot window, and also can be used to modify the current frequency plot options. 2 EME Port​ Feature Description: The EME solver region contains 2 ports by default. The ports button found in the menu bar adds additional ports to the solver. 2.1 Geometry tab​ 1) Port Location: The port can be selected to locate at the left or right end of the EME solver region. 2) Use Full Simulation Span: By checking this option, the whole simulation span inheritted from the EME simulation region is employed. (Default: on) You need to uncheck this option if you wish to specify your own spans for the port. Therefore the following parameters settings are invalid when &quot;Use Full Simulation Span&quot; is enabled. 3) X, Y, Z: The center position of the simulation region. 4) X MIN, X MAX: X min, X max position. 5) Y MIN, Y MAX: Y min, Y max position. 6) Z MIN, Z MAX: Z min, Z max position. 7) X SPAN, Y SPAN, Z SPAN: X, Y, Z span of the simulation region. 2.2 EME Port tab​ 1) Offset: An offset can be endowed to the plane upon which the modes are computed. This guarantees that monitors placed at an angle do not interfere with unexpected structures. 2) Number of Trial Modes: This specifies the number of modes to search for finding a fundamental mode. The modes eventually found by the solver may depend on that. If one uses a too small number, the expected modes could be missing. Usually, setting this number to 100 suffices to guarantee no physical modes would have been missed. However, users who are interested in higher order modes should set a even larger value, since in such cases more than 100 modes may be present. (Default value: 20) 3) Mode Selection: ①　Allow you to select the modes to use for the mode expansion calculation. The &quot;user select&quot; option launches the eigenmode solver where the user can calculate and visualize the supported modes; use this option to select multiple modes. The &quot;Mode calculation&quot; section Allow you to select a mode they are interested in. The user S-matrix result returns the S-matrix for these selected modes. A selected mode can also be used as an input source in the EME propagation stage of the analysis, Fundamental Mode, Fundamental TE Mode, Fundamental TM Mode, Fundamental TE and TM Mode, Use Select and User Import are included. (Default: fundamental mode) ②　Checking the &quot;user select&quot; option enables you to specify mode parameters in the ``Select Mode'' window. The number of trial modes will be displayed in the mode list after they are solved by computation. The plot options of the user's interest can be specified in the mode plot options section. Select Mode tab: ③　User import: Import arbitrary source fields into EME ports. It is possible to use a custom field profile from a .mat file, .datx file or .zbf file as the source in an EME simulation. The field profile data can be from another simulation. To set this as a port mode, open the Edit EME port tab, select “User import” under mode selection and click on “Import Field”. Click the “Click to upload” button, select a generated custom field profile, if you has imported several profiles in the right section, you can specify one of them from right section, then the custom field profile has been imported successfully. Finally, click the “OK” button to save the custom profile. "},{"title":"Check Memory","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/8Checkmemory","content":"Check Memory Feature description:Before running, user can press “ Check Memory Requirements” to check the needed memory.","keywords":""},{"title":"Run","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/9Run","content":"Run Feature description:Run simulation Notes: Please save all the settings, before running simulation. If user chooses FDE simulation, the work flow is Run-&gt;Run FDE -&gt; FDE Analysis -&gt; Calculate modes. If user chooses EME simulation, the work flow is Run-&gt;Run EME -&gt; EME Analysis-&gt;EME propagation / EME sweep / Wavelength sweep. If user chooses FDTD simulation, the work flow is Run-&gt;Run FDTD. Supports simulation memory requirements check.","keywords":""}]