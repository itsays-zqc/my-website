[{"title":"Release Log","type":0,"sectionRef":"#","url":"/my-website/blog/release blog","content":"","keywords":""},{"title":"V3.1.5.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v3150","content":"Release Date: 2023/07/11 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software","content":"Passive Meshgen: V1.6.0.0 Build: 240628.1611 FDTD_CPU: V1.85.2.1 Build: 240512.2338 FDTD_GPU: V1.30.1.1 Build: 240512.2337 FDE: V1.4.9.1 Build: 240618.1925 EME: V0.9.42.1 Build: 240618.1900 ModeExpansion: V1.36.2.0 Build: 240418.1740 FarField: V0.7.0.0 Build: 240301.1711 Overlap: V0.6.6.0 Build: 240701.1307 "},{"title":"V3.2.3.0 2024/07/01​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v3230-20240701","content":"Version: MaxOpticsStudioSetup-3.2.3.0-windows-amd64+build.0701 Update time: 2024/07/01 content: Optimize click Run to pop up a Resource pop-up windowOptimize expression validation logicOptimize the logic of renaming global variablesOptimize progress bar displayOptimize some function prompt informationThe default value of FDTD adapts according to the size of the structureRulerUnit Scale Value Range[0.001,1000]Farfield/Overlapdoes not require the operation of Solver and can be run directlyOptimize the error messages for common errors in DDMImport doping supports file formats such a .txt/.datThe Charge Monitor and other results in SDK support the Save As function, which enables the solution of charge carriers and the import of the complete process of model solving in one scriptImprove the display logic of non input parameter values at the interface of electrical materials New features added Right click on Version to add Delete results only functionObject Tree supports right-click DeleteAdd Apply in All Directions to FDE/FDTD/EME Boundary ConditionsAfter clicking Run on the Ribbon menu, a Stop function has been addedAdd Animate verification to SweetAdd Boundary Conditions setting to View OptionObject Tree adds Copy and PasteNew GUI interface TFLN/APD simulation casesAdd TFLN/APD simulation support and case studies in SDKAdd Doping Monitor and support Doping Monitor Correction Fix the issue of preventing pop-up windows from closing when running tasks such as FDE/OverlapFix the issue where Global Options do not support global variablesFix invalid settings for Tolerance Relax, Relative Tolerance, and Divergence Factor parameters in DDM. Remaining defects Occasional engineering errors using undo/redoEME Index Monitor does not support Y normal/Z normalWhen the installation path is too deep or the project file name is too long, simulation failure may occur due to the Windows longest path (260 characters) limit.Structures made of the same material have different colors from a CAD perspectiveThe Mesh grid display of Monitor is not aligned with the mode fieldGlobal variables do not support uppercase letters and underscoresOccasional result file opening failureSDK show 3D occasional errorThe SDK Structure setting does not verify whether the tilt angle is self crossing, and opening it in GUI will result in an errorOccasional simulation progress shows 100% stuck, and the project needs to be manually stopped and restartedEME Profile Monitor result errorThe mode field csv coordinates generated by SDK are offset by half of the gridNot supporting the Windows 11 professional workstation versionSDK does not support extracting the results of Doping Monitor after simulation endsWhen importing a larger modex file from Data Space and switching to CAD, it may cause CAD to become blankThe Preview in Transform occasionally doesn't workPart of the CAD display shows too many decimal placesEME Sweep occasionally failed to initiate a task and needs to be rerun Historical Versions  "},{"title":"V3.2.2.0 2024/05/22​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v3220-20240522","content":"Version: MaxOpticsStudioSetup-3.2.2.0-windows-amd64+build.0522Update time: 2024/05/22 Improvement Save AsSave Logic AdjustmentsThe Transform table supports global expressionsImprove the CAD interface and Ctrl key multi selection logicImprove the display of the Import GDS interfaceEnrich the Doping and Attribute icons New features added Add dipole sourceAdd Bloch boundaryAdd EME port rotation functionAdded GPU driver inspection functionNew addition of electrical LiNbO3 material and anisotropic dielectric constant modelAdd FDE import electric field distribution decomposition functionAdd Impact Ionization modelAdd DDM module function for SDKAdd DDM license settings for the Setup and License settings interfacesAdd interface script Correction Fix the issue where DDM simulation does not support Structure Group Remaining defects Occasional engineering errors using undo/redoEME Index Monitor does not support Y normal/Z normalWhen the installation path is too deep or the project file name is too long, simulation failure may occur due to the Windows longest path (260 characters) limitStructures made of the same material have different colors from a CAD perspectiveThe Mesh grid display of Monitor is not aligned with the mode fieldGlobal variables do not support uppercase letters and underscoresOccasional result file opening failureSDK show 3D occasional errorThe SDK Structure setting does not verify whether the tilt angle is self crossing, and opening it in GUI will result in an errorOccasional simulation progress shows 100% stuck, and the project needs to be manually stopped and restartedEME Profile Monitor result errorThe mode field csv coordinates generated by SDK are offset by half of the grid  "},{"title":"V3.1.4.3 2024/05/13​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v3143-20240513","content":"Version: MaxOpticsStudioSetup-3.1.4.3-windows-amd64+build.0513 Update time: 2024/05/13 Improvement None New features added None Correction Fixed the issue where the mode source profile displayed an error when using the User Import feature in FDTD Remaining defects Occasional engineering errors using undo/redoEME Index Monitor does not support Y normal/Z normalWhen the installation path is too deep or the project file name is too long, simulation failure may occur due to the Windows longest path (260 characters) limitStructures made of the same material have different colors from a CAD perspectiveThe Mesh grid display of Monitor is not aligned with the mode fieldGlobal variables do not support uppercase letters and underscoresCalculation error in Energy Density of FDE x-normalOccasional result file opening failureSDK show 3D occasional errorThe SDK Structure setting does not verify whether the tilt angle is self crossing, and opening it in GUI will result in an errorOccasional simulation progress shows 100% stuck, and the project needs to be manually stopped and restartedEME Profile Monitor result errorThe mode field csv coordinates generated by SDK are offset by half of the grid  "},{"title":"Directional Coupler","type":0,"sectionRef":"#","url":"/my-website/docs/examples/GUI Examples/PIC/DirectionalCoupler/","content":"Directional Coupler Introduction​ Directional couplers (DC) are an important category of optical splitters, typically composed of two adjacent single-mode optical waveguides. The coupling coefficient is determined by both the length of the coupler and the gap between them. This feature allows for effective control of the splitting ratio.This characteristic allows effective control of the power split ratio. When it comes to directional couplers, we pay close attention to several key parameters, including insertion loss, splitting ratio, device dimensions, and operating bandwidth. Simulation​ The FDTD module can be used to perform precise calculations of light propagation in the DC. The light field transmission images in the monitor allow for a visual assessment,the related data of which facilitate further optimization and validation of the coupling length and spacing parameters in the DC splitter. After data processing, it can be obtained that the splitting ratio, insertion loss, and operating bandwidth of DC. In designing high-performance directional couplers for various optical communication and integrated photonics applications, these calculations and optimization processes are instrumental. Next, we will learn how to model a Directional Coupler using the GUI and calculate the light propagation in the structure using the FDTD module. 1. Simulation Structure​ As shown in the picture, there is the structure preivew of the directional coupler building in the simulation project. The parameters which are used in this simulation are listed in the table. Parameters\tValue\tUnit\tDescriptionh_wg\t0.22\tμm\twaveguide height w_wg\t0.5\tμm\twaveguide width tilt_angle\t8\tdegree\ttilt angle gap\t0.45\tμm\tgap between two waveguides l_dc\t20\tμm\tbeam length l_input\t5\tμm\tinput wavelength length h_slab\t0.09\tμm\tslab height bend_radius\t10\tμm\tradii of curvature monitor_w\t2\tμm\tmonitor width monitor_h\t1\tμm\tmonitor height cpw\t6\t-\tcell per wavelength 2. Simulation Steps​ In this chapter, we will learn how to build the whole simulation project of directional coupler by the GUI. 2.1 Add global parameters​ we need to set the relevant parameters for simulation and parameterized modeling in the project. To add a global variable in the “Global Parameter” area, right-click there and select “Add”. In the “Expression” column, you can input functions, and the “Value” column displays the current variable value. You can also provide a description for the variable in the “Description”, as shown in the image below.The &quot;Dependencies Check&quot; can help to check the varible used the in this simulation. 2.2 Materials​ Subsequently, before building the structures, we need the materials required for the simulation. In the material library above the GUI, you can import material data in &quot;Material Library&quot; or creat the new material using &quot;New Material&quot;. Once you’ve selected or customized the material, click “Export to Project” to add it to the Objects Tree. This makes it easier to use the material during subsequent modeling processes. The steps are illustrated in the image below. 2.3 Structures​ Next, we can create the model of directional coupler by the geometries in &quot;Structure&quot; part. In this example, we mainly need the &quot;Rectangle&quot; , &quot;Straight Waveguide&quot; and &quot;Bezier Waveguide&quot;,clicking the specific geometry to add it into the Objects Tree. Moreover, it is conveniently to use the global paramaters changing the structures of directional coupler. 2.4 FDTD Simulation​ After adding materials and creating the model, we need to configure the simulation module and its parameters. For this simulation, we primarily use the Finite-Difference Time-Domain (FDTD) algorithm. As shown in the figure below, locate the ‘FDTD Solver’ under the ‘Set Solvers’ module, click to open the pop window, and set the relevant parameters, including the ‘General,’ ‘Geometry,’ ‘Mesh Settings,’ ‘Boundary Condition,’ and ‘Advanced Options’ tabs. Once configured, click ‘OK’/‘Apply’ to add the FDTD solver to the simulation. 2.5 Source​ Then we need to establish the light source in the input waveguide. In the entire GUI interface, locate the ‘Source’ section at the top. Currently, it supports adding four types of sources: Mode Source, Gaussian Source, Dipole Source and Optical Generation. For this simulation, we are using a mode source. Click to open the dialog box for the mode source and set its relevant parameters, including the ‘General,’ ‘Geometry,’ and ‘Waveform’ sections. Once configured, click ‘Apply’ or ‘OK’ to add the light source to the Objects Tree.” 2.6 Monitors​ After adding the simulation light source, we need to include various types of monitors in the simulation to obtain the necessary simulation data. The currently supported monitor types include the following: Index Monitor, Field Time, Frequency-Domain Field and Power, EME Profile Monitor, Doping Monitor, Charge Monitor, Band Monitor, Electrical Monitor, and the Global Option for settings monitor parameters globally. We primarily utilize the Field Time Monitor and the Frequency-Domain Field and Power Monitor in this simulation.The Field Time Monitor allows us to collect data in the time domain, while the Frequency-Domain Field and Power Monitor extracts field profiles and power. 2.7 Analyses​ Subsequently, we can further analyze the simulation results in the ‘Analysis’ section. Currently, the supported analyses include: Far Field, Mode Expansion, Overlap, Generation Rate, FDE Analysis, EME Analysis, Matrix Sweep, and Parameter Sweep. Select the desired module, complete the analysis settings, and click ‘Apply’ or ‘OK’ to add it to Objects Tree or Sweep. For this simulation, we primarily use Mode Expansion to obtain the fractional amount of power transmitted into different mode. 2.8 Check Memory/Run​ After completing the above steps, we can begin running the simulation. Before running, you can estimate the required memory by using the ‘Check Memory’ feature. Then, in the GUI’s ‘Run’ module, you can execute the simulation and perform the analysis.For FDTD simulations, the software also supports GPU acceleration. 3. Output Results​ After running the program, we can obtain a series of corresponding output results: Incident light electric field intensity, CRO output port electric field intensity, and TRU output port electric field intensity. DC (Directional Coupler) Z-direction electric field intensity at different wavelengths: 1.50 μm, 1.55 μm, and 1.60 μm. Cross output port and TRU output port transmittance at different wavelengths,from 1.50 μm to 1.60 μm. TE0 mode transmission at Cross output port and TRU output port for different wavelengths,,from 1.50 μm to 1.60 μm. Based on the information provided, we can get the following results when propogating wavelength is 1.55 μm and the two arm length of directional couper is equal to 20 μm: 1. Insertion Loss: 0.076 dB; 2. Power Split Ratio: 60.5 : 37.8 (or approximately 60.5% to one port and 37.8% to the other port); 3. Dimensions: Approximately 3.5 μm X 44 μm. References​ Chrostowski, L., &amp; Hochberg, M. (2015). Silicon Photonics Design: From Devices to Systems. Cambridge: Cambridge University Press. doi:10.1017/CBO9781316084168","keywords":""},{"title":"Multi-Mode Interference","type":0,"sectionRef":"#","url":"/my-website/docs/examples/GUI Examples/PIC/MMI/","content":"Multi-Mode Interference Introduction​ Multi-mode interferometer which consists of input/output waveguides and the multimode interference core area, due to their advantages of low insertion loss, wide bandwidth, simple fabrication process, and good tolerance, have been widely used in important optical devices such as optical switches and wavelength-division multiplexers. The main performance parameters of multi-mode interference couplers include insertion Loss, imbalance, device dimensions, operating bandwidth. Simulation​ The FDTD module can be conducted to obtain the intensity distribution of the optical field and the transmittance at each port. This allows the verification of the optimized results for the multi-mode interferometer. After data processing, performance parameters such as the imbalance, insertion loss, and bandwidth of the device can be determined. Next, we will learn the steps about how to model the Multi-mode interferometer using the GUI and calculate the light propagation in the structure using the FDTD module. 1. Simulation Structure​ As shown in the picture, there is the structure preivew of the MMI building in the simulation project. The parameters which are used in this simulation are listed in the table. Parameters\tValue\tUnit\tDescriptionwg_width\t0.45\tμm\twidth of waveguide wg_length\t3*wv_center\tμm\tlength of input/output waveguides wg_height\t0.22\tμm\theight of waveguide taper_length\t3\tμm\tlength of taper taper_width\t1\tμm\twidth of taper MMI_length\t4.8\tμm\tlength of MMI core MMI_width\t2.4\tμm\twidth of MMI core gap\t0.2\tμm\tgap between output tapers bezier_length\t5\tμm\tlength of bezier waveguide bezier_width\t3\tμm\twidth of bezier waveguide wv_center\t1.55\tμm\twavelength center wv_span\t0.1\tμm\twavelength span angle\t90\tdegree\ttilt angle of waveguide sidewall frequency_points\t11\t-\tfrequency points total_length\t2(wg_length+taper_length)+MMI_length+bezier_length\tμm\tlength of MMI simu_yspan\tMMI_width+2bezier_width+2wv_center\tμm\tthe y span of simulation cells_per_wavelength\t10\t-\tcells per wavelength 2. Simulation Steps​ Now let's learn how to build the whole simulation project of the 1X2 MMI by the GUI. 2.1 Add global parameters​ we need to set the relevant parameters for simulation and parameterized modeling in the project. To add a global variable in the “Global Parameter” area, right-click there and select “Add”. In the “Expression” column, you can input functions, and the “Value” column displays the current variable value. You can also provide a description for the variable in the “Description”, as shown in the image below.The &quot;Dependencies Check&quot; can help to check the varible used the in this simulation. 2.2 Materials​ Subsequently, before building the structures, we need the materials required for the simulation. In the material library above the GUI, you can import material data in &quot;Material Library&quot; or creat the new material using &quot;New Material&quot;. Once you’ve selected or customized the material, click “Export to Project” to add it to the Objects Tree. This makes it easier to use the material during subsequent modeling processes. The steps are illustrated in the image below.And in this simulation, we mainly use the SiO2,Si and Air materials in the material library. 2.3 Structures​ Next, we can create the model of MMI by the geometries in &quot;Structure&quot; part. In this example, we mainly need the &quot;Analytical Waveguide&quot; , &quot;Straight Waveguide&quot; and &quot;Bezier Waveguide&quot;, clicking the specific geometry to add it into the Objects Tree. Moreover, it is conveniently to use the global paramaters changing the structures of directional coupler. 2.4 FDTD Simulation​ After adding materials and creating the model, we need to configure the simulation module and its parameters. For this simulation, we primarily use the Finite-Difference Time-Domain (FDTD) algorithm. As shown in the figure below, locate the ‘FDTD Solver’ under the ‘Set Solvers’ module, click to open the pop window, and set the relevant parameters, including the ‘General,’ ‘Geometry,’ ‘Mesh Settings,’ ‘Boundary Condition,’ and ‘Advanced Options’ tabs. Once configured, click ‘OK’/‘Apply’ to add the FDTD solver to the simulation. 2.5 Source​ Then we need to establish the light source. In the entire GUI interface, locate the ‘Source’ section at the top. Currently, it supports adding four types of sources: Mode Source, Gaussian Source, Dipole Source and Optical Generation. For this simulation, we are using a mode source. Click to open the dialog box for the mode source and set its relevant parameters, including the ‘General,’ ‘Geometry,’ and ‘Waveform’ sections. Once configured, click ‘Apply’ or ‘OK’ to add the light source to the Objects Tree.” 2.6 Monitors​ After adding the simulation light source, we need to add various types of monitors in the simulation to obtain the necessary simulation data. The currently supported monitor types include the following: Index Monitor, Field Time, Frequency-Domain Field and Power, EME Profile Monitor, Doping Monitor, Charge Monitor, Band Monitor, Electrical Monitor, and the Global Option for settings monitor parameters globally. We primarily utilize the Frequency-Domain Field and Power Monitor in this simulation. 2.7 Analyses​ Subsequently, we can further analyze the simulation results in the ‘Analysis’ section. Currently, the supported analyses include: Far Field, Mode Expansion, Overlap, Generation Rate, FDE Analysis, EME Analysis, Matrix Sweep, and Parameter Sweep. Select the desired module, complete the analysis settings, and click ‘Apply’ or ‘OK’ to add it to Objects Tree or Sweep. For this simulation, we primarily use Mode Expansion to obtain the fractional amount of power transmitted into different mode. 2.8 Check Memory/Run​ After completing the above steps, we can begin running the simulation. Before running, you can estimate the required memory by using the ‘Check Memory’ feature. Then, in the GUI’s ‘Run’ module, you can execute the simulation and perform the analysis.For FDTD simulations, the software also supports GPU acceleration. 3. Output Results​ the z-normal E intensity of FDTD propagation The E intensity of two output ports. The TE0 mode transmission at different wavelength of two ports Based on the information provided, we can get the following results when propogating wavelength is 1.55 μm. 1. Insertion Loss: -0.101 dB; 2. Dimensions: Approximately 8 μm X 22 μm.","keywords":""},{"title":"Microring Resonator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/GUI Examples/PIC/Ring/","content":"Microring Resonator Introduction​ As a typical passive device, the ring resonator is widely used in the integrated optics, which has the advantages of small size, wide free spectral range (free spectrum range, FSR), high quality factor (quality factor, Q), high sensitivity and so on. The structure characteristics of the ring resonator fit the large-scale photoelectric integrated system, which is widely used to constitute various functional devices, including filters, sensors, delay lines, wave division multiplexer, etc. The designer can adjust the resonance wavelength, FSR, Q value and coupling efficiency of the ring resonator by adjusting the ring size, the coupling spacing between the straight waveguide and the ring, and the refractive index distribution. The device is based on the principle of waveguide optics, using the time domain finite difference algorithm (Finite Difference Time Domain, FDTD), coupling mode theory (Coupled-mode theory, CMT). Simulation​ The FDTD module can be conducted to obtain the intensity distribution of the optical field and the transmittance at each port. This allows the verification of the optimized results for the microring resonator. Next, we will learn the steps about how to model the microring resonator using the GUI and calculate the light propagation in the structure using the FDTD module. 1. Simulation Structure​ As shown in the picture, there is the structure preivew of the microring resonator building in the simulation project. The parameters which are used in this simulation are listed in the table. Parameters\tValue\tUnit\tDescriptioncoupling_length\t4.5\tμm\tcoupling length of the resonator gap\t0.12\tμm\tgap between the track and bus waveguide waveguide_width\t0.45\tμm\twidth of waveguide radius\t5\tμm\tradius of ring waveguide_height\t0.22\tμm\theight of waveguide wavelength_center\t1.55\tμm\twavelength center wavelength_span\t0.1\tμm\twavelength span points_number\t201\t-\tnumber of frequency points angle\t87\tdegree\ttilt angle of waveguide sidewall cells_per_wavelength\t14\t-\tcells per wavelength 2. Simulation Steps​ Now let's learn how to build the whole simulation project of the Microring resonator by the GUI. 2.1 Add global parameters​ we need to set the relevant parameters for simulation and parameterized modeling in the project. To add a global variable in the “Global Parameter” area, right-click there and select “Add”. In the “Expression” column, you can input functions, and the “Value” column displays the current variable value. You can also provide a description for the variable in the “Description”, as shown in the image below.The &quot;Dependencies Check&quot; can help to check the varible used the in this simulation. 2.2 Materials​ Subsequently, before building the structures, we need the materials required for the simulation. In the material library above the GUI, you can import material data in &quot;Material Library&quot; or creat the new material using &quot;New Material&quot;. Once you’ve selected or customized the material, click “Export to Project” to add it to the Objects Tree. This makes it easier to use the material during subsequent modeling processes. The steps are illustrated in the image below.And in this simulation, we mainly use Si and Air materials in the material library. 2.3 Structures​ Next, we can create the model of microring by the geometries in &quot;Structure&quot; part. In this example, we mainly need the &quot;Straight Waveguide&quot; and &quot;Ring&quot;, clicking the specific geometry to add it into the Objects Tree. Moreover, it is conveniently to use the global paramaters changing the structures of microring resonator. 2.4 FDTD Simulation​ After adding materials and creating the model, we need to configure the simulation module and its parameters. For this simulation, we primarily use the Finite-Difference Time-Domain (FDTD) algorithm. As shown in the figure below, locate the ‘FDTD Solver’ under the ‘Set Solvers’ module, click to open the pop window, and set the relevant parameters, including the ‘General,’ ‘Geometry,’ ‘Mesh Settings,’ ‘Boundary Condition,’ and ‘Advanced Options’ tabs. Once configured, click ‘OK’/‘Apply’ to add the FDTD solver to the simulation. 2.5 Source​ Then we need to establish the light source. In the entire GUI interface, locate the ‘Source’ section at the top. Currently, it supports adding four types of sources: Mode Source, Gaussian Source, Dipole Source and Optical Generation. For this simulation, we are using a mode source. Click to open the dialog box for the mode source and set its relevant parameters, including the ‘General,’ ‘Geometry,’ and ‘Waveform’ sections. Once configured, click ‘Apply’ or ‘OK’ to add the light source to the Objects Tree.” 2.6 Monitors​ After adding the simulation light source, we need to add various types of monitors in the simulation to obtain the necessary simulation data. The currently supported monitor types include the following: Index Monitor, Field Time, Frequency-Domain Field and Power, EME Profile Monitor, Doping Monitor, Charge Monitor, Band Monitor, Electrical Monitor, and the Global Option for settings monitor parameters globally. We primarily utilize the Frequency-Domain Field and Power Monitor in this simulation. 2.7 Analyses​ Subsequently, we can further analyze the simulation results in the ‘Analysis’ section. Currently, the supported analyses include: Far Field, Mode Expansion, Overlap, Generation Rate, FDE Analysis, EME Analysis, Matrix Sweep, and Parameter Sweep. Select the desired module, complete the analysis settings, and click ‘Apply’ or ‘OK’ to add it to Objects Tree or Sweep. For this simulation, we primarily use Mode Expansion to obtain the fractional amount of power transmitted into different mode. 2.8 Check Memory/Run​ After completing the above steps, we can begin running the simulation. Before running, you can estimate the required memory by using the ‘Check Memory’ feature. Then, in the GUI’s ‘Run’ module, you can execute the simulation and perform the analysis.For FDTD simulations, the software also supports GPU acceleration. 3. Output Results​ the z-normal normalized E intensity of FDTD propagation at wavelength 1.539 μm and 1.543 μm. The E intensity of two output ports. The TE0 mode transmission at different wavelength of the drop port.","keywords":""},{"title":"Modulator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/GUI Examples/Active_Device/MOD","content":"Modulator Introduction​ ​We have developed an electro-optic modulator based on carrier-depletion mechanism in silicon to simulate carrier and index distribution in a global structure. The drift and diffusion of carriers result in depletion at the PN junction. Applying a reverse bias voltage at the cathode broadens the depletion region, altering the carrier concentration and modulating the material's refractive index. Gaussian doping was employed in this model. Modulation efficiency, capacitance, and resistance were calculated to analyze the electro-optic characteristics of the modulator. ​The figure below illustrates the device structure we constructed, wherein the aluminum electrode is applied to the silicon modulator, and the entire device is encapsulated with silicon dioxide material. Simulation​ ​The present structural file provides a comprehensive guide for constructing a simulation structure and establishing a Gaussian doping distribution. Initially, one must construct the geometric structure of the device, incorporate materials and physical models, specify the doping distribution, and simulation boundary conditions, and set the light source and simulation solver. Eventually, the simulation result data should be extracted and output. ​Our simulation is designed with a light source entering along the X-axis, and the primary optoelectronic characteristic analysis takes place within the three-dimensional structure on the YZ plane. The FDE solver is utilized to preview the distribution of effective refractive index, and the OEDevice solver is used to preview the doping distribution of the device. Finally, we generate ad output the distribution map of doping and index in modulator structure. 1. Simulation Structure​ It is essential to incorporate materials for structure. The electrical and optical parameters of SiO2、Al and Si materials in the Material Library can be accessed. Then set simulation structure from structure of home. In the Ribbon menu, select &quot;New Material&quot;, specify the material name in the pop-up window, and then click the &quot;Load from Standard Library&quot; button on both the &quot;Optical&quot; and &quot;Electrical&quot; property pages to choose the corresponding optical and electrical materials. Adjust the material parameters as needed. Then click &quot;Import to Project&quot; to import the material into the current project and close the window. Click on &quot;Structure&quot; in the Ribbon menu, then select the corresponding structure type from the drop-down list. Set the name, geometric parameters, and material of the structure in the pop-up window, and finally click the &quot;OK&quot; button. To begin with, it is advisable to define the geometric region of the device structure in geometry and add materials to this region by material. The background material, which is usually Air or SiO2, should be added first. In the overlapping area of the materials, the material with a higher order value will take precedence over the one with a lower value. If the values of Mesh Order are the same, the material defined later will override the one defined earlier. It is worth noting that the material Aluminium will call the PEC material library. Parameter\tUnits\tDescriptionname Restricts the applicability of the statement to regions with the specified name. material Restricts the applicability of the statement to regions of the specified material. geometry Specifies the boundary of specified region in 3D direction x_min, x_max, y_min, y_max, z_min, z_max\tum\tSpecifies the minimum or maximum value in X/Y boundary of modulator structure. x_mean, x_span, y_mean, y_span, z_mean, z_span\tum\tSpecifies the center or spacing value in X/Y boundary of modulator structure.name\tStructure\tx/x span\ty/y span\tz/z span\tmaterialSlab\tRectangle\t0/1\t0/10\t0.045/0.09\tSilicon Rg\tRectangle\t0/1\t0/0.5\t0.155/0.13\tSilicon Anode\tRectangle\t0/1\t-4.4/1.2\t0.34/0.5\tAluminum Cathode\tRectangle\t0/1\t4.4/1.2\t0.34/0.5\tAluminum 1.1 Edit DDM​ Adding electrical silmulation solver, is the prerequisite for output structure file. The type of ddm module can be invoked to enable the charge carrier transport solver for analyzing the optoelectronic properties of a device. In the Ribbon menu, select &quot;Setup Solvers&quot;, then choose &quot;DDM&quot; from the drop-down list, and then set parameters such as background material, normal direction length of the device, and simulation area in the pop-up window. Specifies the boundary of electrical simulation for DDM solver in 2D direction. Additionally, we define the length of the three-dimensional X direction and the solution mode and temperature during the composite process. When specifying meshes, a balance should be struck between accuracy and numerical efficiency. The accuracy, convergence, and program memory of the subsequent computation are all affected by the quality and size of the elements in the mesh, making mesh partitioning crucial in this module. Achieving accuracy requires a fine mesh that can resolve all significant features of the solution, while numerical efficiency requires a coarse mesh that minimizes the total number of grid points. Due to the relatively simple structure of this modulator, a rough initial mesh can be established for electrical simulation of the entire device. We utilize the newton iteration method for calculation, and the mumps direct solver is employed as the linear solver. The max_iterations parameter defines the maximum number of nonlinear iterations. When the number of iterations exceeds this value, the solver reduces the voltage step and starts a new iterative computations. 1.2 Set Doping​ You should define the name and geometry for doping region,and basic parameters of doping module in dopant, such as dopant type and concentration. 1.2.1 Constant Doping​ Specifies the concentration of uniform doping by Concentration and its boundary throuth Geometry in Y-Z plane. Dopant Type specifies the n-type or donor dopant in n , and p-type or acceptor dopant in p , which may be used with gaussian and uniform profile types. Parameter\tUnits\tDescriptionx_min, x_max, y_min, y_max, z_min, z_max\tum\tSpecifies the minimum or maximum value in X/Y boundary of modulator structure. x_mean, x_span, y_mean, y_span, z_mean, z_span\tum\tSpecifies the center or spacing value in X/Y boundary of modulator structure. applicable_regions Selections are ['all_regions','solid','material'] 1.2.2 Diffusion Doping​ Specifies the junction width and peak concentration of gaussian doping byJunction Width and Concentration , its boundary throuth Geometry.Then define source face、junction width、peak concentration and reference concentration in gaussian doping. ref_concentration specifies the diffusion boundary of Gaussian doping. 1.2.3 Import Doping​ Import a new doped file with device structure from the &quot;Data Space&quot; that has already stored doped data files, or from a local path. 1.3 Set Contact​ 1.4 Set Monitor​ Charge Monitor support both 2D and 1D geometry. Parameters\tDefault\tType\tNotesinterpolate_accuracy\t1\tinteger\tSet the accuracy of the rectangular grid for extracting the monitor result. Restrained by condition: &gt;=1 &amp;&amp; &lt;= 10. Here 1 means the grid size is 10nm, and 10 means the grid size is 1nm, and the grid size varies uniformly with the variation in 'interpolate_accuracy'. | Parameters | Default | Type | Notes | | :----------------------------: | :-----: | :-----: | :----------------------------------------------------------: | |monitor_type | | string | Selections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. | 2. Simulation Steps​ 2.1 Obtain Carrier Distribution​ Set the BC model and scanning method here. First, select &quot;Steady State&quot; in Solver Mode of DDM. ​The operational mechanism of the device we simulated in this study primarily revolves around the application of a reverse voltage to modify the width of the depletion region, thereby effectively modifying the carrier concentration and subsequently modulating the refractive index. Hence, it is necessary to specify the voltage of initial、termination and step, with both parameters expressed in volts. The bias voltage range is set for steady-state solutions. Chick Run and wait simulation result. Right-click on the &quot;Charge&quot; result in the &quot;Result View&quot; and select the &quot;Save As&quot; option to save the carrier distribution data with device coordinates as a cdat format file. Then import this data file into the &quot;data space&quot; for use in FDE analysis. 2.2 Modulation efficiency​ You could right-click on an existing version and click &quot;Create a new version&quot; in &quot;Versions&quot; The half-wave voltage refers to the applied voltage required by the modulator's optical signal to generate a phase difference of pi radians, directly reflecting the modulation efficiency of the modulator. Usually, the modulation efficiency of a device is represented by multiplying the half-wave voltage with a parameter that represents the length of the modulator required for phase variation. A smaller value of this parameter indicates higher modulation efficiency, resulting in a smaller required device size. According to the modulator's operating principle, the extra carriers created by the doped device under external bias form an internal electric field and depletion layer in the device via drift diffusion, resulting in changes in refractive index and loss. You may determine np density using DDM's steady-state solution by DDM and then input the data into FDE to calculate changes in optical loss and refractive index by FDE. The initial and ultimate step involves importing the optical characteristics of the substance and activating the nanoparticle density model for silicon materials. Select FDE from Setup Solvers, and set up the general, Geometry, Mesh Settings, Boundary Conditions and Advanced. Import the np density file, which contains the carrier distribution derived from the DDM method, into the FDE model. This integration facilitates the analysis of refractive index and loss variations as a function of bias voltage at specific wavelengths. Add FDE analysis about wavelength as follows: Run FDE solver and add the analysis to calculate the change of effective refractive index and optical loss under specific wavelength. Set the value of &quot;V_cathode&quot; as global parameter to sweep in &quot;Sweeps&quot;. ​This section of the program is dedicated to calculating the parameters VpiL and VpiLoss.​You should extract the parameters for transmission loss and the real part of effective refractive index. 2.3 Capacitance And Resistance​ You could right-click on an existing version and click &quot;Create a new version&quot; in &quot;Versions&quot; ​Capacitance and resistance play crucial roles in determining the performance of devices. Optimal capacitance values enable the modulator to selectively allow or block signals within specific frequency ranges, facilitating signal coupling. Suitable resistance values enable adjustment of signal amplitude and modulation current determination. ​The simulation program for calculating capacitance and voltage exhibits numerous similarities to the program used for investigating modulation efficiency. Prior to conducting the simulation, it is necessary to import the module in order to invoke the structures and physical models. ​The voltages to be applied to the electrodes of the device are specified. ​You can add a solver for the simulation and define its properties. Furthermore, the properties of the AC small-signal module are defined in this section. The frequency interval is logarithmically defined, specifying the initial frequency, final frequency, and the number of frequencies. The variable ssac_amplitude&quot; represents the amplitude of the small signal. In this instance, three frequency values (1, 100, and 10000 MHz) are selected from the range of 1e6 to 1e10. ​You can directly invoke the engineering function and device structure created, and then add the electrodes and their attributes. In this case, a bias voltage ranging from -0.5 V to 4 V with a scan step of 0.5 V is applied to the cathode electrode during small-signal simulation. Run DDM solver and wait simulation results, and export the data of the real and imaginary parts of the AC small signal current,post processed exported data. # region --- 7. Post Processing --- fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) for i,val in enumerate(ssac_frequency_span): plot_path_f = os.path.join(plot_path, f&quot;{val/1e6:.2f}MHz&quot;) Iac_real_data = np.genfromtxt(f&quot;{plot_path_f}/Iac_Cathode_real.csv&quot;, skip_header=1, delimiter=&quot;,&quot;) Iac_imag_data = np.genfromtxt(f&quot;{plot_path_f}/Iac_Cathode_imag.csv&quot;, skip_header=1, delimiter=&quot;,&quot;) Iac = Iac_real_data[:,1] + 1j * Iac_imag_data[:,1] Vdc = Iac_real_data[:,0] Z = ssac_amplitude/Iac R = np.abs(np.real(Z)) C = np.abs(np.imag(1/Z)/(2*np.pi*ssac_frequency_span[i]))/1e4*1e15 np.savetxt(f&quot;{plot_path_f}/resistance.csv&quot;, np.array((Vdc, R)).T, fmt='%f,%.15e', header='voltage,resistance') np.savetxt(f&quot;{plot_path_f}/capacitance.csv&quot;, np.array((Vdc, C)).T, fmt='%f,%.15e', header='voltage,capacitance') fig, ax1 = plt.subplots() fig.set_size_inches(12, 8) ax1.plot(Vdc, R, c='b', linewidth=linewidth, label=f&quot;f:{val/1e6:.2f}MHz&quot;,marker='o') ax1.set_xlabel('VBias[V]') ax1.set_ylabel('Resistance[Ohm]') ax1.legend() ax1.grid() plt.savefig(f&quot;{plot_path_f}/resistance.jpg&quot;) plt.close() fig, ax2 = plt.subplots() fig.set_size_inches(12, 8) ax2.plot(Vdc, C, c='b', linewidth=linewidth, label=f&quot;f:{val/1e6:.2f}MHz&quot;,marker='o') ax2.set_xlabel('VBias[V]') ax2.set_ylabel('Capacitance[fF/um]') ax2.legend() ax2.grid() plt.savefig(f&quot;{plot_path_f}/capacitance.jpg&quot;) plt.close() # endregion 3 Output Result​ 3.1 NP Density​ The charge distribution of n type and p type from charge monitor. 3.2 Loss​ ​This section displays the variation of losses with bias voltage. 3.3 Effective Index​ ​This section displays the variation of effective index with bias voltage. 3.4 Modulation efficiency​ ​ These graphs illustrate the relationship between two parameters that represent modulation efficiency as a function of bias voltage. VpiL\tVpiLoss 3.5 Small Signal AC Current​ ​This section displays the variations of AC current with respect to bias voltage at 100MHZ. 3.6 Capacitance​ ​This section displays the variations of capacitance with respect to bias voltage at 100MHZ.","keywords":""},{"title":"Grating Coupler","type":0,"sectionRef":"#","url":"/my-website/docs/examples/SDK Examples/PIC/GratingCoupler/","content":"Grating Coupler Introduction:​ Grating coupling is a simple method for connecting photonic integrated chips with optical fibers. Simulation​ 1 Code Description​ 1.1 Import Toolkit​ First, we need to import maxoptics_sdk and Python's third-party package. The import module for FDE and FDTD simulation are shown below. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time import numpy as np from typing import NamedTuple 1.2 Define Simulation Function and parameters​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. Before starting the simulation, you can define variables to control the parameters. Set as follows. @timed @with_path def simulation(*, run_mode, wavelength, grids_per_lambda, run_options: 'RunOptions', **kwargs): # region --- 0. General Parameters --- waveform_name = f'wv{wavelength*1e3}' path = kwargs['path'] simu_name = 'GratingCoupler' time_str = time.strftime('%Y%m%d_%H%M%S', time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + '/examples_gds/gc.gds' kL = [f'0{k}' for k in range(5)] # endregion 1.3 Create project​ You can create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion 1.4 Add Material​ Here we demonstrate using the Material function to create material and using the add_lib function to add materials from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_nondispersion(name='Si', data=[(3.47656, 0)], order=2) mt.add_nondispersion(name='SiO2', data=[(1.44402, 0)], order=2) mt.add_lib(name='Air', data=mo.Material.Air, order=2) # endregion The name is used to define the name of the added material. The data is used to receive refractive index data extracted from the material library. The order is used to set the material priority of the grid. 1.5 Add waveform​ Adding a light source for simulating in 3D FDTD, and we use Waveform to set the waveform parameters of the light source. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1) # endregion name sets the name of the waveform, wavelength_center sets the center wavelength of the light source, and wavelength_span sets the wavelength range of the light source. 1.6 Add Structure​ Microring resonator is typical filter for Soi waveguide, including two straight optical waveguides and a coupled ring-shaped waveguide. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select the type from the structural components. The specific properties can be set as follows. # region --- 4. Structure --- st = pj.Structure() st.add_geometry( name='top_cladding', type='gds_file', property={ 'general': { 'path': gds_file, 'cell_name': 'gc', 'layer_name': (1, 0)}, 'geometry': {'z': 0.11, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2} } ) st.add_geometry( name='middle_cladding', type='gds_file', property={ 'general': { 'path': gds_file, 'cell_name': 'gc', 'layer_name': (2, 0)}, 'geometry': {'z': 0.075, 'z_span': 0.15}, 'material': {'material': mt['Si'], 'mesh_order': 2} } ) st.add_geometry( name='grating', type='gds_file', property={ 'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (3, 0)}, 'geometry': {'z': 0.185, 'z_span': 0.07}, 'material': {'material': mt['Si'], 'mesh_order': 2} } ) st.add_geometry( name='SiO2_TOX_UP', type='gds_file', property={'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (4, 0)}, 'geometry': {'z': 0.5, 'z_span': 1.0}, 'material': {'material': mt['SiO2'], 'mesh_order': 1} } ) st.add_geometry( name='SiO2_TOX_DOWN', type='gds_file', property={'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (5, 0)}, 'geometry': {'z': -1, 'z_span': 2}, 'material': {'material': mt['SiO2'], 'mesh_order': 2} } ) st.add_geometry( name='Si_substrate', type='gds_file', property={'general': {'path': gds_file, 'cell_name': 'gc', 'layer_name': (6, 0)}, 'geometry': {'z': -6, 'z_span': 8}, 'material': {'material': mt['Si'], 'mesh_order': 2} } ) # endregion Key\tValue\ttype\tDescriptionname\ttop_cladding\tstring\tname the added geometry type\tgds_file\tstring\tselect the type of structure x 0 float center position in the x-direction of the geometric structure path\tgds_file\tstring\tfile path of GDS file cell_name\tSSC\tstring\tname of the GDS cell layer_name\t(1,0)\tlist\tname of the GDS layer z\t0.11\tfloat\tcenter position in the z-direction of the geometric structure z_span\t0.22\tfloat\tlength of the geometric structure in the z-direction material\tmt[&quot;Si&quot;]\tmaterial\tselect the material added Materials mesh_order\t2\tinteger\tset the priority of the material 1.7 Set Boundary​ Set the user defined parameters of pml boundary in the simulation. # region --- 5. Boundary --- bc = { &quot;pml_layer&quot;: 8, &quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 0.8, &quot;pml_polynomial&quot;: 3, &quot;pml_alpha&quot;: 0, &quot;pml_alpha_polynomial&quot;: 1, } # endregion 1.8 Add Simulation​ We use the `Simulation` function to create a simulation and the `add` function to add a solver. # region --- 6. Simulation --- simu = pj.Simulation() simu.add( name=simu_name, type=&quot;FDTD&quot;, property={ &quot;background_material&quot;: mt[&quot;Air&quot;], &quot;geometry&quot;: { 'x': -3.5, 'x_span': 47, 'y': 0, 'y_span': 28, 'z': -0.5, 'z_span': 5 }, &quot;boundary_conditions&quot;: { &quot;x_min_bc&quot;: &quot;PML&quot;, &quot;x_max_bc&quot;: &quot;PML&quot;, &quot;y_min_bc&quot;: &quot;PML&quot;, &quot;y_max_bc&quot;: &quot;PML&quot;, &quot;z_min_bc&quot;: &quot;PML&quot;, &quot;z_max_bc&quot;: &quot;PML&quot;, &quot;pml_settings&quot;: { &quot;x_min_pml&quot;: bc, &quot;x_max_pml&quot;: bc, &quot;y_min_pml&quot;: bc, &quot;y_max_pml&quot;: bc, &quot;z_min_pml&quot;: bc, &quot;z_max_pml&quot;: bc, }, }, 'general': { 'simulation_time': 30000, # 'dimension': '2d' }, &quot;mesh_settings&quot;: { &quot;mesh_factor&quot;: 1.2, &quot;mesh_type&quot;: &quot;auto_non_uniform&quot;, &quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: grids_per_lambda}, &quot;minimum_mesh_step_settings&quot;: {&quot;min_mesh_step&quot;: 1e-4}, &quot;mesh_refinement&quot;: { &quot;mesh_refinement&quot;: &quot;curve_mesh&quot;, } }, # 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-5, 'down_sample_time': 100}}, } ) # endregion 1.9 Add source​ In 3D FDTD simulation, a light source is required. We use `Source` to create the light source and `add` to add the required light source. The settings for the light source as follows. # region --- 7. GaussianSource --- so = pj.Source() so.add( name='source', type='gaussian_source', property={ 'general': { 'angle_theta': 12, 'angle_phi': 0, 'polarization_angle': 90, &quot;inject_axis&quot;: &quot;z&quot;, &quot;direction&quot;: &quot;backward&quot;, 'waveform': {'waveform_id_select': wv[waveform_name]}, 'beam_settings': { 'beam_parameters': 0, # [waist_size_and_position,beam_size_and_divergence] 'waist_radius': 5.2, 'distance_from_waist': 1.5, # 'beam_radius': 5.201947263996544, # 'divergence_angle': 5.420045638438343 }}, 'geometry': {'x': 4, 'x_span': 20, 'y': 0, 'y_span': 20, 'z': 1.5, 'z_span': 0}}) # endregion Use type to select the type of light source, and axis to set the direction of the mode light source. 1.10 Add Monitor​ In the simulation, Monitor function is used to create monitor and add function is used to add a monitor. By using type to select a power monitor, the transmittance and field distribution of the cross-section can be obtained. It is necessary to add a time monitor to check the field strength at the end of the simulation to determine the accuracy of the simulation results. # region --- 8. Monitor --- ''' 8.0 GlobalMonitor ''' mn = pj.Monitor() mn.add(name='Global Option', type='global_option', property={'frequency_power': {'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 5}}) ''' 8.1 x_normal ''' mn.add(name='x_normal', type='power_monitor', property={'general': {'frequency_profile': {'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 101}}, 'geometry': {'monitor_type': '2d_x_normal', 'x': -26, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0.11, 'z_span': 3}}) ''' 8.2 y_normal ''' mn.add(name='y_normal', type='power_monitor', property={'geometry': {'monitor_type': '2d_y_normal', 'x': -5, 'x_span': 44, 'y': 0, 'y_span': 0, 'z': 0.2, 'z_span': 3.5}}) # endregion 1.11 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation.We support the GPU acceleration for FDTD simlation. # region --- 9. Run --- if run_options.run: fdtd_res = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0},{&quot;id&quot;: 1},{&quot;id&quot;: 2},{&quot;id&quot;: 3}]} ) # endregion 1.13 Run and Extract Results​ Extract data using extract, where data is the calculation result data, savepath is the storage path, target is the classification of the data, and monitor_name is the name of the monitor. The data extraction reference is as follows. # region --- 10. See Results --- if run_options.extract and run_options.run: fdtd_res.extract( data='fdtd:power_monitor', savepath=f'{plot_path}02_x_normal_abs(T)', monitor_name='x_normal', attribute='T', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, show=False ) fdtd_res.extract( data='fdtd:power_monitor', savepath=f'{plot_path}02_y_normal_abs(T)', monitor_name='y_normal', attribute='T', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, show=False ) fdtd_res.extract( data='fdtd:power_monitor', savepath=f'{plot_path}02_y_normal_E_{wavelength}_um', monitor_name='y_normal', target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=False, wavelength=f&quot;{wavelength}&quot;, plot_x=&quot;x&quot;, plot_y=&quot;z&quot;, show=False, export_csv=True, ) # endregion return fdtd_res if run_options.run else None 1.14 Control Switch​ We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code. In every simulation, only one solver will be enabled. When using the FDE solver, set &quot;run_fde&quot; to True and &quot;run_fdtd&quot; to False; When using the FDTD solver, set &quot;run_fdtd&quot; to True and &quot;run_fde&quot; to False. class RunOptions(NamedTuple): index_preview: bool run: bool extract: bool if __name__ == '__main__': simulation(run_mode='local', is_gds_import=True, wavelength=1.55, grids_per_lambda=8, run_options=RunOptions(index_preview=True, run=True, extract=True)) 2. Output results​ Electric profile​ When the wavelength of the incident light meets the Bragg condition, the incident light will enter the waveguide through grating coupling. Transmission​ The transmittance of grating coupling varies with wavelength as shown in the following figure. References​ D. Taillaert, F. Van Laere, M. Ayre, W. Bogaerts, D. Van Thourhout, P. Bienstman and R. Baets, “Grating Couplers for Coupling between Optical Fibers and Nanophotonic Waveguides,” Japanese Journal of Applied Physics, vol. 45, no. 8a, pp. 6071-6077, 2006.","keywords":""},{"title":"Directional Coupler","type":0,"sectionRef":"#","url":"/my-website/docs/examples/SDK Examples/PIC/DirectionalCoupler/","content":"Directional Coupler Introduction​ Directional couplers (DC) are an important category of optical splitters. They are typically composed of two adjacent single-mode waveguides, and the coupling coefficient is determined by both the length of the coupler and the spacing between them. This feature allows for effective control of the splitting ratio. When it comes to directional couplers, we pay close attention to several key parameters, including insertion loss, splitting ratio, device dimensions, and operating bandwidth. Simulation Methods​ The FDE module can be used to calculate the symmetric and anti-symmetric mode field distributions of the directional coupler’s two arms. From these calculations, the effective index can be determined, allowing for the theoretical calculation of the coupling length required to achieve the target splitting ratio. And the FDTD module can be used to perform precise calculations of light propagation in the DC. The light field transmission images in the monitor allow for a visual assessment,the related data of which facilitate further optimization and validation of the coupling length and spacing parameters in the DC splitter. After data processing, it can be obtained that the splitting ratio, insertion loss, and operating bandwidth of DC. In designing high-performance directional couplers for various optical communication and integrated photonics applications, these calculations and optimization processes are instrumental. Directional Coupler(FDE module)​ Using the FDE module, we will calculate symmetric and antisymmetric modes in a Directional Coupler modeled with the SDK. The input light can be considered a combination of the symmetric mode and the antisymmetric mode so that we can precisely calculate the coupling coefficient by effective index from the FDE module. Referring to the Silicon Photonics Design written by Lukas Chrostowski, we build the structure of the Directional coupler in the simulation. 1. Basic Operations​ 1.1 Import File​ Once you have installed and configured the environment, import the python code and the GDS layout. The example library and related model code are usually located in the directory :examples/func_demo. The GDS file is generally imported into the path :examples/examples_gds 1.2 SDK Initialization​ Create a new terminal and run the code after you import the python script and GDS file. Max-Optics SDK may take some time to connect the service. 2. Code Description​ Now let's learn the meaning of functions and parameters that correspond to the code. 2.1 import Modules​ To begin, we need to use the import command to call the relevant functional modules. For instance, we import the typing , os and time module in python. At the same time ,we import the customized module maxoptics_sdk.all and maxoptics_sdk.helper. from typing import List, Literal, NamedTuple import os import time import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path The typing module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. The os module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands. The time module provides various functions to work with time-related operations and to measure time intervals. The maxoptics_sdk package provides all in one optical simulation with Python. 2.2 Define Simulation​ Firstly, We define parameters and give them a default value, such as the simulation wavelength and grid accuracy. Note that we can override this value in the following code. def simulation(*, run_mode=&quot;local&quot;, wavelength =1.55, grid = 0.02, number_of_trial_modes = 20, run_options: &quot;RunOptions&quot;, **kwargs, ): The provided code contains comments that define the simulation parameters. Let's explain each of these parameters. The function simulation is used to define the simulation parameters for the program. The run_mode parameter determines the type of calculation resources to be used. The wavelength parameter specifies the wavelength of the input light in micrometers. The grid parameter represents the grid accuracy in micrometers. Lastly, the number_of_trial_modes parameter sets the number of modes to be calculated. The **kwargs is a special syntax used in function definitions to accept an arbitrary number of keyword arguments as a dictionary. 2.3 Define Parameters​ Define commonly used parameters in region 0, such as the width and height of the simulation boundary, the start time of the simulation, the path and name for the simulation output, the path to the imported GDS layout, and other parameters required for structural parameterized modeling. # region --- 0. General Parameters --- yspan_solver = 5 zspan_solver = 2 time_str = time.strftime('%Y%m%d_%H%M%S', time.localtime()) path = kwargs['path'] simu_name = f'FDE_DC_yspan={yspan_solver}_{time_str}' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + '/examples_gds/DC.gds' project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = kwargs.get('plot_dir', path) + '/plots/' + project_name + '/' kL = [f'0{k}' for k in range(5)] export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} l_bend=5.6 # the length of z bend l_arm=15 # the length of 2 arms l_input=2.5 # the length of input wg # endregion The code defines several parameters and variables necessary for the simulation process. The yspan_solver parameter represents the width of the simulation boundary specified in micrometers. Similarly, the zspan_solver parameter denotes the height of the simulation boundary in micrometers. The time_str variable is used to obtain the current time as a timestamp for the simulation. The path variable defines the file path for the simulation, while simu_name specifies the name of the simulation file. The gds_file_root_path variable defines the path for importing the GDS layout. The project_name variable assigns a name to the project for the simulation output. The plot_path variable determines the directory where the simulation result plots will be saved. The export_options parameter allows for the definition of options for exporting the simulation results. Lastly, the variables l_bend ,l_arm, and l_input represent the lengths of specific components within the simulation, such as the length of the z-bend, the length of the two arms, and the length of the input waveguide, respectively. These parameters and variables together facilitate the successful execution and organization of the simulation process. 2.4 Define Materials​ Indeed, let's proceed to the next step, where we set up the materials required for the simulation in region 2. In this case, we will directly use relevant materials from the MO material library. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) mt.add_lib(name='SiO2', data=mo.Material.SiO2_Palik, order=2) mt.add_lib(name='Air', data=mo.Material.Air, order=2) # endregion The add_lib is used to define three parameters name,data and order. The data calls up the property of simulation materials in the MO material library. The Order parameter determines the mesh order for the material during the simulation. Besides, we also support users to customize the material with add_nondispersionfunction. 2.5 Create Model​ Next, we will create the Directional Coupler model in region 3. We have two options for modeling the structure: # region --- 3. Structure --- st = pj.Structure() st.add_geometry( name=&quot;box&quot;, type=&quot;gds_file&quot;, property={ &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 6}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}, }, ) st.add_geometry( name=&quot;dc&quot;, type=&quot;gds_file&quot;, property={ &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (0, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, }, ) st.add_geometry( name=&quot;slab&quot;, type=&quot;Rectangle&quot;, property={ &quot;geometry&quot;: { &quot;x_min&quot;: -l_input - l_bend - l_beam / 2 - 3, &quot;x_max&quot;: l_input + l_bend + l_beam / 2 + 3, &quot;y&quot;: 0, &quot;y_span&quot;: 8, &quot;z&quot;: 0.045, &quot;z_span&quot;: 0.09,}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, }, ) # endregion Here, we import the DC layout from the GDS file. we can create the DC model directly within the SDK using the Structure function. The name parameter defines the structure name. The type parameter specifies the structure type. The path, cell_name, and layer_name parameters point to the GDS file and specify the relevant layers and cell names used in the layout. The geometry parameter sets the structure's coordinates. The material parameter specifies the material properties The mesh_order parameter sets the mesh order for building structures. 2.6 FDE Simulation​ After establishing the model, we can add the simulation region in region 4.We add the FDE simulation module to support mode calculations and frequency scans. We can also and define the simulation boundary conditions. This involves specifying the geometry of the simulation region, the boundary conditions in the xyz directions, and detailed parameters. # region --- 4. Simulation --- simu = pj.Simulation() simu.add( name=simu_name, type=&quot;FDE&quot;, property={ &quot;background_material&quot;: mt[&quot;SiO2&quot;], &quot;geometry&quot;: { &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: yspan_solver, &quot;z&quot;: 0, &quot;z_span&quot;: zspan_solver,}, &quot;boundary_conditions&quot;: { &quot;y_min_bc&quot;: &quot;PEC&quot;, &quot;y_max_bc&quot;: &quot;PEC&quot;, &quot;z_min_bc&quot;: &quot;PEC&quot;, &quot;z_max_bc&quot;: &quot;PEC&quot;,}, 'general': {'solver_type': '2d_x_normal'}, # default is '2d_x_normal' ['2d_x_normal','2d_y_normal','2d_z_normal'] &quot;mesh_settings&quot;: { &quot;mesh_refinement&quot;: { &quot;mesh_refinement&quot;: &quot;curve_mesh&quot; }, &quot;mesh_factor&quot;: 1.2, &quot;global_mesh_uniform_grid&quot;: { &quot;dy&quot;: grid, &quot;dz&quot;: grid, }, }, }, ) simu_res = simu[simu_name].run() # endregion In this code segment, the name parameter defines the name of the simulation module. The general parameter specifies the type of the simulation module within the structure. It supports the following list selection['2d_x_normal','2d_y_normal','2d_z_normal']. The mesh_settings parameter is set to the previously defined the mesh. In this case,we use Perfect Electric Conductor(PEC) boundary condition. The PEC boundary condition is a modeling approach used to simulate the behavior of perfectly conducting surfaces or boundaries in electromagnetic wave propagation analyses. This effectively models the behavior of a material with infinite conductivity and perfect electrical shielding. This boundary condition is particularly relevant when dealing with the interaction of light and electromagnetic fields with highly conductive materials, such as metals. Moreover, We also provide the usual boundary condition like Perfectly Matched Layer(PML) and Perfect Magnetic Conductor (PMC), you can change the PEC to PML or PMCof 4 dimensions in the code. 2.7 Add Sub-mesh​ To achieve more accurate calculations of the model's modal fields, we can add a sub-mesh in region 5. # region --- 5. Sub Mesh --- lm = pj.LocalMesh() lm.add( name=&quot;sub_mesh&quot;, property={ &quot;general&quot;: {&quot;dx&quot;: 0.002, &quot;dy&quot;: 0.002, &quot;dz&quot;: 0.002}, &quot;geometry&quot;: { &quot;x&quot;: 0, &quot;x_span&quot;: 6, &quot;y&quot;: 0, &quot;y_span&quot;: 2, &quot;z&quot;: 0, &quot;z_span&quot;: 0.2, }, }, ) # endregion In this code segment, we use the LocalMesh to add a sub-mesh. The name parameter defines the name of the mesh. The general parameter specifies the grid accuracy in the xyz directions (in this case, 0.002 micrometers in each direction). The geometry parameter sets the coordinates of the sub-mesh. 2.8 Add Analysis​ Such as mode expansion and frequency analysis, we can add a sub-mesh in region 5 to achieve more analysis. # region --- 6. Analysis --- analysis = pj.Analysis() analysis.add_analysis( name=&quot;Mesh Structure&quot;, type=&quot;FDEAnalysis&quot;, props={ &quot;workflow_id&quot;: simu_res.workflow_id, &quot;simulation_name&quot;: &quot;FDE&quot;, &quot;modal_analysis&quot;: { &quot;calculate_modes&quot;: run_options.run, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: number_of_trial_modes, &quot;search&quot;: &quot;max_index&quot;, # ['near_n','max_index'] &quot;n&quot;: 1, &quot;calculate_group_index&quot;: False, # 'mode_removal': {'threshold': 0.02}, &quot;bent_waveguide&quot;: { &quot;bent_waveguide&quot;: False, &quot;radius&quot;: 1, &quot;orientation&quot;: 0, &quot;location&quot;: &quot;simulation_center&quot;, }, }, &quot;frequency_analysis&quot;: { &quot;frequency_analysis&quot;: run_options.run_frequency_sweep, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 2.67, &quot;detailed_dispersion_calculation&quot;: False, }, } ) result_fde = analysis[&quot;Mesh Structure&quot;].run() # endregion The wavelength parameter sets the wavelength-related parameters for the simulation. The search parameter specifies the mode search type. It supports the following list selection['near_n','max_index']. In this case, we use max_index to automatically search for the mode with max index in the structure. To use the ‘near_n’, we need to set the data in ‘n’. The bent_waveguide parameter can be used to set parameters for a bent waveguide. The frequency_analysis parameter allows us to set parameters for frequency scans or mode calculations with varying wavelengths. 2.9 Retrieve Results​ In region 7, you can retrieve and store the simulation results. # region --- 7. See Results --- if run_options.run: k = kL[2] res = result_fde.extract( data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_neff_table&quot;, export_csv=True, ) print(res.to_string(index=False)) for m in range(len(res)): k = kL[3] result_fde.extract( data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_mode{m}&quot;, attribute=&quot;Ey&quot;, real=True, imag=False, mode=m, show=False, **export_options, ) if run_options.run_frequency_sweep: k = kL[4] result_fde.extract( data=&quot;frequency_analysis&quot;, savepath=f&quot;{plot_path}{k}_freq_sweep_neff&quot;, attribute=&quot;neff&quot;, real=True, imag=True, show=False, export_csv=True, export_mat=True, ) return project_name # endregion The extract function allows you to extract specific simulation results and store them for further analysis. The attribute parameter specifies the type of simulation results to be extracted. The mode parameter corresponds to the index of the FDE calculation mode. The real and imag parameters are used to extract the real and imaginary parts of the simulation results, respectively. If you run the frenquency sweep to calculate mode at different wavelength, you can also extract the relevant results. As an example above, we extrat the effective index. 2.10 Switches​ In this section of the code, the simulation function is called and executed, which allows you to reset relevant parameters for more convenient parameter scanning and optimization design. We also support control switches for various functionalities at the end of the code, and you can use configuration flags(True or False). These flags can be used to turn specific functionalities on or off, making it easier to check the model and perform efficient calculations. class RunOptions(NamedTuple): index_preview: bool run: bool run_frequency_sweep: bool extract: bool if __name__ == &quot;__main__&quot;: simulation( run_mode=&quot;local&quot;, wavelength=1.55, grid=0.02, number_of_trial_modes=3, run_options=RunOptions( index_preview=True, run=True, run_frequency_sweep=True, extract=True ), ) By turning on/off the relevant functionalities, you can control the simulation process and obtain the desired results. For example, the index_preview is to control whether to output images of the structural refractive index. run determines whether to run the program. run_frequency_sweep is used to enable frequency scanning, and extract is used to control data extraction. Properly utilizing these switches can help you inspect the simulation effectively. 3. Output Results​ The results of the calculation mode will be stored in a CSV format file for subsequent data processing in Python and Excel. mode_order TE ratio neff_real neff_imag ng_real ng_imag wavelength(nm)\tloss(dB/cm)0\t0.986860\t2.593169\t0\t0\t0\t1550\t0 1\t0.987740\t2.542372\t0\t0\t0\t1550\t0 2\t0.941287\t2.129843\t0\t0\t0\t1550\t0 Image of the Ey electric field component intensity in symmetric and antisymmetric mode modes. According to the effective refractive index of the obtained mode field, Python is used for data processing and drawing. The coupling length under the gap between two waveguides is calculated with the formula: Lx=λ2∣neff1−neff2∣L_x = \\frac{\\lambda}{2|neff_1-neff_2|}Lx​=2∣neff1​−neff2​∣λ​ We can also get the coupling coefficient by the formula: κ=∣sin(πδ(n)Lλ)∣\\kappa = |sin(\\frac{\\pi\\delta(n)L}{\\lambda})|κ=∣sin(λπδ(n)L​)∣ Similarly, we can obtain the relationship between the gap (distance) between two waveguides and the coupling coefficient and the relationship between the wavelength and the coupling length. Directional Coupler(FDTD module)​ Next, we will learn how to model a Directional Coupler using the SDK and calculate the light propagation in the structure using the FDTD module. 1. Basic Operations​ Similarly, after installing and configuring the environment, we import the relevant python code file and the GDS layout for the model. The example library and related model code are typically stored in the directory examples/func_demo, and the GDS file is imported into the folder examples/examples_gds. 2. Code Description​ Next, we will continue to learn about the specific functionalities corresponding to the code. 2.1 Define Parameters​ Like the operations with the FDE module, after configuring the simulation wavelength, grid precision, and other parameters, we need to set the relevant parameters for simulation and parameterized modeling in Region 0. This includes defining the paths and names for the simulation files and output results and specifying the path for importing the GDS layout. # region --- 0. General Parameters --- l_bend=5.6 # the length of z bend l_beam=15 # the length of 2 beams l_input=2.5 # the length of input wg monitor_w = 3.0 monitor_h = 2.0 waveform_name = &quot;wv&quot; + str(round(wavelength * 1000)) time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) path = kwargs[&quot;path&quot;] simu_name = &quot;FDTD_DC&quot; project_name = f'{simu_name}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/DC.gds&quot; # endregion 2.2 Define Materials​ Subsequently, in Region 2, we ues the materials required for the simulation. We also support users to specify the refractive indices of Si (Silicon) and SiO2 (Silicon Dioxide) materials. # region --- 1. Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) mt.add_lib(name='SiO2', data=mo.Material.SiO2_Palik, order=2) # mt.add_nondispersion(name=&quot;Si&quot;, data=[(3.472, 0)], order=2) # mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=2) mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) # endregion The add_nondispersion function adds a non-dispersion material to the project in the simulation. The data, is specified as a list, typically in the format [(index real, index imag)]. This list contains the complex refractive index values for the material, enabling the simulation to model its optical properties accurately. The function allows users to incorporate non-dispersion materials into the simulation, contributing to a comprehensive and precise optical analysis of the system under investigation. 2.3 Define Waveform​ In Region 3, we define the parameters relevant to the wavelength. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name,type='gaussian_waveform', property={'set': 'frequency_wavelength', # selections are ['frequency_wavelength','time_domain'] 'set_frequency_wavelength': { 'range_type': 'wavelength', # selections are ['frequency','wavelength'] 'range_limit': 'center_span', # selections are ['min_max','center_span'] 'wavelength_center': wavelength, 'wavelength_span': wavelength_span,}, } ) # endregion The Waveform function is used to retrieve the waveform manager for the current project. It allows users to access and manipulate the waveform sources used in the simulation. The name parameter specifies the name of the waveform source. The wavelength_center parameter defines the center of the wavelength range for the source. The wavelength_span parameter determines the span of the wavelength range for the source. 2.4 Create Model\\Boundary​ Next, similar to the procedure in the FDE module, in Region 4, we create the model by importing the GDS layout. Subsequently, in Region 5, we establish the boundary conditions. # region --- 4. Structure --- st = pj.Structure() st.add_geometry( name=&quot;box&quot;, type=&quot;gds_file&quot;, property={ &quot;general&quot;: { &quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1) }, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 6}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1} }, ) st.add_geometry( name=&quot;dc&quot;, type=&quot;gds_file&quot;, property={ &quot;general&quot;: { &quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (0, 0) }, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2} }, ) st.add_geometry( name='slab', type='Rectangle', property={ 'geometry': { 'x_min': -l_input-l_bend-l_beam/2-3, 'x_max':l_input+l_bend+l_beam/2+3, 'y': 0, 'y_span': 8, 'z': 0.045, 'z_span': 0.09 }, 'material': {'material': mt['Si'], 'mesh_order': 2}, } , ) # endregion In this code segment, we set detailed parameters for the PML boundar. 2.5 FDTD Simulation/local mesh​ In Region 6, we add the FDTD simulation. Additionally, in Region 7, we can set the sub-mesh for improved precision. # region --- 6. Simulation --- simu = pj.Simulation() simu.add( name=simu_name, type=&quot;FDTD&quot;, property={ &quot;background_material&quot;: mt[&quot;SiO2&quot;], &quot;geometry&quot;: { &quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_beam/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h }, &quot;boundary_conditions&quot;: {&quot;x_min_bc&quot;: &quot;PML&quot;, &quot;x_max_bc&quot;: &quot;PML&quot;, &quot;y_min_bc&quot;: &quot;PML&quot;, &quot;y_max_bc&quot;: &quot;PML&quot;, &quot;z_min_bc&quot;: &quot;PML&quot;, &quot;z_max_bc&quot;: &quot;PML&quot;, &quot;pml_settings&quot;: {&quot;all_pml&quot;: {&quot;layers&quot;: 8, &quot;kappa&quot;: 2, &quot;sigma&quot;: 0.8, &quot;polynomial&quot;: 3, &quot;alpha&quot;: 0, &quot;alpha_polynomial&quot;: 1, }}}, &quot;general&quot;: { &quot;simulation_time&quot;: 10000, }, &quot;mesh_settings&quot;: { &quot;mesh_factor&quot;: 1.2, &quot;mesh_type&quot;: &quot;auto_non_uniform&quot;, &quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: grids_per_lambda}, &quot;minimum_mesh_step_settings&quot;: {&quot;min_mesh_step&quot;: 1e-4}, &quot;mesh_refinement&quot;: { &quot;mesh_refinement&quot;: &quot;curve_mesh&quot;, } }, # 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-4, 'down_sample_time': 200}}, # 'thread_setting': {'thread': 4} }, ) # endregion # region --- 7. Sub Mesh --- lm = pj.LocalMesh() lm.add( name=&quot;sub_mesh&quot;, property={ &quot;general&quot;: { &quot;dx&quot;: 0.05, &quot;dy&quot;: 0.02, &quot;dz&quot;: 0.02 }, &quot;geometry&quot;: { &quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_beam/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h }, }, ) # endregion The Simulation manager is critical for setting up and running simulations in the current project. The name parameter allows users to assign a unique name to the simulation for identification purposes. The type parameter defines the type of the simulation. we define the boundary conditions for the simulation using the boundary dictionary, where the x ,y and the z directions all have PML boundary conditions.The simulation_time parameter specifies the duration of the simulation. The mesh_settings parameter enables users to configure various settings related to the simulation mesh. The mesh_accuracy parameter controls the precision of the mesh used in the simulation. The cells_per_wavelength parameter determines the wavelength precision used in the simulation. The minimum_mesh_step_settings parameter sets the minimum mesh step, allowing users to define the smallest allowable size for mesh elements. Users can tailor the simulation setup to meet their requirements by utilizing these input parameters, enabling accurate and efficient electromagnetic simulations of complex optical structures. 2.6 Source​ Then we need to establish the light source in the input waveguide, as shown in Region 8. # region --- 8. ModeSource --- src = pj.Source() src.add( name=&quot;source&quot;, type=&quot;mode_source&quot;, # axis=&quot;x_forward&quot;, property={ &quot;general&quot;: { &quot;mode_selection&quot;: &quot;user_select&quot;, &quot;waveform&quot;: {&quot;waveform_id&quot;: wv[waveform_name]}, &quot;inject_axis&quot;: &quot;x_axis&quot;, &quot;direction&quot;: &quot;forward&quot; }, &quot;geometry&quot;: { &quot;x&quot;: -l_input-l_beam/2-l_bend+2, &quot;x_span&quot;: 0, &quot;y&quot;: 1.35, &quot;y_span&quot;: monitor_w, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h }, &quot;modal_analysis&quot;: { &quot;mode_removal&quot;: {&quot;threshold&quot;: 0.01} } , }, ) # endregion The Source function is utilized to retrieve the source manager for the current project. The type parameter specifies the type of the source and is formatted as either [&quot;mode_source&quot;] or [&quot;gaussian_source&quot;]. The name parameter represents the name assigned to the source. The inject_axis parameter defines the axis of the source. The property parameter allows for defining specific properties associated with the source. 2.7 Monitor​ In Region 9, we set up the monitors. # region --- 9. Monitor --- # region --- 9.0 GlobalMonitor --- mn = pj.Monitor() mn.add( name=&quot;Global Option&quot;, type=&quot;global_option&quot;, property={ &quot;frequency_power&quot;: { &quot;spacing_type&quot;: &quot;wavelength&quot;, &quot;spacing_limit&quot;: &quot;center_span&quot;, &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;:wavelength_span, &quot;frequency_points&quot;: 3 }, }, ) # endregion # region --- 9.1 z_normal --- mn.add( name=&quot;z_normal&quot;, type=&quot;power_monitor&quot;, property={ &quot;general&quot;: { &quot;frequency_profile&quot;: { &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: wavelength_span, &quot;frequency_points&quot;: 3, }, }, &quot;geometry&quot;: { &quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_beam/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0 }, }, ) # endregion # region --- 9.2 input --- mn.add( type=&quot;power_monitor&quot;, name=&quot;input_reflect&quot;, property={ &quot;general&quot;: { &quot;frequency_profile&quot;: { &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: wavelength_span, &quot;frequency_points&quot;: 11 } }, &quot;geometry&quot;: { &quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: -l_input-l_beam/2-l_bend+1.5, &quot;x_span&quot;: 0, &quot;y&quot;: 1.35, &quot;y_span&quot;: monitor_w, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h }, } ) # endregion # region --- 9.3 through --- mn.add( type=&quot;power_monitor&quot;, name=&quot;through&quot;, property={ &quot;general&quot;: { &quot;frequency_profile&quot;: { &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: wavelength_span, &quot;frequency_points&quot;: 11 } }, &quot;geometry&quot;: { &quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: l_input+l_beam/2+l_bend-2, &quot;x_span&quot;: 0, &quot;y&quot;: 1.35, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h }, }, ) # endregion # region --- 9.4 cross --- mn.add( name=&quot;cross&quot;, type=&quot;power_monitor&quot;, property={ &quot;general&quot;: { &quot;frequency_profile&quot;: { &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: wavelength_span, &quot;frequency_points&quot;: 11 } }, &quot;geometry&quot;: { &quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: l_input+l_beam/2+l_bend-2, &quot;x_span&quot;: 0, &quot;y&quot;: -1.35, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h }, } ) # endregion # endregion For the global monitor, the Monitor function is utilized to retrieve the monitor manager for the current project, which allows users to access and manage various types of monitors used during simulation. The name parameter represents the name of the Global Option associated with the monitor. The type parameter defines the type of the Global Option and is formatted as a list containing one of several monitor types. The property parameter is used to define and set the relevant parameters specific to the chosen monitor type. These parameters control the monitor's behavior and data collection settings during the simulation. The power monitor is a configuration setting that allows users to specify various simulation parameters. The name parameter assigns a name to the power monitor. The type parameter defines the type of power monitor. The general parameter pertains to settings related to the frequency domain and frequency-dependent behaviors of the simulation. The geometry parameter is used to define the geometric characteristics of the simulated structure. 2.8 Calculate Source​ To calculate the input mode light and save its electric field intensity data in region 10. # region --- 10. Calculate Mode --- if run_options.calculate_modes: simu[simu_name].preview_modes( source_name = &quot;source&quot;, savepath=f&quot;{plot_path}00_source_modeprofile_fdeonly&quot;, attribute=&quot;E&quot;, real=True, imag=True, mode=0, show=False, export_csv=True, ) # endregion 2.9 Run Simulation​ Then, in Region 11, we run the simulation. # region --- 11. Run --- if run_options.run: fdtd_res = simu[simu_name].run() # endregion 2.10 Analysis​ In Region 12, we run the analysis for the simulation. The mode_expansion parameter involves relevant settings for mode expansion simulations. Users can customize the simulation settings by utilizing these input parameters to achieve accurate and comprehensive results based on their specific simulation requirements. # region --- 12. Run --- analysis = pj.Analysis() analysis.add( name=&quot;me_through&quot;, type=&quot;mode_expansion&quot;, property={ &quot;workflow_id&quot;: fdtd_res.workflow_id, &quot;mode_expansion&quot;: { &quot;direction&quot;: &quot;positive&quot;, &quot;monitors_for_expansion&quot;: [ {&quot;name&quot;: &quot;me_through&quot;, &quot;frequency_monitor&quot;: &quot;through&quot;} ], &quot;mode_calculation&quot;: { &quot;mode_selection&quot;: &quot;user_select&quot;, &quot;mode_index&quot;: [0, 1, 2, 3], &quot;override_global_monitor_setting&quot;: { &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 11, }, }, }, } ) analysis.add( name=&quot;me_cross&quot;, type=&quot;mode_expansion&quot;, property={ &quot;workflow_id&quot;: fdtd_res.workflow_id, &quot;mode_expansion&quot;: { &quot;direction&quot;: &quot;positive&quot;, &quot;monitors_for_expansion&quot;: [ {&quot;name&quot;: &quot;me_cross&quot;, &quot;frequency_monitor&quot;: &quot;cross&quot;} ], &quot;mode_calculation&quot;: { &quot;mode_selection&quot;: &quot;user_select&quot;, &quot;mode_index&quot;: [0, 1, 2, 3], &quot;override_global_monitor_setting&quot;: { &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 11, }, }, }, } ) me_res1 = analysis[&quot;me_through&quot;].run() me_res2 = analysis[&quot;me_cross&quot;].run() # endregion 2.11 Results​ In Region 13, we define the desired output results. Lastly, we control the switches of various functional modules at the end of the Python file. # region --- 13. See Results --- if run_options.extract and run_options.run: # region --- z_normal --- &quot;&quot;&quot; 01_top_profile &quot;&quot;&quot; for λ in [1.5, 1.55, 1.6]: fdtd_res.extract( data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;01_top_profile&quot; + str(λ) + &quot;um&quot;, monitor_name=&quot;z_normal&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=True, wavelength=str(λ), plot_x=&quot;x&quot;, plot_y=&quot;y&quot;, show=False, export_csv=True, ) # endregion # # region --- through --- &quot;&quot;&quot; 01_monitorThrough_modeprofile_fdtd &quot;&quot;&quot; fdtd_res.extract( data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;01_monitorThrough_modeprofile_fdtd_&quot;+ f&quot;{wavelength}&quot; + &quot;um&quot;, monitor_name=&quot;through&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=False, wavelength=f&quot;{wavelength}&quot;, plot_x=&quot;y&quot;, plot_y=&quot;z&quot;, show=False, export_csv=True, ) # # &quot;&quot;&quot; 02_Trans_ThroughVsLambda_power &quot;&quot;&quot; fdtd_res.extract( data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;02_Trans_ThroughVsLambda_power&quot;, monitor_name=&quot;through&quot;, target=&quot;line&quot;, attribute=&quot;T&quot;, real=True, imag=False, plot_x=&quot;wavelength&quot;, show=False, export_csv=True, ) # # &quot;&quot;&quot; 021_ME_ThroughVsLambda_mode &quot;&quot;&quot; me_res1.extract( data=&quot;fdtd:mode_expansion&quot;, savepath=plot_path + &quot;021_ME_ThroughVsLambda_mode&quot;, target=&quot;line&quot;, attribute=&quot;T_forward&quot;, real=True, imag=True, monitor_name=&quot;through&quot;, mode_expansion_name=&quot;me_through&quot;, mode=0, plot_x=&quot;wavelength&quot;, show=False, export_csv=True, ) # # region --- cross --- &quot;&quot;&quot; 01_monitorcross_modeprofile_fdtd &quot;&quot;&quot; fdtd_res.extract( data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;01_monitorcross_modeprofile_fdtd_&quot;+ f&quot;{wavelength}&quot; + &quot;um&quot;, monitor_name=&quot;cross&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=False, wavelength=f&quot;{wavelength}&quot;, plot_x=&quot;y&quot;, plot_y=&quot;z&quot;, show=False, export_csv=True, ) # # &quot;&quot;&quot; 02_Trans_crossVsLambda_power &quot;&quot;&quot; fdtd_res.extract( data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;02_Trans_crossVsLambda_power&quot;, monitor_name=&quot;cross&quot;, target=&quot;line&quot;, attribute=&quot;T&quot;, real=True, imag=False, plot_x=&quot;wavelength&quot;, show=False, export_csv=True, ) # # &quot;&quot;&quot; 021_ME_crossVsLambda_mode &quot;&quot;&quot; me_res2.extract( data=&quot;fdtd:mode_expansion&quot;, savepath=plot_path + &quot;021_ME_crossVsLambda_mode&quot;, target=&quot;line&quot;, attribute=&quot;T_forward&quot;, real=True, imag=True, monitor_name=&quot;cross&quot;, mode_expansion_name=&quot;me_cross&quot;, mode=0, plot_x=&quot;wavelength&quot;, show=False, export_csv=True, ) # endregion 2.12 Switches​ At the end of all codes, We control the switches of various functional modules. class RunOptions(NamedTuple): index_preview: bool calculate_modes: bool run: bool extract: bool if __name__ == &quot;__main__&quot;: simulation( wavelength=1.55, wavelength_span=0.1 , grids_per_lambda=6, run_options=RunOptions( index_preview=True, run=True, calculate_modes=True, extract=True ), ) 3. Output Results​ After running the program, we can obtain a series of corresponding output results: Incident light electric field intensity, CRO output port electric field intensity, and TRU output port electric field intensity. DC (Directional Coupler) Z-direction electric field intensity at different wavelengths: 1.50 μm, 1.55 μm, and 1.60 μm. Cross output port and TRU output port transmittance at different wavelengths,from 1.50 μm to 1.60 μm. TE0 mode transmittance at Cross output port and TRU output port for different wavelengths,,from 1.50 μm to 1.60 μm. Based on the information provided, we can get the following results when propogating wavelength is 1.55 μm and the two arm length of directional couper is equal to 15 μm: 1. Insertion Loss: 0.236 dB; 2. Power Split Ratio: 11.2 : 83.3 (or approximately 11.2% to one port and 82.8% to the other port); 3. Dimensions: Approximately 5 μm X 25 μm. Supplement​ To view a function's definition and supported parameters or a parameter dictionary, you can right-click on its name and select &quot;Go to Definition&quot; or press &quot;Ctrl&quot; while left-clicking on its name to view its definition, showing the available parameters and their descriptions. References​ Chrostowski, L., &amp; Hochberg, M. (2015). Silicon Photonics Design: From Devices to Systems. Cambridge: Cambridge University Press. doi:10.1017/CBO9781316084168","keywords":""},{"title":"Microring Resonator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/SDK Examples/PIC/MicroringResonator/","content":"Microring Resonator Introduction​ Microring resonator is important filtering device in photonic integrated circuits, the high performance filter require a wide free spectrum range(FSR) and high quality factor. Obtaining a large spectral range for microring resonator requires the use of a small radius, but too small radius can cause bending loss and reduce the quality factor. In order to meet the requirements of wide free spectrum range and high quality factor, it is necessary to carefully design the size of the ring and coupling efficiency. In this example, we demonstrate the use of finite difference eigenmode(FDE) solver to calculate the group refractive index of an optical waveguide, then calculate the effective refractive index of symmetric and anti symmetric modes at the coupling region between the straight waveguide and the ring, and finally use 3D FDTD simulation to calculate the transmittance of the drop port. Simulation​ 1 Code Description​ 1.1 Import Toolkit​ First, we need to import maxoptics_sdk and Python's third-party package. The import module for FDE and FDTD simulation as follows. from typing import List, Literal, NamedTuple import time import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path 1.2 Define Simulation Function and parameters​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. Before starting the simulation, you can define variables to control the parameters. As shown below. def simulation(*, run_mode, wavelength, grid, number_of_trial_modes, run_options: &quot;RunOptions&quot;, **kwargs): # region --- 0. General Parameters --- time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) path = kwargs[&quot;path&quot;] simu_name = f&quot;Microring_FDE&quot; project_name = f&quot;{simu_name}_{run_mode}_{time_str}&quot; plot_path = f'{kwargs.get(&quot;plot_dir&quot;, path)}/plots/{project_name}/' kL = [f&quot;0{k}&quot; for k in range(5)] export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} # endregion 1.3 Create project​ You can create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion 1.4 Add Material​ Here we demonstrate using the Material function to create material and using the add_lib function to add material from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name=&quot;Si&quot;, data=mo.Material.Si_Palik, order=2) mt.add_lib(name=&quot;SiO2&quot;, data=mo.Material.SiO2_Palik, order=2) # endregion The name is used to define the name of the added material. The data is used to receive refractive index data extracted from the material library. The order is used to set the material priority of the grid. 1.5 Add waveform​ Adding a light source for simulating in 3D FDTD, and we use Waveform to set the waveform parameters of the light source. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1) # endregion name sets the name of the waveform, wavelength_center sets the center wavelength of the light source, and wavelength_span sets the wavelength range of the light source. 1.6 Add Structure​ The microring resonator is typical filter for SOI waveguide, including two straight optical waveguides and a ring-shaped waveguide. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select the type from the structural components. Properties settings as follows. # region --- 4. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;SiO2&quot;]) st.add_geometry(name=&quot;ring&quot;, type=&quot;Ring&quot;,property={&quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 3}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22,&quot;inner_radius&quot;: 2.6, &quot;outer_radius&quot;: 3}}) st.add_geometry(name=&quot;waveguide1&quot;, type=&quot;Rectangle&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;:15, &quot;y&quot;: 3.3, &quot;y_span&quot;: 0.4, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;:3}} ) st.add_geometry(name=&quot;waveguide2&quot;, type=&quot;Rectangle&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;:15, &quot;y&quot;: -3.3, &quot;y_span&quot;: 0.4, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;:3}} ) st.add_geometry(name=&quot;substrate&quot;, type=&quot;Rectangle&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;:15, &quot;y&quot;: 0, &quot;y_span&quot;: 10, &quot;z_min&quot;: -3, &quot;z_max&quot;: -0.11}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;:3}} ) # endregion Key\tValue\ttype\tDescriptionname\tring\tstring\tname the added geometry type\tRing\tstring\tselect the type of structure x 0 float center position in the x-direction of the geometric structure material\tmt[&quot;Si&quot;]\tmaterial\tselect the material added Materials mesh_order\t3\tinteger\tset the priority of the material x\t0\tfloat\tthe center coordinate of the ring in the x-direction y\t0\tfloat\tthe center coordinate of the ring in the y-direction z\t0\tfloat\tthe center coordinate of the ring in the z-direction z_span\t0\tfloat\tthe thickness of the ring in the z-direction inner_radius\t2.6\tfloat\tthe size of the inner radius of the ring outer_radius\t3\tfloat\tthe size of the outer radius of the ring The properties of the ring structure are shown in the table above, properties of Rectangle can refer to the settings of the ring. Select simulation material by using mesh_order in areas where geometry overlaps, the priority of structural materials needs to be higher than that of background material. 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. Use geometry to set the size and position of the boundary, and use boundary to set the boundary conditions at the boundary. The boundary properties of FDE and FDTD as follows. # region --- 5. Boundary --- if run_options.run_fde: st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: -4, &quot;x_span&quot;: 0, &quot;y&quot;: -3.3, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 3}, &quot;boundary&quot;: {&quot;y_min&quot;: &quot;PEC&quot;, &quot;y_max&quot;: &quot;PEC&quot;, &quot;z_min&quot;: &quot;PEC&quot;, &quot;z_max&quot;: &quot;PEC&quot;}}) if run_options.run_fdtd: st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 9, &quot;y&quot;: 0, &quot;y_span&quot;: 9, &quot;z&quot;: 0, &quot;z_span&quot;: 3}, &quot;boundary&quot;: {&quot;x_min&quot;: &quot;PML&quot;, &quot;x_max&quot;: &quot;PML&quot;, &quot;y_min&quot;:&quot;PML&quot;, &quot;y_max&quot;:&quot;PML&quot;, &quot;z_min&quot;: &quot;PML&quot;, &quot;z_max&quot;: &quot;PML&quot;}}) # endregion 1.8 Add source​ In 3D FDTD simulation, a light source is required. We use Source to create the light source and add to add the required light source. The settings for the light source as follows. # region --- 6. Source --- src = pj.Source() if run_options.run_fdtd: src.add(name=&quot;modesource&quot;,type=&quot;mode_source&quot;,axis=&quot;x_forward&quot;,property={ &quot;general&quot;:{&quot;mode_selection&quot;:&quot;fundamental_TE&quot;,&quot;waveform&quot;:{&quot;waveform_id_select&quot;:wv[waveform_name]}}, &quot;geometry&quot;:{&quot;x&quot;:-4,&quot;x_span&quot;:0,&quot;y&quot;:3.3,&quot;y_span&quot;:2,&quot;z&quot;:0,&quot;z_span&quot;:2}}) # endregion 1.9 Add Solver​ We use the Simulation function to create a simulation and the add function to add a solver. The properties settings of FDE and FDTD solvers as follows. # region --- 7. Simulation --- simu = pj.Simulation() if run_options.run_fde: simu.add(name=simu_name, type=&quot;FDE&quot;, property={ &quot;general&quot;: {&quot;solver_type&quot;: &quot;2d_x_normal&quot;}, # default is &quot;2d_x_normal&quot; [&quot;2d_x_normal&quot;,&quot;2d_y_normal&quot;,&quot;2d_z_normal&quot;] &quot;mesh_settings&quot;: { &quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}, # &quot;minimum_mesh_step_settings&quot;: {&quot;min_mesh_step&quot;: 1.0e-4} }, &quot;fde_analysis&quot;: { &quot;modal_analysis&quot;: { &quot;calculate_modes&quot;: run_options.run_fde, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength, &quot;wavelength_offset&quot;: 0.0001, &quot;number_of_trial_modes&quot;: number_of_trial_modes, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True, &quot;mode_removal&quot;: {&quot;threshold&quot;: 0.02}}}}) if run_options.run_fdtd: simu.add(name=simu_name, type='FDTD', property={'general': {'simulation_time': 5000 }, 'mesh_settings': {'mesh_type': 'auto_non_uniform', 'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}, 'minimum_mesh_step_settings': {'min_mesh_step': 1e-4}}, 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-4, 'down_sample_time': 200}}, 'thread_setting': {'thread': 12} }) # endregion The properties settings for the FDE solver as follows. Key\tValue\tType\tDescriptionsolver_type\t2d_x_normal\tstring\tselect the solution plane dy\tgrid\tfloat\tgrid size along the y-direction dz\tgrid\tfloat\tgrid size along the z-direction calculate_modes\trun_options.run_fde\tbool\tchoose whether to calculate the mode of the waveguide mesh_structure\tFalse\tbool\tchoose whether to calculate the refractive index distribution of the structure wavelength\twavelength\tfloat\tcalculate the wavelength of the mode number_of_trial_modes\tnumber_of_trial_modes\tinteger\tnumber of solving modes search\tmax_index\tstring\tchoose &quot;max_index&quot; or &quot;near_n&quot; for finding modes calculate_group_index\tTrue\tbool\tchoose whether to calculate the group refractive index The properties settings for the FDTD solver as follows. Key\tValue\tType\tDescriptionsimulation_time\t5000\tfloat\tset the maximum simulation time mesh_type\tauto_non_uniform\tstring\tselect 'auto_non_uniform' or 'uniform' to set the type of grid cells_per_wavelength\tgrids_per_lambda\tinteger\tset the size of the grid min_mesh_step\t1e-4\tfloat\tset the minimum grid size auto_shutoff_min\t1.e-4\tfloat\tset the energy threshold for terminating the simulation down_sample_time\t200\tfloat\tset additional simulation duration thread\t4\tinteger\tnumber of threads allocated to run the program In the settings of the FDE solver, use calculate_ modes controls whether to calculate the mode. Note that we need to calculate the group refractive index of the waveguide, so set the calculate_ group_index to True. In the setting of the FDTD solver, simulation_time is used to control the simulation time. We set the simulation time to 5000 fs, which is greater than the default value of 1000 fs. The micro ring resonator has a high quality factor, its simulation requires longer time. If the simulation time is set too small and the simulation stops before the field decays, the results obtained are incorrect. 1.10 Add Monitor​ In the simulation, Monitorfunction is used to create monitor and add function is used to add a monitor. By using type to select a power monitor, the transmittance and field distribution of the cross-section can be obtained. It is necessary to add a time monitor at the end of the simulation to check the field strength to judge the accuracy of the simulation results. # region --- 8. Monitor --- mn = pj.Monitor() mn.add(name='time_monitor1', type='time_monitor', property={'general': { 'stop_method': 'end_of_simulation', 'start_time': 0, 'stop_time': 100, 'number_of_snapshots': 0}, 'geometry': {'monitor_type': 'point', 'x': 0, 'x_span': 0, 'y': 0, 'y_span': 0, 'z': 0, 'z_span': 0}, 'advanced': {'sampling_rate': {'min_sampling_per_cycle': 10}}}) mn.add(name='x_normal', type='power_monitor',property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 300}, }, 'geometry': {'monitor_type': '2d_x_normal', 'x': -4, 'x_span': 0, 'y': -3.3, 'y_span': 2, 'z': 0, 'z_span': 2}}) mn.add(name='z_normal', type='power_monitor',property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 100}, }, 'geometry': {'monitor_type': '2d_z_normal', 'x': 0, 'x_span': 9, 'y': 0, 'y_span': 9, 'z': 0, 'z_span': 0}}) #endregion 1.11 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=f&quot;{plot_path}{kL[0]}_{simu_name}&quot;, simulation_name=simu_name) #simu[simu_name].show3d() # endregion 1.12 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation. # region --- 10. Run --- eme_res = simu[simu_name].run() # endregion 1.13 Run and Extract Results​ Extract data using extract, where data is the calculation result data, savepath is the storage path, target is the classification of the data, and monitor_name is the name of the monitor. The data extraction reference is as follows. # region --- 11. See Results --- if run_options.extract: if run_options.run_fde: k = kL[1] res = results.extract(data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_neff_table&quot;, export_csv=True) print(res.to_string(index=False)) for m in range(len(res)): k = kL[2] results.extract(data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_mode{m}&quot;, attribute=&quot;Ey&quot;, mode=m, real=True, imag=False, **export_options, show=False) if run_options.run_fdtd: res = results.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[3]}_profile', monitor_name='x_normal', target='line', plot_x='wavelength', attribute='T', real=True, imag=False, **export_options, show=False) res = results.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[4]}_profile', monitor_name='z_normal', target='intensity', plot_x='x', plot_y='y', attribute='E', real=True, imag=True, **export_options, show=False) # endregion 1.14 Control Switch​ We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code. In each simulation, only one solver will be enabled. When using the FDE solver, set &quot;run_fde&quot; to True and &quot;run_fdtd&quot; to False; When using the FDTD solver, set &quot;run_fdtd&quot; to True and &quot;run_fde&quot; to False. class RunOptions(NamedTuple): index_preview: bool run_fde: bool run_fdtd: bool extract: bool if __name__ == &quot;__main__&quot;: simulation( run_mode=&quot;local&quot;, wavelength=1.55, grid=0.01, grids_per_lambda=14, number_of_trial_modes=5, run_options=RunOptions(index_preview=False,run_fde=False,run_fdtd=True,extract=True)) 2. Output results​ Length of ring​ The light traveling in the waveguide generates evanescent field on its surface, so energy couples into a nearby waveguide as the waveguide approaches. We design a microring resonant filter with an FSR of 30nm, and we can calculate the effective circumference of the microring according to the following formula. The FDE solver can be used to calculate the group refractive index of the waveguide. The following table shows the group refractive index of the waveguide cross-section in the first three modes with a wavelength of 1.55um. 2πR=λ2/(FSR∗ng) 2{\\pi}R= {\\lambda}^2/(FSR*n_g)2πR=λ2/(FSR∗ng​) order\tTEratio\tneff_real\tneff_imag\tng_real\tng_imag\twavelength_nm\tloss_dBpcm0\t0.966627\t2.227503\t0.0\t4.434594\t0.0\t1550.0\t0 1\t0.046759\t1.692711\t0.0\t3.467810\t0.0\t1550.0\t0 2\t0.599748\t1.430406\t0.0\t1.683888\t0.0\t1550.0\t0 Considering the transmission of the fundamental mode of TE polarization, a group refractive index of 4.43 can be obtained. Therefore, selecting a ring with an effective radius of 2.87um can meet the free spectrum range of 30nm. Couple gap and length​ The length of the coupling region can be calculated based on the effective refractive index difference between symmetric and antisymmetric modes, as shown in the following formula. Setting the gap between the straight waveguide and the ring to 100nm can generate strong mutual coupling. Using the FDE solver to calculate the effective refractive index of the coupling region between the waveguide and the microring, the corresponding mode distribution is as follows. The coupling distance calculated at wavelength of 1.55um more than 1.4 um. You can choose to increase the radius of the ring to reduce the coupling length. We choose to set the coupling length to zero and obtain sufficient coupling length and expected loop length by increasing the radius. L=λ/(πΔn)sin−1(∣t12∣)L={\\lambda}/({\\pi}{\\Delta}n)sin^{-1}(|t12|)L=λ/(πΔn)sin−1(∣t12∣) Transmission​ Calculate the resonant response of a straight waveguide coupled to a microring with a radius of 2.8um using 3D FDTD. Adding a mode light source as an excitation for straight waveguide, and use a power monitor to view the field distribution and transmittance. When the light field coupled into the microring meets the resonance condition, it will output from the dorp port. As shown in the figure below, there is the maximum electric field at the drop port at the resonant wavelength. The transmittance of the drop end is shown in the following figure. References​ Hammer, M. and Hiremath, K.R. and Stoffer, R. (2004) Analytical approaches to the description of optical microresonator devices. (Invited) In: Microresonators as Building Blocks for VLSI Photonics, 18-25 October 2003, Erice, Italy. pp. 48-71. AIP Conference Proceedings 709. Springer. ISSN 0094-243X ISBN 978-0-7354-0184-6.","keywords":""},{"title":"Polarization Splitter-Rotator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/SDK Examples/PIC/PolarizationSplitter-Rotator/","content":"Polarization Splitter-Rotator Introduction​ The large refractive index difference of silicon waveguides on insulators can produce strong birefringence effects, making many optical devices very sensitive to the polarization of light. The polarization beam splitter-rotator(PSR) can separate light of different polarizations and output light of the same polarization, which can effectively solve the problem of polarization sensitivity in silicon waveguides. In this example, we demonstrated the simulation process of a compact PSR using an EME solver. the TM0 mode can effectively evolve into the TE1 mode, which can then be converted into the TE0 mode in a narrow waveguide using ADC. Simulation​ 1. Code Description​ 1.1 Import Toolkit​ First, we need to import `maxoptics_sdk` and Python's third-party package. The import module for EME simulation is shown below. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple 1.2 Define Simulation Function​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. def simulation(*, run_mode, wavelength=1.54, global_mesh_grid=0.02, local_mesh_grid=0.01, number_of_modes=10, run_options: &quot;RunOptions&quot;, **kwargs): The run_mode variable parameter is used to define the location of the simulation run. The wavelength variable is defined as wavelength of the optical source. The grid variable is defined as grid size. The number_of_modes variable is used to define the number of modes of calculation. 1.3 Define Parameters​ Before starting the simulation, we can define parameters to facilitate modeling and parameterization sweep. The defined parameters are as follows. # region --- 0. General Parameters --- cell_number = 72 wavelength_start = 1.50 wavelength_stop = 1.58 wavelength_points = 3 path = kwargs[&quot;path&quot;] simu_name = &quot;EME_PSR&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/PSR.gds&quot; # endregion The path variable is used to store the path of this Python file. The simu_name variable is used to store simulation names. The time_str variable is used to store the timestamp. The project_name variable is used to store the project name. The plot_path variable is used to store the result path. The gds_file variable is used to store the file path of GDS. 1.4 Create project​ You can create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion 1.5 Add Material​ Here we demonstrate using the Material function to create material and using the add_lib function to add materials from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name=&quot;Si&quot;, data=mo.Material.Si_Palik, order=2) mt.add_lib(name=&quot;SiO2&quot;, data=mo.Material.SiO2_Palik, order=2) # endregion The name is used to define the name of the added material. The data is used to receive refractive index data extracted from the material library. The order is used to set the material priority of the grid. 1.6 Add Structure​ The structure of PSR is shown in the figure, which consists of an adiabatic conical waveguide, ADC, and MMI mode filter. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select &quot;gds_file&quot; in type to establish the model by importing the GDS file. The properties of GDS modeling are shown in the table below. # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;Air&quot;]) st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;PSR&quot;, &quot;layer_name&quot;: (1, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: -2, &quot;z_span&quot;: 4}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name=&quot;psr&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;PSR&quot;, &quot;layer_name&quot;: (2, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) # endregion Key\tValue\ttype\tDescriptionname\tbox\tstring\tname the added geometry type\tgds_file\tstring\tselect the type of structure path\tgds_file\tstring\tfile path of GDS file cell_name\t(1,0)\tstring\tname of the GDS cell layer_name\tPSR\tlist\tname of the GDS layer x 0 float center position in the x-direction of the geometric structure z\t-2\tfloat\tcenter position in the z-direction of the geometric structure z_span\t4\tfloat\tlength of the geometric structure in the z-direction material\tmt[&quot;SiO2&quot;]\tmaterial\tselect the material in Material mesh_order\t2\tinteger\tset the priority of the material Select simulation material by using mesh_order in areas where geometry overlaps, the higher the number of mesh_order, the higher the priority of the material. 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. The properties are shown below. # region --- 4. Boundary --- st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 6.05, &quot;x_span&quot;: 73.1, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;boundary&quot;: {&quot;y_min&quot;: &quot;PEC&quot;, &quot;y_max&quot;: &quot;PEC&quot;, &quot;z_min&quot;: &quot;PEC&quot;, &quot;z_max&quot;: &quot;PEC&quot;}, &quot;general_pml&quot;: {&quot;pml_same_settings&quot;:True,&quot;pml_kappa&quot;: 1, &quot;pml_sigma&quot;: 5, &quot;pml_layer&quot;: 10, &quot;pml_polynomial&quot;: 3}}) # endregion 1.8 Add Sub Mesh​ After light passes through tapered silicon waveguide gradually becoming smaller, the mode field is strongly limited to a very small range. Therefore, it is necessary to use add_mesh to add a transverse grid to accurately calculate the limited light field. Add local mesh as shown below. # region --- 5. Sub Mesh --- st.add_mesh( name=&quot;sub_mesh&quot;, property={&quot;general&quot;: {&quot;dy&quot;: local_mesh_grid, &quot;dz&quot;: local_mesh_grid}, &quot;geometry&quot;: {&quot;x&quot;: 6.05, &quot;x_span&quot;: 73.1, &quot;y&quot;: 1.256, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.4}}) # endregion The dx,dy,dz are the mesh sizes in the x, y, and z directions, respectively. 1.9 Add EME port​ You can use the port function to create a port and use the &quot;source_port&quot; property to set the location of the source port. You can use the add function to add ports and the properties of port are shown in the table below. # region --- 6. Port --- pjp = pj.Port(property={&quot;source_port&quot;: &quot;input_te_tm&quot;}) # region --- input_te_tm --- pjp.add(name=&quot;input_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;use_full_simulation_span&quot;: True, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1}, &quot;advanced&quot;: {&quot;offset&quot;: 0.1, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # region --- output_up_te_tm --- pjp.add(name=&quot;output_up_te_tm&quot;, type=&quot;eme_port&quot;, property={ &quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: 2.6785, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # region --- output_down_te_tm --- pjp.add(name=&quot;output_down_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: 0, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1, &quot;search&quot;: &quot;max_index&quot;}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # endregion key\tvalue\ttype\tdescriptionname\tleft_port\tstring\tthe name of port type\teme_port\tstring\tselect type of port port_location\tleft\tstring\tselect the location of the port y\t2.6785\tfloat\tcenter position of the port in the y-direction y_span\t2\tfloat\tlength of the port in the y-direction z\t0.11\tfloat\tcenter position of the port in the z-direction z_span\t2\tfloat\tlength of the port in the z-direction mode_selection\tfundamental_TE\tstring\tselect the mode of port number_of_trial_modes number_of_modes integer set the number of port modes 1.10 Add Monitor​ In the simulation, Monitorfunction is used to create monitor and add function is used to add a monitor. Select profile_monitor type monitor from the added monitors to view the mode field distribution. # region --- 7. Monitor --- mn = pj.Monitor() mn.add(name=&quot;z_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 6.05, &quot;x_span&quot;: 73.1, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0}}) for i, pos in enumerate([-29.5, 17.5, 23.5, 34.5, 39.5]): mn.add(name=&quot;section&quot;+str(i+1), type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: pos, &quot;x_span&quot;: 0, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}}) # endregion 1.11 Add EME solver​ We use the Simulation function to create a simulation and the add function to add a solver. Select the EME solver in the type, and the properties of the solver are shown in the table below. # region --- 8. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 6, &quot;cell_number&quot;: 6, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 30, &quot;cell_number&quot;: 6, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 12, &quot;cell_number&quot;: 6, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 8.9, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 5, &quot;cell_number&quot;: 10, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 5.2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 5, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: global_mesh_grid, &quot;dz&quot;: global_mesh_grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;wavelength_sweep&quot;: { &quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: wavelength_start, &quot;stop&quot;: wavelength_stop, &quot;number_of_wavelength_points&quot;: wavelength_points}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) # endregion key\tvalue\ttype\tdescriptionname\tsimu_name string name of simulation type\tEME\tstring\tselect the type of solver wavelength\t1.5\tfloat\twavelength of mode use_wavelength_sweep\tTrue\tbool\tselect to enable wavelength sweep span\t2\tfloat\tthe span of cell group cell_number\t1\tfloat\tnumber of cell in the cell group number_of_modes\t15\tfloat\tCalculate the number of modes per cell sc\tnone\tstring\tselect to enable subcell method dy\t0.05\tfloat\thorizontal mesh of cross-section dz\t0.05\tfloat\tLongitudinal mesh of cross-section eme _propagate\tTrue\tbool\tselect to enable EME propagation propagation_sweep True\tbool\tselect to enable length sweep parameter\tgrop_span_3\tstring\tthe area of length sweep start\t50\tfloat\tstarting length of sweep stop\t250\tfloat\tstoping length of sweep number_of_points\t50\tfloat\tnumber of sweep lengths phase\t0\tfloat\tthe initial phase of optical source select_mode\tTE\tstring\tmode of optical source According to different geometric structures and materials, the PSR is divided into 8 cell groups using cell_group_definition. Set the length of the cell group in span, use cell_number to set the number of cell. The divided cell structure is shown in the following figure. Use number_of_modes to set the number of modes calculated at the interface of adjacent cells, and it is necessary to set a sufficient number of modes to obtain the correct results. The area where the structure has not changed, the number of cell_number is set to 1, and sc is set to &quot;none&quot;. In the area of structural changes, multiple cell number need to be used to characterize the structure and the &quot;sub_cell&quot; method is used to reduce the staircase effect caused by discrete changes of the cross-section. 1.12 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, savepath=plot_path + simu_name, simulation_name=simu_name, celldisplay=True, xyratio=(1, 5), disabled_components=(&quot;box.coordinate&quot;,), show=False) #simu[simu_name].show3d() # endregion The celldisplay control whether to display the boundaries of the divided cells. The xyration controls the aspect ratio of the image. 1.13 Calculate Mode​ You can create a new simulation using simu.add function and run the simulation using simu.add function. The type of simulation needs to be selected as &quot;mode_selection:user_select&quot;, and its properties are shown in the table below. Before running EME simulation calculations, we can calculate the mode field distribution of the port by setting the type of mode selection to True and other simulations to False. # region --- 10. Calculate Mode --- if run_options.calculate_modes: for port in [&quot;input_te_tm&quot;, &quot;output_up_te_tm&quot;, &quot;output_down_te_tm&quot;]: simu.add(name=simu_name+&quot;_&quot;+port+&quot;_cal_mode&quot;, simulation_name=simu_name, source_name=port, type=&quot;mode_selection:user_select&quot;, property={&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: True, &quot;mesh_structure&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: number_of_modes, &quot;calculate_group_index&quot;: True}}) port_res = simu[simu_name+&quot;_&quot;+port+&quot;_cal_mode&quot;].run() for m in range(number_of_modes): port_res.extract(data=&quot;calculate_modes&quot;, savepath=plot_path + &quot;00_modeprofile_fdeonly_&quot; + port + &quot;_mode#&quot; + str(m), mode=m, attribute=&quot;E&quot;, export_csv=False) # endregion key\tValue\tType\tDescriptionmesh_structure\tTrue\tbool\tselect to calculate the refractive index distribution of the port calculate_modes True bool select to calculate mode of cross-section Wavelength\twavelength\tfloat\tcalculate the wavelength of the mode number_of_trial_modes\tnumber_of_modes\tinteger\tnumber of calculation modes search\t&quot;max_index&quot;\tfloat\tmethod of finding mode calculate_group_index\tTrue\tbool\tselect to calculate group refractive index 1.14 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation. # region --- 11. Run --- eme_res = simu[simu_name].run() # endregion 1.15 Run and Extract Results​ # region --- 12. See Results -- if run_options.extract: # region --- 12.1 EME Results -- if run_options.run: # region --- facet data --- eme_res.extract(data='eme_propagate:facet_data', savepath=plot_path, real=True, imag=True, export_csv=True) # endregion # region --- smatrix_intensity --- eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) # endregion # region --- monitor --- eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True) for i in range(5): eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_section&quot;+str(i+1), monitor_name=&quot;section&quot;+str(i+1), attribute=&quot;E&quot;, export_csv=True) # endregion # endregion # region --- 12.2 EME Wavelength Sweep Results --- if run_options.run_wavelength_sweep: &quot;&quot;&quot; 20_wavelength_sweep &quot;&quot;&quot; eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) # endregion # endregion 1.16 Control Switch​ We can control the operation of the simulation by passing bool values through tuples, as shown in the following code. class RunOptions(NamedTuple): calculate_modes: bool run: bool run_wavelength_sweep: bool extract: bool if __name__ == &quot;__main__&quot;: simulation(run_mode=&quot;local&quot;, wavelength=1.50, global_mesh_grid=0.05, local_mesh_grid=0.03, number_of_modes=15, run_options=RunOptions(calculate_modes=True, run=True, run_wavelength_sweep=True, extract=True)) 2 Output Results​ 2.1 taper waveguide​ Change taper width The asymmetry of the cross-section of a waveguide can lead to hybridization of polarization modes within a certain width range, which is a commonly used method for designing polarization conversion. We can easily obtain the effective refractive index of silicon waveguides with different widths by using the SDK's multiple cyclic FDE. As shown in the figure below, mode hybridization occurs near the waveguide width of 0.65um in the air cladding. As the waveguide width widens, the input TE0 mode light field changes to TM1. Therefore, the width variation range of the adiabatic conical waveguide we designed should include the range of mode hybridization.Scan taper length It should be noted that the tapered waveguide must be long enough to convert the input TM mode of the waveguide into TE mode without generating other modes. Here, the length scanning of EME can be used to obtain the optimal mode conversion efficiency of the tapered waveguide length. 2.2 Coupling waveguide​ Add a narrow waveguide near the conical waveguide and convert TE1 in the wide waveguide to TE0 in the narrow waveguide through the design of an asymmetric directional coupler. In this way, the input TM mode is converted to TE0 mode, while the input TE0 mode maintains the same polarization in the conical waveguide transmission, and does not meet the mode conversion conditions in the asymmetric directional coupling region and is output from the through port. 2.3 Mode filtering​ The polarization beam splitter rotator cascades an MMI mode filter at the through port to eliminate residual TM0 and TE1 modes at the output port and improve the extinction ratio of the modes. 2.2 EME Propagation​ The calculation of EME requires adding multiple elements in the area where the cross-section of the waveguide changes, and the more severe the structural change, the more elements are needed. After the calculation of `EME propagation`` is completed, the electric field inside the waveguide can be observed. Using EME simulation can quickly optimize length, and you can use `propagation_sweep` to optimize transmittance. Analysis and Discuss​ For the calculation of long-distance waveguide transmission models, EME has significant advantages. The mode field distribution of input TE0 and TM0 is shown in the following figure. References​ Dai D, Wu H. Realization of a compact polarization splitter-rotator on silicon[J]. Optics letters, 2016, 41(10): 2346-2349.","keywords":""},{"title":"Multi-Mode Interference","type":0,"sectionRef":"#","url":"/my-website/docs/examples/SDK Examples/PIC/MMI/","content":"Multi-Mode Interference Introduction​ Multi-mode interferometer, due to their advantages of low insertion loss, wide bandwidth, simple fabrication process, and good tolerance, have been widely used in important optical devices such as optical switches and wavelength-division multiplexers. The main performance parameters of multi-mode interference couplers include insertion Loss, imbalance, device dimensions, operating bandwidth. Simulation Methods​ With the EME module, the corresponding cell groups and cell numbers can be set up with the structure, and a parameter sweep can be performed in the propagation sweep to obtain the S-parameters of the device. This parameter sweep helps optimize the core dimensions of the multi-mode interferometer, ensuring desired performance characteristics. Alternatively, FDTD module can be conducted to obtain the intensity distribution of the optical field and the transmittance at each port. This allows the verification of the optimized results for the multi-mode interferometer. After data processing, performance parameters such as the imbalance, insertion loss, and bandwidth of the device can be determined. Multi-Mode Interference(EME module)​ The simulation design of a multimode interference coupler typically employs the EME module. This allows for a rapid scan of the length of the multimode interference region to quickly identify the optimal length for beam splitting. Therefore, in the following code, we will learn how to create a Multi-Mode Interference (MMI) simulation and output the results for data processing. 1. Basic Operations​ 1.1 Import File​ Once you have installed and configured the environment, import the python code and the GDS layout. The example library and related model code are usually located in the directory :examples/func_demo. The GDS file is generally imported into the path :examples/examples_gds 1.2 SDK Initialization​ Create a new terminal and run the code after you import the python script and GDS file. Max-Optics SDK may take some time to connect the service. 2.Code Description​ Now let's learn the meaning of functions and parameters that correspond to the code. 2.1 import Modules​ To begin, we need to use the import command to call the relevant functional modules. For instance, we import the typing , os and time module in python. At the same time ,we import the customized module maxoptics_sdk.all and maxoptics_sdk.helper. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple The maxoptics_sdk package provides all in one optical simulation with Python. The os module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands. The time module provides various functions to work with time-related operations and to measure time intervals. The typing module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. 2.2 Define Simulation​ Firstly, We define parameters and give them a default value, such as the simulation wavelength and number of modes. Note that we can override this value in the following code. @timed @with_path def simulation( *, wavelength=1.55, number_of_modes=10, global_mesh_grid=0.155, local_mesh_grid=0.01, run_options: &quot;RunOptions&quot;, **kwargs ): The provided code contains comments that define the simulation parameters. Let's explain each of these parameters. The function simulation is used to define the simulation parameters for the program. The run_mode parameter determines the type of calculation resources to be used. The wavelength parameter specifies the wavelength of the input light in micrometers. The number_of_trial_modes parameter sets the number of modes to be calculated. The **kwargs is a special syntax used in function definitions to accept an arbitrary number of keyword arguments as a dictionary. 2.3 Define Parameters​ Define commonly used parameters in region 0, such as the mesh grid of the simulation boundary, the start time of the simulation, the path and name for the simulation output, the path to the imported GDS layout, and other parameters required for structural parameterized modeling. If you need to calculate the bandwith of the device in the EME simulation, you can also decide the wavelength for sweeping in this section. # region --- 0. General Parameters --- path = kwargs[&quot;path&quot;] simu_name = &quot;EME_1X2MMI&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f'{simu_name}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/1X2MMI.gds&quot; kL = [f&quot;0{k}&quot; for k in range(5)] wavelength_start = 1.55 wavelength_stop = 1.65 wavelength_points = 10 # endregion The code defines several parameters and variables necessary for the simulation process. The global_mesh_grid parameter represents the mesh in the EME simulation region. Similarly, the local_mesh_grid parameter denotes the customized mesh for user defined region. The path variable defines the file path for the simulation, while simu_name specifies the name of the simulation file. The time_str variable is used to obtain the current time as a timestamp for the simulation. The project_name variable assigns a name to the project for the simulation output. The plot_path variable determines the directory where the simulation result plots will be saved. The gds_file_root_path variable defines the path for importing the GDS layout. The parameters wavelength_start,wavelength_stop,wavelength_points are for sweeping. These parameters and variables together facilitate the successful execution and organization of the simulation process. 2.4 Creat Project​ You can create a new project using the Project function of Max's software development toolkit in region 1. # region --- 1. Project --- pj = mo.Project(name=project_name) # endregion 2.5 Define Materials​ Let's proceed to the next step, where we set up the materials required for the simulation in region 2. In this case, we will directly use relevant materials from the MO material library. # region --- 2. Material --- mt = pj.Material() mt.add_nondispersion(name=&quot;Si&quot;, data=[(3.454996, 0)], order=2) mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444991, 0)], order=2) mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) # endregion The add_lib contains three parameters name,data and order. The data calls up the property of simulation materials in the MO material library. The Order parameter determines the mesh order for the material during the simulation. As the same, we also support users to customize the material with add_nondispersionfunction. Detailed explaination about material : Material 2.6 Create Model​ Next, we will create the MMI model in region 3. # region --- 3. Structure --- st = pj.Structure() st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 4}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name=&quot;psr&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (2, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) # endregion We can import the MMI layout from the GDS file. The name parameter defines the structure name. The type parameter specifies the structure type. The path, cell_name, and layer_name parameters point to the GDS file and specify the relevant layers and cell names used in the layout. The geometry parameter sets the structure's coordinates. The material parameter specifies the material properties The mesh_order parameter sets the mesh order for the simulation. 2.7 Simulation​ After establishing the model, we can add the simulation in region 4. # region --- 4. Simulation --- simu = pj.Simulation() simu.add( name=simu_name, type=&quot;EME&quot;, property={ &quot;background_material&quot;: mt[&quot;Air&quot;], &quot;mesh_settings&quot;: { &quot;mesh_factor&quot;: 1.2, &quot;mesh_refinement&quot;: { &quot;mesh_refinement&quot;: &quot;curve_mesh&quot;, }, }, &quot;geometry&quot;: {&quot;x_min&quot;: -1, &quot;y&quot;: 0, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 3}, &quot;boundary_conditions&quot;: { &quot;y_min_bc&quot;: &quot;PML&quot;, &quot;y_max_bc&quot;: &quot;PML&quot;, &quot;z_min_bc&quot;: &quot;PML&quot;, &quot;z_max_bc&quot;: &quot;PML&quot;, &quot;pml_settings&quot;: { &quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 5, &quot;pml_layer&quot;: 12, &quot;pml_polynomial&quot;: 3, }, }, &quot;general&quot;: { &quot;wavelength&quot;: wavelength, &quot;wavelength_offset&quot;: 0.0003, &quot;use_wavelength_sweep&quot;: True, }, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 20, &quot;cell_number&quot;: 10, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 11.5, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 20, &quot;cell_number&quot;: 10, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, ] } }, &quot;transverse_mesh_setting&quot;: { &quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: global_mesh_grid, &quot;dz&quot;: global_mesh_grid} }, }, ) # endregion The name parameter defines the name of the simulation module. The property parameter specifies the general property of the simulation module, such as the geometry of cell, wavelength and so on. The cell_group_definition parameter specifies the general property of the cell group. The number_of_modes parameter specifies the general property of the simulation module within the structure, such as the geometry of cell, wavelength and so on. The sc parameter sets the subcell method in EME simulation. Selections are ['none', 'sub_cell']. 2.8 Add Sub-mesh​ To achieve more accurate calculations of the model's modal fields, we can add a sub-mesh in region 5. # region --- 5. Sub Mesh --- lm = pj.LocalMesh() lm.add( name=&quot;sub_mesh&quot;, property={ &quot;general&quot;: {&quot;dx&quot;: local_mesh_grid,&quot;dy&quot;: local_mesh_grid, &quot;dz&quot;: local_mesh_grid}, &quot;geometry&quot;: {&quot;x&quot;: 30.75, &quot;x_span&quot;: 11.5, &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.4}, }, ) # endregion In this code segment, we add a sub-mesh in region 5. The name parameter defines the name of the mesh. The general parameter specifies the grid accuracy in the xyz directions . The geometry parameter sets the coordinates of the sub-mesh. 2.9 EME Port​ In region 6, we add the EME Port for calculating modes in the simulation. # region --- 6. Port --- pjp = pj.Port() # region --- input_te_tm --- pjp.add( name=&quot;input_port&quot;, type=&quot;eme_port&quot;, property={ &quot;modal_analysis&quot;: { &quot;wavelength&quot;: wavelength, }, &quot;geometry&quot;: { &quot;port_location&quot;: &quot;left&quot;, &quot;use_full_simulation_span&quot;: True, }, &quot;eme_port&quot;: { &quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;mode_index&quot;: 0}, &quot;advanced&quot;: {&quot;offset&quot;: 0.1, &quot;number_of_trial_modes&quot;: number_of_modes }}}) # endregion # region --- output_up_te_tm --- pjp.add( name=&quot;output_port1&quot;, type=&quot;eme_port&quot;, property={ &quot;modal_analysis&quot;: { &quot;wavelength&quot;: wavelength, }, &quot;geometry&quot;: { &quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: 0.9, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2 }, &quot;eme_port&quot;: { &quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;mode_index&quot;: 0}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # region --- output_down_te_tm --- pjp.add( name=&quot;output_port2&quot;, type=&quot;eme_port&quot;, property={ &quot;modal_analysis&quot;: { &quot;wavelength&quot;: wavelength, }, &quot;geometry&quot;: { &quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: -0.9, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}, &quot;eme_port&quot;: { &quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;mode_index&quot;: 0, &quot;search&quot;: &quot;max_index&quot;}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes }}}) # endregion # endregion The name parameter defines the name of the EME port. The port_location parameter sets the location type of EME port. Selections are ['left', 'right']. The use_full_simulation_span parameter confirms whether to use full simulation span. The mode_selection parameter decides the mode which propagates in the waveguide. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. The mode_index is used to decide the source mode in the 'user_select' condition. The search parameter calculates the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. Selections are ['near_n', 'max_index']. The number_of_trial_modes parameter determines the calculated number of modes around the refractive index. 2.10 Add Monitor​ In region 7, we add the profile monitors for the EME simulation. # region --- 7. Monitor --- mn = pj.Monitor() mn.add( name=&quot;z_normal&quot;, type=&quot;profile_monitor&quot;, property={ &quot;geometry&quot;: { &quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 30.75, &quot;x_span&quot;: 55.5, &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0 }}) for i, pos in enumerate([10, 17.5, 23.5, 34.5, 39.5]): mn.add( name=&quot;section&quot;+str(i+1), type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: pos, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}}) # endregion The monitor_type parameter selects the profile monitor type and the orientation.Selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. The x_resolution parameter decides the resolution of output simulation results in profile monitor. 2.11 Calculate Mode​ In this region, we calculate the modes of ports. Before running EME simulation calculations, we can calculate the mode field distribution of the port by setting the type of mode selection to True and other simulations to False. # region --- 8. Calculate Mode --- if run_options.calculate_modes: for port in [&quot;input_port&quot;, &quot;output_port1&quot;,&quot;output_port2&quot;]: k = kL[2] simu[simu_name].preview_modes( port_name=port, data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_modeprofile_fdeonly_{port}&quot;, attribute=&quot;E&quot;, mode=0, ) simu[simu_name].preview_modes( port_name=port, data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_Preview_{port}_neff&quot;, show=False, export_csv=True, ) # endregion 2.14 Run​ In the region 9 ,we can recall the simulation name to run it. # region --- 9. Run --- eme_base_res = simu[simu_name].run() # endregion 2.15 EME Analysis​ In region 10, we run the analysis for this simulation.In this part, we can set detailed information of wavelength sweep,groupspan sweep,periodicity and so on. # region --- 10. Analysis --- grating_periods = 1 analysis = pj.Analysis() analysis.add( name=&quot;eme_propagate&quot;, type=&quot;eme_analysis&quot;, property={ &quot;workflow_id&quot;: eme_base_res.workflow_id, &quot;eme_propagate&quot;: run_options.run, &quot;periodicity&quot;: { &quot;periodicity&quot;: True, &quot;periodic_group_definition&quot;: [ { &quot;start_cell_group&quot;: &quot;group_span_1&quot;, &quot;end_cell_group&quot;: &quot;group_span_1&quot;, &quot;periods&quot;: grating_periods, } ], }, &quot;group_span_sweep&quot;: { &quot;group_span_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_1&quot;, &quot;start&quot;: 0, &quot;stop&quot;: 10, &quot;number_of_points&quot;: 11, }, &quot;wavelength_sweep&quot;: { &quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: 1.5, &quot;stop&quot;: 1.6, &quot;number_of_wavelength_points&quot;: 11, }, # &quot;override_wavelength&quot;:{ # &quot;wavelength&quot;: 1.55 # } },) eme_res = analysis[&quot;eme_propagate&quot;].run() # endregion 2.16 Extract Results​ In region 11, we can retrieve and store the simulation results. # region --- 11. See Results -- if run_options.extract: # region --- 11.1 EME Results -- if run_options.run: # region --- facet data --- eme_res.extract( data=&quot;eme_propagate:facet_data&quot;, savepath=f&quot;{plot_path}&quot;, real=True, imag=True, export_csv=True, ) eme_res.extract( data=&quot;eme_propagate:cell_power_total&quot;, savepath=f&quot;{plot_path}00_cell_power_total&quot;, target=&quot;line&quot;, toward=&quot;forward&quot;, export_csv=True, ) eme_res.extract( data=&quot;eme_propagate:cell_power_mode&quot;, savepath=f&quot;{plot_path}01_cell_power_mode&quot;, target=&quot;intensity&quot;, toward=&quot;forward&quot;, export_csv=True, ) eme_res.extract( data=&quot;eme_propagate:cell_neff&quot;, savepath=f&quot;{plot_path}02_cell_neff&quot;, target=&quot;intensity&quot;, export_csv=True, ) for port_name in [&quot;input_port&quot;, &quot;output_port1&quot;,&quot;output_port2&quot;]: res = eme_res.extract( data=&quot;eme_propagate:port_mesh_structure&quot;, savepath=f&quot;{plot_path}03_eme_structure_{port_name}&quot;, port_name=port_name, target=&quot;intensity&quot;, ) # region --- smatrix_intensity --- eme_res.extract( data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) # endregion # region --- monitor --- eme_res.extract( data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True ) for i in range(5): eme_res.extract( data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_section&quot;+str(i+1), monitor_name=&quot;section&quot;+str(i+1), attribute=&quot;E&quot;, export_csv=True) # # endregion # # endregion # # region --- 11.2 EME Wavelength Sweep Results --- if run_options.run_wavelength_sweep: eme_res.extract( data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;06_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True, ) # endregion # endregion return project_name The extract function allows you to extract specific simulation results and store them for further analysis. The data parameter is to decide what type/field data will be extracted. The savepath parameter specifies the save path of picture. The monitor_name parameter specifies the name of monitor which provides the data needed. The plot_x parameter specifies the data of x axis. The export_csv parameter is to decide whether to export a csv. Default as False. 2.16 Switches​ In this section of the code, the simulation function is called and executed, which allows you to reset relevant parameters for more convenient parameter scanning and optimization design. We also support control switches for various functionalities at the end of the code, and you can use configuration flags(True or False). These flags can be used to turn specific functionalities on or off, making it easier to check the model and perform efficient calculations. class RunOptions(NamedTuple): calculate_modes: bool run: bool run_length_sweep: bool run_wavelength_sweep: bool extract: bool if __name__ == &quot;__main__&quot;: simulation( run_mode=&quot;local&quot;, wavelength=1.55, global_mesh_grid=0.01, local_mesh_grid=0.005, number_of_modes=10, run_options=RunOptions( calculate_modes=True, run=True, run_length_sweep=False, run_wavelength_sweep=True, extract=True, ), ) By turning on/off the relevant functionalities, you can control the simulation process and obtain the desired results. For example, the calculate_modes determines whether to calculate the modes. The run determines whether to do the EME propagation in the program. run_wavelength_sweep is used to enable wavelength scanning, and extract is used to control data extraction. Properly utilizing these switches can help you inspect the simulation effectively. 3.Output Results​ the z-normal E intensity of EME propagation The S matrix of EME propagation and the S parameters and transmission at different wavelength.. As shown in the figure below, the S-matrix is a 3∙3 matrix. The S21 parameter represents the absolute value of the transmission coefficient from port 1 input to port 2 output. Due to the symmetry of the structure, S31=S21. The transmission result is shown in the left picture below which is calculted form the S parameter about the one of output ports. Therefore, we can obtain the insert loss is about 0.114 dB at 1.55 micrometer wavelength. Supplement​ To view a function's definition and supported parameters or a parameter dictionary, you can right-click on its name and select &quot;Go to Definition&quot; or press &quot;Ctrl&quot; while left-clicking on its name to view its definition, showing the available parameters and their descriptions.","keywords":""},{"title":"Modulator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/SDK Examples/Active_Device/MOD/","content":"Modulator Introduction​ ​We have developed an electro-optic modulator based on carrier-depletion mechanism in silicon to simulate carrier and index distribution in a global structure. The drift and diffusion of carriers result in depletion at the PN junction. Applying a reverse bias voltage at the cathode broadens the depletion region, altering the carrier concentration and modulating the material's refractive index. Gaussian doping was employed in this model. Modulation efficiency, capacitance, and resistance were calculated to analyze the electro-optic characteristics of the modulator. ​The figure below illustrates the device structure we constructed, wherein the aluminum electrode is applied to the silicon modulator, and the entire device is encapsulated with silicon dioxide material. Simulation Structure​ ​The present structural file provides a comprehensive guide for constructing a simulation structure and establishing a Gaussian doping distribution. Initially, one must construct the geometric structure of the device, incorporate materials and physical models, specify the doping distribution, and simulation boundary conditions, and set the light source and simulation solver. Eventually, the simulation result data should be extracted and output. ​Our simulation is designed with a light source entering along the X-axis, and the primary optoelectronic characteristic analysis takes place within the three-dimensional structure on the YZ plane. The FDE solver is utilized to preview the distribution of effective refractive index, and the DDM solver is used to preview the doping distribution of the device. Finally, we generate ad output the distribution map of doping and index in modulator structure. Application Library path: :\\mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD00_structure.py 1. Basic Operations​ It is essential to incorporate materials for structure. Although module of maxoptics_sdk.all provides default values for standard semiconductors, these values can be customized in MOD_material.py . Application Library path: :\\mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD_material.py The module of fundamental specifies the base parameters of the material electrical structure . The recombination includes recombination of Auger, SRH, and Radiative. It is crucial to define the model type and parameter values, if another model is used instead of the default. The default mobility model of Silicon is Analytic , but we use the mobility model of Masetti in Mobility of this modulator. elec_Si_properties = { &quot;permittivity&quot;: { &quot;permittivity&quot;: 11.7 }, &quot;work_function&quot;:4.2, &quot;fundamental&quot;: { &quot;electron&quot;: &quot;density_of_states&quot;, &quot;hole&quot;: &quot;density_of_states&quot;, &quot;nc&quot;: { # &quot;constant&quot;: 3.21657e19, &quot;enable_model&quot;: True, &quot;nc300&quot;: 3.21657e19 }, &quot;nv&quot;: { # &quot;constant&quot;: 1.82868e19, &quot;enable_model&quot;: True, &quot;nv300&quot;: 1.82868e19 }, &quot;eg&quot;: { # &quot;constant&quot;: 1.12416, &quot;enable_model&quot;: True, &quot;alpha&quot;: 0.000473, &quot;beta&quot;: 636, &quot;eg0&quot;: 1.16 }, &quot;narrowing&quot;: { &quot;model&quot;: &quot;slotboom&quot;, &quot;slotboom&quot;: { &quot;e0&quot;: 0.0045, &quot;n0&quot;: 1.0e17 } }, }, &quot;recombination&quot;:{ &quot;trap_assisted&quot;: { &quot;enabled&quot;: True, &quot;taun&quot;: { &quot;enable_model&quot;: False, # &quot;constant&quot;: 1e-5, # &quot;alpha&quot;: 0, &quot;dopant&quot;: { &quot;model&quot;: &quot;scharfetter&quot;, &quot;scharfetter&quot;: { &quot;nref&quot;: 7.1e15, &quot;taumax&quot;: 3.3e-6, &quot;taumin&quot;:0 } }, &quot;field&quot;: { &quot;model&quot;: &quot;none&quot;, # &quot;schenk&quot;: { # &quot;hbar_omega&quot;: 0.068, # &quot;mt&quot;: 0.258, # &quot;s&quot;: 3.5 # } } }, &quot;taup&quot;: { &quot;enable_model&quot;: False, # &quot;constant&quot;: 3e-6, # &quot;alpha&quot;: 0, &quot;dopant&quot;: { &quot;model&quot;: &quot;scharfetter&quot;, &quot;scharfetter&quot;: { &quot;nref&quot;: 7.1e15, &quot;taumax&quot;: 4e-6, &quot;taumin&quot;: 0 } }, &quot;field&quot;: { &quot;model&quot;: &quot;none&quot;, # &quot;schenk&quot;: { # &quot;hbar_omega&quot;: 0.068, # &quot;mt&quot;: 0.24, # &quot;s&quot;: 3.5 # } } }, &quot;ei_offset&quot;: 0.0 }, &quot;radiative&quot;: { &quot;enabled&quot;: True, &quot;copt&quot;: 1.6e-14 }, &quot;auger&quot;: { &quot;enabled&quot;: True, &quot;caun&quot;: { &quot;constant&quot;: 2.8e-31, &quot;enable_model&quot;: False, # &quot;a&quot;: 6.7e-32, # &quot;b&quot;: 2.45e-31, # &quot;c&quot;: -2.2e-32, # &quot;h&quot;: 3.46667, # &quot;n0&quot;: 1e18 }, &quot;caup&quot;: { &quot;constant&quot;: 9.9e-32, &quot;enable_model&quot;: False, # &quot;a&quot;: 7.2e-32, # &quot;b&quot;: 4.5e-33, # &quot;c&quot;: 2.63e-32, # &quot;h&quot;: 8.25688, # &quot;n0&quot;: 1e18 } }, &quot;band_to_band_tunneling&quot;: { &quot;enabled&quot;: False, # &quot;model&quot;: &quot;hurkx&quot;, # or &quot;schenk&quot; # &quot;hurkx&quot;: { # &quot;agen&quot;: 3.5e21, # &quot;arec&quot;: 3.5e21, # &quot;bgen&quot;: 2.25e7, # &quot;brec&quot;: 2.25e7, # &quot;pgen&quot;: 2.0, # &quot;prec&quot;: 2.0, # &quot;alpha&quot;: 0 # }, # &quot;schenk&quot;: { # &quot;a&quot;: 8.977e20, # &quot;b&quot;: 2.1466e7, # &quot;hbar_omega&quot;: 0.0186 # } } }, &quot;mobility&quot;:{ &quot;mun&quot;: { &quot;lattice&quot;: { # &quot;constant&quot;: 1417, &quot;enable_model&quot;: True, &quot;eta&quot;: -2.5, &quot;mumax&quot;: 1471 }, &quot;impurity&quot;: { &quot;model&quot;: &quot;masetti&quot;, &quot;masetti&quot;: { &quot;alpha&quot;: 0.68, &quot;beta&quot;: 2, &quot;cr&quot;: 9.68e16, &quot;cs&quot;: 3.43e20, &quot;mu1&quot;: 43.4, &quot;mumin1&quot;: 52.2, &quot;mumin2&quot;: 52.2, &quot;pc&quot;: 0 } }, &quot;high_field&quot;: { &quot;model&quot;: &quot;none&quot;, # &quot;canali&quot;: { # &quot;alpha&quot;: 0, # &quot;beta0&quot;: 1.109, # &quot;eta&quot;: 0.66 # }, # &quot;driving_field&quot;: { # &quot;model&quot;: &quot;e_dot_j&quot;, # or &quot;grad_phi&quot;, # &quot;grad_phi&quot;: { # &quot;nref&quot;: 1e5 # } # }, # &quot;vsat&quot;: { # &quot;constant&quot;: 1.07e7, # &quot;enable_model&quot;: False, # &quot;gamma&quot;: 0.87, # &quot;vsat0&quot;: 1.07e7 # } } }, &quot;mup&quot;: { &quot;lattice&quot;: { # &quot;constant&quot;: 470.5, &quot;enable_model&quot;: True, &quot;eta&quot;: -2.2, &quot;mumax&quot;: 470.5 }, &quot;impurity&quot;: { &quot;model&quot;: &quot;masetti&quot;, # or &quot;none&quot; &quot;masetti&quot;: { &quot;alpha&quot;: 0.719, &quot;beta&quot;: 2, &quot;cr&quot;: 2.23e17, &quot;cs&quot;: 6.1e20, &quot;mu1&quot;: 29, &quot;mumin1&quot;: 44.9, &quot;mumin2&quot;: 44.9, &quot;pc&quot;: 0 } }, &quot;high_field&quot;: { &quot;model&quot;: &quot;none&quot;, # &quot;canali&quot;: { # &quot;alpha&quot;: 0, # &quot;beta0&quot;: 1.213, # &quot;eta&quot;: 0.17 # }, # &quot;driving_field&quot;: { # &quot;model&quot;: &quot;e_dot_j&quot;, # or &quot;grad_phi&quot;, # &quot;grad_phi&quot;: { # &quot;nref&quot;: 1e5 # } # }, # &quot;vsat&quot;: { # &quot;constant&quot;: 8.37e6, # &quot;enable_model&quot;: True, # &quot;gamma&quot;: 0.52, # &quot;vsat0&quot;: 8.37e6 # }, }, }, }, } The parameter values of opto_Si_properties_1550 and opto_Si_properties_1310 are used to describe the perturbation variation of carrier distribution on refractive index. Should choose the &quot;index_perturbation&quot; model and enable the &quot;np_density&quot; model to define these parameters. opto_Si_properties_1550 = { &quot;index_perturbation&quot;: { &quot;enabled&quot;: True, &quot;np_density&quot;: { &quot;enable_model&quot;: True, &quot;np_density_model&quot;: &quot;soref_and_bennett&quot;, &quot;coefficients&quot;: &quot;user_input&quot;, &quot;isotropic_data&quot;: [ { &quot;dalpha_an&quot;: 8.5e-18, &quot;dalpha_ap&quot;: 6e-18, &quot;dalpha_en&quot;: 1, &quot;dalpha_ep&quot;: 1, &quot;dn_an&quot;: -8.8e-22, &quot;dn_ap&quot;: -8.5e-18, &quot;dn_en&quot;: 1, &quot;dn_ep&quot;: 0.8, } ] } } } opto_Si_properties_1310 = { &quot;index_perturbation&quot;: { &quot;enabled&quot;: True, &quot;np_density&quot;: { &quot;enable_model&quot;: True, &quot;np_density_model&quot;: &quot;soref_and_bennett&quot;, &quot;coefficients&quot;: &quot;user_input&quot;, &quot;isotropic_data&quot;: [ { &quot;dalpha_an&quot;: 6e-18, &quot;dalpha_ap&quot;: 4e-18, &quot;dalpha_en&quot;: 1, &quot;dalpha_ep&quot;: 1, &quot;dn_an&quot;: -6.2e-22, &quot;dn_ap&quot;: -6e-18, &quot;dn_en&quot;: 1, &quot;dn_ep&quot;: 0.8, } ] } } } 2. Code description​ 2.1 Import Modules​ To begin, we need to use the import command to call the relevant functional modules and parameter values of material from previously defined file. import sys # encoding: utf-8 from moapi.v3.aggregate import AggregatedUIService as Project import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple import sys current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from MOD_material import elec_Si_properties, opto_Si_properties_1550, opto_Si_properties_1310 The typing module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. The os module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands. The time module provides various functions to work with time-related operations and to measure time intervals. The maxoptics_sdk package provides all in one optical simulation with Python. 2.2 Define Parameters​ 2.2.1 General Parameters​ We define these parameters for entire simulation process. wavelength = 1.55 # um temperature = 300 # K normal_length = 1e4 # um egrid_global = 0.01 # um ogrid_global_y = 0.02 # um ogrid_global_z = 0.02 # um ogrid_local_y = 0.002 # um ogrid_local_z = 0.002 # um run_mode = &quot;local&quot; simu_name = &quot;MOD00&quot; Parameter\tUnits\tDescriptionwavelength\tum\tSpecifies the optical wavelength of the source beam (in the vacuum) for mono-spectral simulations. temperature\tK\tSpecifies the temperature in Kelvin. normal_length\tum\tSpecifies the extent of a mesh section in the X direction. egrid_loacal\tum\tSpecifies the appropriate size of mesh in the Y and Z direction for overall region of DDM simulation. ogrid_global_y\tum\tSpecifies the mesh spacing in the Y direction for region of optical simulation. ogrid_global_z\tum\tSpecifies the mesh spacing in the Z direction for region of optical simulation. ogrid_local\tum\tSpecifies the mesh spacing in the Y and Z direction for local region of optical simulation. run_mode Specifies the simulate model. simu_name Specifies this file name to define name of output result folder. Since we explore two communication wavelength, you should define the wavelength, and use next code to choose relavent parameters values, which we defines in MOD_material.py . if wavelength &gt; 1.4: Si_index_vs_doping = opto_Si_properties_1550 else: Si_index_vs_doping = opto_Si_properties_1310 2.2.2 Structure Geometry​ You should define the location of material in X, Y and Z direction about the modulator structure. st_x_min = -0.3 st_x_max = 0.3 st_x_mean = 0.5*(st_x_min+st_x_max) st_x_span = st_x_max-st_x_min st_y_min = -5 st_y_max = 5 st_y_mean = 0.5*(st_y_min+st_y_max) st_y_span = st_y_max-st_y_min st_z_min = -0.3 st_z_max = 0.8 slab_height = 0.09 rg_height = 0.22 rg_width = 0.5 elec_height = 0.5 elec_width = 1.2 Parameter\tUnits\tDescriptionx_min, x_max, y_min, y_max, z_min, z_max\tum\tSpecifies the minimum or maximum value in X/Y boundary of modulator structure. x_mean, x_span, y_mean, y_span, z_mean, z_span\tum\tSpecifies the center or spacing value in X/Y boundary of modulator structure. slab_height\tum\tSpecifies the height of slab layer in Z direction. rg_height\tum\tSpecifies the height of RG layer in Z direction. elec_height, elec_width\tum\tSpecifies the Z-direction height and Y-direction width of electron. 2.2.3 Electrical Simulation Boundary​ Specifies the boundary of electrical simulation for DDM solver in 3D direction. oe_x_min = 0 oe_x_max = 0 oe_x_mean = 0.5*(oe_x_min+oe_x_max) oe_x_span = oe_x_max-oe_x_min oe_y_min = st_y_min oe_y_max = st_y_max oe_y_mean = 0.5*(oe_y_min+oe_y_max) oe_y_span = oe_y_max-oe_y_min oe_z_min = st_z_min oe_z_max = st_z_max oe_z_mean = 0.5*(oe_z_min+oe_z_max) oe_z_span = oe_z_max-oe_z_min Specifies the concentration of uniform doping by constant_con and its boundary throuth center and span in Y-Z plane. constant_y_center = 0 constant_y_span = 10 constant_z_center = 0.1 constant_z_span = 0.3 constant_con = 1e15 Specifies the junction width and peak concentration of gaussian doping by_jw and _con , its boundary throuth center and span in Y-Z plane of slab. p_slab_y_center = -2.575 p_slab_y_span = 4.85 p_slab_z_center = -0.105 p_slab_z_span = 0.39 p_slab_jw = 0.1 p_slab_con = 7e17 n_slab_y_center = 2.575 n_slab_y_span = 4.85 n_slab_z_center = -0.105 n_slab_z_span = 0.39 n_slab_jw = 0.1 n_slab_con = 5e17 Specifies the doping region of high concentration in slab layer, including boundary、junction width and peak concentration. p_plus_y_center = -3.5 p_plus_y_span = 3 p_plus_z_center = -0.04 p_plus_z_span = 0.52 p_plus_jw = 0.1 p_plus_con = 1e19 n_plus_y_center = 3.5 n_plus_y_span = 3 n_plus_z_center = -0.04 n_plus_z_span = 0.52 n_plus_jw = 0.1 n_plus_con = 1e19 Specifies the doping region of high concentration in waveguide structure, including boundary、junction width and peak concentration. p_wg_y_center = -0.12 p_wg_y_span = 0.36 p_wg_z_center = 0.1275 p_wg_z_span = 0.255 p_wg_jw = 0.12 p_wg_con = 5e17 n_wg_y_center = 0.105 n_wg_y_span = 0.29 n_wg_z_center = 0.12 n_wg_z_span = 0.235 n_wg_jw = 0.11 n_wg_con = 7e17 2.2.4 Optical simulation Boundary​ Specifies the boundary of optical simulation for FDE solver in 3D direction. We only consider optical characteristic of Y-Z plane, since the light travels along X-axis. x_min = 0 x_max = 0 x_mean = 0.5*(x_min+x_max) x_span = x_max-x_min y_min = -2.3 y_max = 2.3 y_mean = 0.5*(y_min+y_max) y_span = y_max-y_min z_min = -1.5 z_max = 1.5 z_mean = 0.5*(z_min+z_max) z_span = z_max-z_min 2.3 Define Engineering Function​ To facilitate the calling of other simulation scripts, it is recommended to define a function that can set materials, model, dope, and add boundary conditions. 2.3.1 Create Project​ Create a new simulation project. class RunOptions(NamedTuple): index_preview: bool = False doping_preview: bool = False calculate_modes: bool = False run: bool = False extract: bool = False def create_project(project_name, run_options: RunOptions) -&gt; Project: # region --- 1. Project --- pj = mo.Project(name=project_name) # endregion return pj 2.3.2 Set Material​ The electrical and optical parameters of SiO2、Al and Si materials in the material library can be accessed. If the parameters defined in the Si section of MOD_material.py are different from the default parameters in the material library, the former will be prioritized. In the overlapping area of the materials, the material with a higher order value will take precedence over the one with a lower value. If the values are the same, the material defined later will override the one defined earlier. It is worth noting that the material Aluminium will call the PEC material library. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_lib(name=&quot;mat_al&quot;, data=mo.OE_Material.Al, order=2, override={&quot;work_function&quot;: 4.1}) mt.add_lib(name=&quot;mat_si&quot;, data=mo.OE_Material.Si, order=2, override=elec_Si_properties) mt[&quot;mat_sio2&quot;].set_optical_material(data=mo.Material.SiO2_Palik) mt[&quot;mat_al&quot;].set_optical_material(data=mo.Material.PEC) mt[&quot;mat_si&quot;].set_optical_material(data=mo.Material.Si_Palik, override=Si_index_vs_doping) # endregion 2.3.3 Define structure​ To begin with, it is advisable to define the geometric region of the device structure in geometry and add materials to this region by material. The background material, which is usually Air or SiO2, should be added first. # region --- 3. Structure --- st = pj.Structure() st.add_geometry(name=&quot;Slab&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z_min&quot;: 0, &quot;z_max&quot;: slab_height}}) st.add_geometry(name=&quot;Rg&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: 0, &quot;y_span&quot;: rg_width, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: rg_height}}) # endregion Parameter\tUnits\tDescriptionname Restricts the applicability of the statement to regions with the specified name. type Specifies the geometry of specified region. material Restricts the applicability of the statement to regions of the specified material. geometry Specifies the boundary of specified region in 3D direction We offer several alternative electrode region for establishing the electrical simulation area. st.add_geometry(name=&quot;Anode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_min, &quot;y_max&quot;: st_y_min + elec_width, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) st.add_geometry(name=&quot;Cathode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_max - elec_width, &quot;y_max&quot;: st_y_max, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) 2.3.4 Add Doping​ You should define the name and type for doping region,and basic parameters of doping module in property, such as dopant and geometry. applicable regions can choose the all region、material or solid to reduce the doping region.Then define source face、junction width、peak concentration and reference concentration in gaussian doping, or only concentration in uniform doping. type specifies the n-type or donor dopant in n , and p-type or acceptor dopant in p , which may be used with gaussian and uniform profile types. ref_concentration specifies the diffusion boundary of Gaussian doping. def add_ddm_settings(pj: Project, run_options: RunOptions): # region --- 4. DDM:Doping --- mt = pj.Material() st = pj.Structure() dp = pj.Doping() dp.add(name=&quot;background_doping&quot;, type=&quot;constant_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;p&quot;, &quot;concentration&quot;: constant_con}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: constant_y_center, &quot;y_span&quot;: constant_y_span, &quot;z&quot;: constant_z_center, &quot;z_span&quot;: constant_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot; }}) dp.add(name=&quot;p_slab&quot;, type=&quot;diffusion_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;p&quot;, &quot;concentration&quot;: p_slab_con, &quot;ref_concentration&quot;: 1e6, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;diffusion_function&quot;: &quot;gaussian&quot;, &quot;junction_width&quot;: p_slab_jw}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: p_slab_y_center, &quot;y_span&quot;: p_slab_y_span, &quot;z&quot;: p_slab_z_center, &quot;z_span&quot;: p_slab_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot; }}) dp.add(name=&quot;n_slab&quot;, type=&quot;diffusion_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;n&quot;, &quot;concentration&quot;: n_slab_con, &quot;ref_concentration&quot;: 1e6, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;diffusion_function&quot;: &quot;gaussian&quot;, &quot;junction_width&quot;: n_slab_jw}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: n_slab_y_center, &quot;y_span&quot;: n_slab_y_span, &quot;z&quot;: n_slab_z_center, &quot;z_span&quot;: n_slab_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot; }}) dp.add(name=&quot;p_plus&quot;, type=&quot;diffusion_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;p&quot;, &quot;concentration&quot;: p_plus_con, &quot;ref_concentration&quot;: 1e6, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;diffusion_function&quot;: &quot;gaussian&quot;, &quot;junction_width&quot;: p_plus_jw}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: p_plus_y_center, &quot;y_span&quot;: p_plus_y_span, &quot;z&quot;: p_plus_z_center, &quot;z_span&quot;: p_plus_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot; }}) dp.add(name=&quot;n_plus&quot;, type=&quot;diffusion_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;n&quot;, &quot;concentration&quot;: n_plus_con, &quot;ref_concentration&quot;: 1e6, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;diffusion_function&quot;: &quot;gaussian&quot;, &quot;junction_width&quot;: n_plus_jw}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: n_plus_y_center, &quot;y_span&quot;: n_plus_y_span, &quot;z&quot;: n_plus_z_center, &quot;z_span&quot;: n_plus_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot; }}) dp.add(name=&quot;p_wg&quot;, type=&quot;diffusion_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;p&quot;, &quot;concentration&quot;: p_wg_con, &quot;ref_concentration&quot;: 1e6, &quot;source_face&quot;: &quot;lower_y&quot;, &quot;diffusion_function&quot;: &quot;gaussian&quot;, &quot;junction_width&quot;: p_wg_jw}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: p_wg_y_center, &quot;y_span&quot;: p_wg_y_span, &quot;z&quot;: p_wg_z_center, &quot;z_span&quot;: p_wg_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot; }}) dp.add(name=&quot;n_wg&quot;, type=&quot;diffusion_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;n&quot;, &quot;concentration&quot;: n_wg_con, &quot;ref_concentration&quot;: 1e6, &quot;source_face&quot;: &quot;upper_y&quot;, &quot;diffusion_function&quot;: &quot;gaussian&quot;, &quot;junction_width&quot;: n_wg_jw}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: n_wg_y_center, &quot;y_span&quot;: n_wg_y_span, &quot;z&quot;: n_wg_z_center, &quot;z_span&quot;: n_wg_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot; }}) # endregion Parameter\tUnits\tDescriptionx_min, x_max, y_min, y_max, z_min, z_max\tum\tSpecifies the minimum or maximum value in X/Y boundary of modulator structure. x_mean, x_span, y_mean, y_span, z_mean, z_span\tum\tSpecifies the center or spacing value in X/Y boundary of modulator structure. applicable_regions Selections are ['all_regions','solid','material'] 2.3.5 Set Monitor​ Charge Monitor and Electrical Monitor support both 2D and 1D geometry, whereas Band Monitor can only be used for 1D geometry and Doping Monitor only supports 2D geometry. # region --- 5. DDM:Monitor --- mn = pj.Monitor() mn.add(name=&quot;charge_monitor&quot;, type=&quot;charge_monitor&quot;, property={ &quot;general&quot;: {&quot;interpolate_accuracy&quot;: 1}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: st_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z&quot;: st_z_mean, &quot;z_span&quot;: st_z_span} }) mn.add(name=&quot;elec_monitor&quot;, type=&quot;electrical_monitor&quot;, property={ &quot;general&quot;: {&quot;interpolate_accuracy&quot;: 1}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: st_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z&quot;: st_z_mean, &quot;z_span&quot;: st_z_span} }) mn.add(name=&quot;band_monitor&quot;, type=&quot;band_monitor&quot;, property={ &quot;general&quot;: {&quot;interpolate_accuracy&quot;: 1}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;y_linear&quot;, &quot;x&quot;: st_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z&quot;: 0.08, &quot;z_span&quot;: 0} }) mn.add(name=&quot;doping_monitor&quot;, type=&quot;doping_monitor&quot;, property={ &quot;general&quot;: {&quot;interpolate_accuracy&quot;: 4}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: st_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 0.8, &quot;z_min&quot;: -0.1, &quot;z_max&quot;: 0.3} }) # endregion Parameters\tDescriptionname\tThe name of band monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of band monitor.Parameters\tDefault\tType\tNotesgeneral.interpolate_accuracy\t1\tinteger\tSet the accuracy of the rectangular grid for extracting the monitor result. Restrained by condition: &gt;=1 &amp;&amp; &lt;= 10. Here 1 means the grid size is 10nm, and 10 means the grid size is 1nm, and the grid size varies uniformly with the variation in 'interpolate_accuracy'. monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. 2.3.6 Add Mesh​ When specifying meshes, a balance should be struck between accuracy and numerical efficiency. The accuracy, convergence, and program memory of the subsequent computation are all affected by the quality and size of the elements in the mesh, making mesh partitioning crucial in this module. Achieving accuracy requires a fine mesh that can resolve all significant features of the solution, while numerical efficiency requires a coarse mesh that minimizes the total number of grid points. Due to the relatively simple structure of this modulator, a rough initial mesh can be established for electrical and optical simulation of the entire device. In order to obtain more accurate calculation results and better convergence, the LocalMesh module is employed to refine the mesh of the regions with significant optical characteristics. def add_fde_settings(pj: Project, run_options: RunOptions): # region --- 6.FDE:Mesh --- lm = pj.LocalMesh() lm.add(name=&quot;Mesh&quot;, type=&quot;Mesh&quot;, property={ &quot;general&quot;: {&quot;dy&quot;: ogrid_local_y, &quot;dz&quot;: ogrid_local_z}, &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;x_span&quot;: x_span, &quot;y&quot;: 0, &quot;y_span&quot;: 2*rg_width, &quot;z_min&quot;: -0.5*rg_height, &quot;z_max&quot;: 1.5*rg_height }}) # endregion 2.3.6 Set preview Doping​ ​To analyze the doping distribution of the device, the DDM module can be invoked. First, define the file name for the resulting image and save it to the &quot;plot&quot; folder. Then, configure the DDM solver and define the region from which to extract the refractive index distribution, which is the coordinate in the two-dimensional Y-Z plane where the X-axis equals 0. Additionally, save the simulation process to the &quot;log&quot; folder in the &quot;project&quot; directory. Through invoking the time module and adding it to the file name, the output file of each simulation can be unique, which facilitates accurate file retrieval after multiple simulations. The plot_path will be used as the path for saving extracted results and is set here to the plots folder in the same directory as the script. @timed @with_path def preview_doping(**kwargs): # region --- 6. Preview Doping --- run_options = RunOptions(index_preview=False, doping_preview=True, calculate_modes=False, run=False, extract=False) vsource = &quot;Cathode&quot; # electrode solid gnd = &quot;Anode&quot; # electrode solid path = kwargs[&quot;path&quot;] time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) simu_name = &quot;MOD00_structure_doping&quot; project_name = f&quot;{simu_name}_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) Adding electrical silmulation solver, is the prerequisite for output structure file. You can specify solver name and type in name and type module, and then define its other property. The type of ddm module can be invoked to enable the charge carrier transport solver for analyzing the optoelectronic properties of a device. For this study, we set the solver to solve the steady state of the device at room temperature. , and should set the electrode in BoundaryCondition. Additionally, we define the length of the three-dimensional X direction and the solution mode and temperature during the composite process. Since the simulation analysis is conducted in the two-dimensional Y-Z plane that is perpendicular to the X-axis, 2d_x_normal is adopted to define the simulation calculation geometry. And set the mesh size for entire region of DDM. We utilize the newton iteration method for calculation, and the mumps direct solver is employed as the linear solver. The max_iterations parameter defines the maximum number of nonlinear iterations. When the number of iterations exceeds this value, the solver reduces the voltage step and starts a new iterative computations. pj: Project = create_project(project_name, run_options) create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() simu = pj.Simulation() simu.add(name=simu_name, type=&quot;DDM&quot;, property={ &quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;general&quot;: {&quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;norm_length&quot;: normal_length, &quot;temperature_dependence&quot;: &quot;isothermal&quot;, &quot;temperature&quot;: temperature, }, &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: oe_y_max, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;mesh_settings&quot;: {&quot;mesh_size&quot;: egrid_global}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;newton&quot;, &quot;linear_solver&quot;: &quot;mumps&quot;, &quot;fermi_statistics&quot;: &quot;disabled&quot;, # or &quot;enabled&quot; &quot;damping&quot;: &quot;none&quot;, # or &quot;potential&quot; &quot;potential_update&quot;: 1.0, &quot;max_iterations&quot;: 15, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e5, &quot;divergence_factor&quot;: 1e25 } }) add_ddm_settings(pj, run_options) bd = pj.BoundaryCondition() bd.add(name=vsource,type=&quot;electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[vsource]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, # &quot;envelop&quot;: &quot;uniform&quot;, } }) bd.add(name=gnd,type=&quot;electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[gnd]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, # &quot;envelop&quot;: &quot;uniform&quot;, } }) simu[simu_name].preview_doping(monitor_name=&quot;doping_monitor&quot;, savepath=f&quot;{plot_path}doping&quot;, export_csv=True, real=True, imag=False) # endregion 2.3.6 Set Preview Index​ You can invoke the FDE module to analyze the refractive index distribution of the device. First, define the file name of the result image and save it to the &quot;plot&quot; folder, add structure and material about index region. To define the region of the refractive index distribution to be extracted in geometry , which is the coordinate in the two-dimensional Y-Z plane at X-axis equal to 0. Then run analysis module of FDE and store the extracted result in file path. @timed @with_path def preview_index(**kwargs): # region --- 7. Preview Index --- run_options = RunOptions(index_preview=True, doping_preview=False, calculate_modes=False, run=False, extract=False) path = kwargs[&quot;path&quot;] simu_name = &quot;MOD00_structure_index&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) pj: Project = create_project(project_name, run_options) create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() simu = pj.Simulation() simu.add(name=simu_name, type=&quot;FDE&quot;, property={&quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;x_span&quot;: x_span, &quot;y&quot;: y_mean, &quot;y_span&quot;: y_span, &quot;z&quot;: z_mean, &quot;z_span&quot;: z_span, }, &quot;boundary_conditions&quot;: {&quot;y_min_bc&quot;: &quot;PEC&quot;, &quot;y_max_bc&quot;: &quot;PEC&quot;, &quot;z_min_bc&quot;: &quot;PEC&quot;, &quot;z_max_bc&quot;: &quot;PEC&quot;,}, # 'mode_removal': {'threshold': 0.02}, # default is '2d_x_normal' ['2d_x_normal','2d_y_normal','2d_z_normal'] 'general': {'solver_type': '2d_x_normal'}, &quot;mesh_settings&quot;: {&quot;mesh_refinement&quot;: {&quot;mesh_refinement&quot;: &quot;curve_mesh&quot;}, &quot;mesh_factor&quot;: 1.2, &quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: ogrid_global_y, &quot;dz&quot;: ogrid_global_z, }, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }}) add_fde_settings(pj, run_options) simu_res = simu[simu_name].run() analysis = pj.Analysis() analysis.add(name=&quot;fde_analysis&quot;, type=&quot;FDEAnalysis&quot;, property={&quot;workflow_id&quot;: simu_res.workflow_id, &quot;simulation_name&quot;: &quot;FDE&quot;, &quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: run_options.run, &quot;mesh_structure&quot;: run_options.index_preview, &quot;wavelength&quot;: wavelength, &quot;wavelength_offset&quot;: 0.0001, &quot;number_of_trial_modes&quot;: 5, &quot;search&quot;: &quot;max_index&quot;, # ['near_n','max_index'] # &quot;n&quot;: 1, &quot;calculate_group_index&quot;: False, &quot;bent_waveguide&quot;: {&quot;bent_waveguide&quot;: False, &quot;radius&quot;: 1, &quot;orientation&quot;: 0, &quot;location&quot;: &quot;simulation_center&quot;} }}) result_fde = analysis[&quot;fde_analysis&quot;].run() result_fde.extract(data=&quot;mesh_structure&quot;, savepath=f&quot;{plot_path}01_index&quot;, export_csv=True) if __name__ == &quot;__main__&quot;: preview_doping() preview_index() 3. Output Result​ ​Here, we present the device geometry as defined in the structure file, along with the P-type and N-type dopant distributions, and the overall doping distribution. ​Application Library path: :mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD00_structure_doping_time Na Doping\tN Doping\tNd Doping ​ We can see the distribution of the refractive index in these three directions of device. ​ Application Library path: :mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD00_structure_index_time X-axis\tY-axis\tZ-axis Analytic Character​ 1.Modulation efficiency​ ​The half-wave voltage refers to the applied voltage required by the modulator's optical signal to generate a phase difference of pi radians, directly reflecting the modulation efficiency of the modulator. Usually, the modulation efficiency of a device is represented by multiplying the half-wave voltage with a parameter that represents the length of the modulator required for phase variation. A smaller value of this parameter indicates higher modulation efficiency, resulting in a smaller required device size. According to the modulator's operating principle, the extra carriers created by the doped device under external bias form an internal electric field and depletion layer in the device via drift diffusion, resulting in changes in refractive index and loss. You may determine np density using DDM's steady-state solution by MOD02_np.py and then input the data into FDE to calculate changes in optical loss and refractive index by MOD0A_vpi.py. ​Application Library path: :mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD02_np.py:mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD0A_vpi.py 1.1 Basic Operations​ ​Before analyzing the characteristic parameters of the device, you need to set up the simulation environment in advance and invoke the modules into the file by import . Please refer to the PD documentation for detailed instructions on specific Python commands. 1.2 Code Description​ 1.2.1 Import Modules​ ​To begin, we need to use the import command to call the relevant functional modules. import sys # encoding: utf-8 from maxoptics_sdk.helper import timed, with_path import os import time import sys import numpy as np current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from MOD00_structure import * ​For specific instructions, see the description document of PD device. ​By adding the runtime function module to the file name, you can ensure the orderly storage of simulation results without data overlay or overwriting during multiple simulation runs. @timed @with_path def simulation(*, run_options: &quot;RunOptions&quot;, **kwargs, ): 1.2.2 Define Parameters​ ​The operational mechanism of the device we simulated in this study primarily revolves around the application of a reverse voltage to modify the width of the depletion region, thereby effectively modifying the carrier concentration and subsequently modulating the refractive index. Hence, it is necessary to specify the voltage of initial、termination and step, with both parameters expressed in volts. vsource = &quot;Cathode&quot; # electrode solid gnd = &quot;Anode&quot; # electrode solid sweep_vstart = -0.5 sweep_vstop = 4 sweep_vstep = 0.5 1.2.3 Set Path​ ​You could define the project name of path, and then define the parameters for path. path = kwargs[&quot;path&quot;] simu_name = &quot;MOD02_np&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_local_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) # endregion # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion 1.2.4 Create Structure​ Could directly reference the device structure and materials set in the previous file MOD00_structure.py and MOD_material.py. # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion # region --- 2. Structure --- create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() # endregion 1.2.5 Set Simulation​ ​You can add a electrical model solver here, include DDM solver and boundary conditons. ​You can specify the physical attributes of an electrode. You can set the BC model and scanning method here. The bias voltage range is set for steady-state solutions. Detailed information about the Electrode attribute can be found in the appendix of the PD documentation. # region --- 3. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;DDM&quot;, property={ &quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;general&quot;: {&quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;norm_length&quot;: normal_length, &quot;temperature_dependence&quot;: &quot;isothermal&quot;, &quot;temperature&quot;: temperature, }, &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: oe_y_max, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;mesh_settings&quot;: {&quot;mesh_size&quot;: egrid_global}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;newton&quot;, &quot;linear_solver&quot;: &quot;mumps&quot;, &quot;fermi_statistics&quot;: &quot;disabled&quot;, # or &quot;enabled&quot; &quot;damping&quot;: &quot;potential&quot;, # or &quot;none&quot; &quot;potential_update&quot;: 1.0, &quot;max_iterations&quot;: 15, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e5, &quot;divergence_factor&quot;: 1e25 } }) # endregion # region --- 4. Simulation settings --- add_ddm_settings(pj, run_options) bd = pj.BoundaryCondition() bd.add(name=vsource,type=&quot;electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[vsource]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: sweep_vstart, &quot;range_stop&quot;: sweep_vstop, &quot;range_step&quot;: sweep_vstep, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, # &quot;envelop&quot;: &quot;uniform&quot;, } }) bd.add(name=gnd,type=&quot;electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[gnd]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, # &quot;envelop&quot;: &quot;uniform&quot;, } }) # endregion 1.2.6 Run​ ​It is recommended to include a module that runs the solver and initiates the simulation. The result_device variable stores simulation results for subsequent extraction. # region --- 5. Run --- if run_options.run: result_ddm = simu[simu_name].run(resources={&quot;threads&quot;: 4}) # endregion 1.2.7 Extract Parameters​ ​You can extract and export simulation results to the plot folder. # region --- 6. Extract --- if run_options.run and run_options.extract: export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: False} # --- Voltage list --- result_ddm.extract(data=&quot;ddm:electrode&quot;, electrode_name=vsource, savepath=f&quot;{plot_path}I_{vsource}&quot;, target=&quot;line&quot;, attribute=&quot;I&quot;, plot_x=f&quot;V_{vsource}&quot;, real=True, imag=False, show=False, export_csv=True) result_ddm.save_as(data=&quot;ddm:charge_monitor&quot;, monitor_name=&quot;charge_monitor&quot;, savepath=f&quot;{plot_path}/charge&quot;) voltage_list = np.genfromtxt(f&quot;{plot_path}I_{vsource}.csv&quot;, delimiter=&quot;,&quot;, skip_header=1)[:,0] # --- Monitor Result --- for voltage in voltage_list: slice_options = {f&quot;v_{vsource.lower()}&quot;: voltage, f&quot;v_{gnd.lower()}&quot;: 0.0} # --- Charge Monitor --- attribute = &quot;n&quot; # &quot;n&quot;, &quot;p&quot; result_ddm.extract(data=&quot;ddm:charge_monitor&quot;, monitor_name=&quot;charge_monitor&quot;, savepath=f&quot;{plot_path}{attribute}/{voltage}V&quot;, target=&quot;intensity&quot;, attribute=attribute, real=True, imag=False, log=False, show=False, **slice_options, **export_options) # --- Electrical Monitor --- attribute = &quot;E&quot; # &quot;E&quot;, &quot;Ex&quot;, &quot;Ey&quot;, &quot;Ez&quot; result_ddm.extract(data=&quot;ddm:electrical_monitor&quot;, monitor_name=&quot;elec_monitor&quot;, savepath=f&quot;{plot_path}{attribute}/{voltage}V&quot;, target=&quot;intensity&quot;, attribute=attribute, real=True, imag=False, log=False, show=False, **slice_options, **export_options) # --- Band Monitor --- attribute = &quot;Ec&quot; # &quot;Ec&quot;, &quot;Ev&quot;, &quot;Efn&quot;, &quot;Efp&quot; result_ddm.extract(data=&quot;ddm:band_monitor&quot;, monitor_name=&quot;band_monitor&quot;, savepath=f&quot;{plot_path}{attribute}/{voltage}V&quot;, target=&quot;line&quot;, attribute=attribute, plot_x=&quot;y&quot;, real=True, imag=False, log=False, show=False, **slice_options, export_csv=True) # endregion return result_ddm if run_options.run else None if __name__ == &quot;__main__&quot;: simulation(run_options=RunOptions(index_preview=False, doping_preview=False, calculate_modes=False, run=True, extract=True)) 1.2.8 Calculate​ Import the np density file, which contains the carrier distribution derived from the DDM method, into the FDE model. This integration facilitates the analysis of refractive index and loss variations as a function of bias voltage at specific wavelengths. ​According to the phase change formula, we can determine that the refractive index n is a function of bias voltage, which means that we can change the refractive index of the material by adjusting the bias voltage. Δφ=2πλΔn(V)L=2πλdndVΔVL\\Delta\\varphi=\\frac{2\\pi}{\\lambda}\\Delta n(V)L\\\\=\\frac{2\\pi}{\\lambda}\\frac{dn}{dV}\\Delta VLΔφ=λ2π​Δn(V)L=λ2π​dVdn​ΔVL ​With the following formula, when the phase difference is pi: ΔVπL=ΔVΔnλ2\\Delta V_\\pi L=\\frac{\\Delta V}{\\Delta n}\\frac{\\lambda}{2}ΔVπ​L=ΔnΔV​2λ​ ​Application Library path::mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD0A_vpi.py The fundamental simulation process entails loading Python modules, retrieving the device's structural and material properties from MOD00_structure, and obtaining the DDM simulation setting from MOD02_np, while also specifying the file paths. import sys # encoding: utf-8 from maxoptics_sdk.helper import timed, with_path import os import time import sys import numpy as np current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from MOD00_structure import * from MOD02_np import simulation as ddm_simulation run_with_ddm = True # True: run ddm first, then import the np result to fde solver automatically # False: run fde only, the np file path need to be specified manually @timed @with_path def simulation(*, run_options: &quot;RunOptions&quot;, **kwargs, ): # region --- 0. General Parameter --- vsource = &quot;Cathode&quot; # electrode solid gnd = &quot;Anode&quot; # electrode solid path = kwargs[&quot;path&quot;] np_file = kwargs[&quot;np_file&quot;] simu_name = &quot;MOD0A_FDE&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) # endregion # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() The optical solver FDE can be configured in this location, allowing for the inclusion of np density file within data space. # region --- 2. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;FDE&quot;, property={&quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;x_span&quot;: x_span, &quot;y&quot;: y_mean, &quot;y_span&quot;: y_span, &quot;z&quot;: z_mean, &quot;z_span&quot;: z_span, }, &quot;boundary_conditions&quot;: {&quot;y_min_bc&quot;: &quot;PEC&quot;, &quot;y_max_bc&quot;: &quot;PEC&quot;, &quot;z_min_bc&quot;: &quot;PEC&quot;, &quot;z_max_bc&quot;: &quot;PEC&quot;,}, # 'mode_removal': {'threshold': 0.02}, # default is '2d_x_normal' ['2d_x_normal','2d_y_normal','2d_z_normal'] 'general': {'solver_type': '2d_x_normal'}, &quot;mesh_settings&quot;: {&quot;mesh_refinement&quot;: {&quot;mesh_refinement&quot;: &quot;curve_mesh&quot;}, &quot;mesh_factor&quot;: 1.2, &quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: ogrid_global_y, &quot;dz&quot;: ogrid_global_z, }, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }}) # endregion # region --- 3. Simulation settings --- add_fde_settings(pj, run_options) ds = pj.DataSpace() ds.import_data(name=&quot;np&quot;, type=&quot;np_density&quot;, property={&quot;path&quot;: np_file}) attr = pj.Attribute() attr.add(name=&quot;np&quot;, type=&quot;np_density&quot;, property={ &quot;data&quot;: ds[&quot;np&quot;], &quot;index&quot;: {f&quot;V_{vsource}&quot;: kwargs[f&quot;V_{vsource}_index&quot;], f&quot;V_{gnd}&quot;: 0} }) # endregion Run FDE solver and add the analysis to calculate the change of effective refractive index and optical loss under specific wavelength. # region --- 4. Run --- simu_res = simu[simu_name].run() # --- Analysis --- analysis = pj.Analysis() analysis.add(name=&quot;fde_analysis&quot;, type=&quot;FDEAnalysis&quot;, property={&quot;workflow_id&quot;: simu_res.workflow_id, &quot;simulation_name&quot;: &quot;FDE&quot;, &quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: run_options.run, &quot;mesh_structure&quot;: run_options.index_preview, &quot;wavelength&quot;: wavelength, &quot;wavelength_offset&quot;: 0.0001, &quot;number_of_trial_modes&quot;: 5, &quot;search&quot;: &quot;max_index&quot;, # ['near_n','max_index'] # &quot;n&quot;: 1, &quot;calculate_group_index&quot;: False, &quot;bent_waveguide&quot;: {&quot;bent_waveguide&quot;: False, &quot;radius&quot;: 1, &quot;orientation&quot;: 0, &quot;location&quot;: &quot;simulation_center&quot;} }}) result_fde = analysis[&quot;fde_analysis&quot;].run() # endregion ​This section of the program is dedicated to calculating the parameters VpiL and VpiLoss. ​You should first extract the parameters for transmission loss and the real part of effective refractive index. ​The filename 01_neff.csv is automatically generated for the n-V data file. The initial 0 indicates the electrode number, which changes when extracting current from different electrodes. Therefore, iterate from 0 to 9 to locate the saved n-V data files. # region --- 5. Extract --- export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} if run_options.extract: if run_options.index_preview: result_fde.extract( data=&quot;mesh_structure&quot;, savepath=f&quot;{plot_path}01_index&quot;, export_csv=True) if run_options.run: res = result_fde.extract( data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}02_neff_table&quot;, export_csv=True) # print(res.to_string(index=True)) # for m in range(len(res)): # result_fde.extract(data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}03_mode{m}&quot;, # attribute=&quot;E&quot;, mode=m, real=True, imag=True, **export_options, show=False) return res # endregion return None if __name__ == &quot;__main__&quot;: simu_name=&quot;MOD0A_vpi&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) plot_folder = os.path.join(current_dir, &quot;plots&quot;, f&quot;{simu_name}_{time_str}&quot;) if not os.path.exists(plot_folder): os.makedirs(plot_folder) if run_with_ddm: result_ddm = ddm_simulation(run_options=RunOptions(run=True)) result_ddm.save_as(data=&quot;ddm:charge_monitor&quot;, monitor_name=&quot;charge_monitor&quot;, savepath=f&quot;{plot_folder}/charge&quot;) np_density_file = f&quot;{plot_folder}/charge.cdat&quot; else: np_density_file = os.path.join(os.path.dirname(__file__), &quot;MOD02_np.cdat&quot;) voltage_list = np.linspace(-0.5, 4, 10) neff = [] loss = [] for index in range(len(voltage_list)): res = simulation(run_options=RunOptions(run=True, extract=True), V_Cathode_index=index, np_file=np_density_file) neff.append(res[&quot;neff_real&quot;][0]) loss.append(res[&quot;loss_dBpcm&quot;][0]) ​Generate the relationship curve and data file for the product of half-wave voltage and effective modulation length (VpiL), the product of half-wave voltage and loss (VpiLoss), as well as VBias, and save them in the respective newly created files. vpil = [] volt_out = [] vpiloss = [] for i in range(1, len(voltage_list)-1): volt_out.append(voltage_list[i]) vpil.append((voltage_list[i+1]-voltage_list[i-1])/(neff[i+1]-neff[i-1])*wavelength/2*1e-4) vpiloss.append(vpil[-1]*loss[i]) neff_file = os.path.join(plot_folder, &quot;01_neff.csv&quot;) loss_file = os.path.join(plot_folder, &quot;02_loss.csv&quot;) vpil_file = os.path.join(plot_folder, &quot;03_vpil.csv&quot;) vpiloss_file = os.path.join(plot_folder, &quot;04_vpiloss.csv&quot;) ​You can use the following program to set up the title and style of the picture. np.savetxt(neff_file, np.array((voltage_list, neff)).T, fmt='%f,%.15f', header='voltage,neff') np.savetxt(loss_file, np.array((voltage_list, loss)).T, fmt='%f,%.15f', header='voltage,loss') np.savetxt(vpil_file, np.array((volt_out, vpil)).T, fmt='%f,%.15f', header='voltage,VpiL') np.savetxt(vpiloss_file, np.array((volt_out, vpiloss)).T, fmt='%f,%.15f', header='voltage,VpiLoss') 1.3 Output Result​ ​Application Library path: :mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD0A_vpi_local_time 1.3.1 Loss​ ​This section displays the variation of losses with bias voltage. 1.3.2 Effective Index​ ​These graphs depict the real and imaginary components of the refractive index as a function of bias voltage. Reffective index real\tReffective index imaginary 1.3.3 Modulation efficiency​ ​ These graphs illustrate the relationship between two parameters that represent modulation efficiency as a function of bias voltage. VpiL\tVpiLoss 2. Capacitance And Resistance​ ​Capacitance and resistance play crucial roles in determining the performance of devices. Optimal capacitance values enable the modulator to selectively allow or block signals within specific frequency ranges, facilitating signal coupling. Suitable resistance values enable adjustment of signal amplitude and modulation current determination. ​Application Library path: :mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD0B_RC.py 2.1 Basic Operations​ ​The simulation program for calculating capacitance and voltage exhibits numerous similarities to the program used for investigating modulation efficiency. Prior to conducting the simulation, it is necessary to import the module in order to invoke the structures and physical models defined in the MOD00_structure.py . 2.2 Code Description​ 2.2.1 Import Modules​ ​The necessary Python modules for the program are invoked within the process. import sys # encoding: utf-8 from maxoptics_sdk.helper import timed, with_path import os import time import sys import numpy as np current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from MOD00_structure import * 2.2.2 Define Parameters​ ​The voltages to be applied to the electrodes of the device are specified. @timed @with_path def simulation(*, run_options: &quot;RunOptions&quot;, **kwargs, ): # region --- 0. General Parameter --- vsource = &quot;Cathode&quot; # electrode solid gnd = &quot;Anode&quot; # electrode solid sweep_vstart = -0.5 sweep_vstop = 4 sweep_vstep = 0.5 ssac_amplitude = 0.001 2.2.3 Set Path​ ​You can use the time module for file naming conventions and then store the files in the plot_path folder. path = kwargs[&quot;path&quot;] simu_name = &quot;MOD01_RC&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_local_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) 2.2.4 Set Simulation​ ​You can add a solver for the simulation and define its properties. Furthermore, the properties of the AC small-signal module are defined in this section. The frequency interval is logarithmically defined, specifying the initial frequency, final frequency, and the number of frequencies. The variable ssac_amplitude&quot; represents the amplitude of the small signal. In this instance, three frequency values (1, 100, and 10000 MHz) are selected from the range of 1e6 to 1e10. # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion # region --- 2. Structure --- create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() # endregion # region --- 3. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;DDM&quot;, property={ &quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;general&quot;: {&quot;solver_mode&quot;: &quot;ssac&quot;, &quot;norm_length&quot;: normal_length, &quot;temperature_dependence&quot;: &quot;isothermal&quot;, &quot;temperature&quot;: temperature, &quot;perturbation_amplitude&quot;: ssac_amplitude, &quot;frequency_spacing&quot;: &quot;log&quot;, &quot;log_start_frequency&quot;: 1e6, &quot;log_stop_frequency&quot;: 1e10, &quot;number_of_points&quot;: 3 }, &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: oe_y_max, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;mesh_settings&quot;: {&quot;mesh_size&quot;: egrid_global}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;newton&quot;, &quot;linear_solver&quot;: &quot;mumps&quot;, &quot;fermi_statistics&quot;: &quot;disabled&quot;, # or &quot;enabled&quot; &quot;damping&quot;: &quot;potential&quot;, # or &quot;none&quot; &quot;potential_update&quot;: 1.0, &quot;max_iterations&quot;: 15, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e5, &quot;divergence_factor&quot;: 1e25 } }) # endregion 2.2.5 Create Component​ ​You can directly invoke the engineering function and device structure created in the MOD00_structure.py file, and then add the electrodes and their attributes. In this case, a bias voltage ranging from -0.5 V to 4 V with a scan step of 0.5 V is applied to the cathode electrode during small-signal simulation. # region --- 4. Simulation settings --- add_ddm_settings(pj, run_options) bd = pj.BoundaryCondition() bd.add(name=vsource,type=&quot;electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[vsource]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: sweep_vstart, &quot;range_stop&quot;: sweep_vstop, &quot;range_step&quot;: sweep_vstep, &quot;apply_ac_small_signal&quot;: &quot;all&quot;, # &quot;envelop&quot;: &quot;uniform&quot;, } }) bd.add(name=gnd,type=&quot;electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[gnd]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, # &quot;envelop&quot;: &quot;uniform&quot;, } }) # endregion 2.2.6 Run​ ​It is recommended to include a module to execute the solver and commence the simulation. # region --- 5. Run --- if run_options.run: result_ddm = simu[simu_name].run(resources={&quot;threads&quot;: 4}) # endregion 2.2.7 Extract Parameters​ ​Firstly, the names of the folders used to store the extracted data for the real and imaginary components of the refractive index should be defined. ​Secondly, the following program can be used to define the output files for the real and imaginary parts of the refractive index, as well as the capacitance and resistance, while also specifying the data content within the files and ensuring proper attention to the frequency units. # region --- 6. Extract --- if run_options.run and run_options.extract: export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: False} # --- Frequency list --- result_ddm.extract(data=&quot;ddm:electrode_ac&quot;, electrode_name=vsource, savepath=f&quot;{plot_path}Iac_f&quot;, target=&quot;line&quot;, attribute=&quot;Iac&quot;, plot_x=f&quot;frequency&quot;, real=True, imag=False, show=False, export_csv=True) ssac_frequency_span = np.genfromtxt(f&quot;{plot_path}Iac_f.csv&quot;, skip_header=1, delimiter=',')[:,0] # --- Iac --- for i,val in enumerate(ssac_frequency_span): plot_path_f = os.path.join(plot_path, f&quot;{val/1e6:.2f}MHz&quot;) result_ddm.extract(data=&quot;ddm:electrode_ac&quot;, electrode_name=vsource, savepath=f&quot;{plot_path_f}/Iac_{vsource}_real&quot;, target=&quot;line&quot;, attribute=&quot;Iac&quot;, plot_x=f&quot;V_{vsource}&quot;, real=True, imag=False, frequency=val, show=False, export_csv=True) result_ddm.extract(data=&quot;ddm:electrode_ac&quot;, electrode_name=vsource, savepath=f&quot;{plot_path_f}/Iac_{vsource}_imag&quot;, target=&quot;line&quot;, attribute=&quot;Iac&quot;, plot_x=f&quot;V_{vsource}&quot;, real=False, imag=True, frequency=val, show=False, export_csv=True) # endregion 2.2.8 Calculate ​Finally, the column names in the previously defined data files can be set, with the first column representing voltage and the second column representing capacitance or resistance. Additionally, the axis titles and styles should be set for the output images. # region --- 7. Post Processing --- fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) for i,val in enumerate(ssac_frequency_span): plot_path_f = os.path.join(plot_path, f&quot;{val/1e6:.2f}MHz&quot;) Iac_real_data = np.genfromtxt(f&quot;{plot_path_f}/Iac_Cathode_real.csv&quot;, skip_header=1, delimiter=&quot;,&quot;) Iac_imag_data = np.genfromtxt(f&quot;{plot_path_f}/Iac_Cathode_imag.csv&quot;, skip_header=1, delimiter=&quot;,&quot;) Iac = Iac_real_data[:,1] + 1j * Iac_imag_data[:,1] Vdc = Iac_real_data[:,0] Z = ssac_amplitude/Iac R = np.abs(np.real(Z)) C = np.abs(np.imag(1/Z)/(2*np.pi*ssac_frequency_span[i]))/1e4*1e15 np.savetxt(f&quot;{plot_path_f}/resistance.csv&quot;, np.array((Vdc, R)).T, fmt='%f,%.15e', header='voltage,resistance') np.savetxt(f&quot;{plot_path_f}/capacitance.csv&quot;, np.array((Vdc, C)).T, fmt='%f,%.15e', header='voltage,capacitance') fig, ax1 = plt.subplots() fig.set_size_inches(12, 8) ax1.plot(Vdc, R, c='b', linewidth=linewidth, label=f&quot;f:{val/1e6:.2f}MHz&quot;,marker='o') ax1.set_xlabel('VBias[V]') ax1.set_ylabel('Resistance[Ohm]') ax1.legend() ax1.grid() plt.savefig(f&quot;{plot_path_f}/resistance.jpg&quot;) plt.close() fig, ax2 = plt.subplots() fig.set_size_inches(12, 8) ax2.plot(Vdc, C, c='b', linewidth=linewidth, label=f&quot;f:{val/1e6:.2f}MHz&quot;,marker='o') ax2.set_xlabel('VBias[V]') ax2.set_ylabel('Capacitance[fF/um]') ax2.legend() ax2.grid() plt.savefig(f&quot;{plot_path_f}/capacitance.jpg&quot;) plt.close() # endregion if __name__ == &quot;__main__&quot;: simulation(run_options=RunOptions(index_preview=False, doping_preview=False, calculate_modes=False, run=True, extract=True)) 2.3 Output Result​ ​Application Library path: :\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD0B_RC_local_time 2.3.1 Small Signal AC Current​ ​This section displays the variations of the real and imaginary components of the AC current with respect to bias voltage at different frequencies. 1 MHZ\t100 MHZ\t10000 MHZReal Image 2.3.2 Capacitance​ ​This section displays the variations of capacitance with respect to bias voltage at different frequencies. 1 MHZ\t100 MHZ\t10000 MHZ 2.3.3 Resistance​ ​This section displays the variations of resistance with respect to bias voltage at different frequencies. 1 MHZ\t100 MHZ\t10000 MHZ ","keywords":""},{"title":"Spot Size Converter","type":0,"sectionRef":"#","url":"/my-website/docs/examples/SDK Examples/PIC/ssc/","content":"Spot Size Converter Introduction​ The spot size converter (SSC) is an important device for connecting silicon photonic integrated chips and external optical fibers, which can couple light transmitted in silicon waveguides into the fiber at low loss. As shown in the figure, SSC has a tapered silicon waveguide with gradually thinning ends and a low refractive index waveguide covered with SiON, and the entire waveguide device is placed in a silicon dioxide environment [1]. The mode field size at the end of the tapered waveguide is similar to that of the optical fiber, so it can effectively couple light from the waveguide into the fiber. Eigenmode expansion (EME) method has great advantages in calculating long taper waveguide. By dividing multiple cells in the cross-sectional variation area, and then calculating the modes at the interface of the cells and the bidirectional transmission of the modes, the s-matrix of the taper waveguide transmission can be quickly obtained. When using length sweep, only the bidirectional transmission part needs to be calculated to obtain the S parameter of length sweep. Simulation​ 1. Code Description​ 1.1 Import Toolkit​ First, we need to import maxoptics_sdk and Python's third-party package. The import module for EME simulation as follows. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple 1.2 Define Simulation Function​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. def simulation(*, run_mode=&quot;local&quot;, wavelength=1.55, grid=0.08, number_of_modes=10, run_options: &quot;RunOptions&quot;, **kwargs): The run_mode variable parameter is used to define the location of the simulation run. The wavelength variable is defined as wavelength of the optical source. The grid variable is defined as grid size. The number_of_modes variable is used to define the number of modes of calculation. 1.3 Define Parameters​ Before starting the simulation, we can define parameters to facilitate modeling and parameterization sweep. The defined parameters as follows. # region --- 0. General Parameters --- path = kwargs[&quot;path&quot;] simu_name = &quot;EME_SSC&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/SSC.gds&quot; # endregion The path variable is used to store the path of this Python file. The simu_name variable is used to store simulation names. The time_str variable is used to store the timestamp. The project_name variable is used to store the project name. The plot_path variable is used to store the result path. The gds_file variable is used to store the file path of GDS. 1.4 Create project​ we create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name) # endregion 1.5 Add Material​ Here we demonstrate using the Material function to create material and using the add_nondispersion function to add non dispersive materials, as well as using the add_lib function to add materials from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_nondispersion(name=&quot;Si&quot;, data=[(3.476, 0)], order=2, color=&quot;#BF2C2C&quot;) mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.465, 0)], order=2, color=&quot;#D4E5FE&quot;) mt.add_nondispersion(name=&quot;SiON&quot;, data=[(1.50, 0)], order=2, color=&quot;#FBBBBB&quot;) mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) # endregion The name is used to define the name of the added material. The data is used to input the real and imaginary parts of the refractive index of the material. The order is used to set the grid order of the material. 1.6 Add Structure​ The structure is composed of silicon dioxide substrate, adiabatic tapered silicon waveguide and polymer covered waveguide. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select &quot;gds_file&quot; in type to establish the model by importing the GDS file method. The properties of GDS modeling are shown in the table below. # region --- 3. Structure --- st = pj.Structure() st.add_geometry(name=&quot;sub&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;SSC&quot;, &quot;layer_name&quot;: (1, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: -1.5, &quot;z_span&quot;: 3}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}}) st.add_geometry(name=&quot;ssc&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;SSC&quot;, &quot;layer_name&quot;: (2, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.1, &quot;z_span&quot;: 0.2}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name=&quot;cover&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;SSC&quot;, &quot;layer_name&quot;: (3, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 1.5, &quot;z_span&quot;: 3}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiON&quot;], &quot;mesh_order&quot;: 1}}) # endregion Key\tValue\ttype\tDescriptionname\tsub\tstring\tname the added geometry type\tgds_file\tstring\tselect the type of structure path\tgds_file\tstring\tfile path of GDS file cell_name\tSSC\tstring\tThe cell name of the GDS. layer_name\t(1,0)\tlist\tname of the GDS layer x 0 float center position in the x-direction of the geometric structure y\t0\tfloat\tcenter position in the y-direction of the geometric structure z\t-1.5\tfloat\tcenter position in the z-direction of the geometric structure z_span\t3\tfloat\tlength of the geometric structure in the z-direction material\tmt[&quot;Si&quot;]\tmaterial\tselect the material in Material mesh_order\t2\tinteger\tset the priority of the mesh Select simulation material by using mesh_order in areas where geometry overlaps, the higher the number of mesh_order, the higher the priority of the material. 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. The properties are shown below. # region --- 4. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;wavelength_offset&quot;: 0.0003, &quot;use_wavelength_sweep&quot;: True}, &quot;background_material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_settings&quot;: {&quot;mesh_factor&quot;: 1.2, &quot;mesh_refinement&quot;: {&quot;mesh_refinement&quot;: &quot;curve_mesh&quot;}}, &quot;geometry&quot;: {&quot;x_min&quot;: -103, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}, &quot;boundary_conditions&quot;: {&quot;y_min_bc&quot;: &quot;PEC&quot;, &quot;y_max_bc&quot;: &quot;PEC&quot;, &quot;z_min_bc&quot;: &quot;PEC&quot;, &quot;z_max_bc&quot;: &quot;PEC&quot;}, &quot;eme_setup&quot;: {&quot;cell_geometry&quot;: {&quot;allow_custom_eigensolver_settings&quot;: True, &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 200, &quot;cell_number&quot;: 30, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 3, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}} }) # endregion 1.8 Add Sub Mesh​ After light passes through tapered silicon waveguide that gradually becoming smaller, the mode field is strongly limited to a very small range. Therefore, it is necessary to use add_mesh to add a transverse grid to accurately calculate the limited light field. Add local mesh as shown below. # region --- 5. Sub Mesh --- st.add_mesh( name=&quot;sub_mesh&quot;, property={&quot;general&quot;: {&quot;dx&quot;: grid, &quot;dy&quot;: grid, &quot;dz&quot;: grid}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) # endregion The dx,dy,dz are the mesh sizes in the x, y, and z directions, respectively. 1.9 Add EME port​ You can use the port function to create a port and use the &quot;source_port&quot; property to set the location of the source port. You can use the add function to add ports and the properties of port are shown in the table below. # region --- 5. Port --- pjp = pj.Port() pjp.add(name=&quot;left_port&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;number_of_trial_modes&quot;: number_of_modes}}, &quot;modal_analysis&quot;: {&quot;mode_removal&quot;: {&quot;threshold&quot;: 0.01}} }) pjp.add(name=&quot;right_port&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;number_of_trial_modes&quot;: number_of_modes}}, &quot;modal_analysis&quot;: {&quot;mode_removal&quot;: {&quot;threshold&quot;: 0.01}} }) # endregion key\tvalue\ttype\tdescriptionname\tleft_port\tstring\tthe name of port type\teme_port\tstring\tselect type of port port_location\tleft\tstring\tselect the location of the port y\t0\tfloat\tcenter position of port width y_span\t5.5\tfloat\tport width y\t0.5\tfloat\tcenter position of port height z_span\t7\tfloat\tport height mode_selection\tfundamental_TE\tstring\tselect the mode of port number_of_trial_modes 15 integer set the number of port modes 1.10 Add Monitor​ The Monitorfunction is used to create monitor and add function is used to add a monitor. Select profile_monitor type monitor from the added monitors to view the mode field distribution. # region --- 5. Port --- pjp = pj.Port() pjp.add(name=&quot;left_port&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;number_of_trial_modes&quot;: number_of_modes}}, &quot;modal_analysis&quot;: {&quot;mode_removal&quot;: {&quot;threshold&quot;: 0.01}} }) pjp.add(name=&quot;right_port&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;number_of_trial_modes&quot;: number_of_modes}}, &quot;modal_analysis&quot;: {&quot;mode_removal&quot;: {&quot;threshold&quot;: 0.01}} }) # endregion 1.11 Add EME solver​ We use the Simulation function to create a simulation and the add function to add a solver. Select the EME solver in the type, and the properties of the solver are shown in the table below. # region --- 8. Analysis --- eme_base_res = simu[simu_name].run() analysis = pj.Analysis() analysis.add(name=&quot;eme_propagate&quot;, type=&quot;eme_analysis&quot;, property={&quot;workflow_id&quot;: eme_base_res.workflow_id, &quot;eme_propagate&quot;: run_options.run, &quot;energy_conservation&quot;:&quot;make_passive&quot;, &quot;periodicity&quot;: {&quot;periodicity&quot;: False}, &quot;group_span_sweep&quot;: {&quot;group_span_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_1&quot;, &quot;start&quot;: 50, &quot;stop&quot;: 250, &quot;number_of_points&quot;: 5}, &quot;wavelength_sweep&quot;: {&quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: 1.5, &quot;stop&quot;: 1.6, &quot;number_of_wavelength_points&quot;: 11}, # &quot;override_wavelength&quot;:{ &quot;wavelength&quot;: 1.55 } }) eme_res = analysis[&quot;eme_propagate&quot;].run() # endregion key\tvalue\ttype\tdescriptionname\tsimu_name string name of simulation type\tEME\tstring\tselect the type of solver wavelength\t1.5\tfloat\twavelength of mode use_wavelength_sweep\tTrue\tbool\tselect to enable wavelength sweep span\t2\tfloat\tthe span of cell group cell_number\t1\tfloat\tnumber of cell in the cell group number_of_modes\t15\tfloat\tCalculate the number of modes per cell sc\tnone\tstring\tselect to enable subcell method dy\t0.05\tfloat\thorizontal mesh of cross-section dz\t0.05\tfloat\tLongitudinal mesh of cross-section eme _propagate\tTrue\tbool\tselect to enable EME propagation propagation_sweep True\tbool\tselect to enable length sweep parameter\tgrop_span_3\tstring\tthe area of length sweep start\t50\tfloat\tstarting length of sweep stop\t250\tfloat\tstoping length of sweep number_of_points\t50\tfloat\tnumber of sweep lengths phase\t0\tfloat\tthe initial phase of optical source select_mode\tTE\tstring\tmode of optical source According to different geometric structures and materials, the SSC is divided into four cell groups using cell_group_definition. Set the length of the cell group in span, use cell_number to set the number of cell. The divided cell structure is shown in the following figure. Use number_of_modes to set the number of modes calculated at the interface of adjacent cells, and it is necessary to set a sufficient number of modes to obtain the correct results. In the area where the cross-sectional area of cells remains unchanged, the number of cell_number is set to 1, and sc is set to &quot;none&quot;; In the area of structural changes, multiple cell number need to be used to characterize the structure and the &quot;sub_cell&quot; method is used to reduce the staircase effect caused by discrete changes of the cross-section. 1.12 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=plot_path + simu_name, simulation_name=simu_name, celldisplay=True, xyratio=(1, 40)) #simu[simu_name].show3d() # endregion The celldisplay control whether to display the boundaries of the divided cells. The xyration controls the aspect ratio of the image. 1.13 Calculate Mode​ You can create a new simulation using simu.add function and run the simulation using simu.run function. The type of simulation needs to be selected as &quot;mode_selection:user_select&quot;, and its properties are shown in the table below. Before running EME simulation calculations, we can calculate the mode field distribution of the port by setting the type of mode selection to True and other simulations to False. # region --- 10. Calculate Mode --- if run_options.calculate_modes: for port in [&quot;left_port&quot;, &quot;right_port&quot;]: simu[simu_name].preview_modes(port_name=port, data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}02_modeprofile_fdeonly_{port}&quot;, attribute=&quot;E&quot;, mode=0) simu[simu_name].preview_modes(port_name=port, data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}02_Preview_{port}_neff&quot;, show=False, export_csv=True) # endregion key\tValue\tType\tDescriptionmesh_structure\tTrue\tbool\tselect to view the refractive index distribution of the port calculate_modes True bool select to calculate the mode of cross-section Wavelength\twavelength\tfloat\tcalculate the wavelength of the mode number_of_trial_modes\tnumber_of_modes\tfloat\tnumber of calculation modes search\t&quot;max_index&quot;\tfloat\tmethod of calculating mode calculate_group_index\tTrue\tbool\tselect to calculate group refractive index bent_waveguide\tFalse\tbool\tselect to enable bent waveguide in calculation mode radius\t1\tfloat\tset the radius of the bent waveguide orientation\t0\tfloat\tset the bending direction of the waveguide location\t&quot;simulation_center&quot;\tstring\tset the position of the bent waveguide 1.14 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation, and assign the result to eme_res. # region --- 11. Run --- eme_base_res = simu[simu_name].run() analysis = pj.Analysis() analysis.add(name=&quot;eme_propagate&quot;, type=&quot;eme_analysis&quot;, property={&quot;workflow_id&quot;: eme_base_res.workflow_id, &quot;eme_propagate&quot;: run_options.run, &quot;energy_conservation&quot;:&quot;make_passive&quot;, &quot;periodicity&quot;: {&quot;periodicity&quot;: False}, &quot;group_span_sweep&quot;: {&quot;group_span_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_1&quot;, &quot;start&quot;: 50, &quot;stop&quot;: 250, &quot;number_of_points&quot;: 5}, &quot;wavelength_sweep&quot;: {&quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: 1.5, &quot;stop&quot;: 1.6, &quot;number_of_wavelength_points&quot;: 11}, # &quot;override_wavelength&quot;:{ &quot;wavelength&quot;: 1.55 } }) eme_res = analysis[&quot;eme_propagate&quot;].run() # endregion 1.15 Run and Extract Results​ Extract data using extract, where data is the calculated result data, savepath is the storage path, target is the classification of the data, and monitor_name is the name of the monitor. # region --- 12. see result --- eme_res.extract(data=&quot;eme_propagate:facet_data&quot;, savepath=plot_path, real=True, imag=True, export_csv=True) eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) eme_res.extract( data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_y_normal&quot;, monitor_name=&quot;y_normal&quot;, attribute=&quot;E&quot;, export_csv=True) eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;014_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True) for i in range(3): eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;0&quot;+str(15+i)+&quot;_eme_section&quot;+str(i+1), monitor_name=&quot;section&quot;+str(i+1), attribute=&quot;E&quot;, export_csv=True) # --- EME Propagation Sweep Results --- if run_options.run_length_sweep: eme_res.extract(data=&quot;propagation_sweep:sweep&quot;, savepath=plot_path + &quot;10_length_sweep&quot;, export_csv=True) # endregion The &quot;eme_propagate:facet_data&quot; stores the calculation mode of cells and ports and the total S-matrix. The &quot;eme_propagate:smatrix&quot; stores the S-matrix after bidirectional transmission of the calculation port mode. The &quot;propagation_sweep:sweep&quot; stores the S-matrix corresponding to each length after sweeping. 1.16 Control Switch​ We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code. class RunOptions(NamedTuple): calculate_modes: bool run: bool run_length_sweep: bool extract: bool if __name__ == &quot;__main__&quot;: simulation(run_mode=&quot;local&quot;, wavelength=1.5, grid=0.02, number_of_modes=20, run_options=RunOptions(calculate_modes=True, run=True, run_length_sweep=True, extract=True)) 2 Output Results​ 2.1 ModeProfile​ We extracted the first two modes of the input port, and the mode field distribution as following figure. After the propagation calculation is completed, the extracted results can be viewed in the storage path, and the extraction of the results can only be set before the program running. The mode fields of TE polarization at the input and output ends are shown below, it is clearly observed that the output mode field size is larger than the input. Silicon waveguides have a strong ability to limit the light field, but it can leak into the environment when the waveguide size is too small. By adding a low refractive index waveguide outside the taper waveguide, the leaked light field is limited and the size of the mode spot is increased. 2.2 EME Propagation​ The EME solver first calculates the mode of the cell boundary cross-section, and then obtains the scattering matrix for each cross-section by matching the tangential electric and magnetic fields. After bidirectional transmission of the scattering matrix for each cross-section, the S-matrix of the entire device can be obtained. To ensure the accuracy of the calculation results, the number of calculated modes in the cross-section can be gradually increased until the results converge. After bidirectional transmission calculation of mode, the electric field distribution in the transmission direction can be constructed. The distribution of the electric field is shown in the following figure. The EME propagation calculation all modes, but only returns the S-matrix of the port mode. As shown in the figure below, the S-matrix is a 2∙2 matrix, where S21 represents the absolute value of the transmission coefficient from port 1 input to port 2 output. Due to the symmetry of the transmission behavior, S12=S21. Analysis and Discuss​ When calculating the area of structural change in EME, it is necessary to divide the structure into multiple cells, and the calculated modes are located at interface between adjacent cells. The more cells divided, the more accurate the characterization of the structure. In the adiabatic tapered waveguide region, the number of cells divided is too small, and the calculated cross-section area varies greatly, resulting in a strong staircase effect. Therefore, before calculating EME, it is necessary to divide the structure into enough cells to ensure the accuracy of the results. It should be noted that when calculating the EME transmission of taper waveguide, we need to use the &quot;sub_cell&quot; method, which can reduce the non physical reflection caused by the step change of the unit cross-section. Within the range of input and output straight waveguides, the cross-section of the waveguide remains unchanged, and the &quot;none&quot; method is used to calculate the transmission. In order to meet the adiabatic condition, we set &quot;run_length_sweep&quot; to True and conducted a length sweep of 50-250 um in the tapered silicon waveguide area. The number of cells divided in the region where the silicon waveguide changes is 50. As shown in the following figure. When the sweeping length is greater than 100 um, the transmission coefficient S21 will fluctuate with the increase of length. When we increase the number of tapered silicon waveguide to 150, the transmission coefficient curve between the sweeping length of 50-250 um becomes smooth. Therefore, in addition to ensuring the number of modes in the unit cross-section, the EME simulation should also have sufficient number of cells. If you need to sweep the wavelength, you can use &quot;wavelength_sweep&quot; to turn on wavelength sweep. Similar to length sweep, it is necessary to input the starting and ending wavelength and the number of wavelength points in the EME simulation. At each frequency point, the modes of all cell interfaces and EME propagation parts are also calculated. Therefore, wavelength sweep will take longer than length sweep. References​ [1] T. Tsuchizawa et al, “Microphotonics devices based on silicon microfabrication technology”, IEEE J. Select. Topics Quantum Electron. 11, 2005, 232-240","keywords":""},{"title":"Y branch","type":0,"sectionRef":"#","url":"/my-website/docs/examples/SDK Examples/PIC/ybranch/","content":"Y branch Introduction​ The Y branch is a fundamental component of integrated optics. Its primary function is to split the incoming light from a single input waveguide into two separate waveguides (splitter). Likewise, it can also combine light from two waveguides into a single waveguide (combiner). The main performance parameters of the Y branch include insertion loss, device dimensions, and operating bandwidth. Simulation Methods​ Through the FDTD module or EME module, the Y branch's structure can be optimized to obtain the transmittance of fundamental mode or S-parameters of each output port. This allows the verification of the optimized results for the multi-mode interferometer.This optimization process aims to improve the Y branch's insertion loss and bandwidth performance. Y branch(FDTD module)​ 1. Basic Operations​ 1.1 Import File​ Once you have installed and configured the environment, import the python code and the GDS layout. The example library and related model code are usually located in the directory :examples/func_demo. The GDS file is generally imported into the path :examples/examples_gds 1.2 SDK Initialization​ Create a new terminal and run the code after you import the python script and GDS file. Max-Optics SDK may take some time to connect the service. 2.Code Description​ Now let's learn the meaning of functions and parameters that correspond to the code. 2.1 import Modules​ To begin, we need to use the import command to call the relevant functional modules. For instance, we import the typing , os and time module in python. At the same time ,we import the customized module maxoptics_sdk.all and maxoptics_sdk.helper. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time import json from typing import NamedTuple The maxoptics_sdk package provides all in one optical simulation with Python. The os module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands. The time module provides various functions to work with time-related operations and to measure time intervals. The typing module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. 2.2 Define Simulation​ Firstly, We define parameters and give them a default value, such as the simulation wavelength and number of modes. Note that we can override this value in the following code. @timed @with_path def simulation( *, wavelength=1.575, grids_per_lambda=25, run_options: 'RunOptions', **kwargs ): The provided code contains comments that define the simulation parameters. Let's explain each of these parameters. The function simulation is used to define the simulation parameters for the program. The wavelength parameter specifies the wavelength of the input light in micrometers. The grids_per_lambda parameter sets the simulation mesh grid. The **kwargs is a special syntax used in function definitions to accept an arbitrary number of keyword arguments as a dictionary. 2.3 Define Parameters​ Define commonly used parameters in region 0, such as the mesh grid of the simulation boundary, the start time of the simulation, the path and name for the simulation output, the path to the imported GDS layout, and other parameters required for structural parameterized modeling. If you need to calculate the bandwith of the device in the EME simulation, you can also decide the wavelength for sweeping in this section. # region --- 0. General Parameters -- waveform_name = f'wv{wavelength * 1e3}' path = kwargs['path'] simu_name = 'FDTD_y_branch' time_str = time.strftime('%Y%m%d_%H%M%S', time.localtime()) project_name = f'{simu_name}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + '/examples_gds/ybranch.gds' # endregion The code defines several parameters and variables necessary for the simulation process. The waveform_name parameter is the name of waveform. The path variable defines the file path for the simulation, while simu_name specifies the name of the simulation file. The time_str variable is used to obtain the current time as a timestamp for the simulation. The project_name variable assigns a name to the project for the simulation output. The plot_path variable determines the directory where the simulation result plots will be saved. The gds_file_root_path and gds_file variable defines the path for importing the GDS layout. 2.4 Creat Project​ You can create a new project using the Project function of Max's software development toolkit in region 1. # region --- 1. Project --- pj = mo.Project(name=project_name) # endregion 2.5 Define Materials​ Let's proceed to the next step, where we set up the materials required for the simulation in region 2. In this case, we will directly use relevant materials from the MO material library. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) mt.add_lib(name='SiO2', data=mo.Material.SiO2_Palik, order=2) mt.add_lib(name='Air', data=mo.Material.Air, order=2) # endregion The add_lib contains three parameters name,data and order. The data calls up the property of simulation materials in the MO material library. The Order parameter determines the mesh order for the material during the simulation. 2.6 Waveform​ In this section, we will define the property of wave. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.15) wv_struct = wv[waveform_name] # endregion 2.7 Create Model​ Next, we will create the structure of Y branch. # region --- 4. Structure --- st = pj.Structure() st.add_geometry(name='in', type='Rectangle', property={'geometry': {'x': -1.5, 'x_span': 1, 'y': 0, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name=&quot;gds_file&quot;, type=&quot;gds_file&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 1, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22}, &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;splitter1&quot;, &quot;layer_name&quot;: (0, 0)}}) st.add_geometry(name='out_up', type='Rectangle', property={'geometry': {'x': 3.1, 'x_span': 0.2, 'y': 0.35, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name='out_down', type='Rectangle', property={'geometry': {'x': 3.1, 'x_span': 0.2, 'y': -0.35, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name=&quot;waveguide_up&quot;, type=&quot;BezierWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22, &quot;width&quot;: 0.5, &quot;control_points&quot;: [{&quot;x&quot;: 3.2, &quot;y&quot;: 0.35}, {&quot;x&quot;: 4, &quot;y&quot;: 0.35}, {&quot;x&quot;: 4, &quot;y&quot;: 0.85},{&quot;x&quot;: 5.2, &quot;y&quot;: 0.85}] }}) st.add_geometry(name=&quot;waveguide_down&quot;, type=&quot;BezierWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22, &quot;width&quot;: 0.5, &quot;control_points&quot;: [{&quot;x&quot;: 3.2, &quot;y&quot;: -0.35}, {&quot;x&quot;: 4, &quot;y&quot;: -0.35}, {&quot;x&quot;: 4, &quot;y&quot;: -0.85},{&quot;x&quot;: 5.2, &quot;y&quot;:-0.85}] }}) st.add_geometry(name='wg_up', type='Rectangle', property={'geometry': {'x': 5.4, 'x_span': 0.8, 'y': 0.85, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) st.add_geometry(name='wg_down', type='Rectangle', property={'geometry': {'x': 5.4, 'x_span': 0.8, 'y': -0.85, 'y_span': 0.5, 'z': 0, 'z_span': 0.22}, 'material': {'material': mt['Si'], 'mesh_order': 2}}) # endregion We import the core of Y branch from the GDS file when other part is created by MO add_geometry function. The name parameter defines the structure name. The type parameter specifies the structure type. The path, cell_name, and layer_name parameters point to the GDS file and specify the relevant layers and cell names used in the layout. The geometry parameter sets the structure's coordinates. The material parameter specifies the material properties The mesh_order parameter sets the mesh order for the simulation. 2.8 Simulation​ After establishing the model, we can add the simulation in region 5 and define the simulation boundary conditions. This involves specifying the geometry of the simulation region, the boundary conditions in the xyz directions, and the other detailed parameters. # region --- 5. Simulation --- bc = { &quot;pml_layer&quot;: 6, &quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 0.8, &quot;pml_polynomial&quot;: 3, &quot;pml_alpha&quot;: 0, &quot;pml_alpha_polynomial&quot;: 1, } simu = pj.Simulation() simu.add( name=simu_name, type=&quot;FDTD&quot;, property={ &quot;background_material&quot;: mt[&quot;SiO2&quot;], &quot;geometry&quot;: { &quot;x&quot;: 2, &quot;x_span&quot;: 7, &quot;y&quot;: 0, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 3, }, &quot;boundary_conditions&quot;: { &quot;x_min_bc&quot;: &quot;PML&quot;, &quot;x_max_bc&quot;: &quot;PML&quot;, &quot;y_min_bc&quot;: &quot;anti_symmetric&quot;, &quot;y_max_bc&quot;: &quot;PML&quot;, &quot;z_min_bc&quot;: &quot;PML&quot;, &quot;z_max_bc&quot;: &quot;PML&quot;, &quot;pml_settings&quot;: { &quot;x_min_pml&quot;: bc, &quot;x_max_pml&quot;: bc, &quot;y_min_pml&quot;: bc, &quot;y_max_pml&quot;: bc, &quot;z_min_pml&quot;: bc, &quot;z_max_pml&quot;: bc, }, }, &quot;general&quot;: { &quot;simulation_time&quot;: 10000, }, &quot;mesh_settings&quot;: { &quot;mesh_factor&quot;: 1.2, &quot;mesh_type&quot;: &quot;auto_non_uniform&quot;, &quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: grids_per_lambda}, &quot;minimum_mesh_step_settings&quot;: {&quot;min_mesh_step&quot;: 1e-4}, &quot;mesh_refinement&quot;: { &quot;mesh_refinement&quot;: &quot;curve_mesh&quot;, } }, # 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-4, 'down_sample_time': 200}}, # 'thread_setting': {'thread': 4} }, ) # endregion The Simulation manager is critical for setting up and running simulations in the current project. The name parameter allows users to assign a unique name to the simulation for identification purposes. The type parameter defines the type of the simulation. The simulation_time parameter specifies the duration of the simulation. The mesh_settings parameter enables users to configure various settings related to the simulation mesh. The mesh_accuracy parameter controls the precision of the mesh used in the simulation. The cells_per_wavelength parameter determines the wavelength precision used in the simulation. The minimum_mesh_step_settings parameter sets the minimum mesh step, allowing users to define the smallest allowable size for mesh elements. Users can tailor the simulation setup to meet their requirements by utilizing these input parameters, enabling accurate and efficient electromagnetic simulations of complex optical structures. 2.9 Source​ Then we need to establish the light source in the input waveguide, as shown in Region 6. # region --- 6. ModeSource --- src = pj.Source() src.add( name='source', type='mode_source', property={ 'general': { 'mode_selection': 'fundamental', 'waveform': {'waveform_id_select': wv_struct}, &quot;inject_axis&quot;: &quot;x&quot;, &quot;direction&quot;: &quot;forward&quot;, }, 'geometry': { 'x': -1.2, 'x_span': 0, 'y': 0, 'y_span': 1, 'z': 0, 'z_span':1.2, } } ) # endregion The Source function is utilized to retrieve the source manager for the current project. The type parameter specifies the type of the source and is formatted as either [&quot;mode_source&quot;] or [&quot;gaussian_source&quot;]. The name parameter represents the name assigned to the source. The inject_axis parameter defines the axis of the source. The property parameter allows for defining specific properties associated with the source. 2.10 Monitor​ In Region 7, we set up the monitors. # region --- 7. Monitor --- mn = pj.Monitor() mn.add( name='Global Option', type='global_option', property={ 'frequency_power': { # 'sample_spacing': 'uniform', 'use_wavelength_spacing': True, # ['min_max','center_span'] 'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.15, 'frequency_points': 100 }}) mn.add(name='monitor_out', type='power_monitor', property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.15,'frequency_points': 200},}, 'geometry': {'monitor_type': '2d_x_normal', 'x': 5.4, 'x_span': 0, 'y': 0.85, 'y_span': 1.2, 'z': 0, 'z_span': 1.2}}) mn.add(name='filed_power', type='power_monitor', property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.15, 'frequency_points': 100}, }, 'geometry': {'monitor_type': '2d_z_normal', 'x': 2, 'x_span': 7, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 0}}) # endregion For the global monitor, the Monitor function is utilized to retrieve the monitor manager for the current project, which allows users to access and manage various types of monitors used during simulation. The name parameter represents the name of the Global Option associated with the monitor. The type parameter defines the type of the Global Option and is formatted as a list containing one of several monitor types. The property parameter is used to define and set the relevant parameters specific to the chosen monitor type. These parameters control the monitor's behavior and data collection settings during the simulation. The power monitor is a configuration setting that allows users to specify various simulation parameters. The name parameter assigns a name to the power monitor. The type parameter defines the type of power monitor. The general parameter pertains to settings related to the frequency domain and frequency-dependent behaviors of the simulation. The geometry parameter is used to define the geometric characteristics of the simulated structure. 2.11 Run​ In the region 8 ,we can recall the simulation name to run it.we run the simulation. We support users to calculate the simulation with GPU by resources to improve the simulation efficiency. # region --- 8. Run --- if run_options.run: fdtd_res = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0},{&quot;id&quot;: 1},{&quot;id&quot;: 2},{&quot;id&quot;: 3}]} ) # endregion 2.12 Extract Results​ In region 9, we can retrieve and store the simulation results. # region --- 10. See Results --- if run_options.extract and run_options.run: fdtd_res.extract( data='fdtd:power_monitor', savepath=f'{plot_path}02_x_normal_abs(T)', monitor_name='x_normal', attribute='T', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, show=False ) fdtd_res.extract( data='fdtd:power_monitor', savepath=f'{plot_path}02_y_normal_abs(T)', monitor_name='y_normal', attribute='T', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, show=False ) fdtd_res.extract( data='fdtd:power_monitor', savepath=f'{plot_path}02_y_normal_E_{wavelength}_um', monitor_name='y_normal', target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=False, wavelength=f&quot;{wavelength}&quot;, plot_x=&quot;x&quot;, plot_y=&quot;z&quot;, show=False, export_csv=True, ) # endregion return fdtd_res if run_options.run else None # endregion The extract function allows you to extract specific simulation results and store them for further analysis. The data parameter is to decide what type/field data will be extracted. The savepath parameter specifies the save path of picture. The monitor_name parameter specifies the name of monitor which provides the data needed. The attribute parameter specifies which attribute will extracted. The plot_x parameter specifies the data of x axis. The export_csv parameter is to decide whether to export a csv. Default as False. 2.16 Switches​ In this section of the code, the simulation function is called and executed, which allows you to reset relevant parameters for more convenient parameter scanning and optimization design. We also support control switches for various functionalities at the end of the code, and you can use configuration flags(True or False). These flags can be used to turn specific functionalities on or off, making it easier to check the model and perform efficient calculations. class RunOptions(NamedTuple): run: bool extract: bool if __name__ == '__main__': simulation(is_gds_import=True, wavelength=1.55, grids_per_lambda=8, run_options=RunOptions(run=True, extract=True)) By turning on/off the relevant functionalities, you can control the simulation process and obtain the desired results. 3.Output Results​ 1.The electric intensity profile of the input fundamental TE mode and the transimission at different wavelengths. 2.The z-normal E intensity of Y branch structure. Above all,the insert loss of this Y branch device is about 0.628 dB at 1.55 micrometer wavelength. Supplement​ To view a function's definition and supported parameters or a parameter dictionary, you can right-click on its name and select &quot;Go to Definition&quot; or press &quot;Ctrl&quot; while left-clicking on its name to view its definition, showing the available parameters and their descriptions. And you can also to find the detailed explaination : SDK Code","keywords":""},{"title":"Photodetector","type":0,"sectionRef":"#","url":"/my-website/docs/examples/SDK Examples/Active_Device/Photodetector","content":"Photodetector This example introduces the modeling and optoelectronic simulation of a vertical Ge-Si photodetector. 1. Overview​ This example utilizes FDTD simulation to obtain the optical field distribution in the Ge absorption layer. Subsequently, the photo-induced carrier generation rate is calculated based on the optical field, which is then imported into the OEDevice simulation to obtain the photo current. We also provide scripts for dark current, capacitance and resistance, frequency response, and saturation power. These simulations are divided into separate scripts, and they all call a unified script for modeling and material setup, making it convenient for modifications and management. 2. Modeling​ The modeling is completed by a callable function in the script file VPD00_structure.py. 2.1 Import simulation toolkit​ First, import maxoptics_sdk and other packages. [1] import sys # encoding: utf-8 from moapi.v3.aggregate import AggregatedUIService as Project import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple import sys current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from VPD_material_Si import elec_Si_properties from VPD_material_Ge import elec_Ge_properties The script file VPD_material.py stores some modified electronic parameters of the materials, which are referenced to override default parameters in the modeling script. 2.2 Set general parameters​ Set some general parameters before modeling. At the beginning are those that need frequent modification during testing and optimization. [2] # region --- 0. General Parameters --- wavelength_center = 1.55 # um wavelength_span = 0.1 # um temperature = 298.15 # K normal_length = 20 # um Ge_SiO2_recombination_velocity = 225000 # cm/s run_mode = &quot;local&quot; simu_name = &quot;VPD02_Id&quot; Wavelength, temperature, the mesh grid size and some other parameters are defined above. They will be detailed in the subsequent settings. [3] # --- structure geometry --- SiO2_x_center = 0 SiO2_x_span = 100 SiO2_y_center = 0 SiO2_y_span = 20 SiO2_z_center = 0 SiO2_z_span = 10 input_wg_x_center = -42.5 input_wg_length = 5 input_wg_width = 0.5 Si_z_span = 0.22 Si_y_center = 0 taper_x_min = input_wg_x_center+input_wg_length/2 taper_length = 40 taper_width = 4 Si_slab_length = 22 Si_slab_x_center = taper_x_min+taper_length+Si_slab_length/2 Si_slab_width = 20 Ge_x_center = 10.75 Ge_x_span_bottom = 20 Ge_x_span_top = 19.5 Ge_y_span_bottom = 4 Ge_y_span_top = 3 Ge_z_span = 0.5 Ge_z_center = Si_z_span+Ge_z_span/2 anode_x_center = 10.75 anode_x_span = 19 anode_y_center = 3.7 anode_y_span_top = 2 anode_y_span_bottom = 2 anode_z_span = 1.37 anode_z_center = Si_z_span+anode_z_span/2 cathode_x_center = 10.75 cathode_x_span = 19 cathode_y_center = 0 cathode_y_span_top = 2.2 cathode_y_span_bottom = 2.2 cathode_z_span = 1 cathode_z_center = Si_z_span+Ge_z_span+cathode_z_span/2 These are geometric parameters of the structures. [4] # --- electrical simulation boundary --- oe_x_min = 10 oe_x_max = 10 oe_x_mean = 0.5*(oe_x_min+oe_x_max) oe_x_span = oe_x_max-oe_x_min oe_y_min = 0 oe_y_max = 3.7 oe_y_mean = 0.5*(oe_y_min+oe_y_max) oe_y_span = oe_y_max-oe_y_min oe_z_min = -0.15 oe_z_max = 1.25 oe_z_mean = 0.5*(oe_z_min+oe_z_max) oe_z_span = oe_z_max-oe_z_min These are geometric parameters of the electrical simulation region. [5] # --- doping parameters --- p_uniform_x_center = 10.75 p_uniform_x_span = 22.5 p_uniform_y_center = 0 p_uniform_y_span = 15 p_uniform_z_center = Si_z_span/2 p_uniform_z_span = Si_z_span p_uniform_con = 1e15 p_well_x_center = 10.75 p_well_x_span = 22.5 p_well_y_center = 0 p_well_y_span = 15 p_well_z_center = -0.035 p_well_z_span = 0.53 p_well_junction_width = 0.05 p_well_con = 7e18 p_pplus_x_center = 10.75 p_pplus_x_span = 22.5 p_pplus_y_center = 4.75 p_pplus_y_span = 4.5 p_pplus_z_center = 0.1675 p_pplus_z_span = 0.115 p_pplus_junction_width = 0.2 p_pplus_con = 3e19 n_pplus_x_center = 10.75 n_pplus_x_span = 19.7 n_pplus_y_center = 0 n_pplus_y_span = 3 n_pplus_z_center = 0.72 n_pplus_z_span = 0.02 n_pplus_junction_width = 0.02 n_pplus_con = 1e20 n_pplus_ref = 1e16 These are parameters for doping setup, including doping box, concentration and the diffusion junction width. [6] # --- optical simulation boundary --- x_min = -43 # light direction x_max = 21 x_mean = 0.5*(x_min+x_max) x_span = x_max-x_min y_min = -3.2 # lateral y_max = 3.2 y_mean = 0.5*(y_min+y_max) y_span = y_max-y_min z_min = -0.5 # vertical z_max = 1 z_mean = 0.5*(z_min+z_max) z_span = z_max-z_min # endregion These are geometry parameters for the optical simulation region. 2.3 Define the function for creating a new project​ A function is defined for creating a project, setting materials, modeling, doping, setting boundary conditions, etc., which can be called by other simulation script files. [7] class RunOptions(NamedTuple): high_field: bool index_preview: bool run: bool extract: bool def create_project(project_name, run_options: RunOptions) -&gt; Project: 2.3.1 Create a new project​ Create a new simulation project. [8] # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode) # endregion return pj mo.Project() parameters: name--Project name, which is also the folder name for the project files to be saved.location--The location of the computing resources. The active device simulation only support the option of &quot;local&quot; currently, which means the simulation uses the local computing resources. 2.3.2 Set materials​ [9] def create_structures(pj: Project, run_options: RunOptions): # region --- 2. Material --- mt = pj.Material() if run_options.high_field: elec_Ge_properties[&quot;mobility&quot;][&quot;mun&quot;][&quot;high_field&quot;][&quot;model&quot;]=&quot;canali&quot; elec_Ge_properties[&quot;mobility&quot;][&quot;mup&quot;][&quot;high_field&quot;][&quot;model&quot;]=&quot;canali&quot; The pj.Material variable imported from VPD_material.py, storing the modified electronic parameters for Silicon and Germanium. The material_property is used to determine which type of material parameters to choose. For details of the physics model and electronic parameter settings, please refer to the appendix. [10] mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=2) mt.add_lib(name=&quot;mat_al&quot;, data=mo.OE_Material.Al, order=2, override={&quot;work_function&quot;: 4.28}) mt.add_lib(name=&quot;mat_si&quot;, data=mo.OE_Material.Si, order=2, override=elec_Si_properties) mt.add_lib(name=&quot;mat_ge&quot;, data=mo.OE_Material.Ge, order=2, override=elec_Ge_properties) mt[&quot;mat_al&quot;].set_optical_material(data=mo.Material.PEC) mt[&quot;mat_si&quot;].set_optical_material(data=mo.Material.Si_Palik) mt[&quot;mat_ge&quot;].set_optical_material(data=mo.Material.Ge_Palik) # endregion When adding materials, start by using the add_lib function to add electrical materials from the material library. add_lib() parameters: name--Custom material namedata--Material data, requiring one of the built-in materials in the electrical material library, namely mo.OE_Materialorder--mesh_order of the material, default to be 2override--Override the default electronic parameters by custom values. It's empty by default, which means default models and parameters are applied Then, use the set_optical_material function to set the optical property for the material. set_optical_material() parameters： data--Optical material property，which can be one of the built-in materials in the optical material library mo.Material, or be from the custom optical material. Example of using custom optical material properties [11] mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=2) mt[&quot;mat_sio2&quot;].set_optical_material(data=mo.Material.SiO2_Palik) Note: Although the electrical and optical material properties are bound together through a two-step setting, in reality, there is no inherent connection between them. For instance, it is possible to set both the electrical properties of SiO2 and the optical properties of Si for the same material. The simulation will not generate errors or warnings in such cases, so users need to determine by themselves whether the material settings align with physics. The FDTD simulation currently doesn't support metal materials. Therefore, the optical property of metal materials should be set to mo.Material.PEC and the material name should also be &quot;pec&quot;. 2.3.3 Create structures​ First, initialize an object of pj.Structure(). [12] pj.Structure() parameters: mesh_type--Type of mesh refinement for optical simulationmesh_factor--The grading factor of non-uniform gridbackground_material--Background material [13] # region --- 3. Structure --- st = pj.Structure() st.add_geometry(name=&quot;BOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: SiO2_x_center, &quot;x_span&quot;: SiO2_x_span, &quot;y&quot;: SiO2_y_center, &quot;y_span&quot;: SiO2_y_span, &quot;z_min&quot;: -SiO2_z_span/2, &quot;z_max&quot;: SiO2_z_center}}) st.add_geometry(name=&quot;SOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: SiO2_x_center, &quot;x_span&quot;: SiO2_x_span, &quot;y&quot;: SiO2_y_center, &quot;y_span&quot;: SiO2_y_span, &quot;z_min&quot;: SiO2_z_center, &quot;z_max&quot;: SiO2_z_span/2}}) st.add_geometry(name=&quot;Si_input&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: input_wg_x_center, &quot;x_span&quot;: input_wg_length, &quot;y&quot;: Si_y_center, &quot;y_span&quot;: input_wg_width, &quot;z&quot;: Si_z_span/2, &quot;z_span&quot;: Si_z_span}}) st.add_geometry(name=&quot;Si_taper&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;control_points&quot;: [{&quot;x&quot;: -40, &quot;y&quot;: -0.25}, {&quot;x&quot;: -40, &quot;y&quot;: 0.25}, {&quot;x&quot;: 0, &quot;y&quot;: 2}, {&quot;x&quot;: 0, &quot;y&quot;: -2}], &quot;z_min&quot;: 0, &quot;z_max&quot;: 0.22, &quot;x&quot;: 0, &quot;y&quot;: 0}}) st.add_geometry(name=&quot;Si_base&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: Si_slab_x_center, &quot;x_span&quot;: Si_slab_length, &quot;y&quot;: Si_y_center, &quot;y_span&quot;: Si_slab_width, &quot;z&quot;: Si_z_span/2, &quot;z_span&quot;: Si_z_span}}) st.add_geometry(name=&quot;Ge&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_ge&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: Ge_x_center, &quot;x_span_bottom&quot;: Ge_x_span_bottom, &quot;x_span_top&quot;: Ge_x_span_top, &quot;y&quot;: 0, &quot;y_span_bottom&quot;: Ge_y_span_bottom, &quot;y_span_top&quot;: Ge_y_span_top, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: Ge_z_span}}) st.add_geometry(name=&quot;Cathode&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: cathode_x_center, &quot;x_span_bottom&quot;: cathode_x_span, &quot;x_span_top&quot;: cathode_x_span, &quot;y&quot;: cathode_y_center, &quot;y_span_bottom&quot;: cathode_y_span_bottom, &quot;y_span_top&quot;: cathode_y_span_top, &quot;z&quot;: cathode_z_center, &quot;z_span&quot;: cathode_z_span}}) st.add_geometry(name=&quot;Anode&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: anode_x_center, &quot;x_span_bottom&quot;: anode_x_span, &quot;x_span_top&quot;: anode_x_span, &quot;y&quot;: anode_y_center, &quot;y_span_bottom&quot;: anode_y_span_bottom, &quot;y_span_top&quot;: anode_y_span_top, &quot;z&quot;: anode_z_center, &quot;z_span&quot;: anode_z_span}}) # endregion add_geometry() parameters: name--Structure nametype--Structure typeproperty--Other properties, listed below Rectangle property list： default\ttype\tnotesgeometry.x_span float\tRestrained by condition: &gt;0. geometry.x_min float geometry.x_max float geometry.y_span float\tRestrained by condition: &gt;0. geometry.y_min float geometry.y_max float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. LinearTrapezoid property list： default\ttype\tnotesgeometry.point_1_x float geometry.point_1_y float geometry.point_2_x float geometry.point_2_y float geometry.point_3_x float geometry.point_3_y float geometry.point_4_x float geometry.point_4_y float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. Pyramid property list： default\ttype\tnotesgeometry.x_span_bottom float\tRestrained by condition: &gt;=0. geometry.y_span_bottom float\tRestrained by condition: &gt;=0. geometry.x_span_top float\tRestrained by condition: &gt;=0. geometry.y_span_top float\tRestrained by condition: &gt;=0. geometry.theta_x\t0\tfloat geometry.theta_y\t0\tfloat geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. Note: The mesh_order of a structure is default to be the mesh order of its material. And the default value will be overridden when the structure's mesh_order is set explicitly.The larger of the mesh_order of a structure, the higher of its priority. With mesh_order of two structures being the same, the structure created later has a higher priority than the one created earlier. When structures overlap, the one with higher priority overrides the one with lower priority. 2.3.4 Add doping​ [14] def add_ddm_settings(pj: Project, run_options: RunOptions): mt = pj.Material() st = pj.Structure() # region --- 4. DDM:Doping --- dp = pj.Doping() dp.add(name=&quot;p_uniform&quot;, type=&quot;constant_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;p&quot;, &quot;concentration&quot;: p_uniform_con}, &quot;geometry&quot;: {&quot;x&quot;: p_uniform_x_center, &quot;x_span&quot;: p_uniform_x_span, &quot;y&quot;: p_uniform_y_center, &quot;y_span&quot;: p_uniform_y_span, &quot;z&quot;: p_uniform_z_center, &quot;z_span&quot;: p_uniform_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot;, },}) dp.add(name=&quot;p_well&quot;, type=&quot;diffusion_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;p&quot;, &quot;concentration&quot;: p_well_con, &quot;ref_concentration&quot;: 1e6, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;diffusion_function&quot;:&quot;gaussian&quot;,&quot;junction_width&quot;: p_well_junction_width,}, &quot;geometry&quot;: {&quot;x&quot;: p_well_x_center, &quot;x_span&quot;: p_well_x_span, &quot;y&quot;: p_well_y_center, &quot;y_span&quot;: p_well_y_span, &quot;z&quot;: p_well_z_center, &quot;z_span&quot;: p_well_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot;, },}) add_doping() parameters: name--Doping nametype--Doping type. Options are &quot;n&quot; or &quot;p&quot; for n-type, p-type doping respectivelyproperty--Other properties According to the selection of general.type, doping is divided into constant doping and gaussian doping. Detailed properties are listed below. Doping property list: default\ttype\tnotesgeometry.x float geometry.x_span float geometry.y float geometry.y_span float geometry.z float geometry.z_span float geometry.rotate_x float geometry.rotate_y float geometry.rotate_z float geometry.x_min float geometry.x_max float geometry.y_min float geometry.y_max float geometry.z_min float geometry.z_max float general.type str\tSelections are ['constant', 'gaussian'] general.concentration float general.source_face str\tAvailable when type is 'gaussian' general.junction_width float\tAvailable when type is 'gaussian' general.ref_concentration float\tAvailable when type is 'gaussian' geometry.applicable_regions\t'all_regions'\tstr\tSelections are ['all_regions', 'material', 'region'] geometry.material_list list\tAvailable when geometry.applicable_regions is 'material' geometry.solid_list list\tAvailable when geometry.applicable_regions is 'region' Description: geometry--Set the geometry parameters of doping box general--Set the distribution function, concentration and so on type: When it's set to &quot;constant&quot;, only concentration is requiredWhen it's set to &quot;gaussian&quot;: concentration, ref_concentration, junction_width, source_face are required concentration--Concentration in the non-diffusion arearef_concentration--Concentration on the edge of diffusion area (edge of doping box)junction_width--Diffusion junction widthsource_face--The doping source face. Options are &quot;lower_x&quot;, &quot;lower_y&quot;, &quot;lower_z&quot;, &quot;upper_x&quot;, &quot;upper_y&quot; or &quot;upper_z&quot;. &quot;lower_x&quot; means the source face is x=x_min. Similarly for the rest. There is no diffusion area on the edge of source face. As for the other edges, there is a diffusion area within the doping box. applicable_regions--Set a list of regions or materials to be doped geometry.applicable_regions: When it's set to &quot;all_regions&quot;(by default)，the doping is applied to all the (semiconductor) structures, restricted by the doping box When it's set to &quot;material&quot;, material_list is required, which means the doping is applied to the structures with one of the specified materials and restricted by the doping box When it's set to &quot;solid&quot;, solid_list is required, which means the doping is applied to the specified structures and restricted by the doping box Examples for complete doping setting syntax [15] dp.add(name=&quot;p_pplus&quot;, type=&quot;diffusion_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;p&quot;, &quot;concentration&quot;: p_pplus_con, &quot;ref_concentration&quot;: 1e6, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;diffusion_function&quot;:&quot;gaussian&quot;,&quot;junction_width&quot;: p_pplus_junction_width}, &quot;geometry&quot;: {&quot;x&quot;: p_pplus_x_center, &quot;x_span&quot;: p_pplus_x_span, &quot;y&quot;: p_pplus_y_center, &quot;y_span&quot;: p_pplus_y_span, &quot;z&quot;: p_pplus_z_center, &quot;z_span&quot;: p_pplus_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot;, },}) dp.add(name=&quot;n_pplus&quot;, type=&quot;diffusion_doping&quot;, property={ &quot;dopant&quot;: {&quot;dopant_type&quot;: &quot;n&quot;, &quot;concentration&quot;: n_pplus_con, &quot;ref_concentration&quot;: n_pplus_ref, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;diffusion_function&quot;:&quot;gaussian&quot;,&quot;junction_width&quot;: n_pplus_junction_width}, &quot;geometry&quot;: {&quot;x&quot;: n_pplus_x_center, &quot;x_span&quot;: n_pplus_x_span, &quot;y&quot;: n_pplus_y_center, &quot;y_span&quot;: n_pplus_y_span, &quot;z&quot;: n_pplus_z_center, &quot;z_span&quot;: n_pplus_z_span, &quot;applicable_regions&quot;: &quot;all_regions&quot;, },}) # endregion 2.3.5 Add surface recombination​ [16] # region --- 5. DDM:Surface Recombination --- bd = pj.BoundaryCondition() bd.add(name=&quot;Cathode_Ge&quot;, type=&quot;surface_recombination&quot;, property={ &quot;general&quot;: {&quot;electron&quot;: {&quot;s0&quot;: 1e7}, &quot;hole&quot;: {&quot;s0&quot;: 1e7}}, &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid_solid&quot;, &quot;solid_1&quot;: st[&quot;Cathode&quot;], &quot;solid_2&quot;: st[&quot;Ge&quot;], } }) bd.add(name=&quot;Anode_Si&quot;, type=&quot;surface_recombination&quot;, property={ &quot;general&quot;: {&quot;electron&quot;: {&quot;s0&quot;: 1e7}, &quot;hole&quot;: {&quot;s0&quot;: 1e7}}, &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid_solid&quot;, &quot;solid_1&quot;: st[&quot;Anode&quot;], &quot;solid_2&quot;: st[&quot;Si_base&quot;], } }) bd.add(name=&quot;Ge_SiO2&quot;, type=&quot;surface_recombination&quot;, property={ &quot;general&quot;: {&quot;electron&quot;: {&quot;s0&quot;: Ge_SiO2_recombination_velocity}, &quot;hole&quot;: {&quot;s0&quot;: Ge_SiO2_recombination_velocity}}, &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid_solid&quot;, &quot;solid_1&quot;: st[&quot;SOX&quot;], &quot;solid_2&quot;: st[&quot;Ge&quot;], } }) # endregion add_surface_recombination() parameters： name--Custom nameproperty--Other properties Surface recombination property list: default\ttype\tnotessurface_type\tsolid_solid\tstring\tSelections are ['solid_solid', 'material_material']. general.hole.s0\t0\tfloat\tSurface recombination velocity of holes. general.electron.s0\t0\tfloat\t-Surface recombination velocity of electrons. solid_1 string\tAvailable when surface_type is 'solid_solid' solid_2 string\tAvailable when surface_type is 'solid_solid' material_1 material\tAvailable when surface_type is 'material_material' material_2 material\tAvailable when surface_type is 'material_material' Description: surface_type--Type of selection for the surface When surface_type is &quot;solid_solid&quot;, the surface is the interface between two structures When surface_type is &quot;material_material&quot;`, the surface is the interface between two materials hole.s0, electron.s0--Surface recombination velocity of holes and electrons. solid_1, solid_2--Names of the two structures at the interface. They must be set explicitly when surface_type is &quot;solid_solid&quot; material_1, material_2--The two materials at the interface. They must be set explicitly when surface_type is &quot;material_material&quot; 2.3.6 Set local mesh​ [19] # region --- 6. DDM:Mesh --- lm = pj.LocalMesh() lm.add(name=&quot;EMesh_Ge&quot;, type=&quot;EMesh&quot;, property={ &quot;general&quot;: {&quot;mesh_size&quot;: 0.01}, &quot;geometry&quot;: {&quot;geometry_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[&quot;Ge&quot;]} }) lm.add(name=&quot;EMesh_Si&quot;, type=&quot;EMesh&quot;, property={ &quot;general&quot;: {&quot;mesh_size&quot;: 0.02}, &quot;geometry&quot;: {&quot;geometry_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[&quot;Si_base&quot;]} }) lm.add(name=&quot;Ge_Boundary&quot;, type=&quot;EMesh&quot;, property={ &quot;general&quot;: {&quot;mesh_size&quot;: 0.002}, &quot;geometry&quot;: {&quot;geometry_type&quot;: &quot;solid_solid&quot;, &quot;solid_1&quot;: st[&quot;Ge&quot;], &quot;solid_2&quot;: st[&quot;Ge&quot;], &quot;growth_ratio&quot;: 2} }) lm.add(name=&quot;Si_Boundary&quot;, type=&quot;EMesh&quot;, property={ &quot;general&quot;: {&quot;mesh_size&quot;: 0.002}, &quot;geometry&quot;: {&quot;geometry_type&quot;: &quot;solid_solid&quot;, &quot;solid_1&quot;: st[&quot;Si_base&quot;], &quot;solid_2&quot;: st[&quot;Si_base&quot;], &quot;growth_ratio&quot;: 2} }) # endregion Emesh set a rectangle region for local mesh of electrical simulation. Parameters: name--Custom nameproperty--Other properties default\ttype\tnotesgeneral.mesh_size\t0.01\tfloat\tThe minimum value of the local mesh region. general.geometry_type\tdirectly defined\tstring\tSelections are ['directly defined', 'solid','solid_solid'] solid_solid string\tNames of the two structures at the interface. solid_1 string\tAvailable when geometry_type is 'solid_solid' solid_2 string\tAvailable when geometry_type is 'solid_solid' Local mesh of electrical simulation in rectangle region property list, when geometry_type is directly defined: default\ttype\tnotesx float x_span float\tRestrained by condition: &gt;=0. x_min float x_max float y float y_span float\tRestrained by condition: &gt;=0. y_min float y_max float z float z_span float\tRestrained by condition: &gt;=0. z_min float z_max float mesh_size float\tmax size of electrical simulation mesh Note: When the simulation region is in the xy plane, only the parameters in the x, y direction are effective, and parameters in the z direction will be ignored. Similarly for the rest. # region --- 10. FDTD:Mesh --- lm = pj.LocalMesh() lm.add(name=&quot;Mesh_Ge&quot;, type=&quot;Mesh&quot;, property={ &quot;general&quot;: {&quot;dz&quot;: 0.02}, &quot;geometry&quot;: {&quot;x&quot;: -42, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0.47, &quot;z_span&quot;: 0.5} }) lm.add(name=&quot;Mesh_Si&quot;, type=&quot;Mesh&quot;, property={ &quot;general&quot;: {&quot;dz&quot;: 0.025}, &quot;geometry&quot;: {&quot;x&quot;: -42, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22} }) # endregion Mesh set the local mesh for optical simulation, parameters: name--Custom nameproperty--Other properties Optical local mesh property list: default\ttype\tnotesgeneral.dx float\tRestrained by condition: &gt;0. general.dy float\tRestrained by condition: &gt;0. general.dz float\tRestrained by condition: &gt;0. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float Description: geometry--Set the region of local mesh. When x_span doesn't vanish, the mesh setting will be applied to the range along the x axis. Similarly for the rest general--Set the mesh size in the corresponding direction 2.3.7 Set waveform​ [17] def add_fdtd_settings(pj: Project, run_options: RunOptions): waveform_name = f&quot;wv{wavelength_center*1e3}&quot; # region --- 7. FDTD:Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, type='gaussian_waveform', property={'set': 'frequency_wavelength', 'set_frequency_wavelength': { 'range_type': 'wavelength', 'range_limit': 'center_span', 'wavelength_center': wavelength_center, 'wavelength_span': wavelength_span, }, } ) # endregion pj.Waveform() parameters： name--Name of the waveformrange_type-- Selections are frequency or wavelengthwavelength_center--Center of wavelengthwavelength_span--Span of wavelength 2.3.8 Set optical sources​ [20] # region --- 8. FDTD:ModeSource --- src = pj.Source() if run_options.run: src.add(name=&quot;source&quot;, type=&quot;mode_source&quot;, property={&quot;general&quot;: {&quot;inject_axis&quot;: &quot;x_axis&quot;, &quot;direction&quot;: &quot;forward&quot;,'amplitude': 1, 'phase': 0, &quot;waveform&quot;: {&quot;waveform_id&quot;: wv[waveform_name]}, &quot;mode_selection&quot;: &quot;user_select&quot;,'mode_index': 0,'rotations': {'theta': 0, 'phi': 0, 'rotation_offset': 0}}, &quot;geometry&quot;: {&quot;x&quot;: x_min + 1, &quot;x_span&quot;: 0, &quot;y&quot;: y_mean, &quot;y_span&quot;: y_span, &quot;z&quot;: z_mean, &quot;z_span&quot;: z_span}, &quot;modal_analysis&quot;: {&quot;mode_removal&quot;: {&quot;threshold&quot;: 0.01}}}) # endregion pj.Source() parameters： name--Name of the sourcetype--Type of the source. It is mode source in this exampleproperty--Other propertiesinject_axis--Direction of the source. &quot;x_axis&quot; means light propagating along x axis and in the direction of increasing x coordinate. &quot;x_axis&quot; means the opposite direction. Similarly for the rest Mode source property list: default\ttype\tnotesgeneral.amplitude\t1.0\tfloat general.phase\t0.0\tfloat general.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. general.mode_index\t0\tinteger general.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. general.n\t1.0\tfloat general.number_of_trial_modes\t20\tinteger general.waveform.waveform_id_select any general.rotations.theta\t0\tfloat general.rotations.phi\t0\tfloat general.rotations.rotation_offset\t0\tfloat bent_waveguide.bent_waveguide\tfalse\tbool bent_waveguide.radius\t1\tfloat bent_waveguide.orientation\t20\tfloat bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float Description: geometray--Set geometric parameters of optical source bent_waveguide--Set parameters related to bent waveguide general： mode_selection--Set the type of selection for the eigen mode. When it is &quot;user_select&quot;, the mode of index in mode_index is selectedwaveform--Set the waveform of the source waveform_id_select--Set to be a specified waveform 2.3.9 Set monitors​ [21] # region --- 9. FDTD:Monitor --- mn = pj.Monitor() mn.add(name=&quot;power_monitor&quot;, type=&quot;power_monitor&quot;, property={&quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength_center, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 5, }, }, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;3d&quot;, &quot;x&quot;: 10.75, &quot;x_span&quot;: 20, &quot;y&quot;: 0, &quot;y_span&quot;: 4, &quot;z&quot;: 0.47, &quot;z_span&quot;: 0.5}}) mn.add(name=&quot;y=0&quot;, type=&quot;power_monitor&quot;, property={&quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength_center, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 5, }, }, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_y_normal&quot;, &quot;x&quot;: 10.75, &quot;x_span&quot;: 20, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0.47, &quot;z_span&quot;: 0.5}}) mn.add(name=&quot;z=0.47&quot;, type=&quot;power_monitor&quot;, property={&quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength_center, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 5, }, }, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x&quot;: 10.75, &quot;x_span&quot;: 20, &quot;y&quot;: 0, &quot;y_span&quot;: 4, &quot;z&quot;: 0.47, &quot;z_span&quot;: 0}}) # endregion The monitor &quot;Power Monitor&quot; is of the 3D type, set to record the optical field profile in the &quot;Ge&quot; structure, which will be used to calculate the optical generation rate. The monitors &quot;y=0&quot; and &quot;z=0.47&quot; are both of the 2D type, set to visualize the optical field profile at the specified cross-sections. mn.add() parameters： name--Name of the monitortype--Type of the monitorproperty--Other properties Power monitor property list: default\ttype\tnotesgeneral.frequency_profile.sample_spacing\tuniform\tstring\tSelections are ['uniform']. general.frequency_profile.use_wavelength_spacing\ttrue\tbool general.frequency_profile.spacing_type\twavelength\tstring\tSelections are ['wavelength', 'frequency']. general.frequency_profile.wavelength_min float general.frequency_profile.wavelength_max float general.frequency_profile.wavelength_center float general.frequency_profile.wavelength_span float general.frequency_profile.frequency_min float general.frequency_profile.frequency_max float general.frequency_profile.frequency_center float general.frequency_profile.frequency_span float general.frequency_profile.frequency_points integer geometry.monitor_type string\tSelections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float advanced.sampling_frequency.min_sampling_per_cycle\t2\tinteger Description: geometry--Set the geometric parameters of the monitor, including the dimension and the size general--Set the frequency points of the monitor frequency_profile: use_wavelength_spacing--Default to be True. When it' True, the frequency points in sampled in wavelength, otherwise, in frequency. spacing_type--Default to be &quot;wavelength&quot;. When it's &quot;wavelength&quot;, the frequency range is set in wavelength; When it's &quot;frequency&quot;, the frequency range is set in frequency frequency_points--Number of frequency points 3. Simulation​ 3.1 Dark current​ This section performs the simulation of dark current in the VPD0A_Id.py script by invoking the pd_project function. 3.1.1 Import simulation toolkit​ [26] import sys # encoding: utf-8 from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple import sys current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from VPD00_structure import * All the variables and functions from VPD00_structure.py are imported. 3.1.2 Set general parameters​ [27] @timed @with_path def simulation(*, run_options: &quot;RunOptions&quot;, **kwargs, ): # region --- 0. General Parameter --- vsource = &quot;Cathode&quot; gnd = &quot;Anode&quot; sweep_vstart = 0 sweep_vstop = 4 sweep_vstep = 0.5 path = kwargs[&quot;path&quot;] simu_name = &quot;VPD0A_Id&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_local_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) # endregion 3.1.3 Create a new project​ [28] # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() 3.1.4 Add the solver​ [30] # region --- 2. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;DDM&quot;, property={ &quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;general&quot;: {&quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;norm_length&quot;: 20, &quot;temperature_dependence&quot;: &quot;isothermal&quot;, &quot;temperature&quot;: 298.15, }, &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: 10, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 3.7, &quot;z_min&quot;: -0.15, &quot;z_max&quot;: 1.25}, &quot;mesh_settings&quot;: {&quot;mesh_size&quot;: 0.06}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;newton&quot;, &quot;linear_solver&quot;: &quot;mumps&quot;, &quot;fermi_statistics&quot;: &quot;disabled&quot;, # or &quot;enabled&quot; &quot;damping&quot;: &quot;potential&quot;, # or &quot;none&quot; &quot;potential_update&quot;: 1.0, &quot;max_iterations&quot;: 15, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e5, &quot;divergence_factor&quot;: 1e25 } }) # endregion Description: The detailed property list of DDM solver can be found in the appendix. geometry--Set the geometric parameters for the simulation region dimension--It's set to 2d_x_normal, which means the simulation is in the yz plane general: norm_length--It's set to normal_length, which is 20, meaning that the size of the device in the third dimension is 20μm. That is to say its length in the x-direction is 20μmsolver_mode--It's set to &quot;steady_state&quot;, which means a steady state simulation 3.1.5 Add electrodes​ [29] # region --- 3. Simulation Settings --- add_ddm_settings(pj, run_options) bd = pj.BoundaryCondition() bd.add(name=vsource,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[vsource]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: sweep_vstart, &quot;range_stop&quot;: sweep_vstop, &quot;range_step&quot;: sweep_vstep, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) bd.add(name=gnd,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[gnd]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) # endregion pj.BoundaryCondition() parameters: name--Name of the electrodeproperty--Other properties The detailed property list of electrode can be found in the appendix. Here a range of voltage from 0V to 4V is applied to the electrode &quot;cathode&quot;, and the step of the voltage is 0.5V. 3.1.6 Run the solver​ [31] # region --- 4. Run --- if run_options.run: result_ddm = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0}]} ) # endregion result_device stores the information of the simulation result, which can be used to perform result extraction. 3.1.7 Extract the result​ [32] # --- Extract --- # region --- 5. Extract --- if run_options.extract: export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} slice_options = {f&quot;v_{gnd.lower()}&quot;: 0.0} result_ddm.extract(data=&quot;ddm:electrode&quot;, electrode_name=vsource, savepath=f&quot;{plot_path}I_{vsource}&quot;, target=&quot;line&quot;, attribute=&quot;I&quot;, plot_x=f&quot;v_{vsource.lower()}&quot;, real=True, imag=False, log=False, show=False, **slice_options, export_csv=True ) # attribute = &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot;, &quot;Id&quot;, &quot;Vs&quot; # endregion run_options.extract() parameters： data--Type of the result. Here it's set to &quot;I&quot; to extract the I-V curve from the simulation resultelectrode_name--Name of an electrode, which means the current data is from the electrodeexport_csv--Whether to export the csv resultshow--Whether to show the plot in a popup windowsavepath--The save path for the result extraction Result show of the dark current extraction Fig 3. Dark Current 3.1.8 Print the simulation time​ [33] return project_name if __name__ == &quot;__main__&quot;: simulation(run_options=RunOptions(high_field=False, index_preview=False, run=True, extract=True)) 3.2 Resistance​ This simulation applies a forward bias to the electrode &quot;anode&quot;. And then the I-V curve is extracted and fitted to obtain the resistance. The script is in the VPD0C_Rs.py file. 3.2.1 Simulate and extract the I-V curve​ [34] import sys # encoding: utf-8 from maxoptics_sdk.helper import timed, with_path import os import time import sys current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from VPD00_structure import * @timed @with_path def simulation(*, run_options: &quot;RunOptions&quot;, **kwargs, ): # region --- 0. General Parameter --- vsource = &quot;Anode&quot; gnd = &quot;Cathode&quot; sweep_vstart = 0 sweep_vstop = 1.5 sweep_vstep = 0.25 path = kwargs[&quot;path&quot;] simu_name = &quot;VPD0C_Rs&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_local_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) # endregion # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() # region --- 2. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;DDM&quot;, property={ &quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;general&quot;: {&quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;norm_length&quot;: 20, &quot;temperature_dependence&quot;: &quot;isothermal&quot;, &quot;temperature&quot;: 298.15, }, &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: 10, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 3.7, &quot;z_min&quot;: -0.15, &quot;z_max&quot;: 1.25}, &quot;mesh_settings&quot;: {&quot;mesh_size&quot;: 0.06}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;newton&quot;, &quot;linear_solver&quot;: &quot;mumps&quot;, &quot;fermi_statistics&quot;: &quot;disabled&quot;, # or &quot;enabled&quot; &quot;damping&quot;: &quot;potential&quot;, # or &quot;none&quot; &quot;potential_update&quot;: 1.0, &quot;max_iterations&quot;: 15, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e5, &quot;divergence_factor&quot;: 1e25 } }) # endregion # region --- 3. Electrode --- add_ddm_settings(pj, run_options) bd = pj.BoundaryCondition() bd.add(name=vsource,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[vsource]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: sweep_vstart, &quot;range_stop&quot;: sweep_vstop, &quot;range_step&quot;: sweep_vstep, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) bd.add(name=gnd,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[gnd]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) # endregion # region --- 4. Run --- if run_options.run: result_ddm = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0}]} ) # endregion # region --- 5. Extract --- if run_options.extract: export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} slice_options = {f&quot;v_{gnd.lower()}&quot;: 0.0} result_ddm.extract(data=&quot;ddm:electrode&quot;, electrode_name=vsource, savepath=f&quot;{plot_path}I_{vsource}&quot;, target=&quot;line&quot;, attribute=&quot;I&quot;, plot_x=f&quot;v_{vsource.lower()}&quot;, real=True, imag=False, log=False, show=False, **slice_options, export_csv=True ) # attribute = &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot;, &quot;Id&quot;, &quot;Vs&quot; # endregion A range of voltage from 0V to 1.5V is applied to the electrode &quot;anode&quot;, with a step of 0.25V. No optical generation rate is applied. And a steady state simulation is performed to extract the I-V curve, which is saved to the folder IV_file_folder. Result show of the I-V curve Fig 4. I-V curve 3.2.2 Fit V-I curve to obtain resistance​ 3.2.2.1 Read the saved I-V data​ [35] # region --- calculate R --- Vdc = np.genfromtxt(f&quot;{plot_path}I_Anode.csv&quot;,skip_header=1,delimiter=&quot;,&quot;)[:,0] Idc = np.genfromtxt(f&quot;{plot_path}I_Anode.csv&quot;,skip_header=1,delimiter=&quot;,&quot;)[:,1] &quot;0_I_Real.csv&quot; is filename generated automatically of the I-V result. The &quot;0&quot; in the beginning indicates the index of the electrode. When the I-V curve is from a different electrode, the index will change. Therefore, a iteration from 0 to 9 is applied to find the saved I-V data file. 3.2.2.2 Fit the data to obtain resistance​ [36] start_idx = len(Vdc)//2 coeffs = np.polyfit(Idc[start_idx:], Vdc[start_idx:], 1) V_fit = coeffs[0]*Idc + coeffs[1] R = abs(coeffs[0]) Fit the data after the index start_idx, which is the start index of the approximately linear portion of the curve. A first-order polynomial fitting is performed on the V-I data. Then the coefficient of the first-order term is the device resistance. 3.2.2.3 Save data and plots​ [37] r_path = f&quot;{plot_path}resistance&quot; if not os.path.exists(r_path): os.makedirs(r_path) with open(f&quot;{r_path}/Rdata.txt&quot;, &quot;w&quot;) as fp: fp.write(&quot;Resistance: &quot; + f&quot;{R} Ohm\\n&quot;) fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(Idc, Vdc, c=&quot;b&quot;, linewidth=linewidth, label=&quot;V-I&quot;) ax.plot(Idc, V_fit, c=&quot;g&quot;, linewidth=linewidth, label=&quot;V_fit-I&quot;) ax.set_xlabel(&quot;I[A]&quot;) ax.set_ylabel(&quot;V[V]&quot;) plt.legend() plt.ticklabel_format(style=&quot;sci&quot;, scilimits=(-1, 2)) ax.grid() plt.savefig(f&quot;{plot_path}resistance/Rs.jpg&quot;) plt.close() # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;) Result show of the V-I fitting Fig 5. V-I fitting 3.3 Capacitance​ This section performs a SSAC simulation, and extracts the capacitance. The script is in the VPD0A_C.py file. [38] import sys # encoding: utf-8 from maxoptics_sdk.helper import timed, with_path import os import time import sys current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from VPD00_structure import * @timed @with_path def simulation(*, run_options: &quot;RunOptions&quot;, **kwargs, ): # region --- 0. General Parameter --- vsource = &quot;Cathode&quot; gnd = &quot;Anode&quot; sweep_vstart = 0 sweep_vstop = 3 sweep_vstep = 0.5 path = kwargs[&quot;path&quot;] simu_name = &quot;VPD0B_C&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_local_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) # endregion # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() # region --- 2. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;DDM&quot;, property={ &quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;general&quot;: {&quot;solver_mode&quot;: &quot;ssac&quot;, &quot;norm_length&quot;: 20, &quot;temperature_dependence&quot;: &quot;isothermal&quot;, &quot;temperature&quot;: 298.15, &quot;perturbation_amplitude&quot;: 0.001, &quot;frequency_spacing&quot;: &quot;single&quot;, &quot;frequency&quot;: 1e8 }, &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: 10, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 3.7, &quot;z_min&quot;: -0.15, &quot;z_max&quot;: 1.25}, &quot;mesh_settings&quot;: {&quot;mesh_size&quot;: 0.06}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;newton&quot;, &quot;linear_solver&quot;: &quot;mumps&quot;, &quot;fermi_statistics&quot;: &quot;disabled&quot;, # or &quot;enabled&quot; &quot;damping&quot;: &quot;potential&quot;, # or &quot;none&quot; &quot;potential_update&quot;: 1.0, &quot;max_iterations&quot;: 15, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e5, &quot;divergence_factor&quot;: 1e25 } }) # endregion # region --- 3. Simulation Settings --- add_ddm_settings(pj, run_options) bd = pj.BoundaryCondition() bd.add(name=vsource,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[vsource]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: sweep_vstart, &quot;range_stop&quot;: sweep_vstop, &quot;range_step&quot;: sweep_vstep, &quot;apply_ac_small_signal&quot;: &quot;all&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) bd.add(name=gnd,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[gnd]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) # endregion # region --- 4. Run --- if run_options.run: result_ddm = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0}]} ) # endregion # region --- 5. Extract --- if run_options.extract: export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} result_ddm.extract(data=&quot;ddm:electrode_ac&quot;, electrode_name=vsource, savepath=f&quot;{plot_path}C&quot;, target=&quot;line&quot;, attribute=&quot;C&quot;, plot_x=f&quot;v_{vsource.lower()}&quot;, real=True, imag=False, frequency=1e8, show=False, export_csv=True) # endregion return project_name if __name__ == &quot;__main__&quot;: simulation(run_options=RunOptions(high_field=False, index_preview=False, run=True, extract=True)) Description: For DDM solver, the detailed properties can be found in the appendix. Here: general: solver_mode--It's set to &quot;SSAC&quot;, which means a SSAC simulation frequency_spacing--It's set to &quot;single&quot;, which means a single frequency point frequency--Set the value of the single frequency For the electrode &quot;cathode&quot;, a range of voltage from 0V to 3V is applied to it, with a step of 0.5V. apply_AC_small_signal--It's set to All, which means the small signal analysis is applied at each voltage step For the result extraction: data--It's set to &quot;C&quot;, which is available after the SSAC simulation and is used to extract the capacitance Result show of the capacitance Fig 6. Capacitance 3.4 Optical generation rate​ This section performs a FDTD simulation to obtain the optical field profile in the structure of &quot;Ge&quot;, and then calculate the photo-induced carrier generation rate. The average of the optical generation rate in the light propagating direction, which is the x-direction, is then taken to obtain the profile in the yz plane to be imported to the OEDevice simulation. The script is in the VPD01_FDTD.py file. 3.4.1 Import simulation toolkit​ [39] import sys # encoding: utf-8 from maxoptics_sdk.helper import timed, with_path import os import time import sys current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from VPD00_structure import * 3.4.2 Set general parameters​ [40] start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # ---------------------- set project_path @timed @with_path def simulation(*, run_options: &quot;RunOptions&quot;, **kwargs, ): # region --- 0. General Parameter --- path = kwargs[&quot;path&quot;] simu_name = &quot;VPD01_FDTD&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_local_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) # endregion 3.4.3 Create a new project​ [41] # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() 3.4.4 Add the solver​ [42] # region --- 2. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;FDTD&quot;, property={&quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;x_span&quot;: x_span, &quot;y&quot;: y_mean, &quot;y_span&quot;: y_span, &quot;z&quot;: z_mean, &quot;z_span&quot;: z_span, }, &quot;general&quot;: {&quot;simulation_time&quot;: 2000, }, &quot;mesh_settings&quot;: {&quot;mesh_factor&quot;: 1.2, &quot;mesh_type&quot;: &quot;auto_non_uniform&quot;, &quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: 14}, &quot;minimum_mesh_step_settings&quot;: {&quot;min_mesh_step&quot;: 1e-4}, &quot;mesh_refinement&quot;: {&quot;mesh_refinement&quot;: &quot;curve_mesh&quot;, }}, &quot;boundary_conditions&quot;: {&quot;x_min_bc&quot;: &quot;PML&quot;, &quot;x_max_bc&quot;: &quot;PML&quot;, &quot;y_min_bc&quot;: &quot;PML&quot;, &quot;y_max_bc&quot;: &quot;PML&quot;, &quot;z_min_bc&quot;: &quot;PML&quot;, &quot;z_max_bc&quot;: &quot;PML&quot;, &quot;pml_settings&quot;: {&quot;all_pml&quot;: {&quot;profile&quot;:&quot;standard&quot;,&quot;layer&quot;: 8, &quot;kappa&quot;: 2, &quot;sigma&quot;: 0.8, &quot;polynomial&quot;: 3, &quot;alpha&quot;: 0, &quot;alpha_polynomial&quot;: 1, }}}, 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-4, 'down_sample_time': 200}}, }) # endregion # region --- 3. Simulation Settings --- add_fdtd_settings(pj, run_options) mn = pj.Monitor() # endregion The FDTD solver for active device simulation can be used to extract the optical generation rate. 3.4.5 Run and extract the result​ [43] # region --- 4. Run --- if run_options.run: result_fdtd = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0}]} ) &quot;&quot;&quot; Analysis &quot;&quot;&quot; analysis = pj.Analysis() analysis.add(name=&quot;generation_rate&quot;, type=&quot;generation_rate&quot;, property={&quot;power_monitor&quot;: &quot;power_monitor&quot;, &quot;average_dimension&quot;: &quot;x&quot;, &quot;light_power&quot;: 1, &quot;workflow_id&quot;: result_fdtd.workflow_id}) gen_res = analysis[&quot;generation_rate&quot;].run() # endregion # region --- 5. Extract --- export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} gen_res.extract(data=&quot;fdtd:generation_rate&quot;, savepath=f&quot;{plot_path}genrate&quot;, generation_rate_name=&quot;generation_rate&quot;, target=&quot;intensity&quot;, attribute=&quot;G&quot;, real=True, imag=False, **export_options, show=False) gen_res.extract(data=&quot;fdtd:generation_rate&quot;, savepath=f&quot;{plot_path}pabs_total&quot;, generation_rate_name=&quot;generation_rate&quot;, target=&quot;line&quot;, attribute=&quot;Pabs_total&quot;, plot_x=&quot;frequency&quot;, real=True, imag=False, show=False, export_csv=True) gen_res.extract(data=&quot;fdtd:generation_rate&quot;, savepath=f&quot;{plot_path}jsc&quot;, generation_rate_name=&quot;generation_rate&quot;, target=&quot;line&quot;, attribute=&quot;Jsc&quot;, plot_x=&quot;frequency&quot;, real=True, imag=False, show=False, export_csv=True) # endregion return project_name if __name__ == &quot;__main__&quot;: simulation(run_options=RunOptions(high_field=False, index_preview=False, run=True, extract=True)) pj.analysis() parameters： name--Custom namemonitor--Name of the power_monitor for calculating optical generation rate. The power_monitor is required to be of 3D typeaverage_dimension--Set the direction to take the average of the optical generate ratelight_power--Set the power of the light source, measured in W. The optical generation rate will be scaled based on the power gen_res.extract() parameters： data--Type of the result When data is set to &quot;generation_rate&quot;, besides an image file and a csv file, the result files also include a text file in .gfile format. The coordinate unit in the csv and the image file is um, and the generation rate unit in the two files is /cm^3/s. These units can't be modified when extracting the result. However, the units in the gfile are controlled by coordinate_unit、field_length_unit. And only the gfile can be imported to the OEDevice solverWhen data is set to &quot;pabs_total&quot;, the total absorption power is extracted export_csv--Whether to export csv file show--Whether to show the plot in a popup window Result show of the optical generation rate Fig 7. Optical generation rate 3.5 Photo current​ This section imports the optical generation rate to the DDM solver, and performs a steady state simulation to obtain the photo current. The script is in the VPD02_Ip.py file. 3.5.1 Import simulation toolkit​ [44] import sys # encoding: utf-8 from maxoptics_sdk.helper import timed, with_path import os import time import sys current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from VPD00_structure import * 3.5.2 Set general parameters​ [45] @timed @with_path def simulation(*, run_options: &quot;RunOptions&quot;, **kwargs, ): # region --- 0. General Parameter --- vsource = &quot;Cathode&quot; gnd = &quot;Anode&quot; sweep_vstart = 0 sweep_vstop = 4 sweep_vstep = 0.5 path = kwargs[&quot;path&quot;] simu_name = &quot;VPD02_Ip&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_local_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) gen_rate_file = os.path.join(os.path.dirname(__file__), &quot;VPD01_FDTD.gfile&quot;) # endregion genrate_file_path is the absolute path of the gfile to be imported to the DDM solver. Here it's set to the absolute path of VPD01_FDTD.gfile in the same directory. And this can be changed to the path of the gfile extracted by the FDTD simulation. 3.5.3 Create a new project​ [46] # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() 3.5.4 Add the solver​ [48] # region --- 2. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;DDM&quot;, property={ &quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;general&quot;: {&quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;norm_length&quot;: 20, &quot;temperature_dependence&quot;: &quot;isothermal&quot;, &quot;temperature&quot;: 298.15, }, &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: 10, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 3.7, &quot;z_min&quot;: -0.15, &quot;z_max&quot;: 1.25}, &quot;mesh_settings&quot;: {&quot;mesh_size&quot;: 0.06}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;newton&quot;, &quot;linear_solver&quot;: &quot;mumps&quot;, &quot;fermi_statistics&quot;: &quot;disabled&quot;, # or &quot;enabled&quot; &quot;damping&quot;: &quot;potential&quot;, # or &quot;none&quot; &quot;potential_update&quot;: 1.0, &quot;max_iterations&quot;: 15, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e5, &quot;divergence_factor&quot;: 1e25 } }) # endregion # region --- 3. Simulation Settings --- add_ddm_settings(pj, run_options) ds = pj.DataSpace() ds.import_data(name=&quot;gen&quot;, type=&quot;generation&quot;, property={ &quot;path&quot;: gen_rate_file }) src = pj.Source() src.add(name=&quot;gen&quot;, type=&quot;optical_generation&quot;, property={ &quot;general&quot;: {&quot;generation_data&quot;: ds[&quot;gen&quot;], &quot;source_fraction&quot;: 0.001}, &quot;transient&quot;: {&quot;envelop&quot;: &quot;uniform&quot;} }) Description: add_ddm_settings: import_data.path--Here it's not empty, meaning that the file at the path will be imported to the DDM solver source_fraction--Set the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport #### 3.5.5 Add electrodes [47] bd = pj.BoundaryCondition() bd.add(name=vsource,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[vsource]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: sweep_vstart, &quot;range_stop&quot;: sweep_vstop, &quot;range_step&quot;: sweep_vstep, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) bd.add(name=gnd,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[gnd]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) # endregion #### 3.5.6 Run and extract the result [49] # region --- 4. Run --- if run_options.run: result_ddm = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0}]} ) # endregion # region --- 5. Extract --- if run_options.extract: electrode_name = &quot;cathode&quot; export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} slice_options = {f&quot;v_{gnd.lower()}&quot;: 0.0} result_ddm.extract(data=&quot;ddm:electrode&quot;, electrode_name=vsource, savepath=f&quot;{plot_path}I_{vsource}&quot;, target=&quot;line&quot;, attribute=&quot;I&quot;, plot_x=f&quot;v_{vsource.lower()}&quot;, real=True, imag=False, log=False, show=False, **slice_options, export_csv=True ) # attribute = &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot;, &quot;Id&quot;, &quot;Vs&quot; # endregion return project_name if __name__ == &quot;__main__&quot;: simulation(run_options=RunOptions(high_field=False, index_preview=False, run=True, extract=True)) Result show of the photo current Fig 8. Photo current 3.6 Bandwidth​ This section performs a transient simulation to extract the step response of the photo current. Then the bandwidth is obtained by postprocessing the I-t curve. The script is in the VPD03_bw.py file. 3.6.1 Import simulation toolkit​ [50] import sys # encoding: utf-8 from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple import sys import numpy as np import matplotlib.pyplot as plt from scipy import interpolate as scip, fft as scfft current_dir = os.path.dirname(__file__) sys.path.extend([current_dir]) from VPD00_structure import * 3.6.2 Set general parameters​ [51] @timed @with_path def simulation(*, run_options: &quot;RunOptions&quot;, **kwargs, ): # region --- 0. General Parameter --- path = kwargs[&quot;path&quot;] simu_name = &quot;VPD03_bw&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f&quot;{simu_name}_local_{time_str}&quot; plot_path = f&quot;{path}/plots/{project_name}/&quot; current_file_path = os.path.abspath(__file__) gen_rate_file = os.path.join(os.path.dirname(__file__), &quot;VPD01_FDTD.gfile&quot;) # endregion 3.6.3 Create a new project​ [52] # region --- 1. Project --- pj: Project = create_project(project_name, run_options) # endregion create_structures(pj, run_options) mt = pj.Material() st = pj.Structure() 3.6.4 Add the solver​ [54] # region --- 2. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;DDM&quot;, property={ &quot;background_material&quot;: mt[&quot;mat_sio2&quot;], &quot;general&quot;: {&quot;solver_mode&quot;: &quot;transient&quot;, &quot;norm_length&quot;: 20, &quot;temperature_dependence&quot;: &quot;isothermal&quot;, &quot;temperature&quot;: 298.15, }, &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: 10, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 3.7, &quot;z_min&quot;: -0.15, &quot;z_max&quot;: 1.25}, &quot;mesh_settings&quot;: {&quot;mesh_size&quot;: 0.06}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;newton&quot;, &quot;linear_solver&quot;: &quot;mumps&quot;, &quot;fermi_statistics&quot;: &quot;disabled&quot;, # or &quot;enabled&quot; &quot;damping&quot;: &quot;potential&quot;, # or &quot;none&quot; &quot;potential_update&quot;: 1.0, &quot;max_iterations&quot;: 15, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e5, &quot;divergence_factor&quot;: 1e25 } }) # endregion # region --- 3. Simulation Settings --- add_ddm_settings(pj, run_options) ds = pj.DataSpace() ds.import_data(name=&quot;gen&quot;, type=&quot;generation&quot;, property={ &quot;path&quot;: gen_rate_file }) src = pj.Source() src.add(name=&quot;gen&quot;, type=&quot;optical_generation&quot;, property={ &quot;general&quot;: {&quot;generation_data&quot;: ds[&quot;gen&quot;], &quot;source_fraction&quot;: 0.001}, &quot;transient&quot;: {&quot;envelop&quot;: &quot;pulse&quot;, &quot;high_amplitude&quot;: 0.1, &quot;low_amplitude&quot;: 0, &quot;time_delay&quot;: 2e-12, &quot;rising_edge&quot;: 1e-13, &quot;falling_edge&quot;: 1e-13, &quot;pulse_width&quot;: 6e-10, &quot;period&quot;: 1e-6} }) Description: general: solver_mode--Here it's set to &quot;transient&quot;, which means a transient simulation advanced: max_iterations--Set the max iterations during the initialization of solving the Poisson equations.fermi_statistics--Whether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. &quot;enabled&quot; means True, and &quot;disabled&quot; means Falsedamping--Set the nonlinear update damping scheme. &quot;potential&quot; means the damping is based on the potential variationpotential_update--Set the threshold potential for potential damping. The large value will reduce the strength of damping effectrelative_tolerance--Set the relative update tolerancetolerance_relax--Set the tolerance relaxation factor for convergence on relative tolerance criteriasource_fraction--When envelop is set touniform, this value is the scaling factor of the light power during the time range 3.6.4 Add electrodes​ [53] bd = pj.BoundaryCondition() bd.add(name=&quot;cathode&quot;,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[&quot;Cathode&quot;]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;transient&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: 0, &quot;range_stop&quot;: 4, &quot;range_step&quot;: 0.5, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, &quot;amplitude&quot;: 1, &quot;time_delay&quot;: 0, &quot;transient_time_control&quot;: [ {&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 2.001e-12, &quot;initial_step&quot;: 3e-17, &quot;max_step&quot;: 3e-17}, {&quot;time_start&quot;: 2.001e-12, &quot;time_stop&quot;: 2.01e-12, &quot;initial_step&quot;: 3e-17, &quot;max_step&quot;: 6e-17}, {&quot;time_start&quot;: 2.01e-12, &quot;time_stop&quot;: 2.03e-12, &quot;initial_step&quot;: 6e-17, &quot;max_step&quot;: 2e-15}, {&quot;time_start&quot;: 2.03e-12, &quot;time_stop&quot;: 1e-11, &quot;initial_step&quot;: 2e-15, &quot;max_step&quot;: 5e-14}, {&quot;time_start&quot;: 1e-11, &quot;time_stop&quot;: 5e-10, &quot;initial_step&quot;: 5e-14, &quot;max_step&quot;: 1e-11}, ] } }) bd.add(name=&quot;anode&quot;,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[&quot;Anode&quot;]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) # endregion Description: For the electrode &quot;cathode&quot;: electrode_mode--Here it's set to &quot;transient&quot;, which means a transient boundary condition is applied to this electrode. Then the time dependence of the optical generation rate can be set at this electroderange_stop--Here it's set to tcad_voltage, meaning that the voltage is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation.range_step--Set the max step of the voltage from the equilibrium state to steady state at the bias of voltage.transient_time_control--Set the time dependence of optical generation rate. It's of a list type, whose item is of a dictionary type. In each of its item: time_start--Set the start time point of the range. The value of 0 represents the steady state of the earlier simulation.time_stop--Set the stop time point of the rangeinitial_step--Set the initial time step of the rangemax_step--Set the max time step of the rangeoptical--Set the optical generation rate during the time range enabled--Whether to apply optical generation rate during the time range. The value of 1 means True, and 0 means Falseenvelop--The envelop of the scaling factor of the light power during the time range. Note: The dependency of scaling factor of light power on time is a step function here. #### 3.6.6 Run the solver [55] # region --- 4. Run --- if run_options.run: result_ddm = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0}]} ) # endregion 3.6.7 Extract the result​ The I-t curve is extracted. Because the dependency of the light power on time is a step function, the I-t curve here represents the step response of the photo current. [56] # region --- 5. Extract --- if run_options.extract: electrode_name = &quot;cathode&quot; export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} result_ddm.extract(data=&quot;ddm:electrode&quot;, electrode_name=electrode_name, savepath=f&quot;{plot_path}I&quot;, target=&quot;line&quot;, attribute=&quot;I&quot;, plot_x=&quot;time&quot;, real=True, imag=False, log=False, show=False, export_csv=True ) # attribute = &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot;, &quot;Id&quot;, &quot;Vs&quot; # endregion return project_name if __name__ == &quot;__main__&quot;: simulation(run_options=RunOptions(high_field=True, index_preview=True, run=True, extract=True)) Result show of the step response Fig 9. Step response 3.6.8 Postprocess​ By taking the derivative of the step response, the impulse response is obtained. Then the Fast Fourier Transform is applied to the impulse response, resulting in the frequency response, which allows to determine the device bandwidth. 3.6.8.1 Obtain the impulse response​ [57] # region --- 6. Post Processing --- I = np.genfromtxt(f&quot;{plot_path}/I.csv&quot;, skip_header=1, delimiter=',')[:,1] t = np.genfromtxt(f&quot;{plot_path}/I.csv&quot;, skip_header=1, delimiter=',')[:,0] start_idx = 0 for i ,val in enumerate(t): if val == 2e-12: start_idx = i break t = t[start_idx:] I = I[start_idx:] dt = np.diff(t) dI = np.diff(I) dIdt = (dI[1:] + (dt[1:]/dt[:-1])**2*dI[:-1])/(dt[1:]*(1+dt[1:]/dt[:-1])) delta_t = 1e-13 th = t[1:len(t)-1] nt = int(np.ceil((th[-1]-th[0])/delta_t)) t_interp = np.linspace(th[0], th[-1], nt) interp1d_func = scip.interp1d(th, dIdt) dIdt_interp = interp1d_func(t_interp) First, take the derivative of the step response to obtain the impulse response. And then uniform time intervals and perform interpolation on the impulse response to facilitate the subsequent application of the Fast Fourier Transform. 3.6.8.2 Export the impulse response result​ [58] # Output impulse response bandwidth_folder = f&quot;{plot_path}/3dB_bandwidth&quot; if not os.path.exists(bandwidth_folder): os.makedirs(bandwidth_folder) impulse_fig = os.path.join(bandwidth_folder, &quot;impulse_response.jpg&quot;) fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(t_interp*1e12, dIdt_interp/np.max(np.abs(dIdt_interp)), c='b', linewidth=linewidth, label=&quot;Impulse response&quot;) ax.set_ylabel(&quot;Impulse response&quot;) ax.set_xlabel(&quot;Time [ps]&quot;) ax.grid() plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1,2)) plt.savefig(impulse_fig) plt.close() Result show of the impulse response Fig 10. Impulse response 3.6.8.3 Obtain the frequency response​ [59] fresponse = scfft.rfft(dIdt_interp) freq = scfft.rfftfreq(len(t_interp), t_interp[1]-t_interp[0]) fresponse = np.abs(fresponse)/np.max(np.abs(fresponse)) # Calculate 3dB bandwidth by interpolation log_freq = np.log10(freq[1:]) log_fresp = 20*np.log10(np.abs(fresponse[1:])) resp_3dB = -3 log_freq_3dB = scip.interp1d(log_fresp, log_freq)(resp_3dB) bandwidth_GHz = 10**log_freq_3dB*1e-9 Obtain the frequency response by Fast Fourier Transform. And then calculate the 3dB bandwidth by interpolation. 3.6.8.4 Export the frequency response result​ [60] bandwidth_file = os.path.join(bandwidth_folder, &quot;3dB_bandwidth.txt&quot;) bandwidth_fig = os.path.join(bandwidth_folder, &quot;3dB_bandwidth.jpg&quot;) with open(bandwidth_file, 'w') as fp: fp.write(&quot;3dB bandwidth: &quot; + f&quot;{bandwidth_GHz:.6f} GHz\\n&quot;) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(freq[1:]*1e-9, 20*np.log10(np.abs(fresponse[1:])), 'b', linewidth=linewidth, label=&quot;Normalized response&quot;) ax.plot(freq[1:]*1e-9, resp_3dB*np.ones(len(freq[1:])), 'g', linewidth=linewidth) ax.set_xlim(left = 1, right = 300) ax.set_ylim(bottom = -25) ax.set_xscale('log') ax.set_ylabel('Normalized response [dB]') ax.set_xlabel('Frequency [GHz]') ax.grid(which='both', axis='both') plt.savefig(bandwidth_fig) # endregion if __name__ == &quot;__main__&quot;: simulation(run_options=RunOptions(high_field=True, index_preview=True, run=True, extract=True)) Result show of the frequency response Fig 11. Frequency response 4. Appendix​ 4.1 Electronic parameters of the materials​ The parameter settings in the VPD_material_Si.py file: [71] elec_Si_properties = { &quot;permittivity&quot;: { &quot;permittivity&quot;: 11.7, }, &quot;work_function&quot;:4.59, &quot;fundamental&quot;: { &quot;electron&quot;: &quot;density_of_states&quot;, &quot;hole&quot;: &quot;density_of_states&quot;, &quot;nc&quot;: { # &quot;constant&quot;: 3.21657e19, &quot;enable_model&quot;: True, &quot;nc300&quot;: 3.21657e19 }, &quot;nv&quot;: { # &quot;constant&quot;: 1.82868e19, &quot;enable_model&quot;: True, &quot;nv300&quot;: 1.82868e19 }, &quot;eg&quot;: { # &quot;constant&quot;: 1.12416, &quot;enable_model&quot;: True, &quot;alpha&quot;: 0.000473, &quot;beta&quot;: 636, &quot;eg0&quot;: 1.16 }, &quot;narrowing&quot;: { &quot;model&quot;: &quot;slotboom&quot;, &quot;slotboom&quot;: { &quot;e0&quot;: 0.0045, &quot;n0&quot;: 1.0e17 } }, }, &quot;recombination&quot;:{ &quot;trap_assisted&quot;: { &quot;enabled&quot;: True, &quot;taun&quot;: { &quot;enable_model&quot;: True, # &quot;constant&quot;: 1e-5, &quot;alpha&quot;: -1.5, &quot;dopant&quot;: { &quot;model&quot;: &quot;scharfetter&quot;, &quot;scharfetter&quot;: { &quot;nref&quot;: 7.1e15, &quot;taumax&quot;: 1.5e-9, &quot;taumin&quot;:0 } }, &quot;field&quot;: { &quot;model&quot;: &quot;none&quot;, # &quot;schenk&quot;: { # &quot;hbar_omega&quot;: 0.068, # &quot;mt&quot;: 0.258, # &quot;s&quot;: 3.5 # } } }, &quot;taup&quot;: { &quot;enable_model&quot;: True, # &quot;constant&quot;: 3e-6, &quot;alpha&quot;: -1.5, &quot;dopant&quot;: { &quot;model&quot;: &quot;scharfetter&quot;, &quot;scharfetter&quot;: { &quot;nref&quot;: 7.1e15, &quot;taumax&quot;: 1.5e-9, &quot;taumin&quot;: 0 } }, &quot;field&quot;: { &quot;model&quot;: &quot;none&quot;, # or &quot;none&quot; # &quot;schenk&quot;: { # &quot;hbar_omega&quot;: 0.068, # &quot;mt&quot;: 0.24, # &quot;s&quot;: 3.5 # } } }, &quot;ei_offset&quot;: 0.0 }, &quot;radiative&quot;: { &quot;enabled&quot;: True, &quot;copt&quot;: 1.6e-14 }, &quot;auger&quot;: { &quot;enabled&quot;: True, &quot;caun&quot;: { &quot;constant&quot;: 2.8e-31, &quot;enable_model&quot;: False, # &quot;a&quot;: 6.7e-32, # &quot;b&quot;: 2.45e-31, # &quot;c&quot;: -2.2e-32, # &quot;h&quot;: 3.46667, # &quot;n0&quot;: 1e18 }, &quot;caup&quot;: { &quot;constant&quot;: 9.9e-32, &quot;enable_model&quot;: False, # &quot;a&quot;: 7.2e-32, # &quot;b&quot;: 4.5e-33, # &quot;c&quot;: 2.63e-32, # &quot;h&quot;: 8.25688, # &quot;n0&quot;: 1e18 } }, &quot;band_to_band_tunneling&quot;: { &quot;enabled&quot;: False, # &quot;model&quot;: &quot;hurkx&quot;, # or &quot;schenk&quot; # &quot;hurkx&quot;: { # &quot;agen&quot;: 3.5e21, # &quot;arec&quot;: 3.5e21, # &quot;bgen&quot;: 2.25e7, # &quot;brec&quot;: 2.25e7, # &quot;pgen&quot;: 2.0, # &quot;prec&quot;: 2.0, # &quot;alpha&quot;: 0 # }, # &quot;schenk&quot;: { # &quot;a&quot;: 8.977e20, # &quot;b&quot;: 2.1466e7, # &quot;hbar_omega&quot;: 0.0186 # } } }, &quot;mobility&quot;:{ &quot;mun&quot;: { &quot;lattice&quot;: { # &quot;constant&quot;: 1417, &quot;enable_model&quot;: True, &quot;eta&quot;: -2.5, &quot;mumax&quot;: 1471 }, &quot;impurity&quot;: { &quot;model&quot;: &quot;masetti&quot;, &quot;masetti&quot;: { &quot;alpha&quot;: 0.68, &quot;beta&quot;: 2, &quot;cr&quot;: 9.68e16, &quot;cs&quot;: 3.43e20, &quot;mu1&quot;: 43.4, &quot;mumin1&quot;: 52.2, &quot;mumin2&quot;: 52.2, &quot;pc&quot;: 0 } }, &quot;high_field&quot;: { &quot;model&quot;: &quot;none&quot;, # &quot;canali&quot;: { # &quot;alpha&quot;: 0, # &quot;beta0&quot;: 1.109, # &quot;eta&quot;: 0.66 # }, # &quot;driving_field&quot;: { # &quot;model&quot;: &quot;e_dot_j&quot;, # or &quot;grad_phi&quot;, # &quot;grad_phi&quot;: { # &quot;nref&quot;: 1e5 # } # }, # &quot;vsat&quot;: { # &quot;constant&quot;: 1.07e7, # &quot;enable_model&quot;: False, # &quot;gamma&quot;: 0.87, # &quot;vsat0&quot;: 1.07e7 # } } }, &quot;mup&quot;: { &quot;lattice&quot;: { # &quot;constant&quot;: 470.5, &quot;enable_model&quot;: True, &quot;eta&quot;: -2.2, &quot;mumax&quot;: 470.5 }, &quot;impurity&quot;: { &quot;model&quot;: &quot;masetti&quot;, # or &quot;none&quot; &quot;masetti&quot;: { &quot;alpha&quot;: 0.719, &quot;beta&quot;: 2, &quot;cr&quot;: 2.23e17, &quot;cs&quot;: 6.1e20, &quot;mu1&quot;: 29, &quot;mumin1&quot;: 44.9, &quot;mumin2&quot;: 44.9, &quot;pc&quot;: 0 } }, &quot;high_field&quot;: { &quot;model&quot;: &quot;none&quot;, # &quot;canali&quot;: { # &quot;alpha&quot;: 0, # &quot;beta0&quot;: 1.213, # &quot;eta&quot;: 0.17 # }, # &quot;driving_field&quot;: { # &quot;model&quot;: &quot;e_dot_j&quot;, # or &quot;grad_phi&quot;, # &quot;grad_phi&quot;: { # &quot;nref&quot;: 1e5 # } # }, # &quot;vsat&quot;: { # &quot;constant&quot;: 8.37e6, # &quot;enable_model&quot;: True, # &quot;gamma&quot;: 0.52, # &quot;vsat0&quot;: 8.37e6 # }, }, }, }, } Description: permittivity --Set the permittivity and affinity fundamental--Set models and parameters of the band and the density of state recombination--Set models and parameters of recombination of electron and hole mobility--Set the model and parameters of mobility, high_field--Set the switch of high field mobility model and Fermi-Dirac statistics model vsat--Set the model and parameters of velocity saturation For the detailed introduction about electronic parameters, please refer to the document examples/active_demo/Physics_Model_in_OEDevice.pdf. 4.2 DDM settings​ DDM property list： default\ttype\tnotesgeneral.norm_length\t1.0\tfloat general.solver_mode\tsteady_state\tstring\tSelections are ['steady_state', 'transient']. general.temperature_dependence\tIsothermal\tstring\tSelections are ['Isothermal']. general.simulation_temperature\t300\tfloat general.background_material string advanced.non_linear_solver\tNewton\tstring\tSelections are ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', 'LU', 'BCGS']. advanced.fermi_statistics\tdisabled\tstring\tSelections are ['disabled', 'enabled']. advanced.damping\tnone\tstring\tSelections are ['none', 'potential']. advanced.potential_update\t1.0\tfloat advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. advanced.thread_count\t4\tinteger advanced.max_iterations\t15\tinteger advanced.relative_tolerance\t1.0e-5\tfloat advanced.tolerance_relax\t1.0e+5\tfloat advanced.divergence_factor\t1.0e+25\tfloat advanced.saving on divergence\tdisabled\tstring\tSelections are ['disabled', 'enabled']. genrate.genrate_path string genrate.source_fraction float genrate.coordinate_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float geometry.z_min float geometry.z_max float small_signal_ac.perturbation_amplitude\t0.001\tfloat small_signal_ac.frequency_spacing\tsingle\tstring\tSelections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat small_signal_ac.start_frequency\t1.0e+06\tfloat small_signal_ac.stop_frequency\t1.0e+09\tfloat small_signal_ac.frequency_interval\t9.9999e+10\tfloat small_signal_ac.num_frequency_points\t2\tinteger small_signal_ac.log_start_frequency\t1.0e+06\tfloat small_signal_ac.log_stop_frequency\t1.0e+10\tfloat small_signal_ac.log_num_frequency_points\t2\tinteger Description: geometry： dimension--Set the dimension of the simulation region. Only 2D simulation is supportd currently. When it's set to &quot;2d_x_normal&quot;, the simulation is on the yz plane. Similarly for the rest general: norm_length--Set the length in the third dimension, default to be 1solver_mode--Set the simulation mode. Steady state, transient and SSAC simulations are supportedtemperature--Set the simulation temperaturetemperature_dependence--Set the type of the temperature dependence. Only &quot;Isothermal&quot; is supported currently genrate: genrate_path--Set the absolute path of the optical generation rate file (gfile) When it's set to &quot;&quot; (by default), and empty string , no optical generation rate will be appliedWhen it's not empty, the gfile at the path will be imported to apply the optical generation rate coordinate_unit--Set the coordinate unit in the gfile field_length_unit--Set the length unit in the generation rate unit in the gfile source_fraction--Set the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport small_signal_ac: perturbation_amplitude--Set the voltage amplitude of the small signal frequency_spacing--Set the spacing type of the frequency When it's set to &quot;single&quot;, the frequency point is singleWhen it's set to &quot;linear&quot;, the frequency points are uniformly sampledWhen it's set to &quot;log&quot;，the frequency points are uniformly sampled base on the logarithm of frequency frequency--Set the value of the single frequency start_frequency--Set the start frequency of linear spacing stop_frequency--Set the stop frequency of linear spacing frequency_interval--Set the frequency interval of linear spacing num_frequency_points--Set the number of frequency points of linear spacing log_start_frequency--Set the start frequency of logarithmic spacing log_stop_frequency--Set the stop frequency of logarithmic spacing log_num_frequency_points--Set the number of frequency points of logarithmic spacing advanced: non_linear_solver--Set the non-linear solver, only Newton method is supported currentlylinear_solver--Set the linear solver. Options are &quot;MUMPS&quot;, &quot;LU&quot;, &quot;BCGS&quot;. MUMPS and LU are direct linear solvers which usually give the exact solution. However, MUMPS supports parallel computation while LU doesn't. ；&quot;BCGS&quot; is a Krylov subspace (KSP) iterative solver, which also supports parallel computation and is more efficient but can only give approximate results.use_quasi_fermi--Whether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. &quot;enabled&quot; means True, and &quot;disabled&quot; means Falsedamping--Set the nonlinear update damping scheme. &quot;potential&quot; means the damping is based on the potential variationpotential_update--Set the threshold potential for potential damping. The large value will reduce the strength of damping effectmulti_threads: When it's set to &quot;let_solver_choose&quot;, the solver will determine the number of threads to use. The default maximum number of threads is 4When it's set to &quot;set_thread_count&quot;, the number of threads is set by the user to thread_count thread_count--Custom number of threadsmax_iterations--Set global maximum number of iterations, available when use_global_max_iterations is Trueuse_global_max_iterations--Whether to use global max iterations during the initialization of solving the Poisson equations and the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, default to be Truepoisson_max_iterations--Set the max iterations during the initialization of solving the Poisson equations, available when use_global_max_iterations is Falseddm_max_iterations--Set the max iterations during the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, available when use_global_max_iterations is Falserelative_tolerance--Set the relative update tolerancetolerance_relax--Set the tolerance relaxation factor for convergence on relative tolerance criteriadivergence_factor--Nonlinear solver fault with divergence when each individual function norm exceeds the threshold as its absolute tolerance multiply by this factor 4.3 Electrode settings​ Electrodes are added and set up through the add_electrode function. The format of the function is [72] add_ddm_settings(pj, run_options) bd = pj.BoundaryCondition() bd.add(name,type=&quot;Electrode&quot;, property) add_electrode() parameters: name--Electrode nameproperty--Other properties There are two different type of electrical boundary conditions, which are &quot;steady_state&quot;and &quot;transient&quot;, specified by the property electrode_mode. 4.3.1 Steady state boundary condition​ When the property electrode_mode is set to &quot;steady_state&quot;, the steady state boundary condition is applied. Property list of steady state boundary condition: default\ttype\tnotesforce_ohmic\ttrue\tbool electrode_mode\tsteady_state\tstring\tSelections are ['steady_state','transient']. apply_AC_small_signal\tnone\tstring\tSelections are ['none', 'All']. sweep_type\tsingle\tstring\tSelections are ['single', 'range', 'value']. voltage\t0\tfloat\tAvailable when sweep_type is 'single' range_start\t0\tfloat\tAvailable when sweep_type is 'range' range_stop\t1\tfloat\tAvailable when sweep_type is 'range' range_interval\t1\tfloat\tAvailable when sweep_type is 'range' range_num_points\t2\tinteger\tAvailable when sweep_type is 'range' []sweep_value_table.index integer\tAvailable when sweep_type is 'value'. []sweep_value_table.number float\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid string Description: surface_type--Type of the surface to be set as an electrode. Currently only &quot;solid&quot; is supported, meaning that all the surfaces of a structure are selected solid--Name of the structure to be set as an electrode. Available when surface_type is set to &quot;solid&quot; force_ohmic--Whether the electrode is ohmic, default to be True. Currently only ohmic contact is supported, so force_ohmic can't be set to False bc_mode--Set to &quot;steady_state&quot; for steady state boundary condition apply_AC_small_signal: When it's set to &quot;none&quot; (as default), no AC small signal is applied at each sweeping voltageWhen it's set to &quot;All&quot;, the AC small signal is applied after steady state simulation at each sweeping voltage sweep_type--Type of sweeping voltage. Options are &quot;single&quot;, &quot;range&quot; and &quot;value&quot; When it's set to &quot;single&quot;, voltage is requiredWhen it's set to &quot;range&quot;, range_start, range_stop, and range_interval or range_num_points are requiredWhen it's set to &quot;value&quot;, sweep_value_table is required voltage--Set the value of the single voltage range_start--Set the start value of the voltage range range_stop--Set the stop value of the voltage range range_interval--Set the voltage interval of the voltage range range_num_points--Set the number of points of the voltage range sweep_value_table--Table of voltage values. It's a list, whose item is a dictionay. In each of its item: index--Set the index of the voltage valuenumber--Set the value of the voltage Example for single voltage [73] add_ddm_settings(pj, run_options) bd = pj.BoundaryCondition() bd.add(name=gnd,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[gnd]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) Example for voltage range [74] add_ddm_settings(pj, run_options) bd = pj.BoundaryCondition() bd.add(name=vsource,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[vsource]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;steady_state&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: sweep_vstart, &quot;range_stop&quot;: sweep_vstop, &quot;range_step&quot;: sweep_vstep, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, } }) 4.3.2 Transient boundary condition​ When the property electrode_mode is set to &quot;transient&quot;, the transient boundary condition is applied. Property list of transient boundary condition: default\ttype\tnotesforce_ohmic\ttrue\tbool electrode_mode string\tSelections are ['transient']. voltage\t0\tfloat []time_table.time_start float []time_table.time_stop float []time_table.initial_step float []time_table.max_step float []time_table.optical.enabled\t0\tinteger\tSelections are [0, 1] []time_table.optical.envelop integer\tSelections are [0] []time_table.optical.source_fraction float surface_type\tsolid\tstring\tSelections are ['solid']. solid string Description: surface_type, solid, force_ohmic--The same as the one in steady state conditionbc_mode--Set to &quot;transient&quot; for transient boundary condition. Then the time dependence of the optical generation rate can be set at this electrodevoltage--Set the voltage that is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation.v_step_max--Set the max step of the voltage from the equilibrium state to steady state at the bias of voltage.time_table--Set the time dependence of optical generation rate. It's a list, whose item is a dictionary. In each of its item: time_start--Set the start time point of the range. The value of 0 represents the steady state of the earlier simulation.time_stop--Set the stop time point of the rangeinitial_step--Set the initial time step of the rangemax_step--Set the max time step of the rangeoptical--Set the optical generation rate during the time range enabled--Whether to apply optical generation rate during the time range. The value of 1 means True, and 0 means Falseenvelop--The envelop of the scaling factor of the light power during the time range. When it's set to 0, the envelop is uniformsource_fraction--When envelop is set to0, this value is the scaling factor of the light power during the time range Example for transient boundary condition [76] bd = pj.BoundaryCondition() bd.add(name=&quot;cathode&quot;,type=&quot;Electrode&quot;, property={ &quot;geometry&quot;: {&quot;surface_type&quot;: &quot;solid&quot;, &quot;solid&quot;: st[&quot;Cathode&quot;]}, &quot;general&quot;: {&quot;electrode_mode&quot;: &quot;transient&quot;, &quot;contact_type&quot;: &quot;ohmic_contact&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: 0, &quot;range_stop&quot;: 4, &quot;range_step&quot;: 0.5, &quot;apply_ac_small_signal&quot;: &quot;none&quot;, &quot;envelop&quot;: &quot;uniform&quot;, &quot;amplitude&quot;: 1, &quot;time_delay&quot;: 0, &quot;transient_time_control&quot;: [ {&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 2.001e-12, &quot;initial_step&quot;: 3e-17, &quot;max_step&quot;: 3e-17}, {&quot;time_start&quot;: 2.001e-12, &quot;time_stop&quot;: 2.01e-12, &quot;initial_step&quot;: 3e-17, &quot;max_step&quot;: 6e-17}, {&quot;time_start&quot;: 2.01e-12, &quot;time_stop&quot;: 2.03e-12, &quot;initial_step&quot;: 6e-17, &quot;max_step&quot;: 2e-15}, {&quot;time_start&quot;: 2.03e-12, &quot;time_stop&quot;: 1e-11, &quot;initial_step&quot;: 2e-15, &quot;max_step&quot;: 5e-14}, {&quot;time_start&quot;: 1e-11, &quot;time_stop&quot;: 5e-10, &quot;initial_step&quot;: 5e-14, &quot;max_step&quot;: 1e-11}, ] } ","keywords":""},{"title":"Obtain Technical Support","type":0,"sectionRef":"#","url":"/my-website/docs/faq/ObtainTechnicalSupport","content":"Obtain Technical Support When you need technical support or have inquiries related to using Max-Optics, you can follow these steps to obtain support and write a request for assistance: Clearly State the Issue or Requirement:​ Describe the issue or requirement concisely. Use clear language to explain the specific support you are seeking. Provide Detailed Information:​ Provide as much relevant information as possible about the issue, such as error messages, steps taken, software version, operating system, etc. This will assist the support personnel in analyzing and diagnosing the problem. Include Screenshots or Log Files:​ If applicable, attach relevant screenshots or log files to supplement the problem description. These visual aids provide additional context and facilitate the identification and resolution of the issue. List Attempted Solutions:​ If you have already attempted some solutions without success, mention them in your request. Provide details of the steps you have taken and the outcomes. This will help the support team understand the efforts you have already made and avoid repetition. Others:​ If you have other suggestions for designing software features or optimizing physical modules, we look forward to talking to you. Please contact our customer support team. Contact Information: Phone: 150 6666 1688E-mail: sales@max-optics.comE-mail：support@max-optics.com","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Installation","content":"Installation How to Install Max-Optics GUI Software?​ Max-Optics Studio Local Passive Software Installation 1. Open the Installation Package​ Find the Setup.exe package, double-click to open the MOPassive-x.x.x.x+build.xxxxxxxx-setup installation package. If there is a pop-up window come out, please press the “Run” button and wait to run. Check the contents and click &quot;I Accept The Agreement&quot; item, then click &quot;Next&quot;. 2. Select Destination Location​ User can custom destination location by pressing “Browse...” button , or just use the auto-default location, then press the “Next” button. 3. Select Start Menu Folder &amp; Create a Shortcut​ In the &quot;Select Start Menu Folder&quot; window, users can either click the &quot;Next&quot; button directly or customize the location for shortcuts by clicking the &quot;Browse...&quot; button. In the &quot;Select Additional Tasks&quot; window, users can choose to create a desktop shortcut by selecting the &quot;Create a desktop shortcut&quot; option, and then proceed by clicking the &quot;Next&quot; button. Alternatively, users can simply uncheck the option and click the &quot;Next&quot; button directly. 4. Ready to Install​ In the &quot;Ready to Install&quot; window, click the &quot;Install&quot; button to proceed with the installation. 5. Installing​ Please wait, until installation is complete. 6. Restart​ Check either the “yes, restart the computer now” or “No, I will restart the computer later” to invoke the software. Then press “Finish” button. 7. Complete​ Once the installation is complete, the user can find a shortcut to the software on their desktop. Notes: User can double click the shortcut to invoke the software; User also can double click a .passive file to open the software automatically How to Install Max-Optics SDK Software?​ 1. Installing Python.​ AIO SDK only supports Python 3.8.x. If you have Python already installed, please verify its version. If you have multiple Python versions installed, ensure that the version specified in the PATH environment variable is Python 3.8.x. If Python is not installed, follow the instructions below: ① Open the 'python-3.8.X-amd64.exe' from the trial package. ② Choose 'Customize installation'. ③ Check the 'Add Python 3.8 to PATH' option. Note: When customizing the installation path, ensure that the folder name in the installation path does not contain any spaces. Spaces can cause the SDK to be unable to locate the Python path (due to code syntax reasons) . We recommend using the installation path: 'D:\\Python\\Python38,' as this path aligns with the default setting path in SDK's settings.json. 2. Install VS Code​ For Python code environment, using a code editor is helpful for managing the SDK simulation script results. Here, we select the free code editor, Visual Studio Code (VSCode) , as the editor for SDK scripts. This section provides guidance on the installation process and considerations for VSCode. ① Install 'VSCodeUserSetup-x64-1.74.3.exe,' just as the default settings. ② In the extensions, search for and install the Python plugin to enhance VSCode's support for the Python development environment. Note that the installation of the SDK and subsequent model simulations will be done within the VSCode interface. 3. Install the SDK​ SDK Directory Structure: ├─.vscode │ settings.json │ tasks.json │ ├─ci │ requirements.txt │ └─wheels SDK dependencies.whl .vscode：Configuration files to enable running tasks in the SDK within VSCode.ci：The requirements.txt file contains information about dependencies and their versions needed to install the SDK.wheels：This directory contains all the dependencies required to install the SDK. P.S.This directory contains all the dependencies required to install the SDK. 3.1 Placing the SDK Folder Put the SDK folder in the directory where you want to manage model scripts and simulation data. It is recommended to place it in the root directory of the D drive. 3.2 Opening the SDK Folder with VSCode (1) Click 'File' in VSCode. (2) Select 'Open Folder' from the dropdown menu. (3) Choose the 'AIO_SDK' folder. 3.3 Configuring the VSCode Environment for the SDK (1) In VSCode's file explorer, open the 'settings.json' file within the '.vscode' folder. (2) In the editing area, set the path to the location of 'python3.8.x.exe,' which is by default 'D:\\Python\\Python38\\python.exe.' 3.4 Reasons for Creating a Python Virtual Environment A virtual environment is an isolated environment separate from the entire computer's operating system. When you install and run AIO_SDK within a virtual environment, it ensures that AIO_SDK doesn't conflict with dependencies already present in the Windows environment. Dependency conflicts can potentially prevent the SDK from functioning correctly. We have already configured a script (tasks.json) to generate a virtual environment and install AIO_SDK. However, Windows, in the interest of system security, may prevent the execution of this configuration script. Therefore, we need to modify the execution policy for Windows scripts to ensure that the subsequent steps proceed smoothly. 3.5 Modify the Execution Policy for Windows Scripts (1) Run 'Windows PowerShell' as an administrator. (2) Enter 'Set-ExecutionPolicy RemoteSigned' and press Enter. If prompted to change the policy, type 'Y' and press Enter. At this point, the security policy for running Windows scripts has been changed. 3.6 Create the virtual environment through the 'Create PIP' task. Click on 'Terminal' and select 'Run Task' from the dropdown menu. A new menu will pop up in VSCode, and within that menu, choose 'Create PIP'. VSCode will automatically open a terminal to install the SDK. After the installation is complete, press any key to exit. 4. Enable the Virtual Environment​ Through the previous steps, you should see the .venv_maxoptics folder in the VSCode file explorer. We need to activate the virtual environment where the SDK is installed. Here are the configuration steps: (1) In VSCode, press F1 to bring up the menu, as shown in the image. (2) Click 'Python: Select Interpreter' and in the new menu, select the interpreter as shown in the image. This interpreter is the virtual environment where the SDK is installed. (3) Start a new terminal and you should see the virtual environment indicator (.venv_maxoptics) in the terminal bar, indicating the successful activation of the virtual environment. 5. How to Access the Handbook​ In VSCode, open a terminal, and the .venv_maxoptics virtual environment will be activated. You can access the handbook by entering the 'mo.sdk doc' command. This step can also serve as a test to verify the correct installation of the software. 6. Copying Examples​ In VSCode, open a terminal, and the .venv_maxoptics virtual environment will be activated. You can import simulation model examples by entering the 'mo.sdk init -n examples' command. Here, '-n' specifies the name of the target folder to copy the examples to. At this point, a set of example script samples named 'examples' will be created in the AIO_SDK folder. 7. Run File​ In the 'examples' folder, open a .py script file for a specific example. Run the 'Run File' task in the terminal to execute the script and perform the simulation. 8. License Configuration:​ Note: Trial licenses and the passive standalone version use the same configuration. If you've already configured a passive standalone license, there's no need to repeat the process. (1) Online License Activation: ① Open the 'MaxOpticsSDK__LicenseManager_x64.exe' license management tool. ② Click 'Activate' (the first button on the upper left) . ③ Select 'Activate automatically via the internet,' and confirm. (2) Offline License Activation: ① Open the 'MaxOpticsSDK__LicenseManager_x64.exe' license management tool. ② Click 'Activate' (the first button on the upper left) .Choose 'Unable to connect to the internet, activate via offline mode' and confirm. ③ Select 'Use activation file,' change the file type to *.txt, and open the 'ZAKT5VW6LY37KNU7-pre.txt' file. ④ A dialog will appear confirming a successful license activation and prompting you to save a confirmation file. Click 'Confirm' and select any folder to save the confirmation file. What to Do If You Encounter an Error During &quot;Create PIP&quot; with a Version Not Found?​ If you encounter an error stating that the required version cannot be found while creating a PIP during the SDK installation： ERROR: Could not find a version that satisfies the requirement max_optics_sdk~ You should first check whether your Python version is 3.8.* as we currently only support this version. Additionally, ensure that the &quot;wheels&quot; folder contains the following three files: max_optics_local_sdk-2.3.0.4.630.2001-cp38-cp38-win_amd64.whl max_optics_sdk-2.3.0.4.630.2000-py3-none-any.whl max_optics_whale-2.3.0.4.630.2003-cp38-cp38-win_amd64.whl Finally, double-check the version information in the &quot;requirements.txt&quot; file to ensure that it matches the versions of the three files mentioned earlier. The error &quot;Tunnel Breakoff&quot; occurs when you open the software for the first time after installation. What should you do?​ You can check if the software was mistakenly installed in a Chinese directory path, if any antivirus software that does not support installation has been closed (currently Tencent Guardian and Windows Defender support MO software usage) , and if the service has been started. Then, restart your computer, reinstall the software, and check if it's installed on the C drive (some users may not have sufficient permissions on the C drive) . Finally, run it as an administrator..\\MOService\\bin\\Release\\mol-mid-pas-console.exe(中间件服务) 。 How to configure and use group services?​ Our Max-Optics series products utilize group authorization services to provide a secure and reliable software protection and authorization management solution. The same licensing configuration method is available for end-users. Since standalone active software products involve and utilize third-party software, you will need to separately configure the license for third-party software. Group authorization refers to deploying it within the local area network of group users, and users will need to install a dedicated group authorization service program to provide comprehensive authorization support for users within the group. After installing the relevant Max-Optics software product, the process for configuring the group service is as follows: 1、Firstly, you need to obtain the License Server IP address and port number from your company's administrator, typically in the format such as 192.168.91.67:8273. 2、In the software installation package, locate the BitAnswer user client configuration software, typically found within the BitAnswer folder. 3、Double-click the configuration software to open the configuration interface. 4、You can configure the License service address using either the &quot;自动查找&quot; or &quot;手动设置&quot; method. (1) Auto Search ① In the &quot;集团服务器列表&quot; select the corresponding IP address row. If there is no corresponding IP address, click the &quot;刷新&quot; button. ② In the &quot;集团服务器列表&quot; select the corresponding IP address row, and then click the &quot;应用&quot; button. ③ A prompt saying &quot;服务器设置成功&quot; will appear. Click the &quot;确定&quot; button. ④ In the &quot;集团服务器设置工具&quot; window, click the &quot;退出&quot; button. Your configuration is now complete. (2) Manual Settings ① In the &quot;设置集团服务器地址&quot; window, enter the IP address and port number that you obtained, then click the &quot;设置&quot; button. ② In the &quot;Group Server Configuration Tool&quot; window, click the &quot;Exit&quot; button. Your configuration is now complete. 4、Max-Optics Studio Active Standalone Version and SDK Extra Configuration Max-Optics Studio active standalone version and SDK products require additional configuration for third-party software components. These components come with two types of license files: trial and full versions. The trial version allows multi-user access and serves as a trial version for users to evaluate before making a formal purchase. The full version, on the other hand, is restricted to a single user and binds to a unique physical machine address for usage. If you install both the Max-Optics Studio active standalone version and the SDK, the configuration of the third-party software's license only needs to be done once. (1) Configuration Method 1 First, place the license file, and then configure the environment variables. This configuration method is only applicable to trial version license files. ① Start by placing the license file in a specified directory. The path for this directory can be chosen based on your preferences. In this document, the author has set the path as shown in the following image: ② Open the system environment variable configuration interface and create a new variable in the system variables. The variable name should be &quot;LM_LICENSE_FILE&quot; (it must be this name) , and the value of the variable should be the absolute path to the license file. Open the &quot;Search&quot; window and type &quot;environment variables&quot; to find &quot;Edit the system environment variables.&quot; Select and open this window. Select the &quot;Advanced&quot; tab, then choose the &quot;Environment Variables&quot; button. Click the &quot;New&quot; button. After filling in the &quot;Variable name&quot; and &quot;Variable value,&quot; click the &quot;OK&quot; button to return to the previous screen. After filling in the &quot;Variable name&quot; and &quot;Variable value,&quot; click the &quot;OK&quot; button to return to the previous screen. On the interface, click the &quot;OK&quot; button to complete the setup. (1) Configuration Method 2 Formal version license files are only applicable to Configuration Method 2, but trial version licenses can also be configured using this method. ① Check your local machine information. Run &quot;ipconfig /all&quot; in the command line to view the Windows IP configuration. Take note of two pieces of data: the hostname and the physical address of the Ethernet adapter, as you will need them in the following steps. ② Modify the License File You need to modify the license file (*.lic) that was provided to you. The normal content should be as follows: In the first line, modify the data according to your local machine. Replace &quot;MG-SE-limao-01&quot; with your machine's hostname, and &quot;1C697AF3CF58&quot; with your machine's physical address (do not include the hyphens when inputting) . The second line must be &quot;VENDOR COGENDA,&quot; please keep it consistent with the image. The third line must be &quot;USE_SERVER,&quot; also keep it consistent with the image. ③ Double-Click to Start the shell.bat Script Locate the directory where you have installed the third-party software (default installation path: C:\\Program Files\\Genius) . Enter the &quot;Bin&quot; folder and copy the modified license file there. Then, double-click the &quot;shell.bat&quot; located in the same directory. ④ Enter the Activation Service Command In the startup window, enter the command: &quot;lmgrd -c license_filename.lic,&quot; where the &quot;-c&quot; option is the certificate address path for the third-party software. After successful validation, two windows will pop up. Do not close these windows while using the third-party software. Group authorization services support a specific number of users. When the user limit is reached, it will prompt: &quot;The number of activated machines has reached the limit, and the authorization code cannot be used on more machines.&quot; For more common issues and error messages, please visit the following URL: https://bit.bitanswer.cn/doc/?t=welcome How to resolve the issue when encountered the common error codes in MO Passive?​ 1.Error Code 264​ Possible Reasons: 1) Incorrect IP or port entered in the Group Service Settings Tool. 2) VPN enabled on the client. 3) Network transmission error. Solution: 1) Verify that the IP and port are entered correctly. 2) Disable VPN. 3) Ensure a stable network connection. 2.Error Code 531​ Possible Reasons: 1) Authorization code blacklisted due to frequent server connections. 2) Group-authorized client access rules prohibiting access. Solution: 1) Access the Bit platform, enter the authorization code, click on &quot;Query,&quot; then click on the authorization code to access detailed information, and remove it from the blacklist. 2) Access the Group Authorization Management Center and remove restrictions in the corresponding product permissions. 3.Error Code 1283​ Possible Reasons: 1) Specified feature item not found. 2) Authorization code not upgraded. Solution: 1) Developers should log in to the control panel, check the relevant feature items in the authorization code, and save the changes. 2) Log in to the Group Authorization Management Center to upgrade the authorization code. If you encounter any issues during usage, please contact your company's administrator or Max-Optics technical support personnel: Phone: 150 6666 1688Email: sales@max-optics.com","keywords":""},{"title":"General","type":0,"sectionRef":"#","url":"/my-website/docs/faq/General","content":"","keywords":""},{"title":"What is Max-Optics?​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#what-is-max-optics","content":"公司简介：​ 上海曼光信息科技有限公司，成立于2018年8月。公司依托山东大学科研团队力量，凭借坚实的电磁场仿真与分析理论与技术基础，以及完备的自动化设备设计与制造、软件设计与开发能力研发出覆盖微波及光学频段的电磁场可视化软硬件产品，为客户提供完善的电磁场相关的仿真、设计、分析、测量解决方案。 公司业务面向5G、光通信、光电传感、光计算、工业物联网、国防安全等领域，主要涵盖电磁场仿真与测量两大业务。电磁仿真业务主要产品包括无源/有源光电芯片及系统仿真设计软件、光电芯片仿真设计服务、微波/射频天线仿真设计服务。电磁场测量业务光电子器件测量与参数提取平台；微波毫米波测量业务主要产品包括5G NR OTA测试系统、平面/柱面/球面近远场天线测试系统；公司以客户为中心，从客户直接需求出发，完成涵盖自动化测量设备软硬件定制化设计、制造、开发、交付的交钥匙工程，并提供电磁场相关设计与测量分析增值服务。 Company Profile:​ Shanghai Max-Optics Information Technology Co.,Ltd was established in August 2018. With the support of the research team from Shandong University, the company has developed electromagnetic field visualization software and hardware products covering microwave and optical frequency bands, based on solid electromagnetic field simulation and analysis theory and technology foundation, as well as comprehensive capabilities in automated equipment design and manufacturing, software design and development. These products provide customers with comprehensive solutions for electromagnetic field simulation, design, analysis, and measurement. The company's business focuses on 5G, optical communication, optoelectronic sensing, optical computing, industrial IoT, and defense security. It mainly covers two major businesses: electromagnetic field simulation and measurement. The electromagnetic simulation business includes simulation design software for passive/active optoelectronic chips and systems, optoelectronic chip simulation design services, and microwave/radio frequency antenna simulation design services. The electromagnetic field measurement business includes optoelectronic device measurement and parameter extraction platforms. The microwave millimeter wave measurement business mainly includes 5G NR OTA testing systems, planar/cylindrical/spherical near-field and far-field antenna testing systems. The company is customer-oriented, starting from the direct needs of customers, and completes turnkey projects that cover customized design, manufacturing, development, and delivery of automated measurement equipment hardware and software. It also provides value-added services for electromagnetic field design and measurement analysis. What are our advantages?​ We are the first company in the industry to offer a &quot;local + cloud&quot; computing platform for photonics integrated circuit (PIC) simulation software. We provide a one-stop solution, delivering software, resources, and technical support anytime, anywhere. The Importance of Software Simulation: As semiconductor devices continue to evolve towards smaller sizes and more complex structures, the use of simulation software solutions offers numerous advantages over laboratory measurement methods, playing a crucial role in semiconductor device development. Highly accurate algorithms enable rapid modeling and simulation of devices, allowing the observation of internal physical processes. Through simulation software, customers can not only design new and complex device structures but also propose solutions to optimize device performance by altering operating conditions or various physical quantities and parameters within device models. From simulating photonic integrated circuits to various types of simulations in different fields, spanning from materials to systems, the use of simulation software not only reduces production costs, shortens development cycles, and increases productivity but also provides clear and concise results data for researchers in various domains to collaborate on complex projects more effectively. Software Uniqueness: We offer two software forms based on 'local + cloud' integration. The first is a software development toolkit SDK based on Python scripting, which includes modeling, simulation, post-processing, and data visualization capabilities. It can call all modules and is user-friendly, easy to learn, and easy to extend. The second is a GUI user interface, enabling interactive simulations using both forms. Additionally, we incorporate advanced grid optimization and GPU acceleration to reduce simulation times. We also provide virtual machine and Windows versions to accommodate various simulation environments preferred by our customers. Key Product Advantages: We currently provide an efficient and reliable one-stop solution for both passive and active devices, combining multiple simulation algorithms. Our simulations exhibit industry-leading accuracy and speed. What products do we currently have?​ We currently support a range of devices, including passive devices, modulators, detectors, and lasers. We've enhanced classical CEM algorithms for analyzing the behavior of light and introduced a novel 'local + cloud' user interface configuration to utilize passive modules for simulating optical waveguides and passive optical devices. Additionally, we've combined carrier transport simulation algorithms with electromagnetic simulation algorithms, providing an efficient and reliable one-stop solution for simulating optoelectronic active devices. For more detailed information on specific device products, please visit the 'Example Library' section on our website. To learn more about our SDK software products, please visit the 'Max-Optics SDK' section on our website for case descriptions related to the software. What functions are available for passive devices simulation?​ We have enhanced the classical CEM algorithm and introduced a novel 'local + cloud' user interface configuration to utilize passive modules for simulating optical waveguides and passive optical devices. The following are the modules supported for passive component simulation: FDTD Module\tShared Module\tEME Module• Mode/Gaussian/Import source • PML/PEC boundary • 0D/1D/2D/3D frequency monitor • 0D/1D/2D/3D time monitor • Early Shutoff • Transmission calculation • Mode expansion • S-parameters calculation • Global parameter sweeping • Multi-threaded computing\t• 3D Modeling• GDS import • Tilt slope of waveguide profile • Non-Uniform/Uniform Mesh • Conformal Mesh Refinement • Standard material library • Custom isotropic/diagonally anisotropic materials • Far field\t• Effective Index Calculation • Group Index Calculation • Arbitrary port settings • PEC/PMC/PML boundary • 2D frequency domain monitor • S-parameter calculation • Frequency Sweeping • Group span quick sweeping • Overlap Analysis • Multi-threaded Computing What functions are available for active component simulation?​ Our active module seamlessly integrates optical and electrical modules, combining carrier transport simulation algorithms with electromagnetic simulation algorithms. This one-stop solution allows for efficient and reliable simulation of optoelectronic active devices with the ability to perform multiple diverse simulations in a single model. The following are the modules supported for active component simulation. AFDTD Module\tAFDE Module\tOEDevice Module• Mode Source • PML/PEC Boundary • 0D/1D/2D/3D Frequency Monitor • Early Shutoff • Transmission Calculation • Multi-thread Computing • Generation Rate Extraction\t• Effective Index Calculation • Group Index Calculation • VpiL, VpiLoss Extraction\t• Steady State / SSAC / Transient Simulation • Physical Models and Parameters of Electrical • Materials • Multi-thread Computing • Convergence Control • Carrier / Potential / Band Profile Monitor • Doping Import • Generation Rate ImportShared Module\tShared Module for AFDTD and AFDE• 3D Modeling • GDS Import\t• Non-Uniform/Uniform Mesh • Conformal Mesh Refinement • Standard Material Library • Custom Isotropic Optical Materials Which simulation modules are applied?​ We employ the finite-difference numerical method for device structure, doping, and grid division within the simulation region. It approximates differentiation with finite differences. We use the Finite-Difference Eigenmode (FDE) method to investigate the field distribution of eigenmodes, as well as the refractive index and losses of devices. The Finite-Difference Time-Domain (FDTD) method is used to study the transmission rate, reflectance, and losses of small to medium-sized devices. For longer devices, we utilize the Eigenmode Expansion Method (EME) to discuss their transmission rate, reflectance, and losses. 1、Max-Optics Studio-FDTD Max-Optics Studio FDTD is a powerful domestic tool for simulating micro-nano optoelectronic devices. It boasts advanced GPU acceleration capabilities, enabling fast solutions to three-dimensional/two-dimensional Maxwell's equations. It offers precise analysis of various sub-wavelength structures in micro-nano optoelectronic devices and the propagation of electromagnetic fields in materials, as well as the interaction between light and matter. It supports both a graphical user interface and script-based operations, making it a valuable assistant for your optoelectronic innovations. It features the unique real-time field overlay function, allowing the direct overlay of the optical field iteration progress onto the 3D CAD structure, providing a clear visual representation of the simulation progress. Key Product Features： —— GPU Acceleration Technology Max-Optics offers a unique GPU FDTD algorithm acceleration technology that leverages the GPU's multi-core resources to increase FDTD computational speed by more than tenfold. This is achieved through efficient thread management and memory access planning, making the most of the GPU's capabilities. 2、Max-Optics Studio-EME Max-Optics Studio EME is an efficient simulation tool for modeling long-distance transmission devices. It supports mode analysis using the Finite-Difference Eigenmode (FDE) method under the Finite-Difference Algorithm, as well as Eigenmode Expansion for propagation, and overlap integral calculations. Key Product Features： —— Curve Mesh Technology Max-Optics introduces a unique 3D curve mesh grid technology that enables precise equivalence for curved or surface structures when using a hexahedral grid. This allows for reduced mesh density without sacrificing computational accuracy, resulting in improved computational efficiency. —— Curve Mesh Technology • The EME module benefits from a 50% reduction in the number of required computational modes, leading to increased computational stability. 3、Max-Optics Studio-OE Device OE Device is a one-stop solution, providing a convenient tool for simultaneous electromagnetic field and carrier motion simulation in active optoelectronic devices. It allows for self-consistent solutions of the electromagnetic field (Maxwell's equations), electrostatic potential (Poisson's equation), and free carrier density (drift-diffusion equations). The entire modeling and simulation process can be completed in one interface. 4、Max-Optics Studio-MO Link MO Link is a link-level simulation tool for photonic chips, supporting multi-mode, bidirectional, and multi-channel simulations. What product forms do we offer?​ We have introduced two software formats that accommodate both offline and cloud-based usage. Offline simulations can be carried out solely using local computing resources. These formats comprise a Software Development Toolkit (SDK) and a GUI user interface. SDK is based on Python scripting. It offers a standardized approach for invoking all modules and supports the import of GDS files. When building simulations within the SDK, the option to generate GUI files is available, providing a more intuitive simulation experience. Product Formats\tWeb-based\tStandalone\tSDKDisplay Features\t•Supports cross-platform login •Flexible scheduling of cloud-based computing resources\t•Local computing resources •Familiar and straightforward operation •Complete 3D modeling interface •Automatic simulation history saving and playback •Allows setting global variable expressions in any input box •Supports non-proportional scaling of simulation structures •Supports script-based modeling •Supports GDS-II import •Integrates a variety of third-party Python open-source libraries •Allows for the use of local and cloud-based computing resources •Convenient interaction with third-party tools •Includes built-in example code for quick start If you would like to learn more about SDK installation and usage instructions, please visit the 'Max-Optics SDK' section on our website for detailed information. What services do we provide?​ Our company's core businesses primarily encompass two major sectors: optoelectronic integrated circuit (OEIC) simulation software and chip and system testing. In the field of optoelectronic integrated circuit simulation software, our main products include passive/active OEIC and system simulation design software, OEIC testing system solutions and services, customized OEIC simulation process services, customized microwave/RF simulation and testing system services. These products and solutions have been successfully applied to top domestic clients, ensuring business continuity within the domestic industry and earning us an excellent reputation. In particular, in the field of optoelectronic integrated circuit simulation design software, Max-Optics has broken through international technical barriers related to the core algorithms and 'know-how' of optoelectronic chips. We have pioneered the development of a cloud-based optoelectronic chip simulation design platform, providing efficient optoelectronic integrated circuit simulation design tools for optical communication, optical computing, optical sensing, quantum computing, and optical displays. Our services benefit areas such as 5G, artificial intelligence, and national defense and security. Education and Training: On our official website, we offer answers to common questions related to device simulation and software installation, which you can independently access online. We have a detailed and typical device case library, complemented by instructional videos and documentation, making it easy for users to acquire professional knowledge about semiconductor physics and software usage. For detailed information about device cases and calculation methods, please visit the 'Example Library' and 'Tutorials' sections on this website. For software installation and usage inquiries, please visit the 'Max-Optics SDK' section. Technical Support Team: Our technical support team possesses extensive professional knowledge and can understand, diagnose, and resolve technology-related issues. We are committed to optimizing devices using proven device modeling methods to address technology development and manufacturing issues, providing customers with calibration, simulation, model development, and consultation services. For users with unique semiconductor device modeling requirements but lacking the time or resources to use SDK software in-house, we offer modeling services, providing complete, fast, and accurate solutions. Deliverables include but are not limited to graphical outputs (structural and characteristic diagrams), structures (device structures and grids), and device characteristic data. You can submit feedback online, or contact us via phone and email. Software Support Team: Our software support team consists of experienced engineers dedicated to software product feature and algorithm development. They also provide license verification, software, and computing platform installation services to customers. Feel free to reach out to us via phone or email:： Phone：150 6666 1688 E-mail：sales@max-optics.comE-mail：support@max-optics.com How to access technical support services?​ When you need technical support or have inquiries related to using Max-Optics, you can follow these steps to obtain support and write a request for assistance: Clearly State the Issue or Requirement: Describe the issue or requirement concisely. Use clear language to explain the specific support you are seeking. Provide Detailed Information: Provide as much relevant information as possible about the issue, such as error messages, steps taken, software version, operating system, etc. This will assist the support personnel in analyzing and diagnosing the problem. Include Screenshots or Log Files: If applicable, attach relevant screenshots or log files to supplement the problem description. These visual aids provide additional context and facilitate the identification and resolution of the issue. List Attempted Solutions: If you have already attempted some solutions without success, mention them in your request. Provide details of the steps you have taken and the outcomes. This will help the support team understand the efforts you have already made and avoid repetition. Be Polite and Clear: Maintain a polite and clear tone when writing your support request. Use professional language and appropriate etiquette to express your issue or requirement and express gratitude for the support team's assistance. Please contact our customer support team. Contact Information: Phone: 150 6666 1688E-mail: sales@max-optics.comE-mail：support@max-optics.com How to set up licensing for remote work or home office use?​ If your company has a group licensing arrangement with the server set up on the corporate intranet, this answer explains how individuals can set up licensing to successfully use our software when working remotely or from home. You can use a VPN to connect to the corporate network from a remote location. If you don't have VPN access, you can request permission from your company's internal licensing server administrator to open public access (with a public IP and port) for you. Then, in the software settings, you can specify the server's IP address as the newly approved public address. Alternatively, we can guide the administrators of your company's licensing server to implement a 'group licensing checkout' mode, allocating one license from the total number of licenses purchased as a temporary offline license. The specific steps for this process are as follows. Setting Up Group Licensing Checkout Mode: (1) Log in to https://bit.bitanswer.cn (2) In the left sidebar, select the '业务' menu. (3) In the '授权信息' on the right, select '授权借出'. How to configure a jupyter environment for AIO SDK?​ In the command line, activate the virtual environment where the All-in-One SDK is located, and then follow these steps: (1) Install ipykernel. pip install ipykernel (2) Write the environment to the kernel of notebook. python -m ipykernel install --user --name &quot;mang1903&quot; --display-name &quot;mang1903&quot; (3) Open Jupyter Notebook. jupyter notebook (4) Click 'New' to create an ipynb file. You will see the kernel option 'mang1903' ('mang1903' is the display name of the previously set 'mang1903' virtual environment, and users can customize it). What to do if there are spaces in the python installation path?​ If there are spaces in the Python installation path, you may encounter errors when creating a virtual environment in the first step of installing AIO. The system may mistakenly interpret the path before the space as a separate command. In such cases, if you cannot modify the Python installation path, you can enclose the path in double quotes or use a raw string, as shown below: path = &quot;C:/Program files/Python/python.exe&quot;  "},{"title":"About the basic concept","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/basic concept","content":"About the basic concept Mode​ Modes refer to the stable transmission of electromagnetic waves in a waveguide, with each mode corresponding to a characteristic solution of Maxwell's equation in the waveguide. Each mode has a stable field distribution and different modes are orthogonal to each other. Propagation constant​ The real part of the propagation constant represents the phase velocity, while the imaginary part represents the loss or gain. Effective refractive index​ The direction and velocity of propagation vary with wavelength, medium structure, and refractive index. The ratio of propagation constant to vacuum wave vector is defined as the effective refractive index of the propagation direction. β=neff2πλβ = n_eff \\frac{2π}{λ}β=ne​ffλ2π​ Phase velocity​ The propagation speed of light of a certain mode at a single frequency. Vp=cneffV_p = \\frac{c}{n_eff}Vp​=ne​ffc​ Group refractive index​ A type of average refractive index formed by changes in the speed and direction of light propagation due to factors such as non-uniformity of the propagation medium and wavelength of light. ng=neff−λdndλn_g=n_eff-λ\\frac{dn}{dλ}ng​=ne​ff−λdλdn​ Coupling​ When power transmission occurs within or between waveguides, it is called coupling between two modes. Two conditions need to be met: The mode overlap integral is not zero.the phase matching condition.","keywords":""},{"title":"How to set boundary condition?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/BC","content":"How to set boundary condition? The boundary conditions include perfectly matched layer (PML), perfect electric conductor (PEC), symmetric and antisymmetric. 1.PML​ The intensity of the light field after entering the PML will decay, which can be used to absorb the electromagnetic field at the boundary. You can set the absorption of PML through the following parameters. Number of layers of PML.Kappa Alpha and Sigma are the orders of polynomials.Increasing Kappa will enhance the absorption of evanescent waves and weaken the absorption of guided modes.Increasing Sigma will reduce reflection and increase dispersion error.Increasing the value of Alpha/Sigma improves the stability of absorption, but the absorption effect will decrease.Increasing Alpha/Sigma increases stability and reduces absorption capacity. The light on the PML interface also generates reflections, which can be reduced by extending the structure through the boundary region.For the EME solver, Max-Optics optimized PML to improve mode orthogonality, which resulted in reduced absorption of guided modes. The general PML parameters of FDTD are as follows: {&quot;pml_layer&quot;:8,&quot;pml_kappa:2,&quot;pml_sigma&quot;:0.8,&quot;pml_polynomial&quot;:3,&quot;pml_alpha&quot;:0,&quot;pml_alpha_polynomial&quot;:1}. 2.PEC​ The conductivity of PEC is infinite and the penetration depth is almost zero, used to reflect electromagnetic fields. It reflects almost 100% without any energy loss. In FDE/EME simulation, the default boundary condition is PEC, and it can greatly reduce simulation time. 3.Symmetric​ When there is a symmetry plane in the structure, certain field components must be zero on the symmetry plane. The use of symmetric boundary conditions can make the horizontal component of the electric field and the vertical component of the magnetic field zero. In periodic structures, using symmetric boundary conditions at the boundary where the source polarization is tangent can shorten the simulation time by half. 4.Anti-Symmetric​ Similarly, using asymmetric boundary conditions can make the vertical component of the electric field and the horizontal component of the magnetic field zero. In periodic structures, asymmetric boundary conditions are used at the boundary perpendicular to the source polarization. If used together with symmetric boundary conditions, it can save four times the time. What situations require strengthening the absorption of PML?​ The default parameters of PML are more accurate for the simulation results of (Bragg grating, spot size converter), and parameter settings that increase guided mode absorption are needed for radiation devices. For the FDTD solver, the absorption parameters of the PML layer are consistent with the Gloden software. Grating coupler is a device with strong radiation, which requires an increase in PML during simulation_ Sigma to improve absorption capacity.Users can moderately increase PML as needed_ The number of layers, but having too many layers can greatly increase simulation time.The PML boundary is calculated in the complex domain, so the calculation time and memory are generally more than twice that of the PEC/PML boundary.","keywords":""},{"title":"How to set up EME scanning?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/EME wavelength sweep","content":"","keywords":""},{"title":"EME length sweep​","type":1,"pageTitle":"How to set up EME scanning?","url":"/my-website/docs/faq/Physics/EME wavelength sweep#eme-length-sweep","content":"EME has great advantages in scanning calculation in the length direction, it does not need to repeatedly calculate the modes at the interface of the divided units, and can quickly obtain the transmitted S-matrix. Open the &quot;length sweep&quot; in the EME solver, select the length range of the scanning area, the number of scanning points, and the mode of the light source to obtain the s matrix transmitted by this mode. EME wavelength sweep​ Due to the variation of mode distribution and effective refractive index with wavelength, wavelength scanning of EME is not suitable for scenarios with high material dispersion and mode dispersion. Taking the classic core size 500∙200 nm^2 SOI waveguide as an example, the accuracy of wavelength scanning is within 5% in the ±40 nm wavelength range. However, this result varies depending on the size, structure, and material of the waveguide, and requires users to judge and verify based on the usage scenario. In order to improve the calculation speed, this feature is disabled by default and can be opened in the settings of the solver EME with the option &quot;use wavelength sweep&quot;. "},{"title":"How to set the position of the light source and monitor?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/location","content":"How to set the position of the light source and monitor? To reduce simulation errors caused by grid accuracy, the Source and Monitor should be placed in the position of the straight waveguide. The calculation of &quot;mode source&quot; in FDTD is based on the position and size of the mode light source, so the calculated mode is suitable for stable transmission on cross-sections of the same size. If the position of the light source set by the user is in an area with structural changes, numerical errors may occur when encountering other waveguide cross-sections of different sizes without forming stable transmission due to the discretization of the Yee grid. Therefore, it is recommended that at least 3 grids around the Source be in the straight waveguide region, and the Monitor will also have the same problem when detecting mode energy. It is also recommended that at least 3 grids around the Monitor be in the straight waveguide region.","keywords":""},{"title":"How to set mesh?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/mesh","content":"","keywords":""},{"title":"1 Mesh type​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#1-mesh-type","content":"Solver\tFDE\tEME\tFDTD\tdescriptionuniform\t√\t√\t√\tThe grid size in the x, y, and z directions are the same in the structure. auto non-uniform √ The size of the non-uniform grid is determined by &quot;cells per wavelength&quot;, and the grid size is the wavelength in the structure divided by &quot;cells per wavelength&quot;. 1.1 Uniform​ The uniform type of grid is evenly distributed in the x, y, and z directions, and the step size of the grid is set by the user. 1.2 Auto non-uniform​ Global automatic non-uniform grid distribution, with &quot;cells per wavelength&quot; determining the grid size at different positions. The grid division uses the same &quot;cells per wavelength&quot;, so the grid step size is smaller in areas with high refractive index. 2 Mesh type refinement​ According to the different ways in which the refractive index of materials is filled in hexahedral and rectangular grids, they can be divided into &quot;staircase&quot; and &quot;curve mesh&quot; types of grids. 2.1Staircase​ When multiple materials appear in a grid, one of them will be selected as the filling material for the grid. The size of the divided grid is too large, which can easily create a stepped shape in curved structures. As shown in the figure below, the refractive index distribution of the structure is observed, and a stepped shape appears at the boundary of the curved waveguide. 2.2 Curve mesh​ In the case of multiple materials in the grid, the equivalent refractive index within the grid is calculated based on the electromagnetic field equation at the boundary, and then filled into the grid. Using &quot;curve mesh&quot; can significantly improve the accuracy of calculations with the same grid accuracy. The refractive index of different materials in the &quot;staircase&quot; type of mesh varies directly at the interface, while the interface of the &quot;curve mesh&quot; material is gradient.Under the same grid size, using a &quot;curve mesh&quot; type of grid is more accurate in characterizing the structure, and the accuracy of the calculation results is significantly improved. From the following example, it can be seen that using a grid size of &quot;cells per wavelength&quot; of 15 for the &quot;curve mesh&quot; type mesh is equivalent to using a grid size of &quot;cells per wavelength&quot; of 22 for the &quot;staircase&quot; type mesh, but the simulation time is saved by four times.The “curve mesh” is applicable to FDE, EME, and FDTD solvers. 3 Mesh accuracy​ The mesh accuracy represents the size of the mesh, and the commonly used grid accuracy is shown in the table below. Mesh Accuracy of &quot;Gloden&quot;\t1\t2\t3\t4\t5 cells per wavelength of &quot;Max-optics&quot; 6 10 14 18 22 To meet the accuracy requirements of the calculation, it is recommended to set &quot;cells per wavelength&quot; to 14 or above.If we only focus on the transmission rate, it is not necessary to set &quot;cells per wavelength&quot; above 22. Generally, the transmission rate set to 18 is within ±0.01 of the transmission rate error for higher grid accuracy.If more accurate reflectivity (-60 dB) is required, &quot;cells per wavelength&quot; should be set to be greater than 26. 4 Mesh factor​ The grid growth factor is only applicable to non-uniform grids and is used to control the rate of grid size change at the junction of different sizes of grids.To ensure the accuracy of the calculation results, the change rate of the grid should not be too large, and the default value of mesh factor is 1.2. In the area where the global mesh and local mesh are connected, the gradient trend of grid size with different growth factors is as follows. It is obvious that the larger the growth factor, the faster the grid change rate in the connected areas, and the corresponding number of meshs is smaller. If the size of the local area network grid is a, the size of the global grid is b, and the grid factor is m, then there will be a grid gradient process of a, a∙m, a∙m^2, a∙m^3, ...b in the connected areas. The mesh factor cannot be too small. If the mesh factor is 1, the grid will be evenly distributed throughout the entire space without any changes in size, and the number of meshs will increase significantly. "},{"title":"What is Mode expansion monitor?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/mode expansion monitor","content":"What is Mode expansion monitor? The pattern expansion monitor, as a sub attribute of the power monitor, inherits the position, size, wavelength range, and frequency points of the power monitor. The meaning of each option in mode selection? In the user selection feature, the mode index starts from 0, and users can customize the number of monitoring modes by entering a list [0, 1, 2, 3,...]. &quot;Fundamental Mode&quot; represents the selection of the first given mode, &quot;Fundamental TE Mode&quot; represents the selection of the first TE mode, which is usually TE0 mode in the 2D waveguide section, &quot;Fundamental TM Mode&quot; represents the selection of the first TM mode, which is usually TM0 in the 2D waveguide section, and &quot;User Select&quot; represents user-defined &quot;. Frequency points can be set separately and will solve for the specified number of FDE modes. Before simulation, FDE calculations will be performed on each frequency point of the mode monitor. When is the mode extension monitor enabled? If there are too many frequency points in the mode monitor, it will increase the simulation time. If the input and output waveguides of the device are both single-mode waveguides, the distance between waveguides is relatively long, and the coupling is weak, and the device does not have polarization and mode conversion, the mode extension of the power monitor can not be enabled.In the presence of polarization, mode conversion, or overlap in the monitoring area of the power monitor in the device, it is necessary to enable mode unfolding of the power monitor to obtain more accurate simulation results.The settings for mode deployment monitoring can refer to (examples\\precision\\FDTD_HalfRing.py).","keywords":""},{"title":"What is the process of simulation?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/Simulation process","content":"","keywords":""},{"title":"FDE​","type":1,"pageTitle":"What is the process of simulation?","url":"/my-website/docs/faq/Physics/Simulation process#fde","content":"The Finite Difference Eigenmode (FDE ) is a numerical solution algorithm that discretizes the Maxwell equations and solves the constructed feature matrix. The solution process for FDE is as follows. Calculate the propagation of electromagnetic waves and the field distribution of harmonic modes with high accuracy.The calculation cost is relatively low. The mode profile of the waveguide using FDE is shown in the following figure. EME​ The Eigenmode Expansion Method (EME) calculates the bidirectional transmission of interface modes in partitioned units to obtain the transfer matrix, which has significant advantages over FDTD in simulating length scanning photonic devices. Calculate the transmission characteristics of the device and quickly scan and optimize the device.Compared to FDTD methods, the treatment of nonlinearity and dispersion equivalence has certain disadvantages. Calculate the electric field distribution of silicon waveguide and silicon nitride waveguide using EME, as shown in the following figure. FDTD​ Finite Difference Time Domain (FDTD) represents the solution of a partial differential equation as discrete points in time and space, and then uses finite difference to solve the partial differential equation.The simulation process of FDTD is as follows. No approximation was used when solving partial differential equations.By using time-domain solutions, it is convenient to observe the propagation of light.Obtain the broadband response of the device through a single calculation in the time domain. Using FDTD to calculate light field transmission, the electric field distribution in the power monitor is shown in the following figure. "},{"title":"How to set simulation time?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/Simulation time","content":"How to set simulation time? When either the maximum simulation time is reached or the energy in the simulation area is less than the convergence threshold, the simulation project will end. In order to obtain convergence results, the simulation time should be set long enough, and it is recommended that the simulation time be no less than 1000 fs. Relationship between structural dimensions and simulation time The estimated time required for simulating and calculating non resonant devices is: L𝑛_𝑔/c;For SOI devices with a 100 micron length and a group refractive index of 4.23, the simulation time should be at least 1410 fs;For SiN devices with a 100 micron length and a group refractive index of 2.01, the simulation time is at least 670fs.In general, we need the light field energy in the simulation to converge below 1e-4. In order to ensure that the energy at the end of the simulation is less than 1e-4, the simulation time should be set sufficiently large. What is the relationship between the 'step. 0.39%' printed during the simulation process and the simulation time? At the beginning of the simulation, a maximum simulation time will be estimated based on the number of grid points, simulation time, and current computer performance, corresponding to the sum of &quot;elapsed&quot; and &quot;remaining&quot; times in each row of the following figure. After each iteration, the program will calculate the current elapsed time elapsed time and the maximum required simulation time remaining time until the end of the simulation. When the simulation time is set sufficiently large, the Early shutdown condition will be triggered when the energy of light in the simulation area decreases to the convergence level, and the simulation time used is less than 100%. step = elapsed_time/(elapsed_time + remain_time) ","keywords":""},{"title":"What is the difference between Staircase and Subcell methods?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/Subcell","content":"","keywords":""},{"title":"Staircase approximation​","type":1,"pageTitle":"What is the difference between Staircase and Subcell methods?","url":"/my-website/docs/faq/Physics/Subcell#staircase-approximation","content":"The Staircase approximation simply uses the mode field of discrete points to represent the mode field of the entire element, which has high computational efficiency. When the cell undergoes discontinuous changes, it can cause non physical reflections at the interface of the cell. The Staircase approximation method is applicable to staircase waveguides, mosaic type photonic devices, and square wave modulated waveguide gratings. Subcell approximation​ The Subcell approximation calculates the mode at the interface of each cell as a first-order interpolation of adjacent cells, and can simulate continuously changing photonic structures with smaller cells.The Subcell approximation method is suitable for gradient waveguides, tapers, and sinusoidal modulated waveguide gratings. When using the Subcell method, it is important to perform convergence analysis on the number of cells in the structural change area to ensure that the number of slices is sufficient. "},{"title":"Material","type":0,"sectionRef":"#","url":"/my-website/docs/test/SDK/1Material","content":"Material Use Material() to instance a material into the project, use add_nondispersion, add_dispersion and add_anisotropy functoin to add new materials or use add_lib utilize materials from the material library. 1.1 Add nondispersion material​ The syntax and properties of adding non dispersive material are shown below. This function does not return any data. add_nondispersion( name: str, data: List[Tuple[float, float]], order: int = 2, color: Optional[str] = None ) Parameter\tType\tDefault\tDescriptionname\tstring\t-\tDefine the name of the material. data\ttuple\t-\tInput a tuple, format is [(index real, index imag)] order\tinteger\t2\tPriority of the material, with larger number indicating higher priority. color\tstring\t-\tSet the color for material display, format is &quot;#RRGGBB&quot; . Example:The following command adds non dispersive material to the material of the instance, sets the material name to &quot;SiO2&quot;, data to [(1.444, 0)], mesh order to 1 and color to &quot;#654321&quot;. mt = Project.Material() mt.add_nondispersion(name=&quot;nondispersion_material&quot;, data=[(1.444, 0)], order=1,color=&quot;#654321&quot;) 1.2 Add dispersion material​ The syntax and properties of adding dispersive material are shown below. This function does not return any data. add_dispersion( name: str, data: List[Tuple[float, float, float]], order: int = 2, color: Optional[str] = None ) Parameter\tType\tDefault\tDescriptionname\tstring\t-\tDefine the name of the material. data\ttuple\t-\tA list of tuple, format is [(wavelength, index real, index imag), ...] order\tinteger\t2\tIndicates the priority of the material, with higher numbers indicating higher priority. name\tstring\t-\tDefine the name of the material. data\ttuple\t-\tA list of tuple, format is [(wavelength, index real, index imag), ...] order\tinteger\t2\tPriority of the material, with larger number indicating higher priority. color\tstring\t-\tSet the color for material display, format is &quot;#RRGGBB&quot; . Example: The following command adds dispersive material to the material of the instance, sets the material name to &quot;SiO2&quot;, data to [(1.55e-06,, 1.444, 0), (1.30e-06, 1.81, 0.227)], mesh order to 2 and color to &quot;#654321&quot;. w_index = [(1.55e-06, 1.444, 0), (1.30e-06, 1.81, 0.227)] mt = pj.Material() mt.add_dispersion(name=&quot;dispersion&quot;, data=w_index, order=2, color=&quot;#654321&quot; ) 1.3 Add anisotropy material​ The syntax and properties of adding non anisotropy material are shown below. This function does not return any data. add_anisotropy( name: str, data: Union[List], order: int = 2, color: Optional[str] = None ) Parameter\tType\tDefault\tDescriptionname\tstring\t-\tDefine the name of the material. data\ttuple\t-\tA list of tuple, format is [(wavelength, xx index real, xx index imag, yy index real, yy index imag, zz index real, zz index imag), ...] order\tinteger\t2\tPriority of the material, with larger number indicating higher priority. color\tstring\t-\tSet the color for material display, format is &quot;#RRGGBB&quot; . Example:The following command adds anisotropy material to the material of the instance, sets the material name to &quot;LN&quot;, data to [(wavelength * 1e-6, 2.211, 0, 2.138, 0, 2.211, 0)] and mesh order to 2. wavelength = 1.55 w_xyz = [(wavelength * 1e-6, 2.211, 0, 2.138, 0, 2.211, 0)] mt = pj.Material() mt.add_anisotropy(name=&quot;anisotropy_material&quot;, data=w_xyz, order=2 ) 1.4 Add material from the material library​ The syntax and properties of adding material from material library are shown below. This function does not return any data. add_lib( name: str, data: Optional[str], order: int = 2 ) Parameter\tType\tDefault\tDescriptionname\tstring\t-\tDefine the name of the material. data\tobject\t-\tA library material object, format is mo.Material.Air order\tinteger\t2\tPriority of the material, with larger number indicating higher priority. Example: The following command adds material from material library to the material of the instance, sets the material name to &quot;Air&quot;, data to mo.Material.Air and mesh order to 2. mt = Project.Material() mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) ","keywords":""},{"title":"Mesh","type":0,"sectionRef":"#","url":"/my-website/docs/test/SDK/3Mesh","content":"Mesh In this section, we will discuss how to add meshing to the simulation. This step is crucial to ensure the precision and dependability of the simulation outcomes. 3.1 Add mesh​ Add sub mesh to the simulation project with the code below (for optical simulation). lm = Project.LocalMesh() lm.add( self, *, name: str, property: dict, ) Example:The following command sets the size of the local mesh area to 6 um 3 um 3 um and the local mesh size of 0.2 um in the x, y, and z directions. lm = pj.LocalMesh() lm.add(name=&quot;sub_mesh&quot;, property={&quot;general&quot;: {&quot;dx&quot;: 0.2, &quot;dy&quot;: 0.2, &quot;dz&quot;: 0.2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 6, &quot;y&quot;: 0, &quot;y_span&quot;:3, &quot;z&quot;: 0, &quot;z_span&quot;: 3 } } ) wget https://github.com/mikefarah/yq/releases/download/v4.16.2/yq_linux_amd64 &amp;&amp; chmod +x yq_linux_amd64 &amp;&amp; mv yq_linux_amd64 /usr/local/bin/yq General properties​ Parameter\tType\tDefault\tDescriptiondx, dy, dz\tnumber\t- Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. x_span, y_span, z_span\tnumber\t-\tX span, Y span, Z span of the geometry. x_min, x_max\tnumber\t-\tX min, X max position of the geometry. y_min, y_max\tnumber\t-\tY min, Y max position of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. 2.1.12 Mesh order​ The mesh order decides the coverage when creating a geometric structure. When the mesh order of two structures are same, the structure which is established later has a higher priority. When the mesh order of two structures are different, the large numerical value of mesh order has greater priority than the small one. That is, The large mesh order of structure is able to cover small mesh order of structure. For example, the mesh order=2 structure will cover the mesh order=1. The advantage is that increasing the value of mesh order allows user to make new nested structures in the complex model. 3.2 Add emesh​ In the context of electrical simulation, we present guidelines on how to incorporate meshing to ensure the precision and dependability of the simulation outcomes. The code explanations and a practical example provided below. add_emesh( self, *, name: str, property: Dict[str, Any], ) Parameters\tDescriptionname\tElectric local mesh name. property\tElectric local mesh property. Example: st.add_emesh(name=&quot;EMesh_Local&quot;, property={ &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: oe_y_max, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;mesh_size&quot;: egrid_local}) Parameters\tDefault\tType\tNotesgeometry.x\t-\tfloat\tThe x-coordinate of the center point position of the electrical mesh. geometry.x_span\t-\tfloat\tThe length in x direction of the electrical mesh. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the electrical mesh. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the electrical mesh. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the electrical mesh. geometry.y_span\t-\tfloat\tThe width in y direction of the electrical mesh. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the electrical mesh. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the electrical mesh. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the electrical mesh. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the electrical mesh. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the electrical mesh. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the electrical mesh. mesh_size\t-\tfloat\tThe max size of electrical simulation mesh. 3.2.3 Add emesh along line​ By implementing an electric mesh along line, you can accurately capture intricate electrical phenomena and variations, enhancing the comprehensiveness of your simulation results. add_emesh_along_line( self, *, name: str, property: Dict[str, Any], ) Parameters\tDescriptionname\tThe name of electric mesh along line. property\tThe property of electric mesh along line. Example: st.add_emesh_along_line(name=&quot;EMesh_Ge_SiO2_Interface_Slope_Left&quot;, property={ &quot;start_x&quot;: oe_x_mean, &quot;start_y&quot;: -Ge_y_span_bottom/2, &quot;start_z&quot;: Si_z_span, &quot;end_x&quot;: oe_x_mean, &quot;end_y&quot;: -Ge_y_span_top/2, &quot;end_z&quot;: Si_z_span+Ge_z_span, &quot;mesh_size&quot;: egrid_interface}) Parameters\tDefault\tType\tNotesstart_x\t0\tfloat\tThe minimum value of mesh region in x axis. start_y\t0\tfloat\tThe minimum value of mesh region in y axis. Restrained by condition: &gt;=0. start_z\t0\tfloat\tThe minimum value of mesh region in z axis. end_x\t1\tfloat\tThe maximum value of mesh region in x axis. end_y\t1\tfloat\tThe maximum value of mesh region in y axis. end_z\t1\tfloat\tThe maximum value of mesh region in z axis. Restrained by condition: &gt;=0. mesh_size\t0.01\tfloat\tThe size of the unit grid.","keywords":""},{"title":"Source","type":0,"sectionRef":"#","url":"/my-website/docs/test/SDK/4Source","content":"Source The subsequent code will exemplify the process of incorporating a light source and port within a simulation project. As of now, the source module accommodates the inclusion of mode source and Gaussian source. Furthermore, our platform extends support for ports into both EME and FDTD simulations. 4.1 Waveform​ In FDTD simulations, waveforms are utilized to control the bandwidth of the source pluse. You can simply enter the central wavelength and range into the added waveform, and the bandwidth and shape of the pulse source will be automatically calculated. The syntax and properties for adding waveform are as follows. This function does not return any data. add( name: str, type: Literal[&quot;gaussian_waveform&quot;], property: dict ) Set frequency wavelength​ Parameter\tType\tDefault\tDescriptionrange_type\tstring\t-\tSelects &quot;frequency&quot; or &quot;wavelength&quot;. range_limit\tstring\t-\tSelects &quot;min_max&quot; or &quot;center_span&quot;. wavelength_center, frequency_center\tnumber\t-\tThe wavelength center and frequency center. wavelength_span, frequency_span\tnumber\t-\tThe wavelength span and frequency span. wavelength_min, wavelength_max\tnumber\t-\tThe minimum wavelength and maximum wavelength. frequency_min, frequency_max\tnumber\t-\tThe minimum frequency and maximum frequency. Set time domain​ Parameter\tType\tDefault\tDescriptionpulsetype\tstring\t-\tSet the source to standard or broadband. frequency\tnumber\t-\tThe center frequency of the optical carrier. pulselength\tnumber\t-\tThe duration of the pulse's full width at half maximum power. offset\tnumber\t-\tThe time it takes for the source to reach its peak amplitude, measured relative to the start of the simulation. bandwidth\tnumber\t-\tThe full width at half maximum frequency of the time-domain pulse. Example: The following script adds a Gaussian waveform by setting the wavelength to 1.55 um and the wavelength span to 0.1 um. This script assumes that FDTD solver has been added to the simulation environment, and the pj is an instance of the project. waveform name = &quot;wv1550&quot; wv = pj.Waveform() wv.add(name=waveform name, type=&quot;gaussian_waveform&quot;, property={&quot;set&quot;: &quot;frequency_wavelength&quot;, # selections are [&quot;frequency wavelength&quot;,&quot;time domain&quot;] &quot;set frequency_wavelength&quot;: { &quot;range_type&quot;: &quot;wavelength&quot;, # selections are [&quot;frequency&quot;,&quot;wavelength&quot;] &quot;range_limit&quot;: &quot;center_span&quot;, # selections are [&quot;min max&quot;,&quot;center span&quot;] &quot;wavelength_center&quot;: 1.55, &quot;wavelength__span&quot;: 0.1, }}) 4.2 Mode source​ The syntax and properties for adding mode source are as follows. This function does not return any data. add( name: str, type: Literal[&quot;mode_source&quot;], property: dict, ) General properties​ Parameter\tType\tDefault\tDescriptioninject axis\tstring\t-\tSelects the mode source propagation along the x-axis, y-axis or zaxis. direction\tstring\tforward\tSelects the forward or backward direction of propagation for the mode source. amplitude\tnumber\t1.0\tSpecifies the peak amplitude of the electric field, with the unit in V/m. phase\tnumber\t0.0\tSpecifies the initial phase of the source, with the unit in degrees. mode_selection\tstring\t-\tSelects &quot;fundamental&quot;, &quot;fundamental TE&quot;, &quot;fundamental TM&quot; or &quot;user select&quot; to inject mode. mode_index\tinteger\t0\tSelects the mode number from the list of calculated modes. search\tstring\tmax_index\tSelects &quot;max index&quot; or &quot;near n&quot; to search modes. n\tnumber\t1.0\tSearchs modes near the specified effective index. number_of_trial_modes\tinteger\t20\tRecords the maximum number of modes in the mode list. waveform\tobject\t-\tSelects the waveform ID from source pulse waveform list. Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the mode source. x span, y span, z span\tnumber\t-\tX span, Y span, Z span of the mode source. x min, x max\tnumber\t-\tX min, X max position of the mode source. y min, y max\tnumber\t-\tY min, Y max position of the mode source. z min, z max\tnumber\t-\tZ min, Z max position of the mode source. boundary conditions.​ Select the override default boundary conditions to True, and each boundary condition can be set separately. The optional boundary conditions include &quot;PEC&quot;, &quot;PMC&quot;, &quot;PML&quot;, &quot;symmetric&quot; or &quot;anti symmetric&quot;. modal analysis.​ If the fraction of magnetic field intensity in PML is greater than the specified threshold, the mode is discarded. Example: The following script adds a mode source in FDTD simulation, sets the position and dimension of the light source, as well as the mode profile and waveform. This script assumes that FDTD solver has been added to the simulation environment, and the pj is an instance of the project. wv_id = wv[&quot;waveform_name&quot;] # Selects the waveform ID from source pulse waveform list. src = pj.Source() src.add(name=&quot;source&quot;, type=&quot;mode_source&quot;, property={ &quot;general&quot;: {&quot;amplitude&quot;: 1, &quot;phase&quot;: 0, &quot;rotations&quot;: {&quot;theta&quot;: 0, &quot;phi&quot;: 0, &quot;rotation_offset&quot;: 0}, &quot;mode_selection&quot;: &quot;fundamental&quot;, &quot;waveform&quot;: {&quot;waveform_id&quot;: wv_id}, &quot;inject_axis&quot;: &quot;x axis&quot;, &quot;direction&quot;: &quot;forward&quot;}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x span&quot;: 0, &quot;y&quot;: 0, &quot;y span&quot;: 3, &quot;z&quot;: 0, &quot;z span&quot;: 3}, &quot;modal_analysis&quot;: {&quot;mode_removal&quot;: {&quot;threshold&quot;: 0.01}}}) 4.3 Gaussian source​ The syntax and properties for adding gaussian source are as follows. This function does not return any data. add( name: str, type: Literial[&quot;gaussian source&quot;], property: dict, ) General properties​ Parameter\tType\tDefault\tDescriptioninject_axis\tstring\t-\tSelects the mode source propagation along the x-axis, y-axis or zaxis. direction\tstring\tforward\tSelects the forward or backward direction of propagation for the mode source. amplitude\tnumber\t1.0\tSpecifies the peak amplitude of the electric field, with the unit in V/m. phase\tnumber\t0.0\tSpecifies the initial phase of the source, with the unit in degrees. waveform\tobject\t-\tSelects the waveform ID from source pulse waveform list. angle_theta\tnumber\t0\tThe angle between the propagation direction and the injection axis of source, with the unit in degrees. angle_phi\tnumber\t0\tIn a right-hand coordinate system, the angle of propagation is rotated around the injection axis of the source. polarization_angle\tnumber\t0\tThe polarization angle defines the orientation of the injected electric field. A polarization angle of zero degrees indicates P-polarized radiation, while an angle of 90 degrees indicates S-polarized radiation. beam_parameters\tstring\twaist_size_and_position\tSelects &quot;waist_size_and_position&quot; or &quot;beam_size_and_divergence&quot; to set the beam parameters. Beam parameters​ waist_size_and_position waist radius: 1/e field (1/e2 power) radius of the beam for a Gaussian beam. distance from waist: The distance between the injection plane and the beam waist. A positive distance indicates a diverging beam, while a negative distance indicates a converging beam. beam_size_and_divergence beam radius: 1/e field (1/e2 power) radius of the beam for a Gaussian beam . divergence angle: The radiation divergence angle measured in the far field. A positive angle indicates a diverging beam, while a negative angle indicates a converging beam. Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the gaussian source. x span, y span, z span\tnumber\t-\tX span, Y span, Z span of the gaussian source. x min, x max\tnumber\t-\tX min, X max position of the gaussian source. y min, y max\tnumber\t-\tY min, Y max position of the gaussian source. z min, z max\tnumber\t-\tZ min, Z max position of the gaussian source. Example: The following script adds a gaussian source in FDTD, sets the position and dimension of the light source, as well as the mode profile and waveform. This script assumes that FDTD solver has been added to the simulation environment, and the pj is an instance of the project. wv_id = wv[&quot;waveform_name&quot;] # Selects the waveform ID from source pulse waveform list. so = pj.Source() so.add(name=&quot;source&quot;, type=&quot;gaussian_source&quot;, axis=&quot;z_backward&quot;, property={&quot;general&quot;: {&quot;angle_theta&quot;: 0, &quot;angle phi&quot;: 0, &quot;polarization_angle&quot;: 0, &quot;waveform&quot;: {&quot;waveform_id&quot;: wv_id}, &quot;beam_settings&quot;: {&quot;calculation method&quot;: &quot;use_scalar_approximation&quot;, &quot;beam parameters&quot;: &quot;waist_size_and_position&quot;, &quot;waist_radius&quot;: 5.2, &quot;distance_from_waist&quot;: 1.5}}, &quot;geometry&quot;: {&quot;x&quot;: 4, &quot;x span&quot;: 20, &quot;y&quot;: 0, &quot;y span&quot;: 20, &quot;z&quot;: 1.5, &quot;z span&quot;: 0}}) 4.3 FDTD port​ Incorporate a port into the current FDTD simulation project. add( name: str, type: Literal[&quot;fdtd port&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the FDTD port. x span, y span, z span\tnumber\t-\tX span, Y span, Z span of the FDTD port. x min, x max\tnumber\t-\tX min, X max position of the FDTD port. y min, y max\tnumber\t-\tY min, Y max position of the FDTD port. z min, z max\tnumber\t-\tZ min, Z max position of the FDTD port. boundary conditions.​ Select the override default boundary conditions to True, and each boundary condition can be set separately. The optional boundary conditions include &quot;PEC&quot;, &quot;PMC&quot;, &quot;PML&quot;, &quot;symmetric&quot; or &quot;anti symmetric&quot;. modal analysis.​ If the fraction of magnetic field intensity in PML is greater than the specified threshold, the mode is discarded. Example: The following script adds a port in FDTD simulation, sets the position and dimension of the light source, as well as the mode profile and waveform. This script assumes that FDTD solver has been added to the simulation environment, and the pj is an instance of the project. wv_id = wv[&quot;waveform_name&quot;] # Selects the waveform ID from source pulse waveform list. pt = pj.Port(property={&quot;waveform_id&quot;: wv_id, &quot;source port&quot;: &quot;port_left&quot;}) pt.add(name=&quot;port_left&quot;, type=&quot;fdtd_port&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x span&quot;: 0, &quot;y&quot;: 0, &quot;y span&quot;: 3, &quot;z&quot;: 0, &quot;z span&quot;: 3}, &quot;modal_properties&quot;: {&quot;general&quot;: {&quot;inject axis&quot;: &quot;x_axis&quot;, &quot;direction&quot;: &quot;forward&quot;, &quot;mode_selection&quot;: &quot;fundamental&quot;}}}) 4.4 EME port​ The syntax and properties for adding mode source are as follows. This function does not return any data. add( name: str, type: Literal[&quot;eme_port&quot;], property: dict, ) Geometry​ Parameter\tType\tDefault\tDescriptionport location\tstring\t-\tSet the location of EME port, selections are &quot;left&quot; and &quot;right&quot;. use full simulation span\tboolean\tTrue\tSet whether the port uses the full simulation area, selections are &quot;True&quot; and &quot;False&quot;. x, y, z\tnumber\t-\tThe center position of the EME port. x span, y span, z span\tnumber\t-\tXspan, Y span, Z span of the EME port. x min, x max\tnumber\t-\tX min, X max position of the EME port. y min, y max\tnumber\t-\tY min, Y max position of the EME port. z min, z max\tnumber\t-\tZ min, Z max position of the EME port. EME port​ | mode selection | string | | Selects &quot;fundamental&quot;, &quot;fundamental TE&quot;, &quot;fundamental TM&quot; or &quot;user select&quot; to inject mode.| | mode index | integer | 0 |Selects the mode number from the list of calculated modes. | | search | string | max index | Selects &quot;max index&quot; or &quot;near n&quot; to search modes. | | n | number | 1.0 | Searchs modes near the specified effective index. | | number of trial modes | integer | 20 | Records the maximum number of modes in the mode list. | Boundary conditions.​ Select the override default boundary conditions to True, and each boundary condition can be set separately. The optional boundary conditions include &quot;PEC&quot;, &quot;PMC&quot;, &quot;PML&quot;, &quot;symmetric&quot; or &quot;anti symmetric&quot;. Modal analysis.​ If the fraction of magnetic field intensity in PML is greater than the specified threshold, the mode is discarded. Example:The following script adds ports in EME simulation, selects the mode of &quot;port1&quot; as the source, and sets the calculation fundamental mode and the size is the span of the full simulation area. This script assumes that EME solver has been added to the simulation environment, and the pj is an instance of the project. pjp = pj.Port(property={&quot;source_port&quot;: &quot;port1&quot;}) pjp.add(name=&quot;port1&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;use_full_simulation span&quot;: True}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;user_select&quot;, &quot;mode_index&quot;: 0, &quot;number_of_trial_modes&quot;: 20}}}) pjp.add(name=&quot;port2&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: True}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;user_select&quot;, &quot;mode_index&quot;: 0, &quot;number_of_trial_modes&quot;: 20}}}) ","keywords":""},{"title":"Active Device Simulation","type":0,"sectionRef":"#","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation","content":"Active Device Simulation 1. How to perform an active device simulation​ Follow the steps below to perform an electrical simulation Create a simulation projectAdd materials and modify the parametersAdd structures and specify the materialAdd dopingAdd electrodesAdd local mesh, surface recombination, electrical monitorsAdd an OEDevice solver, including simulation region, solver mode, generation rate, and convergence control settingsRun solverExtract results Note: If optical simulation is still required, after adding materials, you need to bind optical material properties to each material and add other optical simulation-related settings.For electrical simulation, materials, structures, electrode settings, and an OEDevice solver are essential. Doping, local mesh, surface recombination, and electrical monitors can be set as needed. 2. How to set up doping​ Doping is added and set up through the add_doping function. The format of the function is st.add_doping(name, type, property) add_doping() parameters: name--Doping nametype--Doping type. Options are &quot;n&quot;, &quot;p&quot; and &quot;file&quot;. property--Other properties 2.1 Function doping​ When type is set to &quot;n&quot; or &quot;p&quot;, function doping is applied. In this case, type also means the doping species, with &quot;n&quot; for donor and &quot;p&quot; for acceptor. Property list of function doping: default\ttype\tnotesgeometry.x float geometry.x_span float geometry.y float geometry.y_span float geometry.z float geometry.z_span float geometry.x_min float geometry.x_max float geometry.y_min float geometry.y_max float geometry.z_min float geometry.z_max float general.distribution_function str\tSelections are ['constant', 'gaussian'] general.concentration float general.source_face str\tAvailable when distribution_function is 'gaussian' general.junction_width float\tAvailable when distribution_function is 'gaussian' general.ref_concentration float\tAvailable when distribution_function is 'gaussian' volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' Description: geometry--Set the geometry parameters of doping box general--Set the distribution function, concentration and so on distribution_function: When it's set to &quot;constant&quot;, constant doping is applied and only concentration is requiredWhen it's set to &quot;gaussian&quot;, Gaussian function doping is applied, and concentration, ref_concentration, junction_width, source_face are required concentration--Concentration in the non-diffusion arearef_concentration--Concentration on the edge of diffusion area (edge of doping box)junction_width--Diffusion junction widthsource_face--The doping source face. Options are &quot;lower_x&quot;, &quot;lower_y&quot;, &quot;lower_z&quot;, &quot;upper_x&quot;, &quot;upper_y&quot; or &quot;upper_z&quot;. &quot;lower_x&quot; means the source face is x=x_min. Similarly for the rest. There is no diffusion area on the edge of source face. As for the other edges, there is a diffusion area respectively within the doping box. volume--Set a list of regions or materials to be doped volume_type:When it's set to &quot;all&quot;(by default)，the doping is applied to all the (semiconductor) structures, restricted by the doping boxWhen it's set to &quot;material&quot;, material_list is required, which means the doping is applied to the structures of the specified materials and restricted by the doping boxWhen it's set to &quot;region&quot;, region_list is required, which means the doping is applied to the specified structures and restricted by the doping box Gaussian doping explanation​ Fig 1. Gaussian doping As shown above, for Gaussian doping, there is a partition of constant doping profile in the doping box, and the constant concentration is the value of concentration. The width from the edge of constant area to the edge of doping box is junction_width. Concentration on the edge of doping box is the value of ref_concentration. (Note: There is no junction at the edge of source face.) Example for function doping​ st.add_doping(name=&quot;p_constant&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 1, &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: 1e16}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat1&quot;], mt[&quot;mat2&quot;]]}}) st.add_doping(name=&quot;n_diffusion&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 1, &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: 0.1, &quot;concentration&quot;: 1e18, &quot;ref_concentration&quot;: 1e6}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;region&quot;, &quot;region_list&quot;: [&quot;Structure1&quot;, &quot;Structure2&quot;]}}) 2.2 Imported doping​ When type is set to &quot;file&quot;, doping is imported from a file. Property list for imported doping: default\ttype\tnotesgeneral.format str\tSelections are ['DOP'] general.file_path str general.species str\tSelections are ['n', 'p'] volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' Description: general: format--Set the format of doping file. Only &quot;DOP&quot; is supported currently When it's set to &quot;DOP&quot;, the doping file is a text file that stores a doping profile in rectangular grid. There are three columns in the file, which are the first dimension coordinate [um], the second dimension coordinate [um] and the doping concentration [cm^-3] respectively. Doping concentration should be non-negative. file_path--The absolute path of the doping filespecies--Set the doping species. Option are &quot;n&quot; and &quot;p&quot;, with &quot;n&quot; for donor and &quot;p&quot; for acceptor. volume--Set a list of regions or materials to be doped, which is exactly the same as the case of function doping. Example for imported doping​ st.add_doping(name=&quot;p_imported&quot;, type=&quot;file&quot;, property={ &quot;general&quot;: {&quot;format&quot;: &quot;DOP&quot;, &quot;file_path&quot;: p_file_path, &quot;species&quot;: &quot;p&quot;}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat1&quot;], mt[&quot;mat2&quot;]]}}) 3. How to set up electrical boundary condition​ Electrodes and electrical boundary conditions are set up through the add_electrode function. The format of the function is st.add_electrode(name, property) add_electrode() parameters: name--Electrode nameproperty--Other properties There are two different type of electrical boundary conditions, which are &quot;steady_state&quot;and &quot;transient&quot;, specified by the property bc_mode. 3.1 Steady state boundary condition​ When the property bc_mode is set to &quot;steady_state&quot;, the steady state boundary condition is applied. Property list of steady state boundary condition: default\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode\tsteady_state\tstring\tSelections are ['steady_state']. apply_AC_small_signal\tnone\tstring\tSelections are ['none', 'All']. sweep_type\tsingle\tstring\tSelections are ['single', 'range', 'value']. voltage\t0\tfloat\tAvailable when sweep_type is 'single' range_start\t0\tfloat\tAvailable when sweep_type is 'range' range_stop\t1\tfloat\tAvailable when sweep_type is 'range' range_interval\t1\tfloat\tAvailable when sweep_type is 'range' range_num_points\t2\tinteger\tAvailable when sweep_type is 'range' []sweep_value_table.index integer\tAvailable when sweep_type is 'value'. []sweep_value_table.number float\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid string Description: surface_type--Type of the surface to be set as an electrode. Currently only &quot;solid&quot; is supported, meaning that all the surfaces of a structure are selected solid--Name of the structure to be set as an electrode. Available when surface_type is set to &quot;solid&quot; force_ohmic--Whether the electrode is ohmic, default to be True. Currently only ohmic contact is supported, so force_ohmic can't be set to False bc_mode--Set to &quot;steady_state&quot; for steady state boundary condition apply_AC_small_signal: When it's set to &quot;none&quot; (as default), no AC small signal is applied at each sweeping voltageWhen it's set to &quot;All&quot;, the AC small signal is applied after steady state simulation at each sweeping voltage sweep_type--Type of sweeping voltage. Options are &quot;single&quot;, &quot;range&quot; and &quot;value&quot; When it's set to &quot;single&quot;, voltage is requiredWhen it's set to &quot;range&quot;, range_start, range_stop, and range_interval or range_num_points are requiredWhen it's set to &quot;value&quot;, sweep_value_table is required voltage--Set the value of the single voltage range_start--Set the start value of the voltage range range_stop--Set the stop value of the voltage range range_interval--Set the voltage interval of the voltage range range_num_points--Set the number of points of the voltage range sweep_value_table--Table of voltage values. It's a list, whose item is a dictionay. In each of its item: index--Set the index of the voltage valuenumber--Set the value of the voltage Example for single voltage​ st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) Example for voltage range​ st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: 0, &quot;range_stop&quot;: 1, &quot;range_interval&quot;: 0.5, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) Example for voltage table​ st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;value&quot;, &quot;sweep_value_table&quot;: [{&quot;index&quot;: 0, &quot;number&quot;: 0}, {&quot;index&quot;: 1, &quot;number&quot;: 0.5}, {&quot;index&quot;: 2, &quot;number&quot;: 1}]}) 3.2 Transient boundary condition​ When the property bc_mode is set to &quot;transient&quot;, the transient boundary condition is applied. Property list of transient boundary condition: default\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode string\tSelections are ['transient']. voltage\t0\tfloat []time_table.time_start float []time_table.time_stop float []time_table.initial_step float []time_table.max_step float []time_table.optical.enabled\t0\tinteger\tSelections are [0, 1] []time_table.optical.envelop integer\tSelections are [0] []time_table.optical.source_fraction float surface_type\tsolid\tstring\tSelections are ['solid']. solid string Description: surface_type, solid, force_ohmic--The same as the one in steady state conditionbc_mode--Set to &quot;transient&quot; for transient boundary condition. Then the time dependence of the optical generation rate can be set at this electrodevoltage--Set the voltage that is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation.v_step_max--Set the max step of the voltage from the equilibrium state to steady state at the bias of voltage.time_table--Set the time dependence of optical generation rate. It's a list, whose item is a dictionary. In each of its item: time_start--Set the start time point of the range. The value of 0 represents the steady state of the earlier simulation.time_stop--Set the stop time point of the rangeinitial_step--Set the initial time step of the rangemax_step--Set the max time step of the rangeoptical--Set the optical generation rate during the time range enabled--Whether to apply optical generation rate during the time range. The value of 1 means True, and 0 means Falseenvelop--The envelop of the scaling factor of the light power during the time range. When it's set to 0, the envelop is uniformsource_fraction--When envelop is set to0, this value is the scaling factor of the light power during the time range Example for transient boundary condition​ st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: 1, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 50e-12, &quot;initial_step&quot;: 1e-15, &quot;max_step&quot;: 1e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}, {&quot;time_start&quot;: 50e-12, &quot;time_stop&quot;: 600e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}]}) 3.3 Set up the appropriate boundary condition​ When solving the frequency response of optical signal for the device, transient simulation should be performed. In this case, the bc_mode of the corresponding electrode should be set to &quot;transient&quot;, and the solver_mode of OEDevice solver should be set to &quot;transient&quot;, too. In most of other cases, steady state or SSAC simulation is needed, the bc_mode of electrodes should be &quot;steady_state&quot;. When solving capacitance and resistance with respect to frequency, SSAC simulation is required. The solver_mode of OEDevice solver should be set to &quot;SSAC&quot;, and the apply_AC_small_signal of the corresponding electrode should be set to &quot;All&quot;.When running steady state simulation, just set the solver_mode of OEDevice solver to &quot;steady_state&quot;. 4. How to set up surface recombination​ Surface recombination is added and set up through add_surface_recombination function. The format of the function is st.add_surface_recombination(name, property) add_surface_recombination() parameters: name--Name of the surface recombinationproperty--Other properties Property list of surface recombination: default\ttype\tnotessurface_type\tdomain_domain\tstring\tSelections are ['domain_domain', 'material_material']. interface_type\tnull\tstring\tSelections are ['null', 'InsulatorInterface', 'HomoJunction', 'HeteroJunction', 'MetalOhmicInterface', 'SolderPad']. infinite_recombination\ttrue\tbool\tAvailable when interface_type is 'MetalOhmicInterface' velocity_hole\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' velocity_electron\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' domain_1 string\tAvailable when surface_type is 'domain_domain' domain_2 string\tAvailable when surface_type is 'domain_domain' material_1 material\tAvailable when surface_type is 'material_material' material_2 material\tAvailable when surface_type is 'material_material' Description: surface_type--Type of selection for the surface When surface_type is &quot;domain_domain&quot;, the surface is the interface between two structures When surface_type is &quot;material_material&quot;`, the surface is the interface between two materials interface_type--Type of contact for the surface &quot;InsulatorInterface&quot;--Semiconductor-insulator interface&quot;HomoJunction&quot;--Homogeneous semiconductor-semiconductor interface&quot;HeteroJunction&quot;--Heterogeneous semiconductor-semiconductor interface&quot;MetalOhmicInterface&quot;--Semiconductor-conductor interface&quot;SolderPad&quot;--Conductor-insulator interface infinite_recombination--Only available when interface_type is &quot;MetalOhmicInterface&quot;. The surface recombination velocity of holes and electrons will be available when infinite_recombination is Falsevelocity_hole, velocity_electron--Surface recombination velocity of holes and electrons. Available when interface_type is &quot;MetalOhmicInterface&quot; or &quot;InsulatorInterface&quot;domain_1, domain_2--Names of the two structures at the interface. They must be set explicitly when surface_type is &quot;domain_domain&quot;material_1, material_2--The two materials at the interface. They must be set explicitly when surface_type is &quot;material_material&quot; 5. How to simulate 3dB bandwidth of photodetector​ The OEDevice solver doesn’t support simulations for the small signal of optical generation currently. Therefore, the frequency response of photo detector can only be obtained by transient simulation. 5.1 Introduction for obtaining frequency response through transient simulation​ First, obtain current-time (I-t) curve after applying optical generation in transient simulation. And then postprocess the I-t curve to get the frequency response. Note: Please take the chapter “3.2 Transient boundary condition” above as reference for transient simulation setup;Optical generation is applied at one time point, and keeps until the photo current goes stable. That is, the dependency of optical generation rate on time is a step function and the I-t curve is the step response of photo current;The transient time ranges from the start of optical generation applying, to the time the photo current goes stable;At the beginning when optical generation is turned on, the photo current ramps up very rapidly, so small time step is needed during the period. When photo current varies slowly, the time step can be increased appropriately to shorten the simulation time;The high field mobility model of the material can be applied for a more accurate result of bandwidth;It is often desirable to set up the convergence control parameters to enhance the convergence of transient simulations. 5.2 Comparison between transient simulation and small signal simulation​ Transient simulation is fully nonlinear and can capture all the effects generated by a signal. In contrast, small-signal simulation is a linear approximation performed on a steady-state result. Consequently, all nonlinear effects caused by large signals are lost in this mode. During small-signal simulation, the accuracy increases as the signal amplitude decreases. However, the accuracy of transient simulation is not affected by the signal amplitude. With appropriate settings, the accuracy of transient simulation can be higher than that of small-signal simulation. 6. How to set up materials​ 6.1 Material setup​ When performing optical and electrical simulations, it usually takes two steps to set up a material. First, add an electrical material through add_lib function. The format of the function is mt.add_lib(name, data, order, override) add_lib() parameters: name--Custom material namedata--Material data, requiring one of the built-in materials in the electrical material library, namely mo.OE_Materialorder--mesh_order of the material, default to be 2override--Override the default electronic parameters by custom values. It's empty by default, which means default models and parameters are applied Second, use the set_optical_material function to set the optical property for the material. The format of set_optical_material is set_optical_material(data) set_optical_material() parameters： data--Optical material property，which can be one of the built-in materials in the optical material library mo.Material, or be from the custom optical material. Example of material setup​ mt.add_lib(name=&quot;mat_ge&quot;, data=mo.OE_Material.Ge, order=2, override=elec_Ge_properties) # elec_Ge_properties is a variable storing the modified electronic parameters for Germanium mt[&quot;mat_ge&quot;].set_optical_material(data=mo.Material.Ge_Palik) Example of using custom optical material properties​ mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_nondispersion(name=&quot;mat_sio2_op&quot;, data=[(1.444, 0)], order=1) mt[&quot;mat_sio2&quot;].set_optical_material(data=mt[&quot;mat_sio2_op&quot;].passive_material) Note: Although the electrical and optical material properties are bound together through a two-step setting, in reality, there is no inherent connection between them. For instance, it is possible to set both the electrical properties of SiO2 and the optical properties of Si for the same material. The simulation will not generate errors or warnings in such cases, so users need to determine by themselves whether the material settings align with the physics. The FDTD simulation currently doesn't support metal materials. Therefore, the optical property of metal materials should be set to mo.Material.PEC and the material name should also be &quot;pec&quot;. 6.2 Electronic parameters of materials​ Semiconductor Si and Ge support basic，band，mobility，velocity saturation and high field setting. Taking Ge as an example, the variable elec_Ge_properties below can be used to override its default electronic parameters. elec_Ge_properties = {&quot;model&quot;: {&quot;high_field&quot;: True, &quot;mobility_force&quot;: &quot;EQF&quot;}, &quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.5-0.65969/2.0, &quot;permitti&quot;: 16.0}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Masetti&quot;, &quot;Masetti&quot;: {&quot;pc_e&quot;: 0, &quot;mu_min1_e&quot;: 850, &quot;mu_min2_e&quot;: 850, &quot;mu1_e&quot;: 0, &quot;mumax_e&quot;: 3900, &quot;cr_e&quot;: 2.6e17, &quot;alpha_e&quot;: 0.56, &quot;pc_h&quot;: 0, &quot;mu_min1_h&quot;: 300, &quot;mu_min2_h&quot;: 300, &quot;mu1_h&quot;: 0, &quot;mumax_h&quot;: 1800, &quot;cr_h&quot;: 1e17, &quot;alpha_h&quot;: 1}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;nc300&quot;: 1.1372e+19, &quot;nv300&quot;: 3.9189e+18, # Bandgap &quot;eg300&quot;: 0.65969, &quot;chi300&quot;: 4.5-0.65969/2.0, # Bandgap Narrowing &quot;v0_bgn&quot;: 0, # Auger Recombination &quot;augan&quot;: 1e-30, &quot;augap&quot;: 1e-30, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 1.5e-9, &quot;taupmax&quot;: 1.5e-9, &quot;nsrhn&quot;: 7.1e15, &quot;nsrhp&quot;: 7.1e15, # Radiative Recombination &quot;c_direct&quot;: 6.41e-14}, &quot;print&quot;: 1}, &quot;vsat&quot;: {&quot;model&quot;: &quot;Canali&quot;, &quot;Canali&quot;: {&quot;beta0n&quot;: 2, &quot;beta0p&quot;: 1, &quot;betaexpn&quot;: 0, &quot;betaexpp&quot;: 0, &quot;alpha&quot;: 0, &quot;vsatn0&quot;: 6e6, &quot;vsatp0&quot;: 5.4e6, &quot;vsatn_exp&quot;: 0, &quot;vsatp_exp&quot;: 0}, &quot;print&quot;: 1}} Description: basic--Set the permittivity and affinity band--Set models and parameters of the band and the recombination mobility--Set the model and parameters of mobility model--Set the switch of high field mobility model and Fermi-Dirac statistics model vsat--Set the model and parameters of velocity saturation For the detailed introduction about electronic parameters, please refer to the document examples/active_demo/Physics_Model_in_OEDevice.pdf. 7. How to set up OEDevice solver​ The OEDevice solver is added and set up through simu.add function. The format of the function is simu.add(name, type, property) simu.add() parameters: name--Name of the solvertype--Type of the solver. For active device simulation, the type of carrier transport solver is &quot;OEDevice&quot;property--Other properties Property list of OEDevice solver: default\ttype\tnotesgeneral.norm_length\t1.0\tfloat general.solver_mode\tsteady_state\tstring\tSelections are ['steady_state', 'transient', 'SSAC']. general.temperature_dependence\tIsothermal\tstring\tSelections are ['Isothermal']. general.simulation_temperature\t300\tfloat advanced.non_linear_solver\tNewton\tstring\tSelections are ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', 'LU', 'BCGS']. advanced.use_quasi_fermi\tdisabled\tstring\tSelections are ['disabled', 'enabled']. advanced.damping\tnone\tstring\tSelections are ['none', 'potential']. advanced.potential_update\t1.0\tfloat advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. advanced.thread_count\t4\tinteger advanced.max_iterations\t30\tinteger advanced.use_global_max_iterations\ttrue\tbool advanced.poisson_max_iterations\t30\tinteger advanced.ddm_max_iterations\t30\tinteger advanced.relative_tolerance\t1.0e-5\tfloat advanced.tolerance_relax\t1.0e+5\tfloat advanced.divergence_factor\t1.0e+25\tfloat genrate.genrate_path string genrate.source_fraction float genrate.coordinate_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float geometry.z_min float geometry.z_max float small_signal_ac.perturbation_amplitude\t0.001\tfloat small_signal_ac.frequency_spacing\tsingle\tstring\tSelections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat small_signal_ac.start_frequency\t1.0e+06\tfloat small_signal_ac.stop_frequency\t1.0e+09\tfloat small_signal_ac.frequency_interval\t9.9999e+10\tfloat small_signal_ac.num_frequency_points\t2\tinteger small_signal_ac.log_start_frequency\t1.0e+06\tfloat small_signal_ac.log_stop_frequency\t1.0e+10\tfloat small_signal_ac.log_num_frequency_points\t2\tinteger Description: geometry： dimension--Set the dimension of the simulation region. Only 2D simulation is supportd currently. When it's set to &quot;2d_x_normal&quot;, the simulation is on the yz plane. Similarly for the rest general: norm_length--Set the length in the third dimension, default to be 1solver_mode--Set the simulation mode. Steady state, transient and SSAC simulations are supportedtemperature--Set the simulation temperaturetemperature_dependence--Set the type of the temperature dependence. Only &quot;Isothermal&quot; is supported currently genrate: genrate_path--Set the absolute path of the optical generation rate file (gfile) When it's set to &quot;&quot; (by default), and empty string , no optical generation rate will be appliedWhen it's not empty, the gfile at the path will be imported to apply the optical generation rate coordinate_unit--Set the coordinate unit in the gfile field_length_unit--Set the length unit in the generation rate unit in the gfile source_fraction--Set the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport small_signal_ac: perturbation_amplitude--Set the voltage amplitude of the small signal frequency_spacing--Set the spacing type of the frequency When it's set to &quot;single&quot;, the frequency point is singleWhen it's set to &quot;linear&quot;, the frequency points are uniformly sampledWhen it's set to &quot;log&quot;，the frequency points are uniformly sampled base on the logarithm of frequency frequency--Set the value of the single frequency start_frequency--Set the start frequency of linear spacing stop_frequency--Set the stop frequency of linear spacing frequency_interval--Set the frequency interval of linear spacing num_frequency_points--Set the number of frequency points of linear spacing log_start_frequency--Set the start frequency of logarithmic spacing log_stop_frequency--Set the stop frequency of logarithmic spacing log_num_frequency_points--Set the number of frequency points of logarithmic spacing advanced: non_linear_solver--Set the non-linear solver, only Newton method is supported currentlylinear_solver--Set the linear solver. Options are &quot;MUMPS&quot;, &quot;LU&quot;, &quot;BCGS&quot;. MUMPS and LU are direct linear solvers which usually give the exact solution. However, MUMPS supports parallel computation while LU doesn't. ；&quot;BCGS&quot; is a Krylov subspace (KSP) iterative solver, which also supports parallel computation and is more efficient but can only give approximate results.use_quasi_fermi--Whether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. &quot;enabled&quot; means True, and &quot;disabled&quot; means Falsedamping--Set the nonlinear update damping scheme. &quot;potential&quot; means the damping is based on the potential variationpotential_update--Set the threshold potential for potential damping. The large value will reduce the strength of damping effectmulti_threads: When it's set to &quot;let_solver_choose&quot;, the solver will determine the number of threads to use. The default maximum number of threads is 4When it's set to &quot;set_thread_count&quot;, the number of threads is set by the user to thread_count thread_count--Custom number of threadsmax_iterations--Set global maximum number of iterations, available when use_global_max_iterations is Trueuse_global_max_iterations--Whether to use global max iterations during the initialization of solving the Poisson equations and the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, default to be Truepoisson_max_iterations--Set the max iterations during the initialization of solving the Poisson equations, available when use_global_max_iterations is Falseddm_max_iterations--Set the max iterations during the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, available when use_global_max_iterations is Falserelative_tolerance--Set the relative update tolerancetolerance_relax--Set the tolerance relaxation factor for convergence on relative tolerance criteriadivergence_factor--Nonlinear solver fault with divergence when each individual function norm exceeds the threshold as its absolute tolerance multiply by this factor 8. How to set up electrical monitors​ Electrical monitors are added and set up through mn.add function. The format is mn.add(name, type, property) mn.add() parameters: name--Monitor nametype--Monitor type. Options are &quot;charge_monitor&quot;, &quot;electric_monitor&quot;and &quot;band_monitor&quot;, which are for recording carrier concentration, electric field and potential, band structure respectivelyproperty--Other properties Property list of electrical monitors: default\ttype\tnotesgeometry.monitor_type\tpoint\tstring\tSelections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t0\tinteger Description: geometry: monitor_type--Set the dimension type of the monitor. For electrical monitors, only 1D type and 2D type are available currently When it's charge_monitor or electric_monitor, Options &quot;linear_x&quot;, &quot;linear_y&quot;, &quot;linear_z&quot;, &quot;2d_x_normal&quot;, &quot;2d_y_normal&quot;, &quot;2d_z_normal&quot; are available. &quot;linear_x&quot; means the monitor is of 1D type and is along the x-direction, so the y_span and z_span should be 0. &quot;2d_x_normal&quot; means the monitor is of 2D type and is in the yz plane, so the x_span should be 0. Similarly for the rest interpolate_accuracy--Set the accuracy of the rectangular grid for extracting the monitor result. Its value ranges from 1 to 10, where 1 means the grid size is 10nm, and 10 means the grid size is 1nm, and the grid size varies uniformly with the variation in interpolate_accuracy. Examples of add electrical monitors​ mn.add(name=&quot;electric_2d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y_min&quot;: -1, &quot;y_max&quot;: 1, &quot;z_min&quot;: -1, &quot;z_max&quot;: 1, &quot;interpolate_accuracy&quot;: 4}}) mn.add(name=&quot;electric_1d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_z&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: -1, &quot;z_max&quot;: 1, &quot;interpolate_accuracy&quot;: 4}}) mn.add(name=&quot;band_1d&quot;, type=&quot;band_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_x&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 2, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: 0, &quot;z_max&quot;: 0, &quot;interpolate_accuracy&quot;: 4}}) 9. How to set up eletrical local mesh​ 9.1 Electrical local mesh in a rectangle region​ Electrical local mesh in a rectangle region is added and set up through add_emesh function. The format is st.add_emesh(name, property) add_emesh() parameters: name--Custom nameproperty--Other properties Property list of electrical local mesh in a rectangle region: default\ttype\tnotesx float x_span float\tRestrained by condition: &gt;=0. x_min float x_max float y float y_span float\tRestrained by condition: &gt;=0. y_min float y_max float z float z_span float\tRestrained by condition: &gt;=0. z_min float z_max float mesh_size float\tmax size of electrical simulation mesh Description: mesh_size--Set the max size of electrical mesh grid in the region Note: When the simulation region is in the xy plane, only the parameters in the x, y direction are effective, and parameters in the z direction will be ignored. Similarly for the rest. Example of electrical local mesh in a region setting​ st.add_emesh(name=&quot;local_mesh&quot;, property={ &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1, &quot;mesh_size&quot;: 0.01}) 9.2 Electrical local mesh along a line​ Electrical local mesh along a line is added and set up through add_emesh_alone_line function. The format is st.add_emesh_alone_line(name, property) add_emesh_alone_line() parameters: name--Custom nameproperty--Other properties Property list of electrical local mesh along a line: default\ttype\tnotesstart_x\t0\tfloat start_y\t0\tfloat\tRestrained by condition: &gt;=0. start_z\t0\tfloat end_x\t1\tfloat end_y\t1\tfloat end_z\t1\tfloat\tRestrained by condition: &gt;=0. mesh_size\t0.01\tfloat Description: start_x--Set x coordinate of the start point. Similarly for the restmesh_size--Set the max size of electrical mesh grid in the range Note: When the simulation region is in the xy plane, besides start_x, start_y, end_x and end_y, it is also required to set the start_z and end_z, which should both be the same as the z coordinate of the plane. Similarly for the rest. Example of electrical local mesh along a line setting​ st.add_emesh_along_line(name=&quot;local_mesh_along_line&quot;, property={ &quot;start_x&quot;: 0, &quot;start_y&quot;: -1, &quot;start_z&quot;: -1, &quot;end_x&quot;: 0, &quot;end_y&quot;: 1, &quot;end_z&quot;: 1, &quot;mesh_size&quot;: 0.01}) 10. How to extract electrical result​ The simulation results are extracted by the extract function in SDK. 10.1 Extract generation rate​ Generation Rate is extracted from result_afdtd (result of AFDTD simulation). The format is result_generate = result_afdtd.run_generation_rate_analysis(name, monitor, average_dimension, light_power, coordinate_unit, field_length_unit) result_generate.extract(data, export_csv, show, log, savepath) result_afdtd.run_generation_rate_analysis() parameters: name--Custom namemonitor--Name of the power_monitor for calculating optical generation rate. The power_monitor is required to be of 3D typeaverage_dimension--Set the direction to take the average of the optical generate ratelight_power--Set the power of the light source, measured in W. The optical generation rate will be scaled based on the powercoordinate_unit--Set the coordinate unit in the optical generation rate file (gfile). Options are &quot;m&quot;, &quot;cm&quot;, &quot;um&quot; and &quot;nm&quot;field_length_unit--Set the length unit in the generation rate unit in the optical generation rate file (gfile). Options are &quot;m&quot;, &quot;cm&quot;, &quot;um&quot; and &quot;nm&quot;. If it's set to &quot;m&quot;, the generation rate unit in the gfile will be /m^3/s. Similarly for the rest result_genrate.extract() parameters： data--Type of the result When data is set to &quot;generation_rate&quot;, besides an image file and a csv file, the result files also include a text file in .gfile format. The coordinate unit in the csv and the image file is um, and the generation rate unit in the two files is /cm^3/s. These units can't be modified when extracting the result. However, the units in the gfile are controlled by coordinate_unit、field_length_unit. And only the gfile can be imported to the OEDevice solverWhen data is set to &quot;pabs_total&quot;, the total absorption power is extracted export_csv--Whether to export csv file show--Whether to show the plot in a popup window log--Whether to apply a logarithmic normalization in the intensity plot savepath--The save path of the result extraction Example of extracting generation rate​ result_generate = result_afdtd.run_generation_rate_analysis(name='genrate', monitor=3D_power_monitor_name, average_dimension='x', light_power=1, coordinate_unit='m', field_length_unit='m') result_generate.extract(data='generation_rate', export_csv=True, show=False, log=False, savepath=savepath) 10.2 Extract electrode result​ The results of electrode are extracted from result_oedevice (result of OEDevice simulation). The format is result_oedevice.extract(data, electrode, operation, export_csv, show, savepath) Extraction of electrode result parameters: data--Type of result When it's steady state simulation or SSAC simulation, options &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot; are available, which means the current at the electrode versus voltage is extracted, with &quot;I&quot; for the total current&quot;In&quot; for the electron current&quot;Ip&quot; for the hole current When it's SSAC simulation, options &quot;Iac&quot; and &quot;C&quot; are available, which means the AC current or capacitance at the electrode versus voltage at different frequency points is extracted, with &quot;Iac&quot; for the total AC current&quot;C&quot; for the capacitance When it's transient simulation, options &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot; are available, which means the current at the electrode versus time is extracted, with &quot;I&quot; for the total current&quot;In&quot; for the electron current&quot;Ip&quot; for the hole current electrode--Name of the electrodeoperation--Options are &quot;real&quot; (by default), &quot;imag&quot;, &quot;abs&quot;, &quot;abs2&quot;. For a result whose value is a real number, this parameter can be omitted. Bur for a result whose value is a complex number, like &quot;Iac&quot;, it must be used to extract the real and imaginary part of the result respectivelyexport_csv--Whether to export csv fileshow--Whether to show the plot in a popup windowsavepath--The save path of the result extraction Example of extracting electrode result​ result_oedevice.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=savepath) result_oedevice.extract(data=&quot;Iac&quot;, electrode=&quot;cathode&quot;, operation=&quot;real&quot;, export_csv=True, show=False, savepath=savepath) 10.3 Extract results of electrical monitor​ The electrical monitor result extraction is similar to the electrode result extraction, but a monitor instead of an electrode is required to be specified. The format is result_oedevice.extract(data, monitor, operation, export_csv, show, log, savepath) Extraction of electrode result parameters: data--Type of result When the monitor is charge_monitor, options &quot;n&quot;, &quot;p&quot; are available, which means the concentration of carriers is extracted, with &quot;n&quot; for the electron&quot;p&quot; for the hole When the monitor is electric_monitor, options &quot;electric_field&quot;, &quot;ex&quot;, &quot;ey&quot;, &quot;ez&quot;, &quot;potential&quot; are available, which means the concentration of carriers is extracted, with &quot;electric_field&quot; for the absolute value of the electric field&quot;ex&quot; for the x component of the electric field&quot;ey&quot; for the y component of the electric field&quot;ez&quot; for the z component of the electric field&quot;potential&quot; for the electrostatic potential When the monitor is band_monitor, options &quot;conduction_band&quot;, &quot;valence_band&quot;, &quot;equasi_fermi&quot;, &quot;hquasi_fermi&quot; are available, which means the band structure is extracted, with &quot;conduction_band&quot; for the conduction band energy level&quot;valence_band&quot; for the valence band energy level&quot;equasi_fermi&quot; for the electron quasi-Fermi potential&quot;hquasi_fermi&quot; for the hole quasi-Fermi potential operation--Options are &quot;real&quot; (by default), &quot;imag&quot;, &quot;abs&quot;, &quot;abs2&quot; export_csv--Whether to export csv file. When the monitor is of 2D type, the result is a distribution in a 2D region, and the plot is an intensity image; When the monitor is of 1D type, the result is a distribution along a 1D range, and the plot is a curve show--Whether to show the plot in a popup window log--Whether to take the logarithm of the result savepath--The save path of the result extraction Example of extracting electrical monitor result​ result_device.extract(data=&quot;n&quot;, monitor=&quot;charge_2d&quot;, export_csv=True, show=False, log=True, savepath=savepath) result_device.extract(data=&quot;p&quot;, monitor=&quot;charge_1d&quot;, export_csv=True, show=False, log=False, savepath=savepath) result_device.extract(data=&quot;electric_field&quot;, monitor=&quot;electric_2d&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;ex&quot;, monitor=&quot;electric_2d&quot;, operation=&quot;abs&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;potential&quot;, monitor=&quot;electric_1d&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;conduction_band&quot;, monitor=&quot;band_1d&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;hquasi_fermi&quot;, monitor=&quot;band_1d&quot;, export_csv=True, show=False, savepath=savepath) 10.4 Extract results of modulator analysis​ The results of modulator analysis are extracted from result_afde (result of AFDE). The format is result_afde.extract(data, operation, export_csv, show, savepath) result_afde.extract() parameters: data--Type of result. Options are &quot;effective_index&quot;, &quot;loss&quot;, which means the effective index or loss versus voltage is extractedoperation--Options are &quot;real&quot; (by default), &quot;imag&quot;, &quot;abs&quot;, &quot;abs2&quot;. For a result whose value is a real number, this parameter can be omitted. Bur for a result whose value is a complex number, like &quot;effective_index&quot;, it must be used to extract the real and imaginary part of the result respectivelyexport_csv--Whether to export csv fileshow--Whether to show the plot in a popup windowsavepath--The save path of the result extraction Example of extracting modulator analysis result​ result_afde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;real&quot;, show=False, savepath=savepath) result_afde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;imag&quot;, show=False, savepath=savepath) result_afde.extract(data=&quot;loss&quot;, export_csv=True, show=False, savepath=savepath) ","keywords":""},{"title":"Passive Device Simulation","type":0,"sectionRef":"#","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation","content":"Passive Device Simulation 1. How to create a new SDK simulation project?​ First, we need to import the SDK package to perform optical simulation calculations. import maxoptics_sdk.all as mo Following that, as shown in the following code, create a simulation project. The name represents the project's name. # region --- Project --- pj = mo.Project(name=project_name) # endregion 2. How to add materials in SDK simulation?​ Next, we need to add the materials used in the simulation process, as shown in the following code. Here, name represents the material's name, data represents the material object from the material library, and order is the priority of material coverage. When structures of different materials overlap, materials with higher order values will take precedence over those with lower values. In the case of equal values, the one added later takes precedence. # region --- Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) # endregion 2.1 How to add a non-dispersive material?​ Additionally, we can add a non-dispersive material using add_nondispersion. The data in data=[(real, imag)] represents the real and imaginary parts of the refractive index. mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=1) 2.2 How to add a dispersive material?​ We can add a dispersive material using add_dispersion, as shown in the following code. data=[(wavelength, real, imag)] represents the real and imaginary parts of the refractive index at different wavelengths. we can perform fitting to obtain the refractive index of the material at different wavelengths. mt = pj.Material() mt.add_dispersion(name=&quot;SiO2&quot;,data=[(1.55e-06, 1.444, 0), (1.30e-06, 1.81, 0.227)], order=1) 2.3 How to add an anisotropic material?​ We can add an anisotropic material using add_anisotropy. In this case, data=[(wavelength, nx_real, nx_imag, ny_real, ny_imag, nz_real, nz_imag)] represents the anisotropic refractive index's real and imaginary parts at different wavelengths. Similarly, we can use fitting to obtain the anisotropic refractive index of the material at various wavelengths. mt = pj.Material() mt.add_anisotropy(name=&quot;LN&quot;, fitting=None, data=[(1.55e-06, 2.211, 0, 2.138, 0, 2.211, 0)], order=2) 3. How to add geometric structures in SDK simulation?​ Next, let's learn how to create a geometric structure in SDK. 3.1 How to add background refractive index?​ Define the background refractive index in Structure as shown below. # region --- 3. Structure --- st = pj.Structure() # endregion 3.2 How to add a rectangular structure?​ As shown in the code below, we can add a structure within the Structure function using add_geometry. To add a rectangular structure, use type='Rectangle'. Specify the material from the previously defined material types, and set the mesh_order to determine the material coverage priority, as explained earlier in the material addition section. Within the parameters of the geometry section, x/y/z represent the center coordinates of the structure in three directions, while x_span/y_span/z_span determine the width of the structure in these three directions.The tilt_position is to ensure that the models are placed at the specified sizes on the different ratio of sidewalls when building the structures. Selections are ['top', 'bottom', 'middle','user_defined'].The tilt_angle is tilt angle of structure sidewall.Under the selectionuser_defined, we also need to set the ratio by user_defined_position. st.add_geometry(name=&quot;rectangle&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 1, &quot;x_span&quot;: size,&quot;y&quot;: space, &quot;y_span&quot;: wg_width, &quot;z&quot;: 1, &quot;z_span&quot;: wg_height, &quot;tilt_position&quot;:&quot;user_defined&quot;, &quot;tilt_angle&quot;:70, &quot;user_defined_position&quot;:0.1,}}) 3.3 How to add an arc waveguide in SDK simulation?​ Similarly, we can add an arc waveguide structure in SDK. In the geometry section, we usetype=&quot;Ring&quot; to build an arc waveguide.The inner_radius and out_radius represent the inner and outer radius of the arc structure, angle specifies the bending angle, and xyz determines the center position of the structure in three directions. z_span defines the thickness of the waveguide. st.add_geometry(name=&quot;ring&quot;, type=&quot;Ring&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 1, &quot;y&quot;: 2*space,&quot;z&quot;: 1, &quot;z_span&quot;: wg_height, &quot;angle&quot;:70, &quot;inner_radius&quot;: size-wg_width/2, &quot;outer_radius&quot;: size+wg_width/2, &quot;tilt_angle1&quot;: 70, &quot;tilt_position&quot;: &quot;bottom&quot;, &quot;tilt_angle2&quot;: 90,}}) 3.4 How to add a circular structure?​ Next, we'll learn how to add a circular structure using the following code. In this code, radius represents the radius of the circle, and x/y denote the coordinates of the center of the circle. st.add_geometry(name=&quot;circle&quot;, type=&quot;Circle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: size,&quot;angle&quot;:90, &quot;x&quot;: 2*space, &quot;y&quot;: 1,&quot;z&quot;: 1,&quot;z_span&quot;: wg_height, &quot;tilt_angle&quot;:70,&quot;tilt_position&quot;:&quot;middle&quot;,}}) 3.6 How to add a linear taper (Taper) structure?​ To create a linear taper structure, use the add_geometry function with type=&quot;LinearTrapezoid&quot;. Specify the coordinates of the four vertices of the taper structure using control_points. x/y/z determine the 3D reference point of the taper structure, and z_span sets the thickness of the taper waveguide. st.add_geometry(name=&quot;linear_trapezoid&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 2*space, &quot;y&quot;: space,&quot;z&quot;: 1, &quot;z_span&quot;: wg_height, &quot;control_points&quot;:[{&quot;x&quot;: 1, &quot;y&quot;: 1}, {&quot;x&quot;: 1, &quot;y&quot;: 2}, {&quot;x&quot;: 2, &quot;y&quot;: 2}, {&quot;x&quot;: 2, &quot;y&quot;: 0.1}], &quot;tilt_angle&quot;: 70, &quot;tilt_position&quot;: &quot;bottom&quot;,}}) 3.7 How to add a custom function-based geometric structure?​ Let's take the example of a taper structure with a custom function curve. To do this, use the add_geometry function with type=&quot;AnalyticalWaveguide&quot;. In this case, equation1 represents the expression of the waveguide boundary function. The parameters x/y/z denote the center coordinates, x span/y span define the domain range, resolution sets the resolution, nonsymmetric determines whether the structure is non-symmetric. st.add_geometry(name=&quot;analytical_waveguide&quot;,type=&quot;AnalyticalWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: { &quot;equation1&quot;:&quot;x^0.5&quot;, &quot;nonsymmetric&quot;: True, &quot;equation2&quot;:&quot;x&quot;, &quot;x&quot;: 5*space, &quot;x_span&quot;:20, &quot;y&quot;:5 *space, &quot;y_span&quot;:20, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;resolution&quot;:20, &quot;tilt_angle&quot;:70,&quot;tilt_position&quot;:&quot;middle&quot;,}}) 3.8 How to import a GDS file and create the corresponding model in SDK?​ The following code example demonstrates how to import a GDS file and create the corresponding structure in SDK. First, we need to obtain the full file path of the GDS file (gds_file). Then, use the add_geometry function with type=&quot;gds_file&quot; to import the GDS file. The path parameter should contain the full path to the GDS file, cell_name is the name of the cell to be imported from the GDS file, layer_name specifies the layer type and data type to be imported, and material is the material associated with the structure. gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/fast_fdtd.gds&quot; st.add_geometry(name=&quot;gds_file_3D&quot;,type=&quot;gds_file&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;EXTEND_1&quot;, &quot;layer_name&quot;: (3, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 4*space, &quot;y&quot;: 2*space,&quot;z&quot;: 0.05,&quot;z_span&quot;: 0.1, &quot;tilt_angle&quot;: 60,&quot;tilt_position&quot;: &quot;bottom&quot;,}}) During the process of modeling by importing GDS files, it's important to pay attention to the setting of the material's mesh_order to ensure that the overlapping structures are covered in the correct order. 3.9 How to set the mesh order?​ The mesh order decides the coverage when creating a geometric structure. When the mesh order of two structures are same, the structure which is established later has a higher priority. When the mesh order of two structures are different, the large numerical value of mesh order has greater priority than the small one. That is, The large mesh order of structure is able to cover small mesh order of structure. For example, the mesh order=2 structure will cover the mesh order=1. The advantage is that increasing the value of mesh order allows user to make new nested structures in the complex model. 4. How to set up FDE simulation in SDK?​ 4.1 How to configure various parameters for FDE simulation?​ Next, we will learn how to add an FDE simulation and set its simulation parameters in SDK using the Simulation function. Within the simu.add section, we can set the simulation name name, simulation type type, and various simulation parameters in the property field. Within property. And we also need to set the simulation boundary, where geometry defines the geometry parameters, and boundary_conditions specifies the cross-sectional simulation boundary parameters, we can set the simulation solver type through solver_type (with the default value as 2d_x_normal). In the mesh_settings section, we can configure mesh parameters, including setting the grid sizes in different directions using global_mesh_uniform_grid. # region --- Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;FDE&quot;, property={&quot;background_material&quot;: mt[&quot;Air&quot;], &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: yspan_solver, &quot;z&quot;: 0, &quot;z_span&quot;: zspan_solver, }, &quot;boundary_conditions&quot;: {&quot;y_min_bc&quot;: &quot;PML&quot;, &quot;y_max_bc&quot;: &quot;PML&quot;, &quot;z_min_bc&quot;: &quot;PML&quot;, &quot;z_max_bc&quot;: &quot;PML&quot;, &quot;pml_settings&quot;: {&quot;pml_layer&quot;: 12, &quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 5, # &quot;polynomial_order&quot;: 3, }}, # 'mode_removal': {'threshold': 0.02}, 'fractional_offset_for_group_delay': 0.0003, 'general': {'solver_type': '2d_x_normal'}, # default is '2d_x_normal' ['2d_x_normal','2d_y_normal','2d_z_normal'] &quot;mesh_settings&quot;: {&quot;mesh_refinement&quot;: {&quot;mesh_refinement&quot;: &quot;curve_mesh&quot;}, &quot;mesh_factor&quot;: 1.2, &quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid, }, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }}) simu_res = simu[simu_name].run() # endregion 4.2 How to calculate the overlap in FDE simulation?​ Overlap calculations in FDE simulation can be performed by utilizing the following code to calculate the overlap between the mode light and a Gaussian light source, as illustrated in the code below. if run_options.run_overlap: if run_options.run_beam: beam_res = simu[simu_name].run_fde_beam_and_extract( property={&quot;define_gaussian_beam_by&quot;: &quot;waist_size_and_position&quot;, # [waist_size_and_position,beam_size_and_divergence], &quot;waist_radius&quot;: 5.2, &quot;distance_from_waist&quot;: 1.5, &quot;refractive_index&quot;: 1.45, &quot;theta&quot;: 0, &quot;phi&quot;: 0, &quot;polarization_angle&quot;: 90, &quot;sample_span&quot;: 6, &quot;sample_resolution&quot;: 200}, savepath=plot_path + &quot;beam_heatmap&quot;) analysis.add(name=&quot;overlap&quot;, type=&quot;overlap&quot;, property={&quot;field_1&quot;: {&quot;workflow_id&quot;: beam_res.workflow_id, &quot;mode&quot;: 0}, &quot;field_2&quot;: {&quot;workflow_id&quot;: fde_res.workflow_id, &quot;mode&quot;: 0}, &quot;optimize_position&quot;: True}) overlap_res = analysis[&quot;overlap&quot;].run() overlap_res.extract( export_csv=True, savepath=plot_path + &quot;overlap&quot;) 4.3 How to view the refractive index profile in the FDE/FDTD/EME modules?​ As demonstrated in the code below, we can visualize the refractive index profile of a device's cross-section using index monitor in FDTD/EME simulation.Assuming that we want to calculate the refractive index profile on the x-direction cross-section of the device. Set the position of the index monitor along the x-axis by specifying x=0 and setting x_span=0. Then, configure the center coordinates y/z and the dimensions y_span/z_span for the cross-sectional refractive index profile calculation area. The setup for calculating the refractive index profile in the y/z-direction cross-section is analogous. mn = pj.Monitor() mn.add(name=&quot;index_monitor_1&quot;,type=&quot;index_monitor&quot;, property={&quot;geometry&quot;: { &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0, &quot;z_span&quot;: 5,}},) # results view simu[simu_name].preview_index(monitor_name=&quot;x_normal_index&quot;, savepath=f&quot;{plot_path}01_IndexPreview_x=0&quot;) And in the FDE simulation, we can use the mesh structure to preview the index directly. analysis = pj.Analysis() analysis.add_analysis(name=&quot;fast_FDE_Analysis&quot;, type=&quot;FDEAnalysis&quot;, props={&quot;workflow_id&quot;: simu_res.workflow_id, &quot;simulation_name&quot;: &quot;FDE&quot;, &quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: run_options.run, &quot;mesh_structure&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: number_of_trial_modes, &quot;search&quot;: &quot;max_index&quot;, # ['near_n','max_index'] # &quot;n&quot;: 1, &quot;calculate_group_index&quot;: False, &quot;bent_waveguide&quot;: {&quot;bent_waveguide&quot;: False, &quot;radius&quot;: 1, &quot;orientation&quot;: 0, &quot;location&quot;: &quot;simulation_center&quot;} }, &quot;frequency_analysis&quot;: {&quot;frequency_analysis&quot;: run_options.run_frequency_sweep, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 1, &quot;detailed_dispersion_calculation&quot;: False }}) result_fde = analysis[&quot;fast_FDE_Analysis&quot;].run() 4.4 How to retrieve simulation data in the FDE module of SDK?​ To obtain simulation data in the FDE module of SDK, we can first use result_fde.extract with data='calculate_modes' to retrieve neffctive table of modes, which can be saved in the savepath directory. we can choose to export the mode field data as a CSV file by using export_csv. Set the attribute, mode, real, and imag parameters to extract the specific mode-related data we need. When using the frequency scan feature in the FDE module, we can extract data by specifying data=&quot;frequency_analysis&quot;. As shown in the code, we can retrieve various components such as &quot;neff,&quot; &quot;loss,&quot; &quot;group_index,&quot; &quot;polarization,&quot; and more. # region --- See Results --- if run_options.extract: if run_options.run: result_fde.extract( data=&quot;mesh_structure&quot;, savepath=f&quot;{plot_path}01_index&quot;, export_csv=True) res = result_fde.extract( data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}02_neff_table&quot;, export_csv=True) print(res.to_string(index=True)) for m in range(len(res)): result_fde.extract(data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}03_mode{m}&quot;, attribute=&quot;E&quot;, mode=m, real=True, imag=True, **export_options, show=False) if run_options.run_frequency_sweep: attr_selections: List[Literal[&quot;neff&quot;, &quot;loss&quot;, &quot;group_index&quot;, &quot;polarization&quot;]] = [ &quot;neff&quot;, &quot;loss&quot;, &quot;group_index&quot;, &quot;polarization&quot;] for i, a in enumerate(attr_selections): result_fde.extract(data=&quot;frequency_analysis&quot;, savepath=f&quot;{plot_path}04_freq_sweep_{a}&quot;, attribute=a, real=True, imag=True, export_csv=True, export_mat=True, show=False) # endregion 5. How to set up EME simulation in SDK?​ 5.1 How to configure boundary conditions and ports in EME simulation?​ To begin with, we need to define the boundary conditions. Then, we can set the geometric dimensions of the boundaries with geometry and configure the boundary parameters for each dimension with boundary_conditions in the EME simulation. Next, we should configure the EME ports using Port. we can add a new port using add. Specify the port_location for the port's location. we can choose the mode for this port through mode_selection, such as fundamental_TE or fundamental_TM. Additionally, we can select user_select to define a custom mode for the port by setting mode_index to a positive integer value. Use use_full_simulation_span to determine whether the full simulation span should be used. # region --- Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;background_material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_settings&quot;: {&quot;mesh_factor&quot;: 1.2, &quot;mesh_refinement&quot;: {&quot;mesh_refinement&quot;: &quot;curve_mesh&quot;}}, &quot;geometry&quot;: {&quot;x_min&quot;: -1, &quot;y&quot;: 0, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 3}, &quot;boundary_conditions&quot;: {&quot;y_min_bc&quot;: &quot;PML&quot;, &quot;y_max_bc&quot;: &quot;PML&quot;, &quot;z_min_bc&quot;: &quot;PML&quot;, &quot;z_max_bc&quot;: &quot;PML&quot;, &quot;pml_settings&quot;: {&quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 5, &quot;pml_layer&quot;: 12, &quot;pml_polynomial&quot;: 3} }, &quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;wavelength_offset&quot;: 0.0003, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: {&quot;cell_geometry&quot;: {&quot;allow_custom_eigensolver_settings&quot;: True, &quot;cell_group_definition&quot;: [{&quot;span&quot;: 2, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}} }) # endregion # region --- EME Port --- pjp = pj.Port() pjp.add(name=&quot;eme_in&quot;, type=&quot;eme_port&quot;, property={&quot;modal_analysis&quot;: {&quot;wavelength&quot;: wavelength}, &quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, # 'use_full_simulation_span': False, # default is 'True' # &quot;y&quot;: 0, # &quot;y_span&quot;: 3, # &quot;z&quot;: 0, # &quot;z_span&quot;: 3 }, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: (&quot;fundamental_TE&quot;), &quot;number_of_trial_modes&quot;: number_of_modes, # 'mode_index': 0, 'search': 'max_index' }}}) pjp.add(name=&quot;eme_out&quot;, type=&quot;eme_port&quot;, property={&quot;modal_analysis&quot;: {&quot;wavelength&quot;: wavelength, }, &quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, # 'use_full_simulation_span': False, # default is 'True' # &quot;y&quot;: 0,&quot;y_span&quot;: 3,&quot;z&quot;: 0,&quot;z_span&quot;: 3 }, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: (&quot;fundamental_TE&quot;), &quot;number_of_trial_modes&quot;: number_of_modes, # 'mode_index': 0, 'search': 'max_index' }}}) # endregion 5.2 How to add a profile monitor in EME simulation?​ As shown in the code below, we can add a new monitor to wer EME simulation. Use type='profile_monitor' to specify the type of monitor we want to add. In the property section, we can configure various parameters for the monitor. For example, set monitor_type to determine the direction of the monitor. Define the coordinates and dimensions of the monitor using x/y/z and x_span/y_span/z_span, with the normal span width set to zero. # region --- Monitor --- mn = pj.Monitor() mn.add(name=&quot;x_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, # 'x_resolution': 100, &quot;x&quot;: 0.9, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 3}}) # endregion 5.3 How to configure parameters for EME simulation?​ Next, we will learn how to set the parameters for EME simulation within the code below. Under the general parameters, we can define the wavelength for the EME simulation wavelength. Following that, we can define the EME simulation cells using cell_group_definition. Within this section, span represents the length of each cell, cell_number specifies how many cells the length should be evenly divided into, number_of_modes determines the number of modes to be solved during the calculation, and sc determines the method for calculating the S-matrix between cells. The transverse_mesh_setting section allows we to configure the transverse mesh settings. # region --- Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;background_material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_settings&quot;: {&quot;mesh_factor&quot;: 1.2, &quot;mesh_refinement&quot;: {&quot;mesh_refinement&quot;: &quot;curve_mesh&quot;}}, &quot;geometry&quot;: {&quot;x_min&quot;: -1, &quot;y&quot;: 0, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 3}, &quot;boundary_conditions&quot;: {&quot;y_min_bc&quot;: &quot;PML&quot;, &quot;y_max_bc&quot;: &quot;PML&quot;, &quot;z_min_bc&quot;: &quot;PML&quot;, &quot;z_max_bc&quot;: &quot;PML&quot;, &quot;pml_settings&quot;: {&quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 5, &quot;pml_layer&quot;: 12, &quot;pml_polynomial&quot;: 3} }, &quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;wavelength_offset&quot;: 0.0003, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: {&quot;cell_geometry&quot;: {&quot;allow_custom_eigensolver_settings&quot;: True, &quot;cell_group_definition&quot;: [{&quot;span&quot;: 2, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}} }) # endregion 5.4 How to set up a preview of EME simulation structure images?​ we can preview the EME simulation structure and images using structure_show. In the example code below, the parameter fig_type determines the image format, typically &quot;png.&quot; Use show to specify whether we want to generate images. Set savepath for the path where the result images will be saved. we can use celldisplay to control whether cells are displayed in the image, and xyratio adjusts the aspect ratio between the x and y coordinates in the image, with the default value being (1,1). # region --- Structure Show --- st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=f&quot;{plot_path}00_{simu_name}&quot;, celldisplay=True, xyratio=(1, 1)) # endregion 5.5 How to obtain EME port mode results?​ we can retrieve the results of EME prot mode by using preview_modes. In the example code below, we can extract the port mode information. Set data=&quot;calculate_modes&quot; to specify that we want to retrieve EME port mode results. Use save_path to specify the data saving path, and define attribute to specify the data content we wish to extract. # region --- 11. Calculate Mode --- if run_options.calculate_modes: for port in [&quot;eme_in&quot;, &quot;eme_out&quot;]: simu[simu_name].preview_modes(port_name=port, data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}02_modeprofile_fdeonly_{port}&quot;, attribute=&quot;E&quot;, mode=0) simu[simu_name].preview_modes(port_name=port, data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}02_Preview_{port}_neff&quot;, show=False, export_csv=True) # endregion 5.6 How to obtain mode field plots for EME/FDTD?​ Similarly, we can use eme_res.extract to retrieve simulation results. In the example code below, we can set data='eme_propagate:monitor' to specify that we want to obtain monitor results. Define the save_path for data storage and use the attribute parameter to specify the data to be extracted. plot_x and plot_y control the x and y-axis coordinates for line or heatmap plots. Use real and imag to determine how the output data should be handled: when both are False, the program will raise an error with &quot;real and imag are both false&quot;; when both are True, the results will be taken as the absolute value; if one is True, either the real or imaginary part will be output. show controls whether images are displayed, and export_csv determines if data should be saved as a CSV file. eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, # plot_x='y', plot_y='z', # real=True, imag=True, # export_csv=False, show=False ) 5.7 How to perform EME length sweeps?​ As demonstrated in the code below, we can generate N x N S-parameter matrix length sweep plots using data=&quot;propagation_sweep:sweep&quot;, where N represents the number of ports. # region --- EME Propagation Sweep Results --- if run_options.run_length_sweep: eme_res.extract( data=&quot;propagation_sweep:sweep&quot;, savepath=f&quot;{plot_path}{kL[4]}_length_sweep&quot;, export_csv=True, ) # endregion 5.8 How to perform EME wavelength sweeps?​ As shown in the code below, we can generate N x N S-parameter matrix wavelength sweep plots using data=&quot;wavelength_sweep:sweep&quot;, where N represents the number of ports. # region --- EME Wavelength Sweep Results --- if run_options.run_wavelength_sweep: eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;06_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) # endregion 5.9 During EME simulations, is overlap recalculated when wavelength scans are repeated?​ During EME simulations, when performing wavelength sweeps, the workflow involves first computing all the modes within the cells, and then during the sweep, calculating overlap and normalization as needed. If we repeat wavelength scans, there is no need to recalculate overlap. The program will perform the overlap calculation only once. 6. How to configure FDTD simulations in SDK?​ 6.1 How to set the wavelength for FDTD simulations?​ Waveform supports defining wavelength, wavelength span, and related parameters. It includes common communication wavelengths like 1550 nm and 1310 nm, as well as visible light wavelengths. # region --- Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, type='gaussian_waveform', property={'set': 'frequency_wavelength', # selections are ['frequency_wavelength','time_domain'] 'set_frequency_wavelength': { 'range_type': 'wavelength', # selections are ['frequency','wavelength'] 'range_limit': 'center_span', # selections are ['min_max','center_span'] 'wavelength_center': wavelength, 'wavelength_span': 0.1,},}) # endregion 6.2 How to set up light sources for FDTD simulations?​ we can configure light sources for FDTD simulations using the source function, as shown in the code below. In this setup, the type specifies the source type, commonly using mode sources in waveguides and Gaussian sources in free space. The inject_axis and direction determine the reference propagation dierection for the light source. we can select specific modes using mode_selection and mode_index, and choose a specific waveform with waveform. The geometry parameter defines the geometric dimensions of the light source. # region --- ModeSource --- src = pj.Source() src.add(name=&quot;source&quot;, type=&quot;mode_source&quot;, property={&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;, &quot;waveform&quot;: {&quot;waveform_id&quot;: wv[waveform_name]}, &quot;inject_axis&quot;: &quot;x_axis&quot;, &quot;direction&quot;: &quot;forward&quot;}, &quot;geometry&quot;: {&quot;x&quot;: -l_input-l_beam/2-l_bend+2, &quot;x_span&quot;: 0, &quot;y&quot;: 1.35, &quot;y_span&quot;: monitor_w, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}}) # endregion 6.3 How to configure monitors in FDTD simulations?​ Let's briefly introduce the setup of FDTD monitors, including global monitors, power monitors, and mode expansion monitors. As shown in the code below, we can use type='global_option' to select a global monitor. Set wavelength_center to specify the center wavelength for the monitor, wavelength_span for the wavelength range, and frequency_points to determine the number of points monitored within that wavelength range. # region --- GlobalMonitor --- mn = pj.Monitor() mn.add(name=&quot;Global Option&quot;, type=&quot;global_option&quot;, property={&quot;frequency_power&quot;: {&quot;spacing_type&quot;: &quot;wavelength&quot;, &quot;spacing_limit&quot;: &quot;center_span&quot;, &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 11}}) # endregion As shown in the following code, we can set up power monitors in FDTD simulations using the type='power_monitor'. The name parameter specifies the monitor's name. In the property section, we can configure various monitor parameters, including wavelength-related settings such as wavelength_center, wavelength_span, and frequency_points. The geometry section allows we to set the monitor's orientation, position, and dimensions with parameters such as monitor_type, x/y/z, and x_span/y_span/z_span. # region --- Through --- mn.add(name=&quot;Znormal&quot;, type=&quot;power_monitor&quot;, property={&quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 3}}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_min&quot;: -(l_input+l_bend+l_beam/2-0.5), &quot;x_max&quot;: l_input+l_bend+l_beam/2-0.5, &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0}}) # endregion 6.4 How to configure Port-related parameters in FDTD?​ we can set the parameters related to ports in FDTD simulations as demonstrated in the code below. The waveform_id specifies the input wavelength, and source_port determines the input port. Then, using the add method, we can add the corresponding port with type='fdtd_port', providing a name for the port. In the property section, we can configure its relevant parameters, and in the geometry section, we can set the port's position and dimensions. The modal_properties parameter allows we to specify the properties of the input light, including inject_axis for the light's injection axis, direction for the direction of the incident light, and mode_selection for selecting the light mode. # region --- Port --- pt = pj.Port(property={&quot;waveform_id&quot;: wv[waveform_name], &quot;source_port&quot;: &quot;left_port&quot;, &quot;monitor_frequency_points&quot;: 11}) pt.add(name=&quot;left_port&quot;, type=&quot;fdtd_port&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: -wg_length / 2 + span, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: port_width, &quot;z&quot;: 0, &quot;z_span&quot;: port_height, }, &quot;modal_properties&quot;: {&quot;general&quot;: {&quot;inject_axis&quot;: &quot;x_axis&quot;, &quot;direction&quot;: &quot;forward&quot;, &quot;mode_selection&quot;: &quot;fundamental&quot;}}}) # endregion 6.5 How to extract relevant results from FDTD simulations?​ As shown in the following code, we can specify the savepath for saving the results. Use target='line' for line plots or target='intensity' for intensity plots. The attribute parameter specifies the parameters to be extracted, and wavelength is used to specify the wavelength. To extract the mode field at a specific wavelength from a power monitor: fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=f&quot;{plot_path}04_x_normal_abs(E)&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, monitor_name=&quot;x_normal&quot;, wavelength=str(wavelength), export_csv=True) Extracting the transmittance at different wavelengths from a power monitor: fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=f&quot;{plot_path}03_x_normal_abs(T)&quot;, target=&quot;line&quot;, attribute=&quot;T&quot;, monitor_name=&quot;x_normal&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) Extracting the response of a mode expansion monitor to a specific mode transmission from a power monitor: me_res.extract(data=&quot;fdtd:mode_expansion&quot;, savepath=f&quot;{plot_path}04_TransVsOrder&quot;, target=&quot;line&quot;, attribute=&quot;T_forward&quot;, real=True, imag=True, mode_expansion_name=&quot;me_through&quot;, wavelength=f&quot;{wavelength}&quot;, plot_x=&quot;mode&quot;, show=False, export_csv=True) Extracting the S-matrix results from FDTD simulations: smatrix_res.extract(data=&quot;smatrix_sweep&quot;, savepath=f&quot;{plot_path}05_smatrix_sweep&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) 6.6 Why does the S-matrix in FDTD simulation sometimes exceed 1?​ In FDTD simulations, the presence of a light source in the simulation region can lead to incorrect S-matrix results, such as some port responses exceeding 1. To ensure accurate S-matrix calculations, it's essential to make sure that there are no light sources within the simulation region.","keywords":""},{"title":"Monitor","type":0,"sectionRef":"#","url":"/my-website/docs/test/SDK/5Mornitor","content":"Monitor Type of the monitor, Selections are [&quot;index_monitor&quot;, &quot;time_monitor&quot;, &quot;power_monitor&quot;, &quot;profile_monitor&quot;, &quot;global_option&quot;] 5.1 Index Monitor​ The syntax and properties for adding index monitor are as follows. This function does not return any data. add( name: str, typename: Literal[&quot;index_monitor&quot;], property: dict, ): Geometry​ Parameter\tType\tDefault\tDescriptionmonitor_type\tstring\t-\tThe types of index monitor that can be selected are &quot;2d_x_normal&quot;,&quot;2d_y_normal&quot; and &quot;2d_z_normal&quot;. x, y, z\tnumber\t-\tThe center position of the index monitor. X span, Y span, z_span\tnumber\t-\tXspan, Y span, Z span of the index monitor. x_min, x_max\tnumber\t-\tX min, X max position of the index monitor. y_min, y_max\tnumber\t-\tY min, Y max position of the index monitor. z_min, z_max\tnumber\t-\tZ min, Z max position of the index monitor. Example:The following script add a 2D index monitor and set its dimension and position. This script assumes that FDTD or EME solver has been added to the simulation environment, and the pj is an instance of the project. mn = pj.Monitor() mn.add(name=&quot;x_normal_index&quot;, type=&quot;index_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 6} }) 5.2 Time monitor​ add( name: str, typename: Literal[&quot;time_monitor&quot;], property: dict, ): General​ Parameter\tType\tDefault\tDescriptionstop_method\tstring\t&quot;end_of_simulation&quot;\tSelects &quot;end_of_simulation&quot;, &quot;choose_stop_time&quot; or &quot;choose_number_of_snapshots&quot; to stop start_time\tnumber\t0\tA float, or a parameter, or a parameter expression that evaluates to a float stop_time\tnumber\t1000\tA float, or a parameter, or a parameter expression that evaluates to a float number_of_snapshots\tinteger\t0 Geometry​ Parameter\tType\tDefault\tDescriptionmonitor_type\tstring\t-\tThe types of time monitor that can be selected are &quot;point&quot;, &quot;2d_x_normal&quot;,&quot;2d_y_normal&quot;,&quot;2d_z_normal&quot;, &quot;x_linear&quot;, &quot;y_linear&quot;, &quot;z_linear&quot;, &quot;three_dimension&quot; x, y, z\tnumber\t-\tThe center position of the time monitor. x_span, y_span, z_span\tnumber\t-\tX span, Y span, Z span of the time monitor. x_min, x_max\tnumber\t-\tX min, X max position of the time monitor. y_min, y_max\tnumber\t-\tY min, Y max position of the time monitor. z_min, z_max\tnumber\t-\tZ min, Z max position of the time monitor. Data to record​ Advancd​ sampling_rate:min_sampling_per_cycle: Example:The following script add a time monitor and set its dimension and position. This script assumes that FDTD solver has been added to the simulation environment, and the pj is an instance of the project. mn = pj.Monitor() mn.add(name=&quot;time_monitor1&quot;, type=&quot;time_monitor&quot;, property={&quot;general&quot;: { &quot;stop_method&quot;: &quot;end_of_simulation&quot;, &quot;start_time&quot;: 0, &quot;stop_time&quot;: 100, &quot;number_of_snapshots&quot;: 10}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;point&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0}, &quot;advanced&quot;: {&quot;sampling_rate&quot;: {&quot;min_sampling_per_cycle&quot;: 10}}}) 5.3 Power monitor​ add( name: str, typename: Literal[&quot;index_monitor&quot;], property: dict, ): Frequency profile​ Parameter\tType\tDefault\tDescriptionsample spacing\tstring use_wavelength_spacing\tboolean\tTrue use source limits\tboolean\tFalse spacing type\tstring\twavelength\tSelections are [&quot;wavelength&quot;, &quot;frequency&quot;] spacing_limit\tstring\tmin_max\tSelections are [&quot;min_max&quot;, &quot;center_span&quot;] wavelength center, frequency center\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float wavelength span, frequency span\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float wavelength min, wavelength wax\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float frequency min, frequency max\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float frequency_profile.frequency_points\tinteger\t5 Geometry​ Parameter\tType\tDefault\tDescriptionmonitor_type\tstring\t-\tThe types of power monitor that can be selected are &quot;point&quot;, &quot;2d_x_normal&quot;,&quot;2d_y_normal&quot;,&quot;2d_z_normal&quot;, &quot;x_linear&quot;, &quot;y_linear&quot;, &quot;z_linear&quot;. x, y, z\tnumber\t-\tThe center position of the power monitor. X span, Y span, z_span\tnumber\t-\tXspan, Y span, Z span of the power monitor. x_min, x_max\tnumber\t-\tX min, X max position of the power monitor. y_min, y_max\tnumber\t-\tY min, Y max position of the power monitor. z_min, z_max\tnumber\t-\tZ min, Z max position of the power monitor. Data to record​ Fields: output_ex poynting_vector_and_power: output_power Example:The following script add a power monitor and set its dimension and position. This script assumes that FDTD solver has been added to the simulation environment, and the pj is an instance of the project. mn = pj.Monitor() mn.add(name=&quot;z_normal&quot;, type=&quot;power_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;,&quot;x&quot;: 0, &quot;x_span&quot;: 5, &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0, &quot;z_span&quot;: 0}}) 5.4 Profile monitor​ Geometry properties​ Parameter\tType\tDefault\tDescriptionmonitor type\tstring\t-\tThe types of profile monitor that can be selected are &quot;2d_x_normal&quot;,&quot;2d_y_normal&quot; and &quot;2d_z_normal&quot;. x_resolution\tinteger\t100\tThe resolution of output simulation results of profile monitor. x, y, z\tnumber\t-\tThe center position of the profile monitor. x_span, y_span, z_span\tnumber\t-\tX span, Y span, Z span of the profile monitor. x_min, x_max\tnumber\t-\tX min, X max position of the profile monitor. y_min, y_max\tnumber\t-\tY min, Y max position of the profile monitor. z_min, z_max\tnumber\t-\tZ min, Z max position of the profile monitor. Example:The following script add a profile monitor and set its dimension and position. This script assumes that EME solver has been added to the simulation environment, and the pj is an instance of the project. mn = pj.Monitor() mn.add(name=&quot;y_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_y_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 7}}) 5.5 Global monitor/Global option​ Frequency power properties​ Parameter\tType\tDefault\tDescriptionsample spacing\tinteger\t0\tSet the type of frequency interval for the frequency monitor. use wavelength_spacing\tboolean\tTrue use source limits\tboolean\tFalse spacing type\tstring\twavelength\tSelections are [&quot;wavelength&quot;, &quot;frequency&quot;] spacing limit\tstring\tmin_max\tSelections are [&quot;min_max&quot;, &quot;center_span&quot;] wavelength center, wavelength center\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float wavelength span, frequency span\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float wavelength min, wavelength max\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float frequency_min, frequency max\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float frequency_points\tinteger\t5 Advanced​ advanced: min_sampling_per_cycle Example:The following script add the global monitor and set its frequency domain range and number of frequency points. This script assumes that FDTD solver has been added to the simulation environment, and the pj is an instance of the project. mn = pj.Monitor() mn.add(name=&quot;Global Option&quot;, type=&quot;global_option&quot;, property={&quot;frequency_power&quot;: { # &quot;sample_spacing&quot;: &quot;uniform&quot;, &quot;use_wavelength_spacing&quot;: True, # [&quot;min_max&quot;,&quot;center_span&quot;] &quot;spacing_type&quot;: &quot;wavelength&quot;, &quot;spacing_limit&quot;: &quot;center_span&quot;, &quot;wavelength_center&quot;: 1.5, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 11}}) 5.5 Band monitor​ Integrate a band monitor into the current project. add( self, *, type: Literal[&quot;band_monitor&quot;], name: str, property: PostProcessBandMonitor, ) Parameters\tDescriptionname\tThe name of band monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of band monitor. Example: mn = pj.Monitor() mn.add(name=&quot;band_line&quot;, type=&quot;band_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_z&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;interpolate_accuracy&quot;: 9}}) # endregion Parameters\tDefault\tType\tNotesgeneral.record_ec\ttrue\tbool\tThe conduction band edge energy at 300K. general.record_ev\ttrue\tbool\tThe valance band edge energy at 300K. general.record_ei\ttrue\tbool\tThe fermi level for intrinsic doped material. general.record_efn\ttrue\tbool\tThe electron quasi-Fermi energy. general.record_efp\ttrue\tbool\tThe hole quasi-Fermi energy. general.record_evac\ttrue\tbool geometry.monitor_type string\tSet the dimension type of the monitor. For electrical monitors, only 1D type and 2D type are available currently. Selections are [&quot;linear_x&quot;, &quot;linear_y&quot;, &quot;linear_z&quot;]. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the band monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the band monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the band monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the band monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the band monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the band monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the band monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the band monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the band monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the band monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the band monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the band monitor. geometry.interpolate_accuracy\t1\tinteger\tSet the accuracy of the rectangular grid for extracting the monitor result. Restrained by condition: &gt;=1 &amp;&amp; &lt;= 10. Here 1 means the grid size is 10nm, and 10 means the grid size is 1nm, and the grid size varies uniformly with the variation in &quot;interpolate_accuracy&quot;. 5.6 Charge monitor​ Incorporate a charge monitor into the current project. add( self, *, type: Literal[&quot;charge_monitor&quot;], name: str, property: PostProcessChargeMonitor, ) Parameters\tDescriptionname\tThe name of charge monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of charge monitor. Example: mn = pj.Monitor() mn.add(name=&quot;np_line_080nm&quot;, type=&quot;charge_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_y&quot;, &quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: -0.4, &quot;y_max&quot;: 0.4, &quot;z&quot;: 0.08, &quot;z_span&quot;: 0, &quot;interpolate_accuracy&quot;: 9}}) Parameters\tDefault\tType\tNotesgeneral.record_electrons\ttrue\tbool\tThe distribution of electron concentration in monitor. general.record_holes\ttrue\tbool\tThe distribution of hole concentration in monitor. general.integrate_total_charge\ttrue\tbool\tAvailable when monitor_type is in [&quot;2d_x_normal&quot;, &quot;2d_y_normal&quot;, &quot;2d_z_normal&quot;]. geometry.monitor_type string\tSelections are [&quot;linear_x&quot;, &quot;linear_y&quot;, &quot;linear_z&quot;, &quot;2d_x_normal&quot;, &quot;2d_y_normal&quot;, &quot;2d_z_normal&quot;]. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the charge monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the charge monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the charge monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the charge monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the charge monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the charge monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the charge monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the charge monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the charge monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the charge monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the charge monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the charge monitor. geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10. 5.7 Electric monitor​ Integrate an electric monitor into the current project. add( self, *, type: Literal[&quot;electric_monitor&quot;], name: str, property: PostProcessElectricMonitor, ) Parameters\tDescriptionname\tThe name of electric monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of electric monitor. Example: mn = pj.Monitor() mn.add(name=&quot;electric_2d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: -Ge_y_span_bottom*3/4, &quot;y_max&quot;: Ge_y_span_bottom*3/4, &quot;z_min&quot;: 0, &quot;z_max&quot;: Si_z_span+Ge_z_span, &quot;interpolate_accuracy&quot;: 6}}) Parameters\tDefault\tType\tNotesgeneral.record_electrics_field\ttrue\tbool\tThe distribution of electric field in monitor. general.record_electrostatic_potential\ttrue\tbool\tThe distribution of electric potential in monitor. general.calculate_net_charge\ttrue\tbool\tAvailable when monitor_type is in [&quot;2d_x_normal&quot;, &quot;2d_y_normal&quot;, &quot;2d_z_normal&quot;]. geometry.monitor_type string\tSelections are [&quot;linear_x&quot;, &quot;linear_y&quot;, &quot;linear_z&quot;, &quot;2d_x_normal&quot;, &quot;2d_y_normal&quot;, &quot;2d_z_normal&quot;]. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the electric monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the electric monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the electric monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the electric monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the electric monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the electric monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the electric monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the electric monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the electric monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the electric monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the electric monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the electric monitor. geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10.","keywords":""},{"title":"Structure","type":0,"sectionRef":"#","url":"/my-website/docs/test/SDK/2Structure","content":"Structure The code within the &quot;Structure&quot; section is designed to assist you incorporating the necessary structures during the EO(Electro-Optic) simulation process. You can choose to create geometry models using GDS files. Meanwhile, you can also utilize various methods in this &quot;Structure&quot; module such as Bézier curves, tapering, and circular rings for your simulation project. 2.1 Add geometry​ Use Structure() to instance a structure into the project, and then use add_geometry() to add any geometric structure. The types that support adding geometric structures include &quot;Triangle&quot;, &quot;Rectangle&quot;, &quot;Circle&quot;, &quot;Ring&quot;, &quot;Polygon&quot;, &quot;Ellipse&quot;, &quot;LinearTrapezoid&quot;, &quot;Pyramid&quot;, &quot;AnalyticalWaveguide&quot;, &quot;Sphere&quot;, &quot;StraightWaveguide&quot;, &quot;BezierWaveguide&quot; and &quot;gds_file&quot;. The syntax for adding geometry is as follows. &quot;name&quot; defines the name of the structure, &quot;type&quot; selects the type of the structure, and &quot;property&quot; sets the properties of the structure model. This function does not return any data. note: Set the refractive index of the material for the structure by selecting the material to be added to the project, or use &quot;object_defined_dielectric&quot; to set the material, but require an additional keyword &quot;refractive_index&quot; to set the refractive index of the material. The material setting method for all geometric structures is the same. 2.1.1 Triangle​ The geometric properties of triangle and an example of adding triangle into the project are shown below. add_geometry( name: str, type: Literal[&quot;triangle&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. z_span\tnumber\t-\tZ span of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. control_points\tnumber\t-\tThe vertices position for generating the geometry. tilt_angle\tnumber\t90\tThe tilt angle of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example: The following script adds a triangle to the structure of the instance, with three vertices of (0,0) (0,2) (2,2) um and a thickness of 0.22 um. Select the material of &quot;object_defined_ieleectric&quot; and set the refractive index of the material to 1.4. st = pj.Structure() st.add_geometry(name=&quot;triangle&quot;, type=&quot;Triangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;control_points&quot;:[{&quot;x&quot;: 0, &quot;y&quot;: 0}, {&quot;x&quot;: 0, &quot;y&quot;: 2}, {&quot;x&quot;: 2, &quot;y&quot;: 2}], &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22, &quot;tilt_angle&quot;: 90, &quot;tilt_position&quot;:&quot;middle&quot;}}) 2.1.2 Rectangle​ The geometric properties of rectangle and an example of adding rectangle into the project are shown below. add_geometry( name: str, type: Literal[&quot;rectangle&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. x_span, y_span, z_span\tnumber\t-\tX span, Y span and Z span of the geometry. x_min, x_max\tnumber\t-\tX min, X max position of the geometry. y_min, y_max\tnumber\t-\tY min, Y max position of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. tilt_angle\tnumber\t90\tThe tilt angle of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example: The following script adds a rectangle to the structure of the instance, and set the dimension and material of the structure. st = pj.Structure() st.add_geometry(name=&quot;rectangle&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 1, &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1, &quot;tilt_angle&quot;:90, &quot;tilt_position&quot;:&quot;top&quot;}}) 2.1.3 Circle​ The geometric properties of circle and an example of adding circle into the project are shown below. add_geometry( name: str, type: Literal[&quot;circle&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionradius\t-\tfloat\tThe radius of the circle. angle\t-\tfloat\tThe angle of the arc length of the added circle., in degrees. x, y, z\tnumber\t-\tThe center position of the geometry. z_span\tnumber\t-\tZ span of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. tilt_angle\tnumber\t90\tThe tilt angle of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example:The following script adds a circle to the structure of the instance, sets the radius of the circle to 2 μ m, the thickness to 0.5 μ m, and the refractive index of the material to 1.4. st = pj.Structure() st.add_geometry(name=&quot;circle&quot;, type=&quot;Circle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: 2, &quot;angle&quot;: 360, &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.5 &quot;tilt_angle&quot;:90, &quot;tilt_position&quot;:&quot;top&quot;}}) 2.1.4 Ring​ The geometric properties of ring and an example of adding ring into the project are shown below. add_geometry( name: str, type: Literal[&quot;ring&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptioninner_radius\tnumber\t-\tThe inner radius of the ring. outer_radius\tnumber\t-\tThe outer radius of the ring. angle\tnumber\t360\tDefine the range of the ring angles, in degrees. x, y, z\tnumber\t-\tThe center position of the geometry. z_span\tnumber\t-\tZ span of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. tilt_angle1\tnumber\t90\tThe tilt angle1 of the geometry, in degrees. tilt_angle2\tnumber\t90\tThe tilt angle2 of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example: The following script adds a ring to the structure of the instance, sets the inner radius to 4um, the outer radius to 6um, the thickness to 0.5um, and the refractive index of the material to 1.4. st = pj.Structure() st.add_geometry(name=&quot;ring&quot;, type=&quot;Ring&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.5, &quot;tilt_angle1&quot;: 90, &quot;tilt_position&quot;: &quot;top&quot;, &quot;tilt_angle2&quot;: 90, &quot;angle&quot;:360, &quot;inner_radius&quot;: 4, &quot;outer_radius&quot;: 6,}}) 2.1.5 Polygon​ The geometric properties of polygon and an example of adding polygon into the project are shown below. add_geometry( name: str, type: Literal[&quot;polygon&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. z_span\tnumber\t-\tZ span of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. control_points\t-\tfloat\tThe vertices position for generating the geometry. tilt_angle\tnumber\t90\tThe tilt angle of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example: The following script adds a polygon to the structure of the instance, sets the vertex coordinates of the polygon to (-2, -2) (2, -2) (2, 2) (-2, 2) um, with a thickness of 0.5um., and the refractive index of the material to 1.4. st = pj.Structure() st.add_geometry(name=&quot;polygon&quot;, type=&quot;Polygon&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.5, &quot;control_points&quot;: [{&quot;x&quot;: -2, &quot;y&quot;: -2}, {&quot;x&quot;: 2, &quot;y&quot;: -2}, {&quot;x&quot;: 2, &quot;y&quot;: 2}, {&quot;x&quot;: -2, &quot;y&quot;: 2}], &quot;tilt_angle&quot;: 90, &quot;tilt_position&quot;: &quot;top&quot;, }}) 2.1.6 Ellipse​ The geometric properties of ellipse and an example of adding ellipse into the project are shown below. add_geometry( name: str, type: Literal[&quot;ellipse&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx_radius\tnumber\t-\tThe x-axis radius of the ellipse. y_radius\tnumber\t-\tThe y-axis radius of the ellipse. x, y, z\tnumber\t-\tThe center position of the geometry. z_span\tnumber\t-\tZ span of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. tilt_angle\tnumber\t90\tThe tilt angle of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example: The following script adds a ellipse to the structure of the instance, sets the radius in the x direction to 3 um, the radius in the y direction to 5 um, the thickness to 0.5 um, and the refractive index of the material to 1.4. st = pj.Structure() st.add_geometry(name=&quot;ellipse&quot;, type=&quot;Ellipse&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x_radius&quot;: 3, &quot;y_radius&quot;: 5, &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.5, &quot;tilt_angle&quot;: 90, &quot;tilt_position&quot;: &quot;top&quot;}}) 2.1.7 Linear trapezoid​ The geometric properties of linear trapezoid and an example of adding linear trapezoid into the project are shown below. add_geometry( name: str, type: Literal[&quot;linear_trapezoid&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. z_span\tnumber\t-\tZ span of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. control_points\t-\tfloat\tThe vertices position for generating the geometry. tilt_angle\tnumber\t90\tThe tilt angle of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example: The following script adds a linear trapezoid to the structure of the instance, sets the vertex coordinates to (-2, 2) (-4, -2) (4, -2) (2, 2) um, with a thickness of 0.5 um and the refractive index of the material to 1.4. st = pj.Structrure() st.add_geometry(name=&quot;linear_trapezoid&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: { &quot;control_points&quot;: [{&quot;x&quot;: -2, &quot;y&quot;: 2}, {&quot;x&quot;: -4, &quot;y&quot;: -2}, {&quot;x&quot;: 4, &quot;y&quot;: -2}, {&quot;x&quot;: 2, &quot;y&quot;: 2}], &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.5, &quot;tilt_angle&quot;: 90, &quot;tilt_position&quot;: &quot;top&quot;}}) 2.1.8 Pyramid​ The geometric properties of pyramid and an example of adding pyramid into the project are shown below. add_geometry( name: str, type: Literal[&quot;pyramid&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. z_span\tnumber\t-\tZ span of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. x_span_bottom, y_span_bottom\tnumber\t-\tX bottom span , Y bottom span of geometry. x_span_top, y_span_top\tnumber\t-\tX top span, Y top span of geometry. delta_x, delta_y\tnumber\t0\tX delta, Y delta of geometry. tilt_angle\tnumber\t90\tThe tilt angle of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example:The following script adds a pyramid to the structure of the instance, sets the top width in the x and y directions to 3 μ m, the bottom width to 5 μ m, the thickness to 0.5 μ m, and the refractive index of the material to 1.4. st = pj.Material() st.add_geometry(name=&quot;pyramid&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span_top&quot;: 3,&quot;x_span_bottom&quot;: 5, &quot;y&quot;: 0,&quot;y_span_top&quot;: 3,&quot;y_span_bottom&quot;: 5, &quot;z&quot;: 0, &quot;z_span&quot;: 0.5,&quot;delta_x&quot;: 0, &quot;delta_y&quot;: 0}}) 2.1.9 Sphere​ add_geometry( name: str, type: Literal[&quot;sphere&quot;], property: dict ) The geometric properties of sphere and an example of adding sphere into the project are shown below. Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. radius_x, radius_y, radius_z\tnumber\t1.5\tThe x, y and z axes radius of the geometry. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example:The following script adds a sphere to the structure of the instance, sets the radius in the x, y, and z directions to 1.5 um, and the refractive index of the material to 1.4. st.add_geometry(name=&quot;Sphere&quot;, type=&quot;Sphere&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;radius_x&quot;: 1.5, &quot;radius_y&quot;: 1.5, &quot;radius_z&quot;: 1.5}}) 2.1.10 Straight wavegudie​ The geometric properties of straight waveguide and an example of adding staright waveguide into the project are shown below. add_geometry( name: str, type: Literal[&quot;straight_waveguide&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. x_span, y_span, z_span\tnumber\t-\tX span, Y span and Z span of the geometry. x_min, x_max\tnumber\t-\tX min, X max position of the geometry. y_min, y_max\tnumber\t-\tY min, Y max position of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. tilt_angle1\tnumber\t90\tThe tilt angle1 of the geometry, in degrees. tilt_angle1\tnumber\t90\tThe tilt angle2 of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example:The following script adds a straight waveguide to the structure of the instance, sets the size to 10 um 1 um 1 um, &quot;tile_angle_1&quot; to 70 degrees, and the refractive index of the material to 1.4. st = pj.Structure() st.add_geometry(name=&quot;StraightWaveguide&quot;, type=&quot;StraightWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 10, &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1, &quot;tilt_position&quot;: &quot;top&quot;, &quot;tilt_angle1&quot;: 70, &quot;tilt_angle2&quot;: 90 }}) 2.1.11 Bezier wavegudie​ The geometric properties of bezier waveguide and an example of adding bezier waveguide into the project are shown below. add_geometry( name: str, type: Literal[&quot;bezier_waveguide&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. z_span\tnumber\t-\tZ span of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. width\tnumber\t-\tThe width of the geoemtry. control_points\tnumber\t-\tThe vertices position for generating the geometry. tilt_angle1\tnumber\t90\tThe tilt angle1 of the geometry, in degrees. tilt_angle1\tnumber\t90\tThe tilt angle2 of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example: The following script adds a bezier waveguide to the structure of the instance, sets the coordinates of the control points on the path to (1,1) (1,2) (2,2) (2,3) um with a width of 0.5 um and a thickness of 0.5 um, and the refractive index of the material to 1.4. st = pj.Structure() st.add_geometry(name=&quot;bezier&quot;, type=&quot;BezierWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.5, &quot;width&quot;: 0.5, &quot;control_points&quot;: [{&quot;x&quot;: 1, &quot;y&quot;: 1}, {&quot;x&quot;: 1, &quot;y&quot;: 2}, {&quot;x&quot;: 2, &quot;y&quot;: 2}, {&quot;x&quot;: 2, &quot;y&quot;: 3}], &quot;tilt_angle1&quot;: 90, &quot;tilt_position&quot;: &quot;bottom&quot;, &quot;tilt_angle2&quot;: 90, }}) 2.1.12 Analytical waveguide​ The geometric properties of analytical waveguide and an example of adding analytical waveguide into the project are shown below. add_geometry( name: str, type: Literal[&quot;analytical_waveguide&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. x_span, y_span, z_span\tnumber\t-\tX span, Y span and Z span of the geometry. x_min, _max\tnumber\t-\tX min, X max position of the geometry. y_min, y_max\tnumber\t-\tY min, Y max position of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. equation1\tstring\t-\tDefine the equation for the region where y&gt;0. equation2\tstring\t1\tDefine the equation for the region where y&lt;0. nonsymmetric\tboolean\tFalse\tSelect True to set the equation for y&lt;0 separately. resolution\tinteger\t10\tCalculate the number of variable values in an equation. tilt_angle\tnumber\t90\tThe tilt angle of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example:The following script adds a analytical waveguide to the structure of the instance, sets the size to 3um 3um 0.22um, the expression for x&gt;0 (equation1) is &quot;1/{x}&quot;, and the refractive index of the material is 1.4 st = pj.Structure() st.add_geometry(name=&quot;analyticalwaveguide&quot;, type=&quot;AnalyticalWaveguide&quot;,property={ &quot;material&quot;: &quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 3, &quot;y&quot;: 0, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22, &quot;equation1&quot;: &quot;1/{x}&quot;, &quot;nonsymmetric&quot;: False, # &quot;equation2&quot;: &quot;x^2&quot;, &quot;tilt_position&quot;: &quot;top&quot;, &quot;tilt_angle&quot;: 90, &quot;resolution&quot;: 100, }) 2.1.13 GDS file​ The geometric properties of sphere and an example of adding sphere into the project are shown below. add_geometry( name: str, type: Literal[&quot;gds_file&quot;], property: dict ) Geometry properties​ Parameter\tType\tDefault\tDescriptionx, y, z\tnumber\t-\tThe center position of the geometry. z_span\tnumber\t-\tZ span of the geometry. z_min, z_max\tnumber\t-\tZ min, Z max position of the geometry. path\tstring\t-\tThe path name of the gds file. cell_name\tstring\t-\tIf there is only one cell, a &quot;*&quot; can be input instead of the cell name layer_name\tarray\t-\tThe layer name of the gds file. tilt_angle\tnumber\t90\tThe tilt angle of the geometry, in degrees. tilt_position\tstring\ttop\tSelections tilt position are &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; and &quot;user_defined&quot;. user_defined_position\tnumber\t-\tThis parameter is required when tilt position is &quot;user_defined&quot;. Material properties​ Parameter\tType\tDefault\tDescriptionmaterial\tobject\t-\tSelect a material object in the material database. mesh_order\tinteger\t-\tSelect a material in overlapping areas when generating grids, materials with higher mesh order have higher priority. refractive_index\tnumber\t-\tDefined refractive index of the material. color\tstring\t-\tDefined color of the material, default &quot;#70AD47&quot;. Example: The following script import gds file to the structure of the instance, sets import parameters including the path name, cell name and layer name, structure thickness to 0.22 um, and material refractive index to 1.4. path_name = &quot;gds_file_path&quot; cell_name = &quot;gds_cell_name&quot; layer_name = (1,0) st = pj.Structure() st.add_geometry(name=&quot;gds_file&quot;, type=&quot;gds_file&quot;, property={ &quot;general&quot;: {&quot;path&quot;: path_name, &quot;cell_name&quot;: cell_name &quot;layer_name&quot;: layer_name }, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;object_defined_dielectric&quot;, &quot;refractive_index&quot;: 1.4, &quot;mesh_order&quot;: 2}}) 2.2 Add doping​ When participating in optoelectronic simulation, you have the option to utilize the provided code for introducing doping into the simulation structure. Our platform offers assistance in importing doping data from files and also allows for the customization of doping regions according to your requirements. add_doping( self, *, name: str, type: &quot;StructureDopingTypeSelection&quot;, property: &quot;StructureDopingPropertyDict&quot; ) Parameters\tDescriptionname\tTo set the name of doping in simulation type\tThe method type of setting up doping. Selections are [&quot;type&quot;, &quot;n&quot;, &quot;p&quot;]. property\tThe property of doping. 2.2.1 Function doping​ When type is set to &quot;n&quot; or &quot;p&quot;, function doping is applied. In this case, type also means the doping species, with &quot;n&quot; for donor and &quot;p&quot; for acceptor. You can configure parameters related to importing doping files by adjusting settings under the property.general sections. Example: st.add_doping(name=&quot;Uniform&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_uniform_x_center, &quot;x_span&quot;: p_uniform_x_span, &quot;y&quot;: p_uniform_y_center, &quot;y_span&quot;: p_uniform_y_span, &quot;z&quot;: p_uniform_z_center, &quot;z_span&quot;: p_uniform_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: p_uniform_con}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat_si&quot;]]}}) Parameters\tDefault\tType\tNotesgeometry.x\t-\tfloat\tThe x-coordinate of the center point position of doping box. geometry.x_span\t-\tfloat\tThe length in x direction of the doping. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data doping box. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of doping box. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of doping box. geometry.y_span\t-\tfloat\tThe width in y direction of the doping. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of doping box. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of doping box. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of doping box. geometry.z_span\t-\tfloat\tThe thinckness in z direction of doping box. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of doping box. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of doping box. | general.distribution_function | - | str | To set the type of distribution function for doping region. Selections are [&quot;constant&quot;, &quot;gaussian&quot;]. When it&quot;s set to &quot;constant&quot;, constant doping is applied and only &quot;concentration&quot; is required. When it&quot;s set to &quot;gaussian&quot;, Gaussian function doping is applied, and &quot;concentration&quot;, &quot;ref_concentration&quot;, &quot;junction_width&quot;, &quot;source_face&quot; are required. | | general.concentration | - | float | To set the doping concentration in non-diffusion area. | | general.source_face | - | str | To set the doping source surface. Available when distribution_function is &quot;gaussian&quot;. Selections are [&quot;low_x&quot;, &quot;low_y&quot;,&quot;low_z&quot;].&quot;lower_x&quot; means the source face is &quot;x=x_min&quot;. Similarly for the rest. There is no diffusion area on the edge of source face. As for the other edges, there is a diffusion area respectively within the doping box. | | general.junction_width | - | float | To set the junction width. Available when distribution_function is &quot;gaussian&quot; | | general.ref_concentration | - | float | Concentration on the edge of diffusion area (edge of doping box). Available when distribution_function is &quot;gaussian&quot;. | | volume.volume_type | &quot;all&quot; | str | The default of &quot;all&quot; means the doping is applied to all the (semiconductor) structures, restricted by the doping box. Selections are [&quot;all&quot;, &quot;material&quot;, &quot;region&quot;] | | volume.material_list | - | list | It means the doping is applied to the structures of the specified materials and restricted by the doping box. Available when volume_type is &quot;material&quot;. | | volume.region_list | - | list | It means the doping is applied to the specified structures and restricted by the doping box. Available when volume_type is &quot;region&quot; | 2.2.2 Imported doping​ When type is set to &quot;ile&quot;, doping is imported from a file. Example: st.add_doping(name=&quot;import_n&quot;, type=&quot;file&quot;, property={ &quot;general&quot;: {&quot;format&quot;: &quot;DOP&quot;, &quot;file_path&quot;: n_dop_file, &quot;species&quot;: &quot;n&quot;}}) Parameters\tDefault Type Notesgeneral.format\t-\tstr\tSet the format of doping file. Only &quot;DOP&quot; is supported currently. Selections are [&quot;DOP&quot;]. When it&quot;s set to &quot;DOP&quot;, the doping file is a text file that stores a doping profile in rectangular grid. There are three columns in the file, which are the first dimension coordinate [um], the second dimension coordinate [um] and the doping concentration [cm^-3] respectively. Doping concentration should be non-negative. general.file_path\t-\tstr\tThe absolute path of the doping file general.species\t-\tstr\tTo set the doing species. Selections are [&quot;n&quot;, &quot;p&quot;]. volume.volume_type\t&quot;all&quot;\tstr\tTo set a list of regions or materials for doping. Selections are [&quot;all&quot;, &quot;material&quot;, &quot;region&quot;]. volume.material_list\t-\tlist\tAvailable when volume_type is &quot;material&quot; volume.region_list\t-\tlist\tAvailable when volume_type is &quot;region&quot; 2.3 Add electrode​ In this section, we will demonstrate how to integrate electrode structures into optoelectronic simulations using the provided code. Currently, the platform allows configuring both steady-state and transient voltages for the electrodes. Detailed code descriptions and specific examples are provided below for reference. add_electrode( self, *, name: str, property: StructureElectrodeProperty, ) Parameters Description name\tTo set the name of eelectrode in simulation. property\tTo set the property of electrode in simulation. 2.3.1 Steady state​ When the property bc_mode is set to &quot;steady_state&quot;, the steady state boundary condition is applied. Example: st = pj.Structure() st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) Parameters\tDefault\tType\tNotesforce_ohmic\ttrue\tbool\tWhether the electrode is ohmic, default to be True. Currently only ohmic contact is supported, so force_ohmic can&quot;t be set to False. bc_mode\tsteady_state\tstring\tTo set the type of electircal boundary condition. Selections are [&quot;steady_state&quot;,transient]. apply_AC_small_signal\tnone\tstring\tDetermining whether to apply the small-signal alternating current. Selections are [&quot;none&quot;, &quot;All&quot;]. When it&quot;s set to &quot;none&quot;, no AC small signal is applied at each sweeping voltage. When it&quot;s set to &quot;All&quot;, the AC small signal is applied after steady state simulation at each sweeping voltage sweep_type\tsingle\tstring\tTo set the voltage type of the electrode. Selections are [&quot;single&quot;, &quot;range&quot;, &quot;value&quot;]. v_step_max\t0.5\tfloat\tThe maxium step of voltage value. voltage\t0\tfloat\tThe value of voltage. Available when sweep_type is &quot;single&quot; range_start\t0\tfloat\tThe start value of a voltage range. Available when sweep_type is &quot;range&quot; range_stop\t1\tfloat\tThe stop value of a voltage range. Available when sweep_type is &quot;range&quot; range_interval\t1\tfloat\tThe interval value of a voltage range. Available when sweep_type is &quot;range&quot; range_num_points\t2\tinteger\tThe The number of points within the voltage range. Available when sweep_type is &quot;range&quot; []sweep_value_table.index\t-\tinteger\tThe index table of voltage values. Available when sweep_type is &quot;value&quot;. []sweep_value_table.number\t-\tfloat\tThe value table of voltage. Available when sweep_type is &quot;value&quot;. surface_type\tsolid\tstring\tTo set the surface type of electrode. Currently only &quot;solid&quot; is supported, meaning that all the surfaces of a structure are selected. solid\t-\tstring\tName of the structure to be set as an electrode. Available when surface_type is set to &quot;solid&quot;. 2.3.2 SSAC (Small signal alternating current)​ When solving the frequency response of optical signal for the device, transient simulation should be performed. In this case, the bc_mode of the corresponding electrode should be set to &quot;transient&quot;, and the solver_mode of OEDevice solver should be set to &quot;transient&quot;, too. In most of other cases, steady state or SSAC simulation is needed, the &quot;bc_mode&quot; of electrodes should be &quot;steady_state&quot;. When solving capacitance and resistance with respect to frequency, SSAC simulation is required. The solver_mode of OEDevice solver should be set to &quot;SSAC&quot;, and the apply_AC_small_signal of the corresponding electrode should be set to &quot;All&quot;. When running steady state simulation, just set the solver_mode of OEDevice solver to &quot;steady_state&quot;. Example: st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;All&quot;}) 2.3.3 Transient​ When the property bc_mode is set to &quot;transient&quot;, the transient boundary condition is applied. Example: st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: tcad_vbias, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 2.001e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 30e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.001e-12, &quot;time_stop&quot;: 2.01e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 60e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.01e-12, &quot;time_stop&quot;: 2.03e-12, &quot;initial_step&quot;: 60e-18, &quot;max_step&quot;: 2e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.03e-12, &quot;time_stop&quot;: 10e-12, &quot;initial_step&quot;: 2e-15, &quot;max_step&quot;: 50e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 10e-12, &quot;time_stop&quot;: 500e-12, &quot;initial_step&quot;: 50e-15, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}]}) Parameters\tDefault\ttype\tNotesforce_ohmic\ttrue\tbool bc_mode\t-\tstring\tSelections are [&quot;transient&quot;]. voltage\t0\tfloat\tSet the voltage that is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation. v_step_max\t-\tstring\tSet the max step of the voltage from the equilibrium state to steady state at the bias of voltage. []time_table.time_start\t-\tfloat\tSet the start time point of the range. The value of 0 represents the steady state of the earlier simulation. []time_table.time_stop\t-\tfloat\tSet the stop time point of the range. []time_table.initial_step\t-\tfloat\tSet the initial time step of the range []time_table.max_step\t-\tfloat\tSet the max time step of the range []time_table.optical.enabled\t0\tinteger\tWhether to apply optical generation rate during the time range. The value of 1 means True, and 0 means False. Selections are [0, 1]. []time_table.optical.envelop\t-\tinteger\tThe envelop of the scaling factor of the light power during the time range. When it&quot;s set to 0, the envelop is uniform. Selections are [0]. []time_table.optical.source_fraction\t-\tfloat\tWhen envelop is set to0, this value is the scaling factor of the light power during the time range. surface_type\tsolid\tstring\tSelections are [&quot;solid&quot;]. solid\t-\tstring\tAvailable when surface_type is set to &quot;solid&quot;. 2.4 Add surface recombination​ While conducting optoelectronic simulations, you can incorporate surface recombination into the simulation structure using the following code. add_surface_recombination( self, *, name: str, property: AddSurfaceRecombination, ) Parameters\tDescriptionname\tTo set the name of surface recombination in simulation. property\tTo set the property of surface recombination in simulation. Example: st.add_surface_recombination(name=&quot;Cathode_Si&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;MetalOhmicInterface&quot;, &quot;domain_1&quot;: &quot;Cathode&quot;, &quot;domain_2&quot;: &quot;Si_base&quot;, &quot;infinite_recombination&quot;: False, &quot;velocity_electron&quot;: 1e7, &quot;velocity_hole&quot;: 1e7}) Parameters\tDefault\tType\tNotessurface_type\tdomain_domain\tstring\tTo set the type for calculating surface recombination. Selections are [&quot;domain_domain&quot;, &quot;material_material&quot;]. interface_type\tnull\tstring\tTo set the interface type of surface recombination. Selections are [&quot;null&quot;, &quot;InsulatorInterface&quot;, &quot;HomoJunction&quot;, &quot;HeteroJunction&quot;, &quot;MetalOhmicInterface&quot;, &quot;SolderPad&quot;]. &quot;InsulatorInterface&quot; is interface between semiconductor and insulator, &quot;HomoJunction&quot; means the interface between homogeneous semiconductor and semiconductor,&quot;HeteroJunction&quot; means the interface between heterogeneous semiconductor and semiconductor, &quot;MetalOhmicInterface&quot; means the interface between semiconductor and conductor, &quot;SolderPad&quot; means the interface between conductor and insulator. infinite_recombination\ttrue\tbool\tOnly available when interface_type is &quot;MetalOhmicInterface&quot;. The surface recombination velocity of holes and electrons will be available when infinite_recombination is False. velocity_hole\t0\tfloat\tTo define surface recombination velocity of holes. Available when interface_type is &quot;MetalOhmicInterface&quot;/&quot;InsulatorInterface&quot; velocity_electron\t0\tfloat\tTo define surface recombination velocity of electron. Available when interface_type is &quot;MetalOhmicInterface&quot;/&quot;InsulatorInterface&quot; domain_1\t-\tstring\tThe region 1 for surface recombination. Available when surface_type is &quot;domain_domain&quot; domain_2\t-\tstring\tThe region 2 for surface recombination. Available when surface_type is &quot;domain_domain&quot; material_1\t-\tmaterial\tThe material 1 for surface recombination. Available when surface_type is &quot;material_material&quot; material_2\t-\tmaterial\tThe material 2 for surface recombination. Available when surface_type is &quot;material_material&quot;","keywords":""},{"title":"Preview","type":0,"sectionRef":"#","url":"/my-website/docs/test/SDK/7Preview","content":"Preview In this section, we currently offer the capability to provide an advanced preview of structural models, refractive index and doping profile. This preview serves to validate the structues before initiating the formal simulation, thereby assisting in verifying the accuracy of the structures. Consequently, it leads to reduced simulation time and an overall enhancement of simulation efficiency. 8.1 Preview index​ Preview the index plot of a source or port or monitor in the project by using the preview_index function. The syntax and properties of this function are shown below, and it return visualizer. preview_index( monitor_name: str=&quot;&quot;, port_name: str=&quot;&quot;, source_name: str=&quot;&quot;, savepath: str, export_n: bool export_c: bool export_csv: bool export_mat: bool ) parameter\ttype\tdefault\tdescriptionmonitor_name\tstring\t-\tOnly one of monitor_name, port_name and source_name can be set port_name\tstring\t- source_name\tstring\t- savepath\tstring\t- export_n\tboolean\tTrue\tIf True, export the index. export_c\tboolean\tFalse\tIf True, export the conductivity. export_csv\tboolean\tFalse export_mat\tboolean\tFalse Example: The following command previews the refractive index distribution of the &quot;test_preview&quot; monitor and saves the data to the specified path. simu_name = 'preview_index' path = f&quot;{plot_path}&quot; m_name = &quot;power monitor&quot; path_name = path + &quot;preview_index&quot; simu = Project.Simulation() simu[simu_name].preview_index( monitor_name=m_name, savepath=path_name, export_csv=True, show=False, ) 8.2 Preview mode​ Preview the modal amplitude plot of a source or port or monitor in the project by using the preview_mode function. The syntax and properties of this function are shown below, and it return visualizer. preview_index( monitor_name: str=&quot;&quot;, port_name: str=&quot;&quot;, source_name: str=&quot;&quot;, savepath: str, target: str, attribute: str, mode: int, export_csv: bool, export_mat: bool ) parameter\ttype\tdefault\tdescriptionmonitor_name\tstring\t-\tOnly one of monitor_name, port_name and source_name can be set port_name\tstring\t- source_name\tstring\t- savepath\tstring\t- target\tstring\t-\tSelections are [&quot;intensity&quot;,&quot;target&quot;] attribute\tstring\t-\tSelections are ['E', 'H', 'Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'] mode\tinteger\t0 export_csv\tboolean\tFalse export_mat\tboolean\tFalse Example: The following command previews the mode field distribution of the 'mode_source' light source fundamental mode and saves the data to the specified path. simu_name = 'preview_mode' path = f&quot;{plot_path}&quot; s_name = &quot;mode_source&quot; path_name = path + &quot;preview_index&quot; simu = Project.Simulation() simu[simu_name].preview_modes(source_name=s_name, savepath=path_name, target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=True, mode=0, show=False, export_csv=True) 8.3 Structure show and show 3D​ This portion of the code is primarily intended for show structure. Please note that this method becomes invalid if the current structure manager contains Pyramid or Arc-Waveguide 3D type geometries. structure_show( mode: str, fig_type: Optional[str], show: bool, savepath: str, ) Show the structure. :param mode: Mode of show :param show: Whether to show the structure :param savepath: Path to save the structure :param fig_type: Type of the figure :param disabled_components: Components to disable :param xyratio: Ratio of x and y :param celldisplay: Whether to display the cell :param view: Whether to view the structure :return: None parameter\ttype\tdefault\tdescriptionmode\tstring\tXY\tOnly XY is supported at present show\tboolean\t-\tIf True, show the picture of the structure savepath\tstring\t- fig_type\tstring\tpng\tSelections are ['png', 'svg'] disabled_components\ttuple\t-\tCurrently invalid xyratio\ttuple\t(1,1)\tCurrently invalid celldisplay\tboolean\tFalse\tCurrently invalid Show 3D structure in a pop up windows. show3d(self, show_with: Literal[&quot;webviewer&quot;, &quot;matplotlib&quot;，&quot;local_gui&quot;] = &quot;webviewer&quot;) st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=f&quot;{plot_path}00_{simu_name}&quot;) Parameters\tDescriptionshow_with\tChoose the type of display. The selection are &quot;webviewer&quot;, &quot;matplotlib&quot;，&quot;local_gui&quot;. The &quot;webviewer&quot; will start a server and toggle a browser windows. &quot;matplotlib&quot; will toggle a Axes3D windows. Default as &quot;webviewer&quot;. Example: st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}{kL[0]}{simu_name}', simulation_name=simu_name) simu[simu_name].show3d(show_with=&quot;local_gui&quot;) 8.4 Run doping​ The code within this module enables the preview of doping results for the respective structures. run_doping( self, name: str, property: RunDopingPostProcess, norm: str, scale: str, superimpose: bool, show: bool, material_list: list, cmin: float, savepath: str ) Parameters\tDescriptionproperty\tThe properties of doping preview. name\tThe name of doping preview. show\tDecide whether to show directly the preview of structure directly in the related software.If set to False, the picture will be saved instead. savepath\tThe save path for picture. norm\tThe normalization of colorbar. Selections are ['linear', 'log']. Default as 'linear'. scale\tThe type of pcture scale. Selections are ['equal', 'auto']. Default as 'equal'. superimpose\tSuperimpose doping on structure or not. Default as True. material_list\tSpecified material type list. Default as []. region_list\tSpecified region name list. Default as []. Superior to material_list when not empty. cmax\tMaximum concentration of heatmap colorbar. Default as None. cmin\tMinimum concentration of heatmap colorbar. Default as None. Example: simu[&quot;preview_oedevice&quot;].run_doping(name=&quot;x_in&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}}, norm=&quot;log&quot;, scale=&quot;equal&quot;, superimpose=False, show=False, material_list=[&quot;Ge&quot;, &quot;Si&quot;], cmin=8e5, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;doping_x_in&quot;) Parameters\tDefault\tType\tNotesgeometry.dimension string\tSet the orientation of the doping region. The selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the doping region. geometry.x_span\t-\tfloat\tThe length in x direction of the doping region. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the doping region. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the doping region. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the doping region. geometry.y_span\t-\tfloat\tThe width in y direction of the doping region. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the doping region. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the doping region. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the doping region. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the doping region. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the doping region. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the doping region.","keywords":""},{"title":"Analysis","type":0,"sectionRef":"#","url":"/my-website/docs/test/SDK/8Analysis","content":"Analysis Analysis is an extension function for three basic solvers. In this section, we will introduce the coding method of analysis corresponding to FDE, FDTD and EME. Type of the analysis. Selections are 'fde_analysis', 'eme_analysis', 'overlap', 'far_field', 'mode_expansion'. 7.1 FDE Analysis​ add_analysis( name: str, type: Literal[&quot;fde_analysis&quot;], property: dict, ) 7.1.1 Simulation name​ The name of the simulation solver, and only one solver is allowed to be added to the project. 7.1.2 Workflow id​ The name of the result folder generated by the simulation solver, which can be obtained when the simulation solver is completed. The script for obtaining the workflow id is shown below, assuming that the simulation solver has already been set up. simu_res = simu[simu_name].run() workflow_id_name = simu_res.workflow_id 7.1.2 Modal Analysis​ Parameter\tType\tDefault\tDescriptioncalculate_modes\tboolean\tFalse\tThe eigenmode supported by the structure will be solved. mesh_structure\tboolean\tFalse\tGenerate an images of mesh structure , which is very useful for checking material settings. wavelength\tnumber\t1.55\tThe wavelength used to solve the modes. wavelength_offset\tnumber\t0\tThe wavelength offset used to solve the modes. number_of_trial_modes\tinteger\t10\tThe maximum number of modes stored in the mode list. search\tstring\tmax_index\tSelect 'max_index' or 'near_n' to define the effective index for mode calculation. n\tnumber\t1\tSpecify the value of effective index for mode calculation, when 'serach' selects 'near_n '. calculate_group_index\tboolean\tFalse\tCalculate the group index of the mode. bent_waveguide Parameter\tType\tDefault\tDescriptionbent_waveguide\tboolean\tFalse\tChoose whether the waveguide is bent. radius\tnumber\t0\tThe curvature radius of the bend waveguide. orientation\tnumber\t0\tThe direction of the bent waveguide is defined by angle, measured in degrees. location\tstring\tsimulation_center\tCalculate the position of waveguide bending, options is 'simulation_center'. 7.1.3 Frequency Analysis​ Parameter\tType\tDefault\tDescriptionfrequency_analysis\tboolean\tFalse\tChoose whether to calculate the frequency sweep analysis results of the modes. start_wavelength\tnumber\t1.55\tThe start wavelength for the calculation modes. stop_wavelength\tnumber\t1.499\tThe stop wavelength for the calculation modes. number_of_points\tinteger\t10\tThe number of points to be calculated within the range. effective_index\tnumber\t1\tSpecify the value of effective index for mode calculation. Valid when not tracking a selected mode. number_of_trial_modes\tnumber\t1\tSets the maximum number of modes to use for the frequency sweep. Example: simu_name = &quot;FDE&quot; analysis_name = &quot;FDE_Analysis&quot; analysis = pj.Analysis() analysis.add_analysis(name=analysis_name, type=&quot;fde_analysis&quot;, property={&quot;workflow_id&quot;: simu_res.workflow_id, &quot;simulation_name&quot;: simu_name, &quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: True, &quot;mesh_structure&quot;: True, &quot;wavelength&quot;: 1.55, &quot;wavelength_offset&quot;: 0.0001, &quot;number_of_trial_modes&quot;: 20, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: False, &quot;bent_waveguide&quot;: {&quot;bent_waveguide&quot;: False, &quot;radius&quot;: 1, &quot;orientation&quot;: 0, &quot;location&quot;: &quot;simulation_center&quot;, } }, &quot;frequency_analysis&quot;: {&quot;frequency_analysis&quot;: False, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 1, &quot;detailed_dispersion_calculation&quot;: False, }}) result_fde = analysis[analysis_name].run() 7.2 EMEAnalysis​ 7.1.1 Simulation name​ The name of the simulation solver, and only one solver is allowed to be added to the project. 7.1.2 Workflow id​ The name of the result folder generated by the simulation solver, which can be obtained when the simulation solver is completed. The script for obtaining the workflow id is shown below, assuming that the simulation solver has already been set up. simu_res = simu[simu_name].run() workflow_id_name = simu_res.workflow_id 7.2.2 EME propagate​ eme_propagate: Choose whether to calculation structure S-matrix using all EME solver settings. override_group_spans: Choose whether to override the group spans settings in EME solver and reset them. cell_group_settings: In each cell group, the parameters that are allowed to be changed are &quot;span&quot; and &quot;sc&quot;. 7.2.3 Periodicity​ periodicity: Calculate the results of the periodic structure. periodic_group_definition Parameter\tType\tDefault\tDescriptionstart_cell_group\tstring\t-\tThe cell group at the starting of the periodic structure, 'group_stpan_1' represents the first group, and so on. end_cell_group\tstring\t-\tThe cell group at the ending of the periodic structure, 'group_stpan_1' represents the first group, and so on. periods\tinteger\t-\tThe number of periodic structural regions. 7.2.4 Group span sweep​ Allow setting the length range of group span to obtain transmission results without recalculating the mode of each cell. Parameter\tType\tDefault\tDescriptiongroup_span_sweep\tboolean\tFalse\tCalculate the S-matrix as a function of a group span. parameter\tstring\tgroup_span_1\tSelect the cell group to sweep, 'group_span_1' represents the first group, and so on start\tnumber\t0\tThe start length of a cell group span. stop\tnumber\t1\tThe start length of a cell group span. number_of_points\tinteger\t3\tThe number of points to be scanned within the range. 7.2.5 Wavelength sweep​ Using perturbation method to calculate the S-matrix of the structure as a function of wavelength, it assumes that the mode profile does not significantly change with wavelength. It is suitable for devices with significant changes in phase rather than mode distribution within the studied wavelength range, such as MMI and Waveguide Bragg gratings. Parameter\tType\tDefault\tDescriptionwavelength_sweep\tboolean\tFalse\tCalculate the S-matrix as a function of wavelength. start\tnumber\t1.5\tThe start wavelength of wavelength sweep. stop\tnumber\t1.6\tThe end wavelength of wavelength sweep. number_of_wavelength_points\tinteger\t3\tThe number of points to be scanned within the range. 7.2.6 Select source​ The following settings affect the results of the profile monitor and do not affect the calculation results of the s matrix. Parameter\tType\tDefault\tDescriptionsource_port\tobject\t-\tSelect the port of the input source. select_mode\tstring\tTE\tSelect the injection mode for the port. 7.2.7 Override wavelength​ wavelength: Override the wavelength used to calculate modes in the EME solver and use to calculate the s-matrix. This parameter takes effect when 'use_wavelength_sweep' of EME solver is true. Example: analysis = pj.Analysis() analysis.add(name=&quot;eme_propagate&quot;, type=&quot;eme_analysis&quot;, property={&quot;workflow_id&quot;: eme_base_res.workflow_id, &quot;eme_propagate&quot;: True, &quot;periodicity&quot;: {&quot;periodicity&quot;: True, &quot;periodic_group_definition&quot;: [{&quot;start_cell_group&quot;: &quot;group_span_1&quot;, &quot;end_cell_group&quot;: &quot;group_span_1&quot;, &quot;periods&quot;: 80}]}, &quot;group_span_sweep&quot;: {&quot;group_span_sweep&quot;: False, &quot;parameter&quot;: &quot;group_span_1&quot;, &quot;start&quot;: 41, &quot;stop&quot;: 61, &quot;number_of_points&quot;: 11}, &quot;wavelength_sweep&quot;: {&quot;wavelength_sweep&quot;: False, &quot;start&quot;: 1.5, &quot;stop&quot;:1.6, &quot;number_of_wavelength_points&quot;: 11}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}) eme_res = analysis[&quot;eme_propagate&quot;].run() 7.3 ModeExpansion​ 7.3.1 Simulation name​ The name of the simulation solver, and only one solver is allowed to be added to the project. 7.3.2 Workflow id​ The name of the result folder generated by the simulation solver，which can be obtained when the simulation solver is completed. The script for obtaining the workflow id is shown below, assuming that the simulation solver has already been set up. simu_res = simu[simu_name].run() workflow_id_name = simu_res.workflow_id 7.3.3 Mode expansion​ direction: Selections are 'positive', 'negative'. monitors_for_expansion: The name of the power monitor needs to analyze mode expansion. mode_calculation Parameter\tType\tDefault\tDescriptionmode_selection\tstring\t-\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'user_select'] mode_expansion.mode_calculation.mode_index\tarray\t-\t1d list, the index of the mode to be expanded, for example, [0, 1, 2] mode_calculation.search\tstring\tmax_index\tSelections are ['max_index', 'near_n'] mode_calculation.n\tnumber\t1.0\tA float, or a parameter, or a parameter expression that evaluates to a float number_of_trial_modes\tinteger\t20 override_global_options\tboolean\tFalse sample_spacing\tinteger\t0 use_wavelength_spacing\tboolean\tTrue use_source_limits\tboolean\tFalse override_global_monitor_setting\tboolean\tFalse sspacing_type\tstring\twavelength\tSelections are ['wavelength', 'frequency'] spacing_limit\tstring\tmin_max\tSelections are ['min_max', 'center_span'] wavelength_min\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float override_global_monitor_setting.frequency_points\tinteger\t5 bent_waveguide.use_bent_waveguide\tboolean\tFalse bent_waveguide.radius\tnumber\t1.0\tA float, or a parameter, or a parameter expression that evaluates to a float bent_waveguide.orientation\tnumber\t0.0\tA float, or a parameter, or a parameter expression that evaluates to a float bent_waveguide.location\tstring\tsimulation_center\tSelections are ['simulation_center'] override_default_boundary_conditions\tboolean\tFalse rotate_settings.theta\tnumber\t0\tA float, or a parameter, or a parameter expression that evaluates to a float rotate_settings.phi\tnumber\t0\tA float, or a parameter, or a parameter expression that evaluates to a float rotate_settings.rotation_offset\tnumber\t0\tA float, or a parameter, or a parameter expression that evaluates to a float modal_analysis.mode_removal.threshold\tnumber\t0.01\tA float, or a parameter, or a parameter expression that evaluates to a float Example: fdtd_res = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0}]} ) analysis = pj.Analysis() analysis.add(name=&quot;me_through&quot;, type=&quot;ModeExpansion&quot;, property={&quot;workflow_id&quot;: fdtd_res.workflow_id, &quot;mode_expansion&quot;: {&quot;direction&quot;: &quot;positive&quot;, &quot;monitors_for_expansion&quot;: [{&quot;frequency_monitor&quot;: &quot;through&quot;}], &quot;mode_calculation&quot;: {&quot;mode_selection&quot;: &quot;user_select&quot;, &quot;mode_index&quot;: [0, 1, 2, 3], &quot;override_global_monitor_setting&quot;: {&quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 11}}}}) me_res = analysis[&quot;me_through&quot;].run() 7.4 Farfield​ Parameter\tType\tDefault\tDescriptionhuygens_source\tstring\t-\tSelections are ['from_dataspace', 'from_monitor'] workflow_id\tstring\t-\tThe name of the result folder generated by the FDE solver field_data.fde_analysis_name\tstring\t-\tThe name of the FDE analysis needs to analyze far field field_data.mode\tinteger\t0 field_data.data\tobject\t-\tSelect a dataspace object power_monitor_name\tstring\t-\tThe name of the power monitor needs to analyze far field Frequency_settings​ Parameter\tType\tDefault\tDescriptionauto\tboolean\tFalse wavelength\tnumber\t- frequency\tnumber\t- projection_method\tstring\t-\tSelections are ['planar', 'angular'] material index\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float farfield filter\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float projection distance\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float points in x\tinteger\t- points_in_y\tinteger\t- farfield x span\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float farfield y span\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float farfield x\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float farfield y\tnumber\t-\tA float, or a parameter, or a parameter expression that evaluates to a float projection direction\tstring\t-\tSelections are ['forward', 'backward'] horizontal points\tinteger\t- vertical points\tinteger\t- Example: if run_options.run_far_field: fde_res = = analysis[&quot;FDEAnalysis&quot;].run() far_field_base_workflow_id = fde_res.workflow_id if run_options.run_far_field: analysis.add(name=&quot;Far_Field&quot;, type=&quot;FarField&quot;, property={ 'huygens_source': 'from_dataspace', # selections are ['from_dataspace','from_monitor'] 'workflow_id': far_field_base_workflow_id, 'field_data': {&quot;fde_analysis_name&quot;: &quot;FDEAnalysis&quot;, 'mode': 0, }, 'far_field_settings': {'projection_method': 'planar', # selections are ['planar','angular'] 'material_index': 3.7, 'farfield_filter': 0, 'projection_distance': 8000, 'points_in_x': 50, 'points_in_y': 50, 'farfield_x_span': 40, 'farfield_y_span': 40, 'farfield_x': 0, 'farfield_y': 0,}} ) far_field_res = analysis[&quot;Far_Field Simulation&quot;].run() 7.4 Overlap​ workflow id​ huygens source​ field data​ far field settings​ Parameter\tType\tDefault\tDescriptionfield_1workflow_id\tstring\t-\tThe name of the result folder generated by the FDE solver field_1.mode\tinteger\t- field_1.data\tobject\t-\tSelect a dataspace object field_2.workflow_id\tstring\t-\tThe name of the result folder generated by the FDE solver field_2.mode\tinteger\t- field_2.data\tobject\t-\tSelect a dataspace object optimize_position\tboolean\tTrue x_shift\tnumber\t0 y_shift\tnumber\t0 z_shift\tnumber\t0 recenter\tstring\tcustom\tSelections are ['to_center_of_field_data_1', 'to_0_0', 'custom'] shift_center\tinteger\t1 Example: beam_res = simu[simu_name].run_fde_beam_and_extract( property={&quot;define_gaussian_beam_by&quot;: &quot;waist_size_and_position&quot;, # [waist_size_and_position,beam_size_and_divergence], &quot;waist_radius&quot;: 5.2, &quot;distance_from_waist&quot;: 1.5, &quot;refractive_index&quot;: 1.45, &quot;theta&quot;: 0, &quot;phi&quot;: 0, &quot;polarization_angle&quot;: 90, &quot;sample_span&quot;: 6, &quot;sample_resolution&quot;: 200}, savepath=plot_path + &quot;beam_heatmap&quot;) analysis.add(name=&quot;overlap&quot;, type=&quot;overlap&quot;, property={&quot;field_1&quot;: {&quot;workflow_id&quot;: beam_res.workflow_id, &quot;mode&quot;: 0}, &quot;field_2&quot;: {&quot;workflow_id&quot;: fde_res.workflow_id, &quot;mode&quot;: 0}, &quot;optimize_position&quot;: True}) overlap_res = analysis[&quot;overlap&quot;].run() ","keywords":""},{"title":"Simulation","type":0,"sectionRef":"#","url":"/my-website/docs/test/SDK/6Simulation","content":"","keywords":""},{"title":"3.1 Boundary​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/SDK/6Simulation#31-boundary","content":"The following content comprises code explanations and specific examples of boundary conditions in optical simulation. OBoundary( self, *, pml_same_settings: bool = True, property: Union['OBoundarySameSettingsPostProcess', 'OBoundaryNotSameSettingsPostProcess'], )  Parameters\tDescriptionproperty\tThe default property of the optical boundary. pml_same_settings\tTo decide whether using the same pml settings on every directions or not. As demonstrated in the following examples, we also provide support for customizing boundary conditions in different directions. Example: st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_beam/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}, &quot;boundary&quot;: {&quot;x_min&quot;: &quot;PML&quot;, &quot;x_max&quot;: &quot;PML&quot;, &quot;y_min&quot;: &quot;PML&quot;, &quot;y_max&quot;: &quot;PML&quot;, &quot;z_min&quot;: &quot;PML&quot;, &quot;z_max&quot;: &quot;PML&quot;}, &quot;general_pml&quot;: {&quot;pml_same_settings&quot;: True, &quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 0.8, &quot;pml_layer&quot;: 8, &quot;pml_polynomial&quot;: 3}})  Parameters\tDefault\tType\tNotesgeneral_pml.pml_same_settings\ttrue\tbool\tTo decide whether using the same pml settings on every directions or not. general_pml.pml_profile\tstandard\tstring\tTo provide the options of PML profile. general_pml.pml_layer\t-\tinteger\tSet the number of layers after discretizing the PML region. general_pml.pml_kappa\t-\tfloat\tSet the kappa parameter related to the absorption characteristics of the PML region. general_pml.pml_sigma\t-\tfloat\tSet the sigma parameter related to the absorption characteristics of the PML region. general_pml.pml_polynomial\t-\tinteger\tSet the order of the kappa and the sigma parameters. general_pml.pml_alpha\t-\tfloat\tSet the alpha parameter related to the absorption characteristics of the PML region. general_pml.pml_alpha_polynomial\t-\tinteger\tSet the order of the alpha parameter. general_pml.pml_min_layers\t-\tinteger\tSet the minimum number of layers within a reasonable range for the PML layers. general_pml.pml_max_layers\t-\tinteger\tSet themaximum number of layers within a reasonable range for the PML layers. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the boundary. geometry.x_span\t-\tfloat\tThe length in x direction of the boundary. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the boundary. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the boundary. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the boundary. geometry.y_span\t-\tfloat\tThe width in y direction of the boundary. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the boundary. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the boundary. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the boundary. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the boundary. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the boundary. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the boundary. boundary.x_max\t-\tstring\tSet the boundary type in the x+ direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.x_min\t-\tstring\tSet the boundary type in the x- direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.y_max\t-\tstring\tSet the boundary type in the y+ direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.y_min\t-\tstring\tSet the boundary type in the y- direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.z_max\t-\tstring\tSet the boundary type in the z+ direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.z_min\t-\tstring\tSet the boundary type in the z- direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. If you need to customize the boundary conditions for simulation requirements, you can also refer to the table below for modifying boundary conditions in different directions.Taking the x coordinate axis as an example, the parameters invocation is the same for the y/z coordinates. Parameters\tDefault\tType\tNotesgeneral_pml.pml_same_settings\ttrue\tbool\tTo decide whether using the same pml settings on every directions or not. general_pml.x_min_bc.pml_profile\tstandard\tstring\tTo provide the options of PML profile in x- direction. general_pml.x_min_bc.pml_layer\t-\tinteger\tSet the number of layers after discretizing the PML region in x- direction. general_pml.x_min_bc.pml_kappa\t-\tfloat\tSet the kappa parameter related to the absorption characteristics of the PML region in x- direction. general_pml.x_min_bc.pml_sigma\t-\tfloat\tSet the sigma parameter related to the absorption characteristics of the PML region in x- direction. general_pml.x_min_bc.pml_polynomial\t-\tinteger\tSet the order of the kappa and the sigma parameters in x- direction. general_pml.x_min_bc.pml_alpha\t-\tfloat\tSet the alpha parameter related to the absorption characteristics of the PML region in x- direction. general_pml.x_min_bc.pml_alpha_polynomial\t-\tinteger\tSet the order of the alpha parameter in x- direction. general_pml.x_min_bc.pml_min_layers\t-\tinteger\tSet the minimum number of layers within a reasonable range for the PML layers in x- direction. general_pml.x_min_bc.pml_max_layers\t-\tinteger\tSet the maximum number of layers within a reasonable range for the PML layers in x- direction. general_pml.x_max_bc.pml_profile\tstandard\tstring\tTo provide the options of PML profile in x+ direction. general_pml.x_max_bc.pml_layer\t-\tinteger\tSet the number of layers after discretizing the PML region in x+ direction. general_pml.x_max_bc.pml_kappa\t-\tfloat\tSet the kappa parameter related to the absorption characteristics of the PML region in x+ direction. general_pml.x_max_bc.pml_sigma\t-\tfloat\tSet the sigma parameter related to the absorption characteristics of the PML region in x+ direction. general_pml.x_max_bc.pml_polynomial\t-\tinteger\tSet the order of the kappa and the sigma parameters in x+ direction. general_pml.x_max_bc.pml_alpha\t-\tfloat\tSet the alpha parameter related to the absorption characteristics of the PML region in x+ direction. general_pml.x_max_bc.pml_alpha_polynomial\t-\tinteger\tSet the order of the alpha parameter in x+ direction. general_pml.x_max_bc.pml_min_layers\t-\tinteger\tSet the minimum number of layers within a reasonable range for the PML layers in x+ direction. general_pml.x_max_bc.pml_max_layers\t-\tinteger\tSet the maximum number of layers within a reasonable range for the PML layers in x+ direction. "},{"title":"Material","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/1Material","content":"Material Features Description: The Global Material Database allows for the definition of complex materials using experimental data or parameterized models. The Material Database stores the material data to be used in the simulation. It also provides an interface to change material properties like color, mesh order, and fit parameters. User could import materials from “Standard” database to “User” material database. Standard &amp; User :Material database includes standard and user material database. 1 Standard Material Database​ The standard material database includes three parts, one is material list, the another is material property plot, and the another one is the material type. The material list includes a number of common materials, when creating a new simulation, the standard database will be loaded. And the materials in the standard material database can be imported into “User” material database. The default materials cannot be edited directly. 1.1 Material List​ ID : Data ranking index Name : Material Name Mesh Oder: Decides how overlapping objects are meshed in the simulation. Color : Material Color.You can set the colors according to your own preferences. Type : Types of material, including two types, Normal Material and List Data. Normal Material: Non-dispersive materials. List Data: Dispersive materials, Materials whose dielectric permittivity changes with wavelength settings, displayed in tabular form.changes with wavelength settings, displayed in tabular form. Last Modified :Last modified time Import to User/ Import to Project: Import materials to user or project database. Export: Export materials according to user needs. 1.2 Materials in the Standard Material Database​ The following materials are included in the standard material database. ID\tName\tMesh Order\tType1\tAir\t2\tLossless Material 2\tAl (Aluminium) - Palik\t2\tList Data 3\tAl (Aluminium) - CRC\t2\tList Data 4\tAu (Gold) - CRC\t2\tList Data 5\tAu (Gold) - Johnson and Christy\t2\tList Data 6\tAu (Gold) - Palik\t2\tList Data 7\tGe (Germanium) - CRC\t2\tList Data 8\tGe (Germanium) - Palik\t2\tList Data 9\tSi (Silicon) - Palik\t2\tList Data 10\tSiO2 (Glass) - Palik\t2\tList Data 11\tSi3N4 (Silicon Nitride) - Kischkat\t2\tList Data 12\tSi3N4 (Silicon Nitride) - Phillip\t2\tList Data 13\tAg (Silver) - CRC\t2\tList Data 14\tPt (Platinum) - Palik\t2\tList Data 15\tTa (Tantalum) - CRC\t2\tList Data 16\tTiN - Palik\t2\tList Data 17\tCu (Copper) - Palik\t2\tList Data 18\tFe (Iron) - CRC\t2\tList Data 19\tW (Tungsten) - CRC\t2\tList Data 20\tTi (Titanium) - Palik\t2\tList Data 21\tTi (Titanium) - CRC\t2\tList Data 22\tSn (Tin) - Palik\t2\tList Data 23\tH2O (Water) - Palik\t2\tList Data 24\tCr (Chromium) - CRC\t2\tList Data 25\tPd (Palladium) - Palik\t2\tList Data 26\tInAs - Palik\t2\tList Data 27\tAg (Silver) - Palik (1-10um)\t2\tList Data 28\tAg (Silver) - Johnson and Christy\t2\tList Data 29\tW (Tungsten) - Palik\t2\tList Data 30\tFe (Iron) - Palik\t2\tList Data 31\tCr (Chromium) - Palik\t2\tList Data 32\tAl2O3 - Palik\t2\tList Data 33\tIn (Indium) - Palik\t2\tList Data 34\tCu (Copper) - CRC\t2\tList Data 35\tNi (Nickel) - CRC\t2\tList Data 36\tV (Vanadium) - CRC\t2\tList Data 37\tInP - Palik\t2\tList Data 38\tGaAs - Palik\t2\tList Data 39\tNi (Nickel) - Palik\t2\tList Data 40\tRh (Rhodium) - Palik\t2\tList Data 41\tAg (Silver) - Palik (0-2um)\t2\tList Data 42\tPEC\t2\tPEC 1.3 Material Properties:​ Plot :User can view each material property in this plot area via clicking a certain material in material list, also can view properties they are interested in via two options in the bottom of plot. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index) &amp; Im(refractive index), “εr′,εr″-Re(relative permittivity) &amp; Im(relative permittivity), “εr′,σ”-Re(relative permittivity) &amp; conductivity. 1.3.1 Material Data &amp; Model Fitting​ Material Data tab: User can view each material property in this list via double clicking a certain material in material list. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index) &amp; Im(refractive index), “εr′,εr″-Re(relative permittivity) &amp; Im(relative permittivity), “εr′,σ”-Re(relative permittivity) &amp; conductivity. (1). Material Data 2. Model Fitting: (Currently, the model fitting feature is not available and is still in the development process.) 2 User Material Database​ Feature Description:The User material database, a database that stores materials defined by user.It includes two parts, one is material list, and another is material property plot. User can copy or delete a selected material, and also can export materials according to their needs. 2.1 Material List​ ID : Data ranking index Name : Material Name Mesh Oder: Decides how overlapping objects are meshed in the simulation. Color : Material Color. You can set the colors according to your own preferences. Type : Types of material, including two types, Normal Material and List Data. Normal Material: Non-dispersive materials. List Data: Dispersive materials, Materials whose dielectric permittivity changes with wavelength settings, displayed in tabular form.changes with wavelength settings, displayed in tabular form. Last Modified :Last modified time Import to User/ Import to Project: Import materials to user or project database. Export: Export materials according to user needs. 2.2 Material Properties​ Plot : User can view each material property in this plot area via clicking a certain material in material list, also can view properties they are interested in via two options in the bottom of plot, Such as &quot;Wavelength&quot;, &quot;Frequency&quot;,“n,k”-Re(refractive index) &amp; Im(refractive index), “εr′,εr″-Re(relative permittivity) &amp; Im(relative permittivity), “εr′,σ”-Re(relative permittivity) &amp; conductivity. 2.2.1 Material Data &amp; Model Fitting​ Material Data Tab: User can view each material property in this list via double clicking a certain material in material list.Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index) &amp; Im(refractive index), “εr′,εr″-Re(relative permittivity) &amp; Im(relative permittivity), “εr′,σ”-Re(relative permittivity) &amp; conductivity. Anisotropy : Two options in this drop-down menu, “None” and “Diagonal”, when diagonal option is checked, user can create FDTD, FDE, or EME anisotropic optical material in the “User Material Database” window. Solver physics :Anisotropic materials react to electric field with directional dependent electric displacement. Permittivity can be represented by a 9 element tensor εij\\varepsilon_{ij}εij​. Di=εijEjD_i = \\varepsilon_{ij}E_jDi​=εij​Ej​ In general, this tensor can be diagnonalized by a proper choice of coordinate system, e.g. in principle dielectric axes. So it is simplified to ε=[εx000εy000εz]\\varepsilon =\\begin{bmatrix} \\varepsilon_x &amp; 0 &amp; 0\\\\ 0 &amp; \\varepsilon_y &amp; 0\\\\ 0 &amp; 0 &amp; \\varepsilon_z \\end{bmatrix}ε=​εx​00​0εy​0​00εz​​​ Diagonal anisotropic materials:To define an anisotropic material, set the Anisotropy field in the material database to Diagonal and assign the parameters for each diagonal component.","keywords":""},{"title":"Structure","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/2Structure","content":"Structure Features Description: Add or Edit Structures. This Part mainly contains the establishment of structures and the importation and exportation of GDS files or STL files. 1 Structures​ In the Structure, there are “Triangle”, “Rectangle”, “Circle”, “Ring”, “Polygon”, “Ellipse”, “Linear Trapezoid”, “Pyramid”, “Sphere”, “Straight Waveguide”, “Bezier Waveguide”, “Analytical Waveguide”. All structures support 3d modeling, and meet X, Y, Z direction rotation. The edit window of each structure contains three tabs: Geometry, Material. The interface of Material tab and function are below. 1.1 Triangle​ 1.2 Rectangle​ 1.3 Circle​ 1.4 Ring​ 1.5 Polygon​ 1.6 Ellipse​ 1.7 Linear Trapezoid​ 1.8 Pyramid​ 1.9 Sphere​ 1.10 Analytical Waveguide​ 1.11 Straight Waveguide​ Note : The straight wave-guide and the rectangle are the same in modeling when the tilt angle and tile position are not used to change the sidewall. It is important to note that the straight wave-guide only has two sides to be shaped, whereas the rectangle will be shaped by the parameters regarding the fore sides. 1.12 Bezier Waveguide​ Tilt Position-&gt; User-Defined: allows user to define the objective location,if user-defined is selected, user can set the value in the “User-Defined” box, the value of user defined location would be limited between 0~1.(default:1) 2 Import/Export​ Additionally, for modeling complex structures, users can efficiently import or export GDS II/STL files using GDS II/STL files. 2.1 Import GDS File​ The descriptions of each tab in the Import GDS II File are below: The descriptions of each tab in the Export GDS II File are below: Import GDS II File\tDescriptionFile Path\tThe file path of the imported GDS II file. select file\tTo import GDS II file. Cell Name\tThe name of different cell in the GDS II file. Layer Number\tThe layer number. X/Y (um)\tIn the XY direction, the position offset from the origin. Z, Z span/ Z min, Z max\tZ center position and Z span of the object/Z min and Z max of the object. Tile Position\tTo ensure the object is placed at the specified sizes on the different ratio of sidewalls. Selections are [ 'Top', 'Bottom', 'Middle','UserDefined']. Tilt Angle\tTilt angle of the object's sidewall. Construction Method\tSelections are [ 'Method 1', 'Method 2']. Default value is Method 1. 2.2 Export GDS File​ The descriptions of each tab in the Export GDS II File are below: Export GDS II File\tDescriptionStructure\tDrop down to select the exported structure in the project Z\tThe Z plane position of the exported structure. Path\tThe file path of the exported GDS II file. Moreover, clicking the “Import STL II File”, a windows will pop up directly and users can import structures from the STL File. Clicking the “Export STL II File”, a windows will pop up directly and export structures to the STL file. 3 Structure Group​ In this section, users can use “Structure Group” to change the properties of all the structures in this group, including location bias, material and tilt angle. To set the Geometry and Material of Structure Group in “Edit”. 4 Transform​ Enable users to transform selected objects. Clicking the “Transform” button in the ribbon initiates a dialog box. Users can add transform items with a right-click and select types from the drop-down menu. The available transform types encompass translation, scaling, rotation, and mirroring. Type -- A drop-down menu, with options for “Translate”, “Scale”, “Rotate”, or “Mirror”. Shape Center -- When in the “on” state, X0, Y0, and Z0 are non-editable; the switch is defaulted to “on”. Note that, the shape center does not support “Translate” feature. X/Y/Z -- Define translate vector / scale vector / rotate angle / mirror plane normal. X0/Y0/Z0 -- Specify the origin for the transform operation, excluding the translate operation.","keywords":""},{"title":"FDE Solver","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/3Simulation/1FDE","content":"FDE Solver Solver Physics: The FDE solver employs finite-difference techniques to compute the spatial characteristics and frequency dependence of modes. By solving the Maxwell's equations on a cross-sectional mesh of the waveguide, the solver determines the mode field profiles, effective index, and loss values. The simulation example for the z-normal eigenmode solver features the following vector fields: E(x,y)ei(−ωt+βz)E (x,y)e^{i(-\\omega t+\\beta z)}E(x,y)ei(−ωt+βz) H(x,y)ei(−ωt+βz)H (x,y)e^{i(-\\omega t+\\beta z)}H(x,y)ei(−ωt+βz) The propagation constant is denoted by β, and ω represents the angular frequency. Based on these parameters, the modal effective index and loss are defined as follows: neff=cβωn_{eff}= \\frac{c\\beta}{\\omega } neff​=ωcβ​ To identify the modes, the Eigensolver solves Maxwell's equations on a cross-sectional waveguide mesh. The finite-difference algorithm, which can handle complex waveguide geometries, is currently employed for meshing purposes. After the meshing process, the equations are reformulated into a matrix eigenvalue problem, which is solved using sparse matrix techniques. This approach enables the effective index and mode profiles of the waveguide modes to be determined. Features Description: Add or edit FDE simulation area and boundary conditions. 1 Tool bar​ In this example, we show how to use Max-Optics local passive to run FDE and view the simulation result. 1.1 General tab​ 1) Solver Type: Chooses either a 2D X/Y/Z normal. (Default: 2D X normal) 2) Background Material: The combo box allow user to set the background material from drop down menu. Project, object defined dielectric, and go to material library can be operated. Project: The background material inherits from the project’s material setting. Object Defined Dielectric: The object-defined dielectric material, a default setting if user forgets to set background material, is defined for the current object background material setting, and once the user chooses this option, he does not need to set any material from the standard, user, or project material database. And the object-defined dielectric will not be loaded into any material database. Go to Material Library: If selected, user can go to standard material database to set background material according to needs. And the selected material relative property from standard material database will be displayed in the material data list. Index: specify background index manually in stead of choosing form library. (Default :1). 1.2 Geometry tab​ 1) X, Y, Z: The center of the simulation region. 2) X Min, X Max: minimal and maximal.in x direction 3) Y Min, Y Max: minimal and maximal.in y direction. 4) Z Min, Z Max: minimal and maximal.in z direction 5) X Span, Y Span, Z Span: X, Y, Z span of the simulation region. (Notes: The availability is based on the solver type.) 1.3 Mesh setting tab​ 1) DX/ DY/DZ: Maximum mesh step settings. The default setting is 0.02 μm. 2) Mesh Refinement: Mesh refinement can give sub-cell accuracy for a simulation. ①Staircase: The material at each position of the Yee cell is defined as the material occupies majority space of the cell. Resulting a “staircase” like permitivity mesh. ②Curve Mesh:Effective permittivities can be derived via a contour path recipe, which effectively takes the dielectric interface shapes, as well as material weight inside a cell into account. 3) DX/DY/DZ: Maximum mesh step settings. The default setting is 0.02 μm. 4) Mesh Grading: Grading factor : In the case of a non-uniform mesh, Mesh Grading specifies the maximum ratio at which a neighboring grid can be enlarged or reduced. For instance, if dx(k+1) = c*dx(k), then 1/(GRADING FACTOR) &lt;= c &lt;= GRADING FACTOR. It is recommended that 1 &lt;= GRADING FACTOR &lt;= sqrt(2). (Default: 1.2) 5) Minimum Mesh Step Settings: This indicates the minimum mesh step for the whole region managed by the solver (including also the mesh override regions). (Default: 0.0001μm) 1.4 Boundary conditions tab​ 1) PML: The electromagnetic waves indicent upon a perfectly matched layer (PML) boundary will all be absorbed without any reflection at all frequencies and omni direction, i.e., a PML mimics in essence an ideally open (or reflectionless) boundary. In contrast to conventional boundary conditions, a PML boundary occupies a finite volume surrounding the simulation region and hence possesses only a finite thickness, and the process of light absorption takes place inside this thickness span. ① LAYERS: specify the number of layers PML regions are to be divided. ② KAPPA, SIGMA, ALPHA : Kappa and sigma are used for controlling the absorption performance of PML boundaries according to the simulation needs. As can be found in the reference, kappa is unitless by definition, while sigma requires normalization before being entered into the PML settings table as a unitless value. Specifically, kappa and sigma are both evaluated through polynomial variations with respect to their geometric positions inside the PML regions. ③ PML Polynomial: This determines the degree of the polynomial utilized to grade kappa and sigma. 2) PEC: Metal boundary conditions are used to specify boundaries that behave as a Perfect Electric Conductor (PEC), Metal boundaries are perfectly reflecting, allowing no energy to escape the simulation volume along that boundary. 3) PMC: Perfect Magnetic Conductor (PMC) boundary conditions are introduced to be the magnetic correspondence of the metal (PEC) boundaries. 4) Symmetry/Anti-symmetry: When investigating a system that exhibits one or more axes/planes of symmetry, the symmetric/anti-symmetric boundary conditions are frequently employed, for both the structure and the source. For the electric field, symmetric boundaries serve as mirrors and anti-symmetric boundaries serve as anti-mirrors---whereas for the magnetic field, the story is exactly the opposite. For a desired vector symmetry of the solution, the choice between the symmetric or anti-symmetric boundary conditions is often of pivotal importance. Note that the sources and the boundary conditions must use the same type of symmetry for the results to be meaningful. 5) Periodic: Periodic BCs allow you to analyze the whole system by studying only one unit cell if the interested system is somewhat spatially periodic, and they are easily enabled by setting the simulation span identical to the length of one unit cell, plus choosing then &quot;Periodic BCs&quot; for that boundary. Upon doing so, the EM fields at one side of the unit cell (which is subjected to Periodic BCs) are always duplicated accordingly at the other side during the entire simulation. Notes: It is crucial to keep in mind that when employing Periodic Boundary Conditions (PBCs), both the physical structure and the electromagnetic (EM) fields in the system must be periodic. Neglecting this key aspect often leads to errors, such as utilizing PBCs in systems with a periodic structure but non-periodic EM fields. 1.5 Advanced tab​ 1) Dispersion Settings: Sets dispersion. Fractional Offset for Group Delay: Numerically, the group delay of the device is computed by means of a finite-difference approximation of diffentiating the phase with respect to frequency. The “fractional offset for group delay” refers to the fractional amount of the frequency used in the step size of finite difference. If this setting is too small, the phase change may be severely affected by noise, whereas a too large setting could result in an unrealistic group delay since the phase may change by more than 2π. For rather long devices (10000+ wavelengths) in which the phase varies quickly with frequency, the user is encouraged to reduce this setting from the default value. Otherwise the default setting is generally recommended. (Default:0.0001 μm) ng=neff−λΔneffλoffsetn_{g}=n_{eff} -\\lambda \\frac{\\Delta n_{eff}}{\\lambda_{offset} } ng​=neff​−λλoffset​Δneff​​ 2) Remove PML Mode Settings: ① Automatically Remove PML Modes: Decide whether to remove modes in the PML boundary condition. ② Threshold for PML Mode Removal: Set the threshold for mode removal.(Default is 0.01).Under the PML boundary condition, if the fraction of magnetic field intensity is larger than this threshold, the modes will be removed . 3) Dispersion Settings: Sets dispersion.","keywords":""},{"title":"EME Solver","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/3Simulation/3EME","content":"EME Solver Solver Physics: As an attractive substitute to FDTD-based techniques for numerical solutions of Maxwell's equations, the EME method operates in the frequency domain and is highly dept at dealing with scenarios involving long propagation distances. The EME method comprises two significant steps: ①　In the first step of the EME method, the electromagnetic fields are decomposed into a series of eigenmodes using a modal approach. To compute these modes, the geometry is partitioned into several cells, and the modes at the interfaces between adjacent cells are calculated. The next step involves constructing scattering matrices for each section by matching the tangential E and H fields at the cell boundaries. This is the most computationally intensive stage of the EME calculation, and it employs the FDE solver; ②　After completing the first two steps, the simulation enters the analysis mode, allowing for the bi-directional propagation of the solution for each section to compute the S matrix of the entire device. If needed, the internal fields can be reconstructed as well. This stage can be executed expeditiously. Furthermore, once in analysis mode, the propagation distance of each section can be altered as desired, without the need to repeat step 1. This is why the EME method is highly efficient when scanning the lengths of devices. Feature Description: Adds or sets EME simulation area and boundary conditions. 1 Tool bar​ 1.1 General tab​ 1) Algorithm: The type of mesh algorithm used (Currently，it is not available ). 2) Solver Type: “3D X Property” is currently the option, two-dimensional solver is not available present. 3) Background Material : The combo box allow user to set the background material from drop down menu. Project, object defined dielectric, and go to material library can be operated. ①Project: The background material inherits from the project’s material setting. ②Object Defined Dielectric: The object-defined dielectric material, a default setting if user forgets to set background material, is defined for the current object background material setting, and once the user chooses this option, he does not need to set any material from the standard, user, or project material database. And the object-defined dielectric will not be loaded into any material database. ③Go to Material Library: If selected, user can go to standard material database to set background material according to needs. And the selected material relative property from standard material database will be displayed in the material data list. ④Refractive Index: This refers to the refractive index of the ambient background medium inside the simulation window (Default: 1) 4) Frequency/Wavelength: Sets the frequency (Default: 193.414 THz) or wavelength (Default:1.55 μm) to calculate. 5) Use Wavelength Sweep off/on: If checked, the wavelength sweep function is on, which used for wavelength sweep in EME analysis window. 1.2 EME Setup tab​ 1) Y, Z: The center position of the simulation region. 2) Y Min, Y Max: Y min, Y max position. 3) Z Min, Z Max: Z min, Z max position. 4) Y Span, Z Span: Y, Z span of the simulation region. 5) Cell geometry： ①　X Min: Minimum x position of solver region. The first cell group starts from this position. ②　Number of Modes for All Cell Group: When the switch “Allow Custom Eigensolver Settings” is off, determine the number of modes for all cell group. ③　Allow Custom Eigensolver Settings: if the button switch on, which allows users to set a different number of modes to solve for different cell groups in the Cell Group Definition table. ④　Cell Group Definition: Specify the parameters of each cell group. --&gt; Span: Specify the span of each cell group. --&gt; Cell Number: The number of cells in each cell group. --&gt; Number of Modes: The number of modes in each cell group. --&gt; Sub Cell Method: Decide which sub-cell method to employ. (None or Sub Cell) --&gt; Custom: When “Custom” is Default, the value in “Number of Modes” is equal to the “Number of Modes for All Cell Group”. --&gt; Delete button: Clears the custom settings for the selected cell group. --&gt; Add button: Allow you to make custom settings for the selected cell group. ⑤　Clear Settings for Cell Group: Clears the custom settings for the selected cell group. ⑥　Custom Settings for Cell Group：When the “Custom Settings for Cell Group” button is clicked, the “Select Mode” window will appear, enabling users to customize modes for the selected cell group. Notes:The availability of clear settings for cell groups and custom settings for cell groups is contingent upon enabling the “Allow Custom Eigensolver Settings” button. ⑦　Display Groups: Displays cell boundaries in the CAD. ⑧　Display Cells: Displays cells in the CAD. 1.3 Mesh Settings tab​ Since the propagation in the EME solver is along the x-direction, the mesh settings are applicable merely along the y and/or z axes, depending on the solver type (3DX2D). 1) Mesh Refinement: Select an approach to calculate refined mesh properties. ①　Staircase: Any point inside a Yee cell might be evaluated to determine of which material it is consisted, and the properties for that single material are used for depicting the E field at that point. As a consequence, the discretized structure hardly accounts for structure variations that arises inside a single Yee cell, therefore leading to a “Staircase” permittivity grid which agrees exactly with the Cartesian grid. Besides, all layers are effectively shifted to the closest E field position inside the Yee cell, implying that there is no way for the thickness to be resolved as finer than dx. ②　Curve Mesh: Effective permittivities can be derived via a contour path recipe, which effectively takes the dielectric interface shapes, as well as material weight inside a cell into account. 2) Mesh Grading: Grading factor : In the case of a non-uniform mesh, Mesh Grading specifies the maximum ratio at which a neighboring grid can be enlarged or reduced. For instance, if dx(k+1) = c*dx(k), then 1/(GRADING FACTOR) &lt;= c &lt;= GRADING FACTOR. It is recommended that 1 &lt;= GRADING FACTOR &lt;= sqrt(2). (Default: 1.2) 3) Maximum Mesh Step Settings DY/DZ: Maximum mesh step settings. The default setting is 0.02 μm. 4) Minimum Mesh Step Settings: This indicates the minimum mesh step for the whole region managed by the solver (including also the mesh override regions). (Default: 0.0001μm). 1.4 Boundary Conditions tab​ 1) PML: The electromagnetic waves incident upon a perfectly matched layer (PML) boundary will all be absorbed, i.e., a PML mimics in essence an ideally open (or reflection-less) boundary. In contrast to conventional boundary conditions, a PML boundary occupies a finite volume surrounding the simulation region and hence possesses only a finite thickness, and the process of light absorption takes place inside this thickness span. --&gt; LAYERS: For discretization purposes, PML regions are divided into layers. --&gt; KAPPA, SIGMA, ALPHA: Kappa and sigma are used for controlling the absorption performance of PML boundaries according to the simulation needs. As can be found in the reference, kappa is unitless by definition, while sigma requires normalization before being entered into the PML settings table as a unitless value. Specifically, kappa and sigma are both evaluated through polynomial variations with respect to their geometric positions inside the PML regions. --&gt; PML Polynomial: It specifies the order of the polynomial used to grade kappa and sigma. Reference: S. D. Gedney and B. Zhao, An Auxiliary Differential Equation Formulation for the Complex-Frequency Shifted PML, IEEE Trans. on Antennas &amp; Propagat., vol. 58, no. 3, 2010. 2) PEC: PEC boundary conditions are introduced to mimic boundaries that behave exactly like a Perfect Electric Conductor (PEC). Metal boundaries reflect all the electromagnetic waves, and hence no energy can get through a simulation volume bounded by metals. 3) PMC: Perfect Magnetic Conductor (PMC) boundary conditions are introduced to be the magnetic correspondence of the metal (PEC) boundaries. 4) Symmetry/Anti-Symmetry: When investigating a system that exhibits one or more axes/planes of symmetry, the symmetric/anti-symmetric boundary conditions are frequently employed, for both the structure and the source. For the electric field, symmetric boundaries serve as mirrors and anti-symmetric boundaries serve as anti-mirrors -- whereas for the magnetic field, the story is exactly the opposite. For a desired vector symmetry of the solution, the choice between the symmetric or anti-symmetric boundary conditions is often of pivotal importance. Note that the sources and the boundary conditions must use the same type of symmetry for the results to be meaningful. 5) Periodic: Periodic BCs allow you to analyze the whole system by studying only one unit cell if the interested system is somewhat spatially periodic, and they are easily enabled by setting the simulation span identical to the length of one unit cell, plus choosing then “Periodic BCs” for that boundary. Upon doing so, the EM fields at one side of the unit cell (which is subjected to Periodic BCs) are always duplicated accordingly at the other side during the entire simulation. Notes: The most important detail to remember is that when using Periodic BC's, everything in the system must be periodic: both the physical structure and the EM fields. A common source of error is to use periodic boundary conditions in systems where the structure is periodic, but the EM fields are not. 1.5 Advanced tab​ 1) EME settings: ①　Max Stored Modes: Maximum number of modes for each cell in the EME setup.(Default: 1000, the input is limited to [1,1000]). 2) Dispersion Settings: ①　Fractional Offset for Group Delay: Numerically, the group delay of the device is computed by means of a finite-difference approximation of diffentiating the phase with respect to frequency. The “fractional offset for group delay” refers to the fractional amount of the frequency used in the step size of finite difference. If this setting is too small, the phase change may be severely affected by noise, whereas a too large setting could result in an unrealistic group delay since the phase may change by more than 2π. For rather long devices (10000+ wavelengths) in which the phase varies quickly with frequency, the user is encouraged to reduce this setting from the default value. Otherwise the default setting is generally recommended. (Default:0.0003 μm) ng=neff−λΔneffλoffsetn_{g}=n_{eff} -\\lambda \\frac{\\Delta n_{eff}}{\\lambda_{offset} } ng​=neff​−λλoffset​Δneff​​","keywords":""},{"title":"Source","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/4Source","content":"Source 1 Mode Source​ Feature Description:The mode source is used to inject a guided mode into the simulation region in FDTD. 1.1 General tab​ 1) Injection Axis: This field specifies the axis for the mode source propagation. Three options are available: “X-Axis”, “Y-Axis”, and “Z-Axis”. 2) Direction: This field indicates the direction of mode source propagation. Two options are available: “Forward” means the propagation is along a positive direction, while “Backward” means the propagation is along a negative direction. 3) Amplitude: This field specifies the amplitude of the mode source. See the section ``Units and normalization section''. (Default value: 1) 4) Phase: This field refers to the phase value (in units of degrees) of the mode source. It makes sense only when there exist relative phase differences among multiple sources of radiation. 5) Mode selection: Define the method of directly selecting the &quot;Fundamental&quot; mode, &quot;User Select&quot;, and &quot;User Import&quot; to select the mode field of the light source. The &quot;Fundamental&quot; mode options include &quot;Fundamental&quot;, &quot;Fundamental TE Mode&quot; and &quot;Fundamental TM Mode&quot;. ① Select Mode: If the mode selection method is &quot;User Select&quot;, the &quot;Select Mode&quot; button will be enabled, and clicking &quot;Select Mode&quot; will call the FDE analyzer to solve the waveguide cross-section mode. ② Number of Trial Modes: When searching for the fundamental mode, the number of modes of waveguide cross-section to be solved. Usually, setting the number of trial modes to 20 can find fundamental mode that the user is interested in. It will be enabled when the &quot;Mode Selection&quot; is &quot;Fundamental&quot;,&quot;Fundamental TE Mode&quot; or &quot;Fundamental TM Mode&quot;. ③ Mode Index: This field sets the ID number of mode source calculated modes using FDE Analysis. It is only enabled when &quot;Mode Selection&quot; is &quot;User Select&quot;. ④ Import Data:When 'Mode Selection' selects 'User Import', a mode field profile can be imported as the mode light source through 'Import Data'. In the pop-up dialog box, use 'Select' to support importing file formats including mat and zbf. ⑤ View Data: You can use this field to check the mode field profile imported by “Import Data”. 1) Rotations: ① Theta: The angle between the incident direction and the injection axis after the rotation of the mode source. This refers to the angle of propagation measured by degrees, with respect to the incident axis of the source in a 3D simulation. In a 2D simulation, it is the angle of propagation measured by degrees revolved around the global Z-axis in compliance with the right-hand rule, that is, the angle of propagation in the XY plane. ② Phi: The rotation angle of the mode source around the incident axis, it may change the polarization of the mode source.This refers to the angle of propagation measured by degrees revolved around the incident axis of the source in compliance with the right-hand rule in a 3D simulation. In a 2D simulation, this value does not take effect. ③ Rotation Offset: Offset is used to set the impact of the deviation of the mode source position on the simulation results, it can be used to verify the rationality of the design.A rotation offset can be endowed to the plane upon which the mode is computed. This guarantees that mode sources at an angle do not interfere with structures not belonging to the waveguide/fiber. 1.2 Geometry tab​ 1) X, Y, Z: The center position of the simulation region. 2) X Min, X Max: X min, X max position. 3) Y Min, Y Max: Y min, Y max position. 4) Z Min, Z Max: Z min, Z max position. 5) X Span, Y Span, Z Span: X, Y, Z span of the simulation region. 1.3 Waveform tab​ 1) Waveform: This field sets the waveform of the light source. You can use predefined waveforms, such as &quot;Waveform_1550&quot;, &quot;Waveform_1310&quot; or &quot;Visible_Light&quot;. You can also use 'User Custom' to set a new desired waveform on this interface. 2) Set: This field you can choose &quot;Frequency/Wavelength&quot; or &quot;Time domain&quot; to set the source pulse shape and bandwidth. 3) Set Frequency/Wavelength: ① Range Type: You can choose the type of &quot;Wavelength&quot; or &quot;Frequency&quot; to set the waveform. ② RangeLimit: Min/Max,Center/Span: You can choose Min/Max or Center/Span to set the values. ③ Wavelength Min/Max：The wavelength of the minimum and maximum values input is used to calculate the pulse waveform and bandwidth of the light source. 4) Set Time Domain: ① Frequency: Center frequency of optical carrier. ② Pulselength:The duration of the full-width at half-maximum(HWHM) power of the light source pulse. ③ Offset: Indicates the time it takes for the light source to reach its maximum amplitude. ④ Bandwidth: Used to set the “FWHM” frequency width of the time-domain pulse. 5) Save to Waveform List: This field is used to save user defined waveforms. 2 Gaussian source​ Feature Description: The gaussian source is used to inject a gaussian source into the simulation region in FDTD. You could add and set gaussian source here. 2.1 General tab​ 1) Injection Axis: This field specifies the axis for the gaussian source propagation. Three options are available: “X-Axis”, “Y-Axis”, and “Z-Axis”. 2) Direction: This field indicates the direction of gaussian source propagation. Two options are available: “Forward” means the propagation is along a positive direction, while “Backward” means the propagation is along a negative direction. 3) Angle Theta: This refers to the angle of propagation measured by degrees, with respect to the incident axis of the source in a 3D simulation. In a 2D simulation, it is the angle of propagation in degrees revolved around the global Z-axis in compliance with the right-hand rule, that is, the angle of propagation in the XY plane. 4) Angle Phi: For 3D simulations, Phi corresponds to the angle of propagation (measured by degrees) revolved around the axis of source injection in compliance with the right-hand rule. This value has no meaning for 2D simulations. 5) Amplitude: This field specifies the source amplitude. (Default value: 1) 6) Phase: This field refers to the phase value (in units of degrees) of the point source. It makes sense only when there exist relative phase differences among multiple sources of radiation. 7) Polarization Angle: For an injective electric field, the polarization angle is meant to be its orientation, measured with respect to the plane formed by the vector of propagating direction and the normal of the injection plane. Radiation with a vanishing polarization angle is P-polarized regardless of the direction of propagation, while radiation with a polarization angle of 90 degrees is S-polarized. 8) Beam Settings: ① Beam Parameters: The user can choose either &quot;Waist Size and Position&quot; or &quot;Beam Size and Divergence&quot; to define a scalar beam. Select &quot;Waist Size and Position&quot;, &quot;Waist radius W0&quot; and &quot;Distance from Waist&quot; will be enabled, or select &quot;Beam Size and Divergence&quot;, &quot;Beam radius Wz&quot; and &quot;Divergence Angle&quot; will be enabled. ② Waist Radius W0: The user can input the value of waist radius Gaussian beam. (Default: 1.01818) . ③ Distance from Waist: The distance between the injection plane and the beam waist plane. If the distance is positive, the resulting beam is divergent, while if the distance is negative, the resulting beam is convergent. ④ Beam Radius Wz: radius of the beam for a Gaussian beam. ⑤ Divergence Angle: Angle of the radiation spread as measured in the far-field, where positive values represent diverging beams and negative values represent converging beams. 2.2 Geometry tab​ The geometry tab contains options to change the size and location of the sources.You can set the position and size of the light source through X, X Span, Y, Y Span, Z and Z Span. Note that when the Injection Axis is selected as X-Axis, X Span is automatically set to 0 and cannot be edited. 2.3 Waveform Tab​ The waveform of Gaussian light source is similar to that of mode light source, and users can set it by analogy with mode light source. 3 Dipole Source​ Feature Description: The dipole source is used to inject a dipole source into the simulation region in FDTD. In general, it can be applied to simulate radiation sources, such as antennas, etc. 3.1 General tab​ 1) Dipole Type:: Two options are available: “Electric Dipole” and “Magnetic Dipole”. 2) Amplitude: Set the amplitude of the source. 3) Phase: Set the phase of the source. 4) Theta: Set the angle between the source vector and z-aixs. 5) Phi: Set the angle between the source vector and x-aixs. 3.2 Geometry tab​ 1) X, Y, Z: The center position of the simulation region. 2) X Min, X Max: X min, X max position. 3) Y Min, Y Max: Y min, Y max position. 4) Z Min, Z Max: Z min, Z max position. 5) X Span, Y Span, Z Span: X, Y, Z span of the simulation region. 3.3 Waveform Tab​ The waveform of Gaussian light source is similar to that of mode light source, and users can set it by analogy with mode light source. 4 Waveform​ Features Description: Global waveforms settings include only one part, the standard waveform list. There are three default waveforms in the standard waveform list, includes Waveform_1550, Waveform_1310 and Visible_Light. The default waveforms in the standard waveform list cannot be edited directly. user can add a new waveform via right-click in the standard waveform list. User only can delete newly added waveforms in the standard waveform list.","keywords":""},{"title":"FDTD Solver","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/3Simulation/2FDTD","content":"FDTD Solver Solver Physics: The numerical method of computational electrodynamics that provides approximate solutions to the system of Maxwell's equations is known as Finite-Difference Time-Domain (FDTD). It is also referred to as Yee's method, named after Kane S. Yee, a Chinese-American applied mathematician. As a time-domain method, FDTD handles nonlinear material properties in a rather natural way and can cover a wide frequency range by running only a single simulation. Features Description: Adds or sets FDTD simulation region and boundary conditions. Notes : When FDTD solver is selected, user cannot add FDE solver and EME solver at the same time. 1 Tool bar​ 1.1 General tab​ 1) Dimension: Number of dimensions of the simulation region. (Default: 3D) 2) Using Optical Path Estimate Time: It is the switch button that the estimation of simulation time based on optical path. 3) Simulation Time: Simulation time indicates the maximum duration of the simulation to be implemented. In reality the simulation may end earlier when some of the auto-shutoff conditions are satisfied before running till this maximum simulation time. (Default: 1000 fs) 4) Background Material: The combo box allows user to set the background material from drop down menu. “Project”, “Object Defined Dielectric”, and “Go to Material Library” can be operated. 5) Project: The “Background Material” can be selected from the “Project” sublist in the “Material Database” based upon the needs. 6) Object Defined Dielectric: The object-defined dielectric material, a default setting if user forgets to set background material, is defined for the current object background material setting, and once the user chooses this option, he does not need to set any material from the standard, user, or project material database. And the object-defined dielectric will not be loaded into any material database. Go to Material Library: If selected, user can go to standard material database to set background material according to needs. And the selected material relative property from standard material database will be displayed in the material data list. 7) Refractive Index: The refractive index of the surrounding, background medium in the simulation region.(Default: 1) 1.2 Geometry tab:​ 1) X, Y, Z: The center position of the simulation region. 2) X Min, X Max: X min, X max position. 3) Y Min, Y Max: Y min, Y max position. 4) Z Min, Z Max: Z min, Z max position. 5) X Span, Y Span, Z Span: X, Y, Z span of the simulation region. 1.3 Mesh Settings tab:​ 1) Mesh Type: Algorithms for generating the mesh are available, to be explained as follows: ①　Auto non-uniform (Default): By default, a non-uniform mesh is generated according to the mesh accuracy. ②　Uniform: A uniform mesh is used over the whole simulation region, disregarding any material properties. An override region forces the specified mesh size everywhere instead of inside the override region only, whenever it is used together with this option. 2) Mesh Accuracy: Mesh Accuracy indicates the number of cells per wavelength. (Default: 15). 3) Minimum Mesh Step Settings: Minimum Mesh Step indicates the absolute minimum grid size inside the entire solver window. 4) Mesh Refinement: Select an approach to calculate refined mesh properties. ①　Staircase: Any point inside a Yee cell might be evaluated to determine of which material it is consisted, and the properties for that single material are used for depicting the E field at that point. As a consequence, the discretized structure hardly accounts for structure variations that arises inside a single Yee cell, therefore leading to a “Staircase” permittivity grid which agrees exactly with the Cartesian grid. Besides, all layers are effectively shifted to the closest E field position inside the Yee cell, implying that there is no way for the thickness to be resolved as finer than dx.thickness cannot be resolved to better than dx. ②　Curve Mesh: Effective permittivities can be derived via a contour path recipe, which effectively takes the dielectric interface shapes, as well as material weight inside a cell into account. ③　Grading: The Grading factor specifies the biggest ratio of the neighboring spatial grids. (Default: 1.2) 1.4 Boundary Conditions tab:​ 1) PML: A PML (Perfectly Matched Layer) mimics in essence an ideally open (or reflectionless) boundary upon which is designed to absorb all the incident electromagnetic waves with impedance matched materials to eliminate reflections. 2) PEC: PEC boundary conditions are introduced to mimic boundaries that behave exactly like a Perfect Electric Conductor (PEC). Metal boundaries reflect all the electromagnetic waves, and hence no energy can get through a simulation volume bounded by metals, simulating ideal metal boundaries, such as metal waveguide, reflector antenna, etc. 3) Symmetric/Anti-Symmetric: The Symmetric or Anti-Symmetric Boundary condition is used for reducing simulation time by the Electromagnetic fields which is symmetric through the middle plane of the simulation region. The specific selection between “Symmetric” and “Anti-Symmetric” is according to the relationship of source polarization and symmetric plane. If the normal of symmetric plane is tangential to source polarization, choose the “Symmetric” option. Otherwise, choose the “Anti-symmetric” option. 4) PML settings: The properties of every PML boundary can be set separately. However if the state of the Same Settings on All Boundary Conditions is enabled, all PML boundaries will possess the same profile by sharing the common properties in the table, including “Layers”, “Kappa”, “Alpha”, “Sigma”, “Polynomial”, “Alpha Polynomial”, “Min Layers”, and “Max Layers”. And you can also customize the PML Boundary in Profile，which concludes “Custom” and “Standad” two selections. 5) X/Y/Z min/ max PML: These fields describe the boundary conditions to be applied along the perimeter of the simulation region. 1.5 Advanced Options tab:​ 1) Auto Shutoff : Stops the simulation when the energy in the simulation goes below the “Auto Shutoff Min” when the “Use Early Shutoff ” state is on , you can set min auto shutoff (Default: 1e-4) and down sample time (Default: 200) 2) Down sample time: Under the dt time step down sampling, check whether satisfying the auto shutoff conditions. (Default: 200, and 10 &lt;= it &lt;= 1000) 3) Live Slice Field Display Settings ① Show Field: Real-time filed slice display switch. (Default: on) ② Select Field Section: Combo box allows you to choose from a list of 2D planes normal to the axes for field display. ( 2D Z Normal by default) ③　Position：The position of slice (0 μm by default) ④　Select Component：Combo box allows you to choose from a list of the existing field components ( Ex by default) ⑤　Down sample time: The time step down sampling for displaying field.(200 fs by default)","keywords":""},{"title":"Port","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/5Port","content":"Port 1 FDTD Port​ Feature description:Ports are usually viewed as a combination of mode source and field monitor. Ports can be used either separately or together with the S-parameter sweep tool. Notes:Press the &quot;Port&quot; button in the menu bar, and select &quot;FDTD Port&quot; from the drop-down menu to add a port. Note that the prerequisite is that an FDTD simulation region must be already there. Upon adding a port, a port group named “Ports” is automatically generated as the child of the “Object Tree” , and all port objects are enclosed in this group. In particular, the port hierarchy is arranged in such a manner that ports cannot be moved outside the “Ports group”, and other objects are not allowed to be moved into the group. 1.1 Geometry tab​ 1) X,Y,Z:The center position of the simulation region. 2) X Min, X Max:X min, X max position. 3) Y Min, Y Max:Y min, Y max position. 4) Z Min, Z Max:Z min, Z max position. 5) X Span, Y SP, Z Span:X, Y, Z span of the simulation region. 1.2 Modal properties tab​ 1) Injection Axis:This indicates the axis of propagation. The geometry parameters that will work under the &quot;Geometry&quot; tab may depend on this setting (For instance, if the incident wave is along the x-axis, the port object possesses accordingly a 2D x-normal geometry). 2) Direction:This field indicates the direction of source propagation. Forward means the propagation is along a positive direction, while Backward means the propagation is along a negative direction. 3) Amplitude:&quot;Amplitude&quot; specifies the peak magnitude of electric field measured by V/m in the beam sources. (Default :1) 4) Phase:This refers to the phase of the source measured by degrees. 5) Mode Selection:This enables the user to select the modes used in the mode expansion computations. The eigenmode solver, with which the user may compute and visualize the supported modes , is launched by checking the &quot;User Select&quot; option---this option can also be used to select the desired mode among multiple ones. 6) Number of Trial Modes: The number of solving modes. 7) Mode Index: Find the sequence number of the pattern. 8) Bent Waveguide:Selecting this option enables the bent waveguide solver to work with the following settings: ① Bend Radius:This specifies the bend radius in units of um counted from the center of the port region. (Default value: 1.0 um) ② Bend Orientation: This specifies the orientation of the cylindrical coordinates employed for the computation of modes.Orientation of the cylindrical coordinate system used for calculating modes. ③ Bend Location: This option specifies the location of bend. (Note that only the simulation center is supported at present) 2 EME Port​ Feature Description: The EME solver region contains 2 ports by default. The ports button found in the menu bar adds additional ports to the solver. 2.1 Geometry tab​ 1) Port Location: The port can be selected to locate at the left or right end of the EME solver region. 2) Use Full Simulation Span: By checking this option, the whole simulation span inheritted from the EME simulation region is employed. (Default: on) You need to uncheck this option if you wish to specify your own spans for the port. Therefore the following parameters settings are invalid when &quot;Use Full Simulation Span&quot; is enabled. 3) X, Y, Z: The center position of the simulation region. 4) X MIN, X MAX: X min, X max position. 5) Y MIN, Y MAX: Y min, Y max position. 6) Z MIN, Z MAX: Z min, Z max position. 7) X SPAN, Y SPAN, Z SPAN: X, Y, Z span of the simulation region. 2.2 EME Port tab​ 1) Mode Selection: ①　Allow you to select the modes to use for the mode expansion calculation. The &quot;user select&quot; option launches the eigenmode solver where the user can calculate and visualize the supported modes; use this option to select multiple modes. The &quot;Mode calculation&quot; section Allow you to select a mode they are interested in. The user S-matrix result returns the S-matrix for these selected modes. A selected mode can also be used as an input source in the EME propagation stage of the analysis, Fundamental Mode, Fundamental TE Mode, Fundamental TM Mode, Fundamental TE and TM Mode, Use Select and User Import are included. (Default: fundamental mode) ②　Checking the &quot;user select&quot; option enables you to specify mode parameters in the ``Select Mode'' window. The number of trial modes will be displayed in the mode list after they are solved by computation. The plot options of the user's interest can be specified in the mode plot options section. ③　User import: Import arbitrary source fields into EME ports. It is possible to use a custom field profile from a .mat file, .datx file or .zbf file as the source in an EME simulation. The field profile data can be from another simulation. To set this as a port mode, open the Edit EME port tab, select “User import” under mode selection and click on “Import Field”. 1) Number of Trial Modes: This specifies the number of modes to search for finding a fundamental mode. The modes eventually found by the solver may depend on that. If one uses a too small number, the expected modes could be missing. Usually, setting this number to 100 suffices to guarantee no physical modes would have been missed. However, users who are interested in higher order modes should set a even larger value, since in such cases more than 100 modes may be present. (Default value: 20) 2) Offset: An offset can be endowed to the plane upon which the modes are computed. This guarantees that monitors placed at an angle do not interfere with unexpected structures.","keywords":""},{"title":"Monitor","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/6Monitor","content":"Monitor 1 Index Monitor​ Feature Description: Index monitors store the values of n and k as functions of frequency/wavelength in a simulation. 1.1 Geometry tab​ 1) Monitor type: This field selects a refractive index monitor that is perpendicular to different coordinate axes. You can choose &quot;2D X-Normal&quot;, &quot;2D Y-Normal&quot;, or &quot;2D Z-Normal&quot;. 2) X, Y, Z: The center position of the simulation region. 3) X Min, X Max: X min, X max position. 4) Y Min, Y Max: Y min, Y max position. 5) Z Min, Z Max: Z min, Z max position. 6) X Span, Y Span, Z Span: X, Y, Z span of the simulation region. 7) Index Preview: You can use “Index Preview” to view the refractive index distribution of the structure before running the simulation. Double click to run “Index Preview” in the drop-down box of the refractive index monitor in the Object tree. 2 Frequency-Domain Field and Power Monitor​ Feature Description:Frequency domain field monitors work in the frequency domain and extract the field profiles across some spatial regions of the FDTD simulation. 2.1 General tab​ 1) Override Global Options: This is a toggle for overriding the global monitor settings. Checking this option enables the user to specify the frequency spans and number of points at which frequency-domain data will be collected. Otherwise the following options should be specified from the global monitor settings. 2) Sample Spacing: The sampling frequency or wavelength is determined somehow based on this choice parameter. Only the &quot;uniform&quot; option is available at present. 3) Use Wavelength Spacing:The monitor defaults to recording frequency points at equal intervals. Select this option to take values at equal intervals relative to the wavelength of the data. 4) Use Source Limits: ① Range Type: This field is used to select the type of light source range to set: wavelength or frequency. ② Range Limit: This field is used to select the way to set the range of light sources: Min/Max or Center/Span. ③ Wavelength Min: This field sets the minimum value for monitoring wavelength. ④ Wavelength Max: This field sets the maximum value for monitoring wavelength. 1) Frequency Points: Sets to choose the number of frequency points at which to record data. (Default: 5) 2.2 Geometry Tab​ 1) Monitor Type: The monitor type and orientation, this option will control the available of spatial setting below, Point, Linear X/Y/Z, 2D X-Normal/2D Y-Normal/2D Z-Normal, 3D are included. ( Default: 2D X-normal) 2) X/X Span; Y/Y Span; Z/Z Span: ① X, Y, Z: The center position of the simulation region. ② X Min, X Max: X min, X max position. ③ Y Min, Y Max: Y min, Y max position. ④ Z Min, Z Max: Z min, Z max position. ⑤ X SPAN, Y SPAN, Z SPAN: X, Y, Z span of the simulation region. 2.3 Data to Record tab​ 1) Fields &amp; Poynting vector and power: Users can choose to output electromagnetic field components of interest. Ex, Ey, Ez, Hx, Hy, Hz. 2) Poynting Vector and Power: Users can choose to output the Poynting Vector(Px, Py, Pz) and Power of interest. For 3D simulations, only part of the components are non-vanishing (i.e., for TE simulations only EX, EY, and HZ will make sense). However to facilitate fast switches between TE and TM simulations, all the field quantities will remain active. 2.4 Advanced tab​ 1) Sampling Frequency ① Min Sampling Per Cycle: This parameter suggests the realistic minimum amount of samplings for each optical cycle. Default value is 2 (the Nyqusit limit) for sake of the optimum efficiency. ② Desired Sampling: This converts the minimum sampling points in each optical cycle into an actual rate of sampling measured by Hz. ③ Nyquist Limit: The Nyquist limit of sampling is determined in accordance with the maximum frequencies that may arise in the simulation region. ④ Actual Sampling: The actual rate of sampling is identical to the rate that is actually employed for the discrete Fourier transform (DFT), by appropriately taking the desired sampling rate, the Nyquist limit, and the time step dt into account ⑤ Down Sample Time: This specifies the time for step down sampling. Notes: Right-click on the “Frequency-Domain Field and Power” monitor in the object tree and utilize “Preview Modes” or “Preview Index” to pre-visualize modes or index distribution at the cross-section of the monitor. Once the calculation concludes, the Mode Analysis interface (Preview Index and Modes) will pop out. Follow the same steps to select “Mode Expansion Analysis” for advanced analysis of waveguide or fiber modes by right-clicking the “Run Analysis” button. 3 Field Time monitor​ Feature Description: These monitors collect time-domain data for field components over the entire simulation course. Point, line or area monitors can be set and used for collecting such information over various spatial scales inside the simulation regions. 3.1 General Tab​ The general tab for the time monitor includes options to edit the amount of data, and time period over which data is collected. 1) Stop Method: “End of Simulation”, “Choose Stop Time” and “Choose Number of Snapshots”. 2) Start Time: The time to switch on recording. 3) Stop Time: The time to end recording. 4) Number of Snapshots: The number of time steps to be recorded. 3.2 Geometry tab​ 1) Monitor Type: The monitor type and orientation, this option will control the available of spatial setting below , “Point”, “Linear X”, “Linear Y”, “Linear Z”, “2D X-Normal”, “2D Y-Normal”, “2D Z-Normal”,3D are included. (Default: Point) 2) X,Y,Z: The center position of the simulation region. 3) X Min/X Max: X min, X max position. 4) Y Min/ Y Max: Y min, Y max position. 5) Z Min/ Z Max: Z min, Z max position. 6) X Span/ Y Span / Z Span: X, Y, Z span of the simulation region. 3.3 Data to Record tab​ 1) Fields &amp; Poynting vector and power: Output quantities EX, EY, EZ, HX, HY, HZ, PX, PY, PZ: The user can select from the field components (EX, EY, EZ, HX, HY, HZ) or the Poynting vector (PX, PY, PZ). 3.4 Advanced tab​ Sampling rate: 1) Min Sampling Per Cycle: This parameter indicates the realistic minimum amount of samplings in each optical cycle. Default value is 10. 2) Sampling Rate: The actual rate of sampling measured by THz. 3) Down Sample Time: This specifies the time for step down sampling. 4 EME Profile Monitor​ Feature description: EME profile monitors work in the frequency domain to extract field profiles from the simulation results produced by an EME solver over some spatial regions. 4.1 Geometry tab​ 1) Monitor Type: This option specifies the monitor type and orientation, and will affect the availability of the spatial settings below. 2) X, Y, Z: The center position of the simulation region. 3) X Min, X Max: X min, X max position. 4) Y Min, Y Max: Y min, Y max position. 5) Z Min, Z Max: Z min, Z max position. 6) X Span, Y Span, Z Span: X, Y, Z span of the simulation region. 7) X Resolution: The number of mesh steps along propagation direction. 5 Global Option​ Feature description: The global monitor option setting can be used for adding monitors in the FDTD simulation region, if the &quot;override global option&quot; is not enabled. 5.1 Frequency power tab​ 1) Sample Spacing: The sampling frequency or wavelength is determined somehow based on this choice parameter. Only the &quot;uniform&quot; option is available at present. 2) Use Wavelength Spacing: The monitor will record frequency points at equal intervals. Select this option to take values at equal intervals relative to the wavelength of the data. 3) Use Source Limits: When checked these monitors use the source limits. When unchecked, the frequencies/wavelengths at which to record data can be set using the pull down menus and boxes below them. ① Range Type: This field is used to select the type of light source range to set: wavelength or frequency. ② Range Limit: This field is used to select the way to set the range of light sources: Min/Max or Center/Span. ③ Wavelength Min: This field sets the minimum value for monitoring wavelength. ④ Wavelength Max: This field sets the maximum value for monitoring wavelength. 4) Frequency Points: Set to choose the number of frequency points at which to record data (Default 11). 5.2 Advanced tab​ 1) Min Sampling Per Cycle: This parameter suggests the realistic minimum amount of samplings for each optical cycle. Default value is 2 (the Nyqusit limit) for sake of the optimum efficiency. 2) Desired Sampling: This converts the minimum sampling points in each optical cycle into an actual rate of sampling measured by Hz. 3) Nyquist Limit: The Nyquist limit of sampling is determined in accordance with the maximum frequencies that may arise in the simulation region. 4) Actual Sampling: The actual rate of sampling is identical to the rate that is actually employed for the discrete Fourier transform (DFT), by appropriately taking the desired sampling rate, the Nyquist limit, and the time step dt into account. 5) Down Sample Time: This specifies the time for step down sampling.","keywords":""},{"title":"Local Mesh","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/7Mesh","content":"Local Mesh Feature Description: Adds local mesh to simulation.When the global mesh (solver mesh) is not accurate enough to identify the fine structure of some complex models, the local mesh is used to supplement it to improve the mesh accuracy. 1 General tab​ 1) Override X/Y/Z mesh: When “Override X/Y/Z mesh” button state is on, you can set dx/dy/dz mesh override region. The smaller the value of dx/dy/dz, the better accuracy you will get. 2 Geometry tab​ 1) X, Y, Z: The center position of the simulation region. 2) X Min, X Max: X min, X max position. 3) Y Min, Y Max: Y min, Y max position. 4) Z Min, Z Max: Z min, Z max position. 5) X Span, Y Span, Z Span: X, Y, Z span of the simulation region.","keywords":""},{"title":"Run","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/9Run","content":"Run 1 Check Memory​ Feature Entry: Check Memory button in the Home tab of the Ribbon menu. Interaction Logic: Clicking the Check Memory button prompts the software to display a popup window showing estimated memory information. 2 Run​ Feature description : Call the &quot;Solver&quot; or &quot;Solver+Analysis&quot; activated in the project for simulation calculation. Notes: 1) Save the project project project and then run the simulation. If not saved, the following dialog box will pop up. Click &quot;Conform&quot; to save the project and run the simulation. 2) Before the version in the project is completed, new simulations cannot be run, otherwise the following dialog box will pop up. 3) If the parameters of the project are incorrect or the excitation source is not set in FDTD simulation, an error will be reported in the message 4) The estimated memory of the model is greater than the available memory of the current computing resource, and a warning of insufficient memory will be reported in the message","keywords":""},{"title":"Extract result","type":0,"sectionRef":"#","url":"/my-website/docs/test/SDK/9Extract","content":"Extract result Parameters\tDescriptionPowerAttributes\tThe following are power related physical attributes. Literal[&quot;E&quot;, &quot;Ex&quot;, &quot;Ey&quot;, &quot;Ez&quot;, &quot;H&quot;, &quot;Hx&quot;, &quot;Hy&quot;, &quot;Hz&quot;, &quot;Px&quot;, &quot;Py&quot;, &quot;Pz&quot;, &quot;Energy density&quot;] ModeAttributes\tThe following are mode related physical attributes. Literal[&quot;a&quot;, &quot;b&quot;, &quot;n&quot;, &quot;p&quot;, &quot;N&quot;, &quot;P&quot;, &quot;t_forward&quot;, &quot;t_backward&quot;, &quot;T_forward&quot;, &quot;T_backward&quot;] The following are other attributes which can be extracted. Literal[&quot;TEratio&quot;, &quot;neff_real&quot;, &quot;neff_imag&quot;, &quot;ng_real&quot;, &quot;ng_imag&quot;, &quot;wavelength_nm&quot;, &quot;loss_dBpcm&quot;]Parameters\tDescriptiondata\tTo decide what type/field data will be extracted. export_csv\tWhether to export a csv. Default as False. show\tWhether to show the picture. If set to False, the picture will be saved instead. Default as False. savepath\tThe save path of picture . Default as &quot;a&quot;. target\tHow the data is organized/displayed. Default as None. attribute\tWhich attribute will extracted, in few cases this parameter is not needed. Default as None. real\tWhether to add real part of data. Default as True. imag\tWhether to add imag part of data. If both real and imag is activate, &quot;ABS&quot; data will be extracted. Default as True. plot_x\tThe selection of x axis of heatmap or line plot. plot_y\tThe selection of y axis of heatmap. **kwargs\tOther visualization parameters. For example: &quot;monitor_name&quot; , &quot;mode_expansion_name&quot; for &quot;fdtd:mode_expansion&quot;. 8.1 FDE​ In this section, we will provide examples for extracting simulation result data from FDE simulation, along with a description table of parameters. 8.1.1 Calculate mode result​ Get the result of calculated mode. extract( self, data: Literal[&quot;fdtd:power_monitor&quot;], savepath: str, target: Optional[enums.TargetType], attribute: Optional[str], real: bool, imag: bool, monitor_name: str, wavelength: Optional[Union[StrictInt, StrictStr]] = None, plot_x: Optional[str] = None, plot_y: Optional[str] = None, show: bool = False, export_csv: bool = False, export_mat: bool = False, export_zbf: bool = False, ) Example: result_fde.extract(data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_mode{m}&quot;, attribute=&quot;E&quot;, mode=m, real=True, imag=True, **export_options, show=False) 8.1.2 Far-field FDE result​ Get the result of calculated far-field FDE. extract( self, *, # target - table data: Literal[&quot;farfield_fde&quot;], attribute: PowerAttributes, show=False, export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = &quot;a&quot;, mode: int, ) Example: fde_res.extract(data=&quot;farfield_fde&quot;, savepath=f&quot;{plot_path}05_{simu_name}_far_field&quot;, attribute=&quot;E&quot;, mode=0, export_csv=True) 8.1.3 Mesh structure result​ To extract the result of meshing structure. extract( self, *, data: Literal[&quot;mesh_structure&quot;], savepath:Any = &quot;a&quot;, target: Literal[&quot;intensity&quot;] = &quot;intensity&quot;, export_csv=False, export_mat=False, export_zbf=False, show=False, ) Example: simu.add(name=simu_name+&quot;_cal_mode&quot;, type=&quot;mode_selection:user_select&quot;, simulation_name=simu_name, source_name=&quot;source&quot;, property={&quot;modal_analysis&quot;: {&quot;mesh_structure&quot;: True, &quot;calculate_modes&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: 10, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True}}) 8.1.4 Frequency analysis result​ To extract the result of frequency analysis. extract( self, *, target: Literal[&quot;line&quot;] = &quot;line&quot;, data: Literal[&quot;frequency_analysis&quot;], attribute: Literal[&quot;neff&quot;, &quot;group_index&quot;, &quot;loss&quot;, &quot;polarization&quot;], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None ) Example: result_fde.extract(data=&quot;frequency_analysis&quot;, savepath=f&quot;{plot_path}{k}_freq_sweep_neff&quot;, attribute=&quot;neff&quot;, real=True, imag=True, export_csv=True, export_mat=True, show=False) 8.2 EME​ To extract the relevant data of EME module. 8.2.1 EME propagate:facet data​ Get the result of calculated facet data of EME propagation. extract( self, *, data: Literal[ &quot;eme_propagate:facet_data&quot;, ], export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = &quot;a&quot;, ) Example: eme_res.extract(data=&quot;eme_propagate:facet_data&quot;, savepath=plot_path, real=True, imag=True, export_csv=True) 8.2.2 EME propagate:monitor​ Get the result of monitor data of EME propagation. extract( self, *, data: Literal[ &quot;eme_propagate:monitor&quot;, ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) Example: eme_res.extract( data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_y_normal&quot;, monitor_name=&quot;y_normal&quot;, attribute=&quot;E&quot;, export_csv=True) 8.2.3 Propagation sweep:monitor​ Get the result of monitor data of propagation sweep. extract( self, *, data: Literal[ &quot;propagation_sweep:monitor&quot;, ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) Example: eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True) 8.2.4 Wavelength sweep:monitor​ Get the result of monitor data of wavelength sweep. extract( self, *, data: Literal[ &quot;wavelength_sweep:monitor&quot;, ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) Example: eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) 8.2.5 EME propagate:smatrix​ Get the result of smatrix data of EME propagation. extract( self, *, data: Literal[ &quot;eme_propagate:smatrix&quot;, ], target: Literal[&quot;intensity&quot;] = &quot;intensity&quot;, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) Example: eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) 8.2.6 EME propagate:port mode infomation​ Get the result of port mode data of EME propagation. extract( self, *, # target - intensity data: Literal[&quot;eme_propagate:port_mode_info&quot;], target: Literal[&quot;intensity&quot;] = &quot;intensity&quot;, attribute: Literal[&quot;E&quot;, &quot;H&quot;], port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, ) Example: eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) 8.2.7 EME propagate:port mesh structure​ Get the result of port mesh structure data of EME propagation. extract( self, *, # target - intensity data: Literal[&quot;eme_propagate:port_mesh_structure&quot;], port_name: str, target: Literal[&quot;line&quot;, &quot;intensity&quot;] = &quot;intensity&quot;, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) Example: eme_res.extract(data=&quot;eme_propagate:port_mesh_structure&quot;, savepath=f&quot;{plot_path}{kL[3]}_eme_structure_{port_name}&quot;, port_name=port_name, target=&quot;intensity&quot;, # plot_x=&quot;y&quot;, plot_y=&quot;z&quot;, export_csv=False, show=False ) 8.2.8 EME propagate:cell mesh structure​ Get the result of cell mesh structure data of EME propagation. extract( self, *, data: Literal[ &quot;eme_propagate:cell_mesh_structure&quot;, ], target: Literal[&quot;intensity&quot;, &quot;line&quot;], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) Example: eme_res.extract(data=&quot;eme_propagate:cell_mesh_structure&quot;, savepath=f&quot;{plot_path}{kL[4]}_eme_c{cell_index}_index&quot;, cell_params=&quot;c&quot; + str(cell_index), target=&quot;intensity&quot;, plot_x=&quot;y&quot;, plot_y=&quot;z&quot;, # export_csv=False, show=False ) 8.2.9 EME propagate:port overlap​ Get the result of port overlap data of EME propagation. def extract( self, *, data: Literal[ &quot;eme_propagate:port_overlap&quot;, ], target: Literal[&quot;line&quot;] = &quot;line&quot;, port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) 8.2.10 EME propagate:cell mode information​ Get the result of cell mode information of EME propagation. extract( self, *, target: Literal[&quot;intensity&quot;] = &quot;intensity&quot;, data: Literal[ &quot;eme_propagate:cell_mode_info&quot;, ], attribute: Literal[&quot;E&quot;, &quot;H&quot;], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, ) 8.2.11 EME propagate:propagation field​ Get the result of propagation field of EME propagation. extract( self, *, data: Literal[ &quot;eme_propagate:prop_field&quot;, ], # target: intensity&quot;, attribute:PowerAttributes, cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) 8.2.12 EME propagate:internal S​ Get the result of internal S data of EME propagation. extract( self, *, data: Literal[ &quot;eme_propagate:internal_s&quot;, ], target: Literal[&quot;intensity&quot;] = &quot;intensity&quot;, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) 8.2.13 EME propagate:cell p matrix/cell overlap/cell S/propagation S​ Get the result of cell p matrix/cell overlap/cell S/propagation S data of EME propagation. def extract( self, *, data: Literal[ &quot;eme_propagate:cell_p_matrix&quot;, &quot;eme_propagate:cell_overlap&quot;, &quot;eme_propagate:cell_s&quot;, &quot;eme_propagate:prop_s&quot;, ], target: Literal[&quot;intensity&quot;] = &quot;intensity&quot;, cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, ) 8.3 FDTD​ To extract the relevant data of FDTD module. 8.3.1 FDTD:power monitor​ Get the result of power monitor data of FDTD. extract( self, *, data: Literal[&quot;fdtd:power_monitor&quot;], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: Union[PowerAttributes, Literal[&quot;T&quot;]], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, wavelength: Optional[Any] = None, ) Example: fdtd_res.extract( data=&quot;fdtd:power_monitor&quot;, savepath=&quot;path_name&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=False, monitor_name=&quot;monitor_name&quot;, plot_x=&quot;x&quot;, plot_y=&quot;y&quot;, show=False, export_csv=True) fdtd_res.extract( data=&quot;fdtd:power_monitor&quot;, savepath=&quot;path_name&quot;, target=&quot;line&quot;, attribute=&quot;T&quot;, real=True, imag=False, monitor_name=&quot;monitor_name&quot;, plot_x=&quot;wavelength&quot;, show=False, export_csv=True) 8.3.2 FDTD:time monitor​ Get the result of FDTD time monitor data. extract( self, *, data: Literal[&quot;fdtd:time_monitor&quot;], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: Union[PowerAttributes, Literal[&quot;T&quot;]], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, wavelength: Optional[Any] = None, ) Example: fdtd_res.extract(data='fdtd:time_monitor', savepath=f'{plot_path}08_TransVstime', monitor_name='time_monitor_name', target='line', attribute='E',plot_x='time', real=True, imag=False, export_csv=True, show=False) fdtd_res.extract( data=&quot;fdtd:time_monitor&quot;, savepath=f&quot;{plot_path}08_linear&quot;, target=&quot;line&quot;, attribute=&quot;E&quot;, real=True, imag=False, monitor_name=&quot;time_monitor_1D&quot;, time=f&quot;{0}&quot;, plot_x=&quot;y&quot;, show=False, export_csv=True) fdtd_res.extract( data=&quot;fdtd:time_monitor&quot;, savepath=f&quot;{plot_path}08_2D&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=False, monitor_name=&quot;time_monitor_2D&quot;, time=f&quot;{0}&quot;, plot_x=&quot;y&quot;,plot_y=&quot;z&quot;, show=False, export_csv=True) fdtd_res.extract( data=&quot;fdtd:time_monitor&quot;, savepath=f&quot;{plot_path}08_time_3D&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=False, monitor_name=&quot;time_monitor_3D&quot;, time=f&quot;{0}&quot;, x=f&quot;{0}&quot;, plot_x=&quot;y&quot;,plot_y=&quot;z&quot;, show=False, export_csv=True) 8.3.3 FDTD:mode expansion​ Get the result of FDTD mode expansion data. extract( self, *, data: Literal[&quot;fdtd:mode_expansion&quot;], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: ModeAttributes, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, plot_y: OptStr=None, mode: Optional[Any] = None, wavelength: Optional[Any] = None, monitor_name: str, mode_expansion_name: str, ) Example: me_res.extract( data=&quot;fdtd:mode_expansion&quot;, savepath=f&quot;{plot_path}04_TransVsOrder&quot;, target=&quot;line&quot;, attribute=&quot;T_forward&quot;, real=True, imag=True, monitor_name=&quot;through&quot;, mode_expansion_name=&quot;me_through&quot;, wavelength=f&quot;{wavelength}&quot;, plot_x=&quot;mode&quot;, show=False, export_csv=True, ) me_res.extract( data=&quot;fdtd:mode_expansion&quot;, savepath=f&quot;{plot_path}05_TransVsLambda_mode=1&quot;, target=&quot;line&quot;, attribute=&quot;T_forward&quot;, real=True, imag=True, mode_expansion_name=&quot;me_through&quot;, mode=0, plot_x=&quot;wavelength&quot;, show=False, export_csv=True, ) me_res.extract( data=&quot;fdtd:mode_expansion&quot;, savepath=f&quot;{plot_path}05_mode_expansion&quot;, target=&quot;intensity&quot;, attribute=&quot;T_forward&quot;, real=True, imag=False, monitor_name=&quot;through&quot;, mode_expansion_name=&quot;me_through&quot;, plot_x=&quot;mode&quot;, plot_y=&quot;wavelength&quot;, show=False, **export_options, ) 8.3.6 FDTD:mode expansion information​ Get the result of FDTD mode expansion information. extract( self, *, data: Literal[&quot;fdtd:mode_expansion_mode_info&quot;], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: Literal[&quot;E&quot;, &quot;H&quot;, &quot;Loss&quot;, &quot;Neff&quot;, &quot;TE Polarization Fraction&quot;], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, monitor_name: str, mode_expansion_name: str, plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, wavelength: Any = None, ) Example: me_res.extract( data=&quot;fdtd:mode_expansion_mode_info&quot;, savepath=f&quot;{plot_path}05_TransVsLambda_modeinfo&quot;, target=&quot;line&quot;, attribute=&quot;Neff&quot;, real=True, imag=False, monitor_name=&quot;through&quot;, mode_expansion_name=&quot;me_through&quot;, plot_x=&quot;wavelength&quot;, show=False, **export_options, ) me_res.extract( data=&quot;fdtd:mode_expansion_mode_info&quot;, savepath=f&quot;{plot_path}03_me_throughmode_info&quot;, monitor_name=&quot;through&quot;, mode_expansion_name=&quot;me_through&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, mode=0, wavelength=f&quot;{wavelength}&quot;, real=True, imag=True, **export_options, show=False, ) 8.3.4 FDTD:port mode information​ Get the result of FDTD port mode information. extract( self, *, data: Literal[&quot;fdtd:port_mode_info&quot;], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: Literal[&quot;E&quot;, &quot;H&quot;, &quot;Loss&quot;, &quot;Neff&quot;, &quot;TE Polarization Fraction&quot;], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, port_name: str, mode: Any = None, plot_x: OptStr=None, plot_y: OptStr=None, ) Example: &quot;&quot;&quot; 02_top_profile &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=f&quot;{plot_path}{kL[2]}_profile&quot;, monitor_name=&quot;z_normal&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, wavelength=f&quot;{wavelength}&quot;, export_csv=True) &quot;&quot;&quot; 03port1_modeprofile &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:port_mode_info&quot;, savepath=f&quot;{plot_path}{kL[3]}_port_1_profile&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, port_name=&quot;port_1&quot;, mode=0, export_csv=True) 8.3.5 FDTD:mode source information​ Get the result of FDTD mode source information. extract( self, *, data: Literal[&quot;fdtd:mode_source_mode_info&quot;], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: Literal[&quot;E&quot;, &quot;H&quot;, &quot;Loss&quot;, &quot;Neff&quot;, &quot;TE Polarization Fraction&quot;], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, source_name: str, mode: Any = None, plot_x: OptStr=None, plot_y: OptStr=None, ) Example: fdtd_res.extract( data=&quot;fdtd:mode_source_mode_info&quot;, savepath=f&quot;{plot_path}02_source_modeprofile&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, real=True, imag=True, source_name=&quot;source&quot;, show=False, **export_options, ) fdtd_res.extract( data=&quot;fdtd:mode_source_mode_info&quot;, savepath=f&quot;{plot_path}02_source_modeinfo&quot;, target=&quot;line&quot;, attribute=&quot;Neff&quot;, real=True, imag=True, source_name=&quot;source&quot;, plot_x=&quot;wavelength&quot;, show=False, **export_options, ) 8.4 Sweep​ To extract the relevant data of sweep function. 8.4.1 parameter sweep​ Get the result of sweep data. extract( self, *, data: Literal[&quot;sweep&quot;], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: str, monitor_name: Optional[str] = None, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, **kwargs, ) Example: swp_res.extract(data=&quot;sweep&quot;, target=&quot;line&quot;, attribute=&quot;S&quot;, plot_x=&quot;sweep_gap&quot;, savepath=f&quot;{plot_path}/01 S&quot;, export_csv=True) swp_res.extract(data=&quot;mode_expansion&quot;, target=&quot;line&quot;, attribute=&quot;T_forward&quot;, plot_x=&quot;sweep_gap&quot;, monitor_name=&quot;through&quot;, savepath=f&quot;{plot_path}/03 {resultL[2]}&quot;, export_csv=True, ) 8.4.2 smatrix sweep​ Get the result of smatrix sweep data. extract( self, *, data: Literal[&quot;smatrix_sweep&quot;], target: Literal[&quot;intensity&quot;, &quot;line&quot;], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = &quot;a&quot;, plot_x: OptStr=None, ) Example: smatrix_res.extract(data=&quot;smatrix_sweep&quot;, savepath=f&quot;{plot_path}{kL[8]}_smatrix_sweep&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, real=True, imag=True, export_csv=True, export_mat=True, show=False) ","keywords":""},{"title":"Analysis","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/8Analysis","content":"Analysis 1 EME Analysis​ Features Description: The EME analysis window can be opened in the “Analyses” of “Objects Tree”. By right clicking “EME Analysis” to add a new analysis in this project. But before running the analysis, it’s necessary to run the EME solver first. in the drop-down menu “Run” which will calculate the modes at each cell of the EME solver region, changing the simulation to Analysis mode. In Analysis mode, we can use the EME analysis window to propagate the fields and calculate scattering parameters (s-matrix) for the structure. The propagation distances can be changed in analysis mode, and the fields can be propagated without recalculating the modes. In addition, it is possible to compare the s-matrix results for a different number of modes (up to the number used in the simulation), without having to recalculate the modes. 1) Make Passive/None/Energy Conservation: Choose the energy conservation type for the Page S-matrix. The Page S-matrix is calculated at every Page of the neighboring cells accounting for the modes at the left- and right- hand sides of the Page. ① Make passive: Nothing is done when the norm of the Page S-matrix is less than or equal to 1; otherwise the norm is mandatorily altered to be identical to 1. ② Energy Conservation: Set the norm of Page S-matrix to 1. 2) Cell Group Definition: The cell group definition section exhibits the location of the cell groups and every group span using a tabular format. This information will be identical to that in the EME setup tab of the EME solver object which was configured under the layout mode. Right from here, the user can modify the group spans and sub-cell method for any cell group then propagate the fields and calculate the s-matrix using the new settings with the &quot;EME propagate&quot; button (and does not need to again compute the modes in every cell). ① Override Group Spans: Decide whether to override the group spans. ② Reset Group Spans: To recover the group spans the same as the default values in EME simulations. 3) Periodicity: This part enables the user to define cell regions with periodic features and specifies the number of periods in each of them. The &quot;start cell group&quot; and the &quot;end cell group&quot; refer to the sequential numbers from &quot;cell group definition&quot;.The user acquires the new monitor and s-matrix results by clicking the &quot;EME Propagate&quot; button, and hence does not have to recompute any modes. Under this option, the periodic sequence specified in the tabular format in the periodicity section will be displayed in the cell group sequence box. 4) Select Source: The select source section allow you to select the input source port with corresponding mode to inject at the input port. 5) EME Propagate: When you press the “EME propagate” button it calculates the device using all the current settings shown in the EME Analysis Window. 6) Sweep: This box gives you the opportunity to scan the span of a specified group or wavelength that you might obtain additional information on the EME propagation.Two options “Group Span Sweep” and “Wavelength Sweep” (when opening “Use Wavelength Sweep” in the “Edit EME” dialog box) are available. ① Group Span Sweep: This option allows the results for a range of spans to be calculated without having to recalculate the modes at each cell. To set up the sweep, select the cell group whose length will be varied, and set the start and stop lengths of the cell group, and either the length interval between each sweep point or the number of points to sweep over in the range. ② Wavelength Sweep: Upon choosing &quot;Wavelength Sweep&quot; and then specifying a start and stop wavelength as well as a number of points to compute, the S-matrix will be swept as a function of wavelength. Once the calculation is completed, the user may view the results in “Result View”. 7) S-matrix Index Mapping: The entries of the s-matrix enclose key information associated with the transmission and reflection coefficients between ports and the selected modes there. The size of the user s-matrix is thus dependent on both the number of ports and the number of modes selected for every port. Since the big amount of ports and selected modes result naturally in a user s-matrix also of large size, the S-matrix index mapping, as its name suggests, makes a viewable table mapping the user s-matrix indices to the modes and ports of the structure. The left &amp; right indices of the S-parameter refer to the modes of output &amp; input, respectively. 2 FDE Analysis​ Features Description: The FDE analysis window can be opened by pressing the run button and choosing “Run FDE” in the drop-down menu “Run” which will calculate the frequency dependent mode field under a specified kind of boundary condition. The FDE Analysis Window supports modal analysis, frequency analysis and overlap analysis. In this window you can calculate modal analysis via pressing “Calculate modes” button after relative parameters setting. You can also calculate frequency analysis and overlap analysis in a similar way. 2.1 Modal Analysis Tab​ This tab provides two options “Set Calculation parameters” and “Power and Impedance Integration”, where you can calculate the integration of specific mode in selected region. 2.1.1 Set Calculation parameters​ 1) Frequency: The modes will be solved for this specified frequency. (Default 193.414 THz) 2) Wavelength: The modes will be solved for this specified wavelength. (Default 1.55 um) 3) Number of Trial Modes: When calculating modes, determine the calculated number of modes around the refractive index. (Default:20) 4) Search: This defines the target value(s) of effective index around which the modes will be calculated. (Default: max index) ① Near n: To find all the modes close to a certain value of effective index. ② Max index: Being checked by default, this enables you to search the modes having the highest possible effective indices; typically, the fundamental modes will be stored in the search results. If unchecked, the user should manage to define N and find other modes. 5) Calculate group index: Upon checking this, the group index is computed and the result will be returned to the mode list. 6) Bent waveguide: Three parameters, radius, orientation and central location as illustrated in the figure below, suffice for a description of the bent waveguide structure. ① Radius: The radius terminates at the center of the eigenmode simulation region. Given the orientation and radius, math is performed by the solver to determine the bent waveguide center. ② Orientation (θ): This is the angle made by the bend direction and the +horizontal direction. 0 &lt;= theta &lt;= 90 measured by degrees is supported by the solver, and this exhausts all the possibilities we may encounter. ③ Location: In the current version, as a default setting, the end radius is located at the simulation center. It can be alternatively viewed as the center of a waveguide. We have XY, YZ, and ZX coordinate systems, in which the horizontal direction is +x, +y, and +z, respectively. 7) Mesh Structure: User can view structure and material information about mesh. When clicking the button, the result view will be shown, and attribute drop-down list includes: Index x, Index y, Index z. 8) Calculate Modes: After setting the number of trial modes in the modal analysis tab, user clicks the calculate modes button and then the modes will be calculated and the results along with their effective index, group index, wavelength, loss, and TE polarization will be displayed in the mode list. 9) Mode Plot Area：To view the results in the Mode Plot Area. 10) Mode List:The mode list shows all of the modes that were calculated in the modal analysis tab along with your effective index, group index (if applicable), wavelength, loss and TE polarization. 2.1.2 Power and Impedance Integration​ 1) Integration Shape：To calculate the integration of the mode distribution within the selected region. This selected region provides two options: “Rectangular” and “Circular”. 2) Integrate: “Power” and “Electric” intensity filed are supported in this tab. 3) X Min/X Max/Y Min/Y Max: Define the geometry of the rectangular shape. 4) Center X/Center Y /Radius: Define the geometry of the circular shape. 5) Fraction Integrated: To show the integration result of the mode distribution within the selected region. 6) Define Integration Region: Under this option, you can choose the selected region directly in the mode plot area by right long press. 7) Zoom Mode: Under this option, you can zoom in the mode plot. 2.2 Frequency Analysis Tab​ This tab is used to analyse the attributes of modes in the range of start frequency and stop frequency. 1) Track selected mode: Check this option to enable tracking the modes selected from the mode list. 2) Start/ Stop Frequency: The beginning and final frequencies at which the modes will be solved for. The start frequency value is locked to the one for initial computations of modes inside the “Modal Analysis” tab, whenever a particular mode is being tracked. 3) Start/Stop Wavelength: The beginning and final wavelengths at which the modes will be solved for. The start wavelength value is locked to the one for initial computations of modes inside the Modal Analysis tab, whenever a particular mode is being tracked. 4) Number of Points: This counts the sampling frequency/wavelength points to be swept. 5) Number of Trial modes:This number specifies the maximum amount of modes to be swept. To track a single mode, this number is recommended to be about 3 in order to reduce the computation time to its minimum (this number will need to be raised a little bit in case there are discontinuities in the sweep data). When “Track Selected Mode” is not selected, this number determines the maximum amount of modes to be swept at per frequency/wavelength within our attention scope. 6) Effective index: This parameter indicates the effective index value around which the modes will be solved for. It takes effect only when the selected modes are not being tracked. 7) Detailed Dispersion Calculation: Mode properties at extra frequencies are computed for collecting more accurate dispersion data over the domain of frequency/ wavelength within our attention scope. This produces more precise results with extra cost of time. 8) Bent Waveguide: Checking this option enables the user to configure the bent waveguide. ① Radius: The radius of bent waveguide ② Orientation: The orientation of bent waveguide ③ Location: The location of bent waveguide (Default: Simulation Center) These settings are same as bent waveguide inside modal analysis tab. 3 Far Field​ 1) Field Data:Import the near-field data.There are two selections. The “Data Space” means importing the near-field data from this simulation project, which user already import from simulation results. The “New Data” allows user to import a new data. Import File ① Name: To set the name of imported near-field data. ② Path: The path of the near-field data. ③ Attribute &amp; Opration: To set the attribute and opration of the near-field data. ④ Add to DataSpace: Decide whether to import the near-field data to DataSpace. 2) Frequency Settings: ① Auto: Decide whether to calculate the far field in all wavelength span. ② Frequency: When Auto is off, you can choose the specific frequency here. ③ Wavelength: When Auto is off, you can choose the specific wavelength here. 3) Material: ① Material Index: This specifies the refractive index in far field during the course of computation. 4) Far Field Settings: ① Projection Method: Two types of projection method, planar and angular methods are included. --&gt; Angular: In this method, the near-field is projected into an angular coordinate system using a vectorial algorithm which is exactly accurate. The far field data is plotted as a function in Cartesian coordinates for slab waveguides, but in polar coordinates for waveguides with a 2D cross-section. --&gt; Planar: In this method, the near-field is projected into a Cartesian coordinate system using a vectorial algorithm which is exactly accurate. ② Far field Filter: When calculating far-field data, the near-field data at the edge may not be zero, which causes high-frequency waves generated from far-field projection results. Thus, the far-field filter is used to truncate the near-field data effectively, making the near-field data at the edge more smoothly approach to zero, to get rid of the high-frequency wave. filter=a(a+b)filter=\\frac{a}{(a+b)} filter=(a+b)a​ ③ Projection Direction: To set the direction of projection, including “Forward” and “Backward”. ④ Horizontal Points (only for angular): Sets the number of points in the projection. ⑤ Projection Distance (only for planar): Sets the distance to the projection plane.(Default: 8000 μm) ⑥ Points in X/Y (only for planar): Sets the number of points in the projection plane. The larger the number of points, the longer it will take to calculate the far field projection. ⑦ Far-field X/Y span (Only for planar): Sets the span of far-field plane. ⑧ Far-field X/Y center(only for planar): Sets the center of far-field plane. ⑨ Recenter: After setting the center of far-field plane, clicking the recenter button, the far-field projection will be recalculated. 4 Overlap​ Features Description: This yields the overlap result. The overlap calculation evaluates the fractional power coupling from the profile of the Field_Data_2 (E2, H2) into the mode (E1, H1). The overlap does not account for the reflections originated from a mismatch in effective indices between the mode and the Field_Data_2 profile. The overlap is calculated in terms of: overlap =∣Re⁡[(∫E1→×H2∗→⋅dS⃗)(∫E2→×H1∗→⋅dS⃗)∫E1→×H1∗→⋅dS⃗]1Re⁡(∫E2→×H2∗→⋅dS⃗)∣\\text { overlap }=\\left|\\operatorname{Re}\\left[\\frac{\\left(\\int \\overrightarrow{E_{1}} \\times \\overrightarrow{H_{2}^{*}} \\cdot d \\vec{S}\\right)\\left(\\int \\overrightarrow{E_{2}} \\times \\overrightarrow{H_{1}^{*}} \\cdot d \\vec{S}\\right)}{\\int \\overrightarrow{E_{1}} \\times \\overrightarrow{H_{1}^{*}} \\cdot d \\vec{S}}\\right] \\frac{1}{\\operatorname{Re}\\left(\\int \\overrightarrow{E_{2}} \\times \\overrightarrow{H_{2}^{*}} \\cdot d \\vec{S}\\right)}\\right| overlap =​Re​∫E1​​×H1∗​​⋅dS(∫E1​​×H2∗​​⋅dS)(∫E2​​×H1∗​​⋅dS)​​Re(∫E2​​×H2∗​​⋅dS)1​​ 1) Import Data: ① Field Data 1/2: To import the field data .There are four selections,shown as the picture below. The “Data Space(Project)” means importing the near-field data from this simulation project, which user already import from simulation results. The “Data Space(Shared)” supports importing the near-field data from other simulation projects, which data already add to the Data Space shared part. The “New Data” allows user to import a new data from simulation results. Now we support the data from Passive Field and ZBF Field. Refer to the Chapter 10.3 for The detail information. The “Create Beam” enables the user to modify the default Gaussian beam for overlap evaluations. 2) Analysis: ① Calculate Overlap/Power Coupling: Clicking this button launches the computation for the overlap and the power coupling of the currently specified mode with the currently selected Field_Data_2. The Field_Data_2 profile is displaced in the x, y and z directions by the specified amounts of X Shift, Y Shift and Z Shift, respectively. The power coupling, compared to overlap function, considers the reflection of the two modes. ② Shift Field_Data_2 Center: Upon clicking this, the user can displace the Field_Data_2 profile in the XYZ-coordinate by the specified values of X Shift, Y Shift and Z Shift. Recenter: This pull-down button enables the user to recenter the X Shift, Y Shift and Z Shift to (0,0,0), or such that the center of the Field_Data_2 profile comes out to be the same with that of the selected mode at present. It is recommended to perform the latter before optimizing the positions of X Shift, Y Shift and Z Shift. --&gt; X Shift: the actual amount of displacement in the x-direction. --&gt; Y Shift: the actual amount of displacement in the y-direction. --&gt; Z Shift: the actual amount of displacement in the z-direction. ③ Optimize Position: Clicking this button a set of values of X Shift, Y Shift and Z Shift will be evaluated for maximizing the overlap of the currently specified mode with the currently selected Field_Data_2. 3) Create Beam: The Beam tab enables the user to modify the default Gaussian beam for overlap evaluations, as well as to generate Gaussian beams in the deck which can be accessed via scripting. There are two options for defining Gaussian beams: the scalar approximation for the electric field or the fully vectorial beam profile(currently not supported). ① Beam Direction: Options available for the direction of beam are 2D X normal, 2D Y normal and 2D Z normal. ② Wavelength:To set the wavelength of beam. ③ Define Gaussian Beam by: Work under this menu to define the scalar beam in terms of either Waist Size+Position or Beam size+Divergence. --&gt; Waist radius: This is either the radius at which the field magnitude decays to 1/e of the maximum (or power magnitude decays to 1/e^2 of the maximum) for a Gaussian beam, or a half-width half-maximum (HWHM) position for the Cauchy/Lorentzian beam. --&gt; Distance from waist: The Distance from waist is illustrated in the figure below. Positive/Negative values of this distance correspond to diverging/converging beams, respectively. --&gt; Beam radius: This is either the radius at which the field magnitude decays to 1/e of the maximum (or power magnitude decays to 1/e^2 of the maximum) for a Gaussian beam, or a half-width half-maximum (HWHM) position for the Cauchy/Lorentzian beam. --&gt; Divergence angle: This is the angle of radiation spreading into the far field as measured, illustrated in the figure below. Positive/Negative angles correspond to diverging/converging beams, respectively. ④ Refractive index: This is the refractive index of the homogeneous material inside which the Gaussian beam is present. ⑤ Theta: This is the angle made by the normal-vector and the propagating direction. ⑥ Phi: This is the angle made by the horizontal axis and the propagation direction projected into the Eigenmode Solver plane. ⑦ Polarization Angle: The polarization angle is defined with respect to the horizontal-axis if the fields are normal-incident. In the case of an off-axis incidence, the polarization angle comes out to be 0 for a p-polarized light and 90 degrees for a s-polarized light. ⑧ Sample Span: This specifies the span of the beam on each axis. Sample Resolution: This specifies the beam resolution, the number of sampling points on each axis. 5 Mode Expansion​ 1) Import Data: ① Binding Monitor: Select the power monitor which provides the mode field data in the simulation project. ② Direction: Direction of the Mode expansion monitor. Two options “Negative” and “Positive” are available. (Default value: Positive) 2) Mode Calculation: ①　Mode Selection &amp; Mode List: Allow you to select the modes for the mode expansion calculation. The “Fundamental Mode”, “Fundamental TE Mode” , “Fundamental TM Mode” and “User Select” are included. (Default: Fundamental Mode). When Selection is “User Select”, you need to input the number of mode in “Mode List”. ②　Override Global Monitor Settings:To decide whether to override the global monitor settings.If this switch is on, reset the related properties below. --&gt; Sample spacing: The sampling frequency or wavelength is determined somehow based on this combo-choice parameter. --&gt; Use wavelength spacing: As a default setting, data is recorded at certain spatially discretized points depending on the involved wavelengths. --&gt; Use source limits: When checked, the source limits are used by the monitors. Otherwise one uses the pull down menus and their underlying boxes to specify the frequencies/wavelengths at which to collect data. ③　Frequency Points: Sets to choose the number of frequency points at which to record data. (Default: 5) ④　Bent Waveguide: Upon checking this option, the user can define a bent waveguide. --&gt; Radius: Radius of the bent waveguide. (Default value: 1.000e+6 μm). --&gt; Orientation: Orientation of the bent waveguide. --&gt; Location: Location of the bent waveguide. (at Simulation Center by default) ⑤　Rotations: --&gt; Theta：This refers to the angle of propagation measured by degrees, with respect to the incident axis of the source in a 3D simulation. In a 2D simulation, it is the angle of propagation measured by degrees revolved around the global Z-axis in compliance with the right-hand rule, that is, the angle of propagation in the XY plane. --&gt; Phi：This refers to the angle of propagation measured by degrees revolved around the incident axis of the source in compliance with the right-hand rule in a 3D simulation. In a 2D simulation, this value does not take effect. --&gt; Rotation Offset: A rotation offset can be endowed to the plane upon which the mode is computed. This guarantees that mode sources at an angle do not interfere with structures not belonging to the waveguide/fiber.","keywords":""}]