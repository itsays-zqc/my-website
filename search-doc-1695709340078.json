[{"title":"Release Log","type":0,"sectionRef":"#","url":"/my-website/blog/release blog","content":"","keywords":""},{"title":"V2.3.0.4​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2304","content":"Release Date: 2023/06/30 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.91.0.1 build 0626.0819 FDE: Version: 00.09.08.1 Build: 0613.1936 EME: Version: 00.09.22.01 Build: 0618.1400 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.08.1 Build: 0613.1936 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature","content":"Passive None. Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs","content":"Passive Added exception catch for eme_propagate:facet_data. Fixed the support issue of the whl installation package for the fourth paragraph of the version number. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.3.0.3​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2303","content":"Release Date: 2023/06/21 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-1","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.81.2.1 build 0609.0839 FDE: Version: 00.09.08.1 Build: 0613.1936 EME: Version: 00.09.22.01 Build: 0618.1400 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.08.1 Build: 0613.1936 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-1","content":"Passive None. Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-1","content":"Passive Fixed the boundary condition processing logic problem in the mode_selection:user_select method, and the logic after the fix was: Support setting boundary conditions in the mode_selection:user_select method, the default boundary condition is PEC, where the PML boundary condition parameter is the same as ‘FDE’. If the user specifies a boundary condition, use that condition for calculate mode, otherwise use PEC. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-1","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-1","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.3.0.2​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2302","content":"Release Date: 2023/06/21 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-2","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.81.2.1 build 0609.0839 FDE: Version: 00.09.07.1 Build: 0613.0209 EME: Version: 00.09.22.01 Build: 0618.1400 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-2","content":"Passive None. Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-2","content":"Passive When the relevant parameters of demodulation in the mode_selection:user_select method are not set, the default value is wrong. -&gt; fast_EME.py ModeSource/FDTDPort/EMEPort/ModeExpansion does not have parameters such as n/number_of_trial_modes/bent_waveguide. -&gt; fast_FDTD.py/fast_EME.py Some models report errors in the eme_propagate:facet_data method. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-2","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-2","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.3.0.1​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2301","content":"Release Date: 2023/06/19 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-3","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.81.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 EME: Version: 00.09.22.01 Build: 0618.1400 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-3","content":"Passive None. Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-3","content":"Passive The Source/Port setting is not overridden by the parameters related to demodulation in the mode_selection:user_select method. -&gt; fast_EME.py Active Solve the problem that OEDevice does not support long paths through temporary folders. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-3","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-3","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.3.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2300","content":"Release Date: 2023/06/15 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-4","content":"Passive meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDTD_GPU: V0.81.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 EME: Version: 00.09.21.01 Build: 0614.1925 ModeExpansion: 1.16.0.4 Build: 20230606.1841 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0614.1839 FDTD_CPU: V1.17.1.1 build 0517.0828 FDE: Version: 00.09.07.1 Build: 0613.0209 GenRate: v0.2.3 06/06/2023 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-4","content":"Passive Modified the PML model and parameters for FDE. FDE/EMEPort supports Mode Removal function under PML boundary conditions. -&gt; fast_FDE.py/fast_EME.py Add Periodic Structure function in EME. -&gt; EME_Periodic_Structure.py StructureShow supports custom Border. -&gt; maxoptics.toml Add simu[simu_name].show3d(show_with=&quot;local_gui&quot;) method calls LocalGUI. -&gt; fast_FDE.py Add simulation log aggregation of passive file siblings. -&gt; fast_FDE.py Active Use Solver to output absolute coordinates for result extraction. Updated some Linux operating system adaptations. OEDevice Solver is included by default and requires no additional installation. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-4","content":"Passive passive file after SDK FDE simulation, white screen when opened with LocalGUI. The parameter limit of the PML boundary condition in FDE/EME is unreasonable. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-4","content":"Passive ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-4","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.2.3.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2230","content":"Release Date: 2023/05/31 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-5","content":"Passive meshgen: 1.1.0505.1842 FDTD_CPU: V1.17.1.0 build 0517.0826 FDTD_GPU: V0.81.0.0 build 0514.2151 FDE: 00.09.03.1 Build: 0213.1440 EME: 00.09.17.01 Build: 0525.0011 ModeExpansion: 1.16.0.3 Build: 20230525.2010 FarField: Version: 0.4.2 Build: 0510.1103 Overlap: Version: 0.4.1 Build: 0518.1308 Active meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 12/16/2022 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-5","content":"Passive AnalyticalWaveguide type in Structure, supporting tilt_angle and location. GaussianSource supports ModeExpansion. StructureShow supports custom colors. Active Result export file format changes from json to csv. Support Schenk trap-assisted tunneling model for Si. Support Schenk and Hurkx band to band tunneling model for Ge. Optimize extraction of photo induced carrier generation rate. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-5","content":"Passive FDTD extracts the ModeProfile coordinate value offset. SDK simulation results are automatically Remesh when LocalGUI is opened. Active Fix extraction of electric field intensity for electric monitor. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-5","content":"Passive Periodic Group Definition function in EME. ModeSource/FDTDPort/EMEPort support UserImport. Active Setting the surface recombination velocity of Ge/Si. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-5","content":"Passive When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). The DividingLine of the structure in the echo echo has incorrect coordinates in the case of symmetric/antisymmetric boundaries, etc. Active None. "},{"title":"V2.2.2.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2220","content":"Release Date: 2023/04/28 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-6","content":"Passive meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDTD_GPU: V0.80.2.1 build 0422.2215 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: 0.93.0.4 Build: 20230410.1606 Active meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 12/16/2022 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-6","content":"Passive Add PASSIVE_FDTD_GPU authorization limit. Structure export as GDSII file. -&gt; Structure_Export_GDS.py Import the GDSII file and stretch it at Middle. -&gt; Rect_Trapezoidal_Extend.py Structure adds the AnalyticalWaveguide type to support the equation formula. -&gt; Analytical_Waveguide.py The extract function supports export mat and zbf format file. -&gt; fast_FDE.py/fast_FDTD.py Active None. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-6","content":"Passive FDE/FDTD simulation results are offset under the Symmetric/Anti-Symmetric boundary conditions. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-6","content":"Passive Periodic Group Definition function in EME. ModeSource/FDTDPort/EMEPort support UserImport. Active None. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-6","content":"Passive FDTD does not support ModeExpansion in the case of Gaussian source excitation. FDTD has problems with FarField calculations at the Symmetric/Anti-Symmetric boundary. When the installation path is too deep or the project file name is too long, the simulation fails due to the limit of the longest path to Windows (260 characters). Active None. "},{"title":"V2.2.1.2​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2212","content":"Release Date: 2023/04/14 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-7","content":"Passive meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDTD_GPU: V0.80.1.1 build 0414.2224 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: 0.93.0.4 Build: 20230410.1606 Active meshgen: 1.1.0320.1930 FDTD_CPU: V1.15.4.1 build 0414.2214 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 12/16/2022 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-7","content":"Passive Added the ability to specify the passive file path for simulation, preparing for third-party schedulers -&gt; mo.sdk run. After generating passive by importing GDS, it supports automatic display of groupings in LocalGUI. In structure_show, view=True can directly evoke the GUI for modeling and viewing (simulation results do not support real-time synchronization at the moment). Active Support for GDS file import (Beta version). Support for adding electrical local mesh along a line. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-7","content":"Passive None. Active None. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-7","content":"Passive None. Active None. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-7","content":"Passive None. Active None. "},{"title":"V2.2.1.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2210","content":"Release Date: 2023/03/31 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-8","content":"Passive meshgen: 1.1.0320.1930 FDTD: V1.15.2.1 build 0301.2202 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.1.0320.1930 FDTD: V1.15.2.1 build 0301.2202 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 OEDevice: 20230324 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-8","content":"Passive Add FarField calculation for PowerMonitor in FDTD. -&gt; FDTD_Far_Field.py Add Symmetric/Anti-Symmetric boundary condition in FDTD. requirements.txt depends only need to set max_optics_sdk~=2.2.1.0. Active run_doping set geometry for doping preview. add_doping supports selected areas or specified material lists. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-8","content":"Passive None. Active Supplement some of the note information. Results such as LPD are output slowly. run_index does not support LocalMesh. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-8","content":"Passive None. Active None. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-8","content":"Passive None. Active None. "},{"title":"V2.2.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2200","content":"Release Date: 2023/03/15 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-9","content":"Passive meshgen: 1.1.0213.1427 FDTD: V1.15.2.1 build 0301.2202 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.1.0213.1427 FDTD: V1.15.2.1 build 0301.2202 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 OEDevice: 20221220 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-9","content":"Passive Enable new authorization controls. Export the historical result file in Local mode. -&gt; Extract_History_Results.py EME supports Custom Setting of Cell Group. -&gt; EME_CellGroup_Custom_Setting.py run_index adds max_index/max_sigma parameter to filter the display results. -&gt; Run_Index_Filter.py Active Enable new authorization controls. When importing DOP doping files, additional Gaussian doping is supported. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-9","content":"Passive None. Active In some electrical simulation scenarios, the boundary file generation error caused the electrical simulation to fail. When the simulation area exceeds the structure boundary, the probability of error will increase. The code comments of some new functions are not completed, such as add_doping, etc. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-9","content":"Passive None. Active None. "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-9","content":"Passive The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; V2.2.1.0 by 2023/3/31 In the FDTD_Oblique_Input.py, the material boundary condition and starting position is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; V2.2.1.0 by 2023/3/31 ModeExpansion ‘s calculation results are labeled incorrectly. -&gt; V2.2.1.0 by 2023/3/31 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active None. "},{"title":"V2.1.1.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2110","content":"Release Date: 2023/02/28 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-10","content":"Passive meshgen: 1.1.0213.1427 FDTD: V1.15.1.1 build 0220.0954 FDE: Version: 00.09.03.1 Build: 0213.1440 EME: Version: 00.09.12.01 Build: 0228.1810 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.1.0213.1427 FDTD: V1.15.0.1 build 0219.2157 FDE: Version: 00.09.03.1 Build: 0213.1440 GenRate: V0.2.1 OEDevice: 20221220 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-10","content":"Passive Adjust FDTD ModeExpansion as a submodule of PowerMonitor, which can inherit the geometric parameters of PowerMonitor in SDK/LocalGUI/CloudGUI simulation process. -&gt; fast_FDTD.py Support Overlap/Beam calculation. -&gt; FDE_Beam_Overlap.py Active Support for selecting a specific material or region when adding doping. -&gt; MOD00_doping_import_DOP.py Doping import supports pure doping data files, and at this time also supports setting uniform doping in SDK. -&gt; MOD00_doping_import_DOP.py "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-10","content":"Passive When the simulation results of SDK are run and viewed in LocalGUI, an error is reported when viewing the results of ModeSource in FDTD, the results in FDE Parameter Sweep are not imported, and the intensity graph of SMatrix in EME Parameter Sweep cannot view. The default value of stop_wavelength in FDE Frequency Sweep is smaller than start_wavelength -&gt; scan according to the interval between start_wavelength and stop_wavelength, support stop_wavelength to be smaller than start_wavelength, see fast_FDE.py. Active The current results output by the same script are positive and negative. In Modulator, only max_index is supported, and near_n is not supported. Only the mesh_order of the material is effective in electrical simulation, and the mesh_order of the structure is not effective. When setting the frequency scan for small signals, the literal meaning of the num_frequency_points_per_dec field does not match the actual meaning in the SDK. Change the field to log_num_frequency_points to indicate the total number of frequency scan points including the start frequency and stop frequency. SDK electrical Solver version check fails. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-10","content":"Passive SDK script supports the extraction of historical simulation results. -&gt; V2.2.1.0 by 2023/3/31 Active None "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-10","content":"Passive The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; V2.2.0.0 by 2023/3/15 In the FDTD_Oblique_Input.py, the material boundary condition and starting position is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; V2.2.0.0 by 2023/3/15 ModeExpansion ‘s calculation results are labeled incorrectly. -&gt; V2.2.0.0 by 2023/3/15 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active In some electrical simulation scenarios, the boundary file generation error caused the electrical simulation to fail. When the simulation area exceeds the structure boundary, the probability of error will increase. The code comments of some new functions are not completed, such as add_doping, etc. "},{"title":"V2.1.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2100","content":"Release Date: 2023/02/10 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-11","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.2 build 0104.2052 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221220 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-11","content":"Passive Provide FDTD Parameter Sweep/EME Parameter Sweep/FDE Parameter Sweep -&gt; DC_FDTD_ParameterSweep.py/wg_FDE_ParameterSweep.py/DC_EME_ParameterSweep.py The simulation result of SDK can be viewed in LocalGUI(FDTD Parameter Sweep not support) Active Input parameter of GFile changes from folder path to the absolute path of the file. [46] Modulator Analysis supports users to adjust the voltage interpolation step. Add error reporting for some parameters when no setup. [42] OEDevice license support remote desktop. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-11","content":"Passive None Active [45] The wavelength is 1550 by default in some scenarios. Material index of refraction not interpolated by wavelength. OEDevice doesn’t support cross section other than 2d_x_normal. When the electrical section is set at certain positions, the bnd file generation error occurs due to floating-point errors and the electrical simulation is stuck. norm_length doesn’t support floating numbers. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-11","content":"Passive Adjust FDTD ModeExpansion as a submodule of PowerMonitor, which can inherit the geometric parameters of PowerMonitor in SDK/LocalGUI/CloudGUI simulation process. -&gt; V2.1.0.1 by 2023/2/28 Active None "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-11","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. In the FDTD_Oblique_Input.py, the material boundary condition and starting position is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; V2.1.0.1 by 2023/2/28 ModeExpansion ‘s calculation results are labeled incorrectly. -&gt; V2.1.0.1 by 2023/2/28 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active The output current results sometimes have redundant negative signs. -&gt; V2.1.0.1 by 2023/2/28 The Mode Calculate of Modulator just support max_index, not support near_n -&gt; V2.1.0.1 by 2023/2/28 "},{"title":"V2.0.1.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2010","content":"Release Date: 2023/01/12 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-12","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.2 build 0104.2052 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-12","content":"Passive None Active None "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-12","content":"Passive mesh_factor parameter did not add input parameter range check, modified to [1.05,1.6]. -&gt; fast_FDE.py Fixed FDE FarField in the cloud mode, the parameter settings were displayed incorrectly. -&gt; FDE_Far_Field.py Modify fast_fdtd.gds, put ModeSource at the straight waveguide. -&gt; fast_FDTD.py Active Fix the problem that active emulation occupies passive authorization. Active doping file import run result extraction error. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-12","content":"Passive AIO features include FDTD Parameter Sweep/FDE Parameter Sweep/EME Parameter Sweep-&gt; V2.1.0.0 by 2023/2/10 The simulation result of AIO can be viewed in LocalGUI-&gt; V2.1.0.0 by 2023/2/10 The frequency port setting in the FDTD Port inherits from Global Monitor, which does not support parameter setting alone. -&gt; V2.1.0.0 by 2023/2/10 Modify FDTD ModeExpansion as PowerMonitor sub-attribute and participate in AIO/LocalGUI/CloudGUI simulation process. -&gt; by 2023/2/28 Active None "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-12","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. In the FDTD_Oblique_Input.py, the material boundary condition is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; V2.1.0.0 by 2023/2/10 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; by 2023/2/28 The output current results sometimes have redundant negative signs. -&gt; by 2023/2/28 "},{"title":"V2.0.0.1​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2001","content":"Release Date: 2023/01/10 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-13","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.2 build 0104.2052 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-13","content":"Passive FDE Far Field -&gt; FDE_Far_Field.py Adds material boundary condition into FDTD ModeSource/FDTDPort/ModeExpansion and EME Port/Cell mode calculation result. -&gt; fast_FDTD.py/FDTD_Matrix_Sweep.py/fast_EME.py Add export_c parameter to control σ output result of run_index function . -&gt; fast_FDTD.py Modifies the EME Port/EME Cell legends’ description in the structure_show. -&gt; fast_EME.py Active None "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-13","content":"Passive The run_index result is incorrect when setting GDS as the bottom to perform trapezoidal extend. (The trapezoidal section imported by GDS currently only supports the real trapezoidal structure) -&gt; LN_anisotropy_BENT_FDTD_GDS.py The mode calculation result is incorrect, when selecting near_n in the FDE. -&gt; fast_FDE.py After running mode source in the FDTD, finding that the neff/profile shown in the source-preview-mode is different with neff/profile shown in the source mode.-&gt; fast_FDTD.py Active The title name of Doping Concentration[cm^-3] has been changed to Net Doping[cm^-3] in the run_doping plot. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-13","content":"Passive AIO features include FDTD Parameter Sweep/FDE Parameter Sweep/EME Parameter Sweep-&gt; by 2023/2/10 The simulation result of AIO can be viewed in LocalGUI-&gt; by 2023/2/10 The frequency port setting in the FDTD Port inherits from Global Monitor, which does not support parameter setting alone. -&gt; by 2023/2/10 Modify FDTD ModeExpansion as PowerMonitor sub-attribute and participate in AIO/LocalGUI/CloudGUI simulation process. -&gt; by 2023/2/28 Active None "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-13","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. In the FDTD_Oblique_Input.py, the material boundary condition is incorrect in the inclined incidence ModeSource mode calculation result. -&gt; by 2023/2/10 The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 delete waveform in fast_FDTD -&gt; Tianchi V200 run_doping in fast_FDE.py -&gt; Tianchi V200 The structure model supports user custom function model import. -&gt; Tianchi V200 run_index figure qty 3pcs-&gt; 1pcs -&gt; Tianchi V200 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; by 2023/2/28 "},{"title":"V2.0.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v2000","content":"Release Date: 2023/01/05 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-14","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.2 build 0104.2052 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-14","content":"Passive None Active Support plot net doping Support plot doping of selected materials Optimizing plot of doping Adjust the authorization method and cancel the old authorization and local configuration file "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-14","content":"Passive When ModeSource run fde only , the mesh is 3D Mesh but not 2D Mesh -&gt; fast_FDTD.py The subscript of EME SMatrix does not use determinant -&gt; fast_EME.py The source mode profile of FDE Only is different from source mode profile of FDTD run -&gt; fast_FDTD.py after EME.run(), need one command to extract index for p0,p1, c0, c1, … cxx. also to extract profile, modes -&gt; fast_EME.py When the comment out code is recover，the script is not run -&gt; fast_FDE.py When the background_material of OBoundary is not set to mt or public material, the error message is unclear in meaning -&gt; fast_FDE.py In Cloud run_mode, the plot axis position of FDE result in ModeSource/FDTDPort and EMEPort/EMECell is wrong -&gt; fast_FDTD.py/fast_EME.py The σy output data of run_index in Rect_Trapezoidal_Extend.py script is wrong -&gt; Rect_Trapezoidal_Extend.py ModeExpansion’s mode_list parameter and the mode_index parameter of ModeSource/FDTDPort/EMEPort begin with 1 change to begin with0 -&gt; fast_FDTD.py/fast_EME.py The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from simulation mesh setting. -&gt; fast_FDTD.py Active There is too much messages printed out of result options in running log. The scale and title font of the axis is small in the result image. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-14","content":"Active Supports run_doping method. -&gt; V2.0.0.2 by 2023/2/10 Active Modulator Analysis supports optical simulation in designated mode. -&gt; V2.0.0.2 by 2023/2/10 "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-14","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; Tianchi V200 The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually. -&gt; V2.0.0.2 by 2023/2/10 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; V2.0.0.2 by 2023/2/10 "},{"title":"V1.9.1.1​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1911","content":"Release Date: 2022/12/27 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-15","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.1 build 1106.1945 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-15","content":"Passive supports script run in cloud mode -&gt; fast_FDE.py/fast_FDTD.py/fast_EME.py Active supports run_index(The type of Terraceneeds changing into Pyramid) "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-15","content":"Passive The order does not start from 0 in the FDE result. -&gt; fast_FDE.py The background material of EME failed to deliver correctly. -&gt; fast_EME.py Script reports an error in Cloud mode : ERROR: Connection Failed -&gt; fast_FDE.py The project gets from Cloud finding that, material does not display in the GUI object tree. -&gt; fast_FDE.py The project gets from Cloud finding that, the color of material does not show in the GUI. -&gt; fast_FDE.py The background material of FDE displays incorrectly in Cloud mode. -&gt; fast_FDE.py FDEresult check reports an error, in Cloud mode. : ERROR: Cannot load backend TkAgg -&gt; fast_FDE.py The result of run_index export reports an error, in Cloud mode. -&gt; fast_FDTD.py The coordinate displays incorrectly in the result image of PowerMonitor, in Cloudmode. -&gt; fast_FDTD.py Active During electrical stimulation, the name of the MY’s temp file can not be changed, causing electrical files to occur conflicts. The parameters of norm and scale do not work in run_doping function. The result image of small signal capacitance is incorrect. Unit is lost in the generation rate result image. Parts of the results’ values extract incorrectly from PD voltage scanning. The show3dmethod in PD, informs that materialID reports an error. The linear image of carrier can not match with golden aims, the reason is that the highest interpolation of chager_monitor , while lower of its precision. Run run_doping directly, while no doping is imported, the electric simulation will be executed. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-15","content":"Passive Supports run_doping method. -&gt; V1.9.1.3 by 2023/1/10 Active Modulator Analysis supports optical simulation in designated mode. -&gt; V1.9.1.2 by 2023/1/3 Supports DC static capacitance calculation. -&gt; V1.9.1.2 by 2023/1/3 The authorized integration of MY needs to be verified -&gt; V1.9.1.2 by 2023/1/3 "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-15","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The start parameters of mode_listof ModeExpansion andmode_index of ModeSource/FDTDPort/EMEPort are 1 -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; TBD The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from simulation mesh setting.-&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The Release Log and Install Doc are not fully translated into English. The format of the parameter list in handbook is not standardized, and the Chinese translation is incomplete. -&gt; V1.9.1.2 by 2023/1/3 The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually. -&gt; V1.9.1.2 by 2023/1/3 The coordinate is incorrect for the mode calculation of FDTD’s source/port and EME’s port/cell in cloud mode. -&gt; WebAPP(V1.4.0.1) by 2022/12/31 The value of mode index of ModeExpansion in FDTDdoes not start from 0-&gt; V1.9.1.2 by 2023/1/3 In the Rect_Trapezoidal_Extend.py script, the output data of run_index is σy, which is incorrect. -&gt; V1.9.1. by 2023/1/3 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; V1.9.1.3 by 2023/1/10 There is too much messages printed out of result options in running log. -&gt; V1.9.1.2 by 2023/1/3 The scale and title font of the axis is small in the result image. -&gt; V1.9.1.2 by 2023/1/3 add_emesh lacks of notes -&gt; V1.9.1.2 by 2023/1/3 "},{"title":"V1.9.1.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1910","content":"Release Date: 2022/12/19 is "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-16","content":"Passive meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 Active meshgen: 1.0.1206.1835 FDTD: V0.93.0.1 build 1106.1945 FDE: Version: 00.08.11.1 Build: 1103.1658 GenRate: V0.2.1 OEDevice: 20221102 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-16","content":"Passive Modifies the default logic of structure material, and supports simulation even mt without Air material. -&gt; fast_FDE.py The type of Structure supports case sensitivity -&gt; fast_FDE.py Supports trapezoidal extending via GDS importing, the parameters include tilt_angle and tilt_location, tilt_angle, limited from 0 to 180 degrees, which means the upward/downward extending trapezoidal tilt angle. The tilt_location means taking the GDS as bottom/top trapezoidal extending, which option is bottom/top. -&gt; Rect_Trapezoidal_Extend.py Supports wavelength_offset parameter, 0.0001μm by default in FDE/EME to calculate ng . -&gt; fast_FDE.py/fast_EME.py Active Supports simulation in All-In-One SDK template manner. Supports doping checking method. Supports a fixed display of the material color and the show3dfunction has been optimized. Supports transient simulation. Supports custom naming of electrode. Supports high field mobility model of material. Supports customized small signal frequency single-point scanning. Supports adding electrical monitors. Fixed Bug None "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-16","content":"Passive None Active Small-signal frequency multi-point scanning -&gt; V2.0.0.0 by 2022/12/30 Modulator Analysis supports optical simulation in designated mode. -&gt; V2.0.0.0 by 2022/12/31 Supports electrical monitors such asband_monitor/electric_monitor and so on. -&gt; V2.0.0.0 by 2022/12/31 DC static capacitance calculation -&gt; V2.0.0.0 by 2022/12/31 The authorized integration of MY needs to be verified -&gt; V2.0.0.0 by 2022/12/31 "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-16","content":"Passive Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The start parameters of mode_listof ModeExpansion andmode_index of ModeSource/FDTDPort/EMEPort are 1 -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. The inner/ external box of the run_indexsimulation boundary can not be shown. -&gt; TBD The scripts reports error, in the Cloud mode. -&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from simulation mesh setting.-&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The Release Log and Install Doc are not fully translated into English. The format of the parameter list in handbook is not standardized, and the Chinese translation is incomplete. -&gt; V1.9.1.2 by 2023/1/3 The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually. -&gt; V1.9.1.2 by 2023/1/3 Active The structure edge of the carrier concentration intensity exists sawtooth-shaped edges in the result image. -&gt; V2.0.0.0 by 2022/12/31 There is no unit in the generation rate result image. -&gt; V2.0.0.0 by 2022/12/31 The current cannot be read according to the binded electrode, resulting in current positive or negative from time to time -&gt; V2.0.0.0 by 2022/12/31 The resistance calculation results are positive or negative from time to time. -&gt; V2.0.0.0 by 2022/12/31 The effective refractive index precision of Modulator does not meet requirements. -&gt; V1.9.1.1 by 2022/12/26 "},{"title":"V1.9.0.4​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1904","content":"Release Date: 2022/12/13 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-17","content":"meshgen: 1.0.1206.1835 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.09.00.1 Build: 1207.1935 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-17","content":"Modifies the data format of DataFrame calling from FDE: order/TEratio/neff_real/neff_imag/ng_real/ng_imag/wavelength_nm/loss_dBpcm -&gt; fast_FDE.py Removes monitor_type parameter in run_index and takes span==0 as auto judgement logic -&gt; fast_FDE.py Modifies geometry assignment method:center/span, center/min, min/max, center/max, span/min and span/maxsix combinations in total.(When there are multiple possible combinations of parameters, the priority is: min/max, min/sfindan , max/span, min/center, max/center, center/span) -&gt; fast_FDE.py Modifies the Structure ‘s ’background_material setting logic, which public materials and materials except mt are forbidden to be input. -&gt; fast_FDE.py Modifies the OBoundary logic, changes the name of general into general_pml, and moves pml_same_settings into general_pml. -&gt; fast_FDE.py The show3dfunction of simu has been optimized, which supports 3D displayed on the webside. (You need to close the webpage and press Enter on the command line to continue the simulation) -&gt; fast_FDE.py Modifies material color ofstructure_show, which supports auto RGB function calculation based on index. -&gt; fast_FDTD.py Removes the Frequency Sweep in the fast_FDE.pyscript. -&gt; fast_FDE.py Adds maxoptics_OEDevice_local_sdk into whl installation package for matching with Active SDK.(Active simulation is not available temporarily)-&gt; wheels/requirements.txt "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-16","content":"Fixed, coordinate offset of mode calculation result caused by incorrect transmit parameters, when setting PML of FDE. -&gt; fast_FDE.py Fixed the PML Region does not show in the Structure_show. -&gt; fast_FDTD.py Fixed, simulation result incorrectly caused by wrong transmit parameters from anisotropy materials -&gt; LN(anisotropy)_EOM.py/LN(anisotropy)_EME_MMI.py/LN(anisotropy)_BENT_FDTD.py Removed useless print messages for modifying in the LN(anisotropy)_EOM.py script. -&gt; LN(anisotropy)_EOM.py Fixed, FDTD would repeat simulation for each Port in the FDTD Matrix Sweep. -&gt; FDTD_Matrix_Sweep.py Fixed, FDTDPort does not show in the Structure_show. -&gt; FDTD_Matrix_Sweep.py Fixed, DataFrame calling from FDE reports an error, caused by incorrectly complex numbers of ng processing. -&gt; FDE_dispersion.py Fixed, when sets y to 0 in the Structure of GratingCoupler , runs run_index , it will report an error. -&gt; GratingCoupler.py The output project files of structure_show are placed into simulations file, and the output files of run_index are placed into main simulation file. -&gt; FDTD_HalfRing.py "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-17","content":"Supports trapezoidal extending via GDS importing. -&gt; V1.9.1.0 by 2022/12/16 "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-17","content":"Thestart_frequency of FDE Frequency Sweep does not work -&gt; The FDE Frequency Sweep function is hidden temporarily, to be fixed. The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength . -&gt; The logic keeps with Cloud, to be fixed. The start parameters of mode_listof ModeExpansion andmode_index of ModeSource/FDTDPort/EMEPort are 1 -&gt; The logic keeps with Cloud, to be fixed. The parameters of Boundary and PMLlack of default values in the Oboundary -&gt; The different parameter settings of FDE’s PML can not be merged with FDTD’s. The inner/external box of the run_indexsimulation boundary can not be shown. -&gt; TBD Script running reports error in Cloud mode. -&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from simulation mesh setting.-&gt; WebAPP(V1.4.0.0)+AIO(V2.0.0.0) by 2022/12/31 The Release Log and Install Doc are not fully translated into English. The format of the parameter list in handbook is not standardized, and the Chinese translation is incomplete-&gt; V1.9.1.1 by 2022/12/23 The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually -&gt; V1.9.1.1 by 2022/12/23 The Type of Structure.add_geometry does not type in lowercase. -&gt; V1.9.1.0 by 2022/12/16 FDE does not support ng calculation for incorrect ng parameter transmit. -&gt; V1.9.1.0 by 2022/12/16 The script reports an error when using the background_material default value of Structure and there is no Air material in the mt. -&gt; V1.9.1.0 by 2022/12/16 "},{"title":"V1.9.0.3​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1903","content":"Release Date: 2022/12/06 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-18","content":"meshgen: 1.0.1110.1500 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.08.13.1 Build: 1128.1845 EME: Version: 00.09.08.01 Build: 1130.1718 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-18","content":"Moves run_index method from Structure to Simulation. Removes local sdk and whale version information output, only ALL-In-One version information is left. Adds the default values of plot_x and plot_y in the intensity result image. Moves the position of the legend to the upper right in the Line image. Adds a new file named precision with FDTD_HalfRing/EME_SSC/EME_PSR/dc_dummy_1310 scripts. Adds EME_PSR_MMI script in the fast_demo to verify the correctness of EME. Adds FDTD_Matrix_Sweep script in the fast_demo as an example of the FDTD Matrix Sweep function. Adds show3d function in the Simulation. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-17","content":"Fixed,propagation_sweep and wavelength_sweep parameters of EME are processed incorrectly. Modified the inappropriate name of material_name in the script. Fixed, the detailed_dispersion_calculation does not work for FDE Frequency Sweep in Cloud mode. The simulation boundary is lost in thestructure_show. The parameter transmit is incorrect in theglobal_mesh_uniform_grid of FDE. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-18","content":"Supports 3DStructure_show . (The 3d Structure_show function has been developed, and plan to release on December 13th of V1.9.0.4) Supports trapezoidal extending via GDS importing (The function is in progress, and plan to release on December 20th of V 1.9.0.4 ) FDTD/FDE/EME Parameter Sweep (TBD) "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-18","content":"Thestart_frequency of FDE Frequency Sweep does not work The default value of stop_wavelength in FDE Frequency Sweep is less than start_wavelength The Type of Structure.add_geometry does not type in lowercase There are no default values of PML and Boundary in the Oboundary. Currently, only supports three types for add_geometry with center/span, center/min and min/max. The output project files routes of run_index and structure_show are incorrect in the Local mode. The name of FDE output file has been modified but Cloud Server does not synchronize with. run_index reports an error in Cloud mode, which will be planned to fix after CloudServer updating. -&gt; by 2022/12/31 Therun_index does not support the inner/external simulation boundary box displayed. The column name in the DataFrame returned by the extract method is inappropriate. The number of run_indexmesh setting is fixed( 1000*1000), does not inherit from the simulation mesh setting. The frequency point setting of FDTD Port inherits from Gloabal Monitor, can not be set individually. FDTD simulation will run double times for each port of FDTD Matrix Sweep. The useless print messages of LN_EOM in FDE script should be removed. The Release Log and Install Doc are not fully translated into English. The format of the parameter list in handbook is not standardized, and the Chinese translation is incomplete. The usage logic of project_name and simu_name is in chaos in the Cloud mode. The dispersion material does not work, which is caused by theng parameter transmitting incorrectly. "},{"title":"V1.9.0.2​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1902","content":"Release Date: 2022/11/28 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-19","content":"meshgen: 1.0.1110.1500 FDTD: V0.94.0.1 build 1124.0823 FDE: Version: 00.08.13.1 Build: 1128.1845 EME: Version: 00.09.07.01 Build: 1128.1830 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-19","content":"The transmit parameters of pj.Structure with mesh_type/mesh_factor/background_material have been modified as elective options. The maximum_mesh_step_settings name has been changed to global_mesh_uniform_grid. Adds FDE/EME/FDTD related results, which return parameters are DataFrame. The show parameters will be canceled, when setting target=&quot;table&quot; for calculate_modes method, in the fast_FDE. Modified transmit parameters of target default value as intensity with eme_propagate:port_mode_info/eme_propagate:port_overlap/eme_propagate:port_mesh_structure /eme_propagate:cell_mode_info/eme_propagate:cell_p_matrix/eme_propagate:cell_overlap/eme_propagate:cell_s/eme_propagate:internal_s method. Modified the mode transmit parameter default value as 0 with eme_propagate:cell_mode_info method. Modified frequency_analysis method in the FDE . And its attribute includes &quot;neff&quot;/&quot;loss&quot;/&quot;group_index&quot;/&quot;polarization&quot;. Modified the propagation_sweep in the EME and changed the calculation logic of propagation_sweep as an inner calculation in Slover. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-18","content":"An error will occur, when Jupyter imports maxoptics_sdk.all. IF x_min is not set in the Simulation, an error will occur, even the simu region of OBoundary has been set in the EME. The script reports an error, because uses the default list directly without adding necessary values in the EME_PSR.py program. Fixed, set the offset of the port default value to 0 in the EME. Fixed, set the detailed_dispersion_calculation default value to False in the FDE. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-19","content":"3D structure_show. Supports trapezoidal extending via GDS importing FDTD/FDE/EME Parameter Sweep "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-19","content":"The start_frequency function in the FDE Frequency Sweep does not work yet. The detailed_dispersion_calculation in the FDE Frequency Sweep does not work in the Cloud mode. The default value of stop_frequency is less than start_wavelength in the FDE Frequency Sweep. The Type of Structure.add_geometry does not type in lowercase There are no default values of PML and Boundary in the Oboundary. Currently, only supports three types for add_geometry with center/span, center/min and min/max. The usage logic of name in the Simulation and name in the Project are confused, both in the Local and Cloud modes. The name of the FDE output file has been modified but Cloud Server does not synchronize with it . "},{"title":"V1.9.0.1​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1901","content":"Release Date: 2022/11/22 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-20","content":"meshgen: 1.0.1110.1500 FDTD: Version: 0.93.0.1 Build 1106.1945 FDE: Version: 00.08.11.1 Build: 1103.1658 EME: Version: 00.09.05.01 Build: 1009.2025 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-20","content":"Supports hover function with input parameters, whether the property parameter is checked, and the property default value . The parameter default values have been updated. Modified the setting of PML, which only permitted setting in the OBoundary. Modified the Mesh related settings, which only permitted setting in the Structure. The running method of location parameter setting is moved into the project. Notes: Compared with AIO V1.9.0.0 features, the V1.9.0.1 has added five new features. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-19","content":"Fixed, Jupyrer notebook failed to import maxoptics_sdk.all . Fixed, the maximum_mesh_step_settings in the FDE does not transmit correctly. Fixed, the pml_alpha setting in the OBoundary in the FDTD does not transmit to FDTD the Solver.json interface. Fixed, the GlobalMonitor value is not adopted, when sets the override_global_options of PowerMonitor to False, in the FDTD. The mesh_type reports an error, when sets mesh_type of FDTD to staircase and calculates modes alone. IF x_min is not set in the Simulation, an error will occur, even the simu region of OBoundary has been set in the EME. Fixed, EME_PSR.py reports an error running in the Cloud mode. Add a timestamp in the script to create a project to prevent the project and results from being overwritten. The mesh.json y and z values are incorrect in the FDE, after setting the OBoundary. Fixed, the n of search in the FDE does not transmit correctly into solver.json. Fixed, the mesh_type reports an error, when sets mesh_type of FDTD to staircase. The default values in the fast_demo have been commented out or removed. The anisotropy material parameter transmit is incorrect. 3D model structure parameter transmit is incorrect. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-20","content":"FDTD S-Matrix FDE/EME/FDTD parameter sweep Take the method, which AIO reading from output files of results in the json format，to encapsulate. Data reading from json files, and public encapsulation method with searching. SDK material database does not synchronize with Cloud ‘s material database with Standard, User and Project . "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-20","content":"The structure_show does not work, when there has a pyramid or ArcWaveguide3D structure in the modeling script. The anisotropy results of EME and FDTD are incorrect casing by the worng parameter transmit of LN materials. The FDTD S-Matrix feature has not been verified yet. The structure boundary displayed in the calculation mode result image is incorrect. There has a slight difference of V1.9.0.1 fast_FDTD results both in the local and cloud mode with V1.3.9’s results got in local mode The title should be EME in the EME’s monitor result image. Logic adjustment of back-end parameters to front-end page. The types of boundary conditions that can be used in FDE/EME and FDTD are different. For example, FDE/EME supports symmetric and antisymmetric boundary conditions, while FDTD does not. At present, no comprehensive verification has been done The boundary conditions can be set in different ways between FDE/EME and FDTD. For example, there is only one PML parameter for FDE/EME, while FDTD supports setting x/y/z’s PML parameters separately. Due to the support of Python 3.8 for TypingCheck is not good, the implemented spelling check cannot continue to be supported, and will be closed in the next version. Currently， the user cannot know the parameter assignment error in the IDE, and can only view the output in the command line window to check the error. The display of similar materials of the index is not obvious, due to the RGB color of structure_show in the user’s setting material being set according to the index’s real and imaginary auto RGB assignment method. Currently, the run_ index method is based on the 2D mesh created by FDE. When the script is run in cloud mode and viewed in cloud server, finding that there has no results for the index monitor in the result tree. (FDE does not support IndexMonitor in the cloud server) The method of inputting wavelength_min and wavelength_max into waveform and monitor and inputting frequency method has not been verified. The waist_radius/distance_from_waist settings in the gaussian source do not synchronize with beam_radius/divergence_angle settings. When sets x_min&gt;x_span in the geometry, it will report “x_span&lt;0”. When sets run_mode to None in the project, the program does not have any error prompt. When adds several waveforms in the FDTD, and selects one of mode source to calculate mode,the program will report an error. Set the frequency_profile of ModeExpansion in the FDTD finding that the result value is got from the Global monitor. EME_PSR.py reports an error:”in get_source_start_stop spatial = solver_json[ports][self.monitor_index][spatial] IndexError: list index out of range” The simulation will fail if there exists space in the project_name. When getting calculation modes results of cells in the EME, the program will report an error. FDTD runs in cloud mode, reporting an error. When set mesh type is uniform in the FDTD, it will report the inputting parameter error. The Release Log and Install Doc have not been translated into English completely. "},{"title":"V1.9.0.0​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#v1900","content":"Release Date: 2022/11/15 "},{"title":"Dependent Software​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#dependent-software-21","content":"meshgen: 1.0.1110.1500 FDTD: Version: 0.93.0.1 Build 1106.1945 FDE: Version: 00.08.11.1 Build: 1103.1658 EME: Version: 00.09.05.01 Build: 1009.2025 ModeExpansion: V0.82.0.0.2 "},{"title":"New Feature​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#new-feature-21","content":"Supports FDE Frequency Sweep; Supports EME Wavelength Sweep; Supports FDTD Gaussian Source; Supports FDTD Oblique Input ; Supports full type structure modeling . Notes: Compared with MOL V1.3.9 features, the V1.9.0.0 has added five new features. "},{"title":"Fixed Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#fixed-bugs-20","content":"fast_FDE.py Fixed, there are a lot of useless {} that have been output, in the cloud mode. Fixed, there are a lot of 1000010000100001 have been output, both in the local and cloud modes. Fixed, the json_body has been output in create_material method, in the cloud mode. fast_FDTD.py The origin coordinates of monitor are incorrect. The ModeExpansion result reports an error. There is no background material in the mesh.mat Adds an ME into Monitor in the mesh.json. 11 frequency points have been set in total in the GolbalMonitor, but only 5 of them exist in the Cloud. The Region of PML in the structure_show is incorrect. The mode_info of the source’s vertical axis is incorrect in the cloud mode. The vertical axis coordinates of the E field image of power monitor are incorrect, in the cloud mode. When in the local mode, it will report an error：TypeError:”passive_fdtd_mode_source_mode_info_chart() takes 5 positional arguments but 6 were given” The horizontal and vertical axes of CSV derived from ModeSource’s independent mode calculation are not absolute coordinate values, in the local mode. fast_EME.py The Cell’s boundary does not show in the structure_show. The port position is incorrect in the structure_show.(The x position of port for solver.json in the EME is incorrect.) The MeshStructure is incorrect in the independent mode calculation results. The independent mode calculation results are incorrect, and both in the local and cloud modes, the left port and right port simulation results are the same. For mode_info of port, the results of leftport and rightport are the same in the cloud mode, while the results are correct in the local mode. The Intensity images of cell_overlap/cell_s/cell_p_matrix and internal_s got by interpolation method are incorrect. The Simu[project_name].run() reports an error:AssertionError: cannot found matched dependency task! in the cloud mode The FDE_passive_parser.py reports an error in the local mode: IndexError: list index out of range. When setting the parameter of the use_full_simulation_span to Ture in the cloud mode, but it shows False on the page. The meshgen reports an error in the local mode. The mode_info of port reports an error:if mode_selection is None and args[-1] in [“TE”, “TM”], im the local mode. The meshgen warns:Edge Filling Algorithm Error, in the local mode. FDTD_HalfRing.py The run_index reports an error: ‘SimulationTaskBase’ object has no attribute ‘run_index’. ME result reports an error:The value of attribute must be in [‘T_backward’, ‘P’, ‘N’, ‘T_forward’, ‘b’, ‘a’], but t_forward is given. When setting y to -3 of run_index, its nx result is incorrect, in the local mode. ERROR:component[“background_material”] = mat_wav_recreation_list[“m”] ,in the cloud mode. The field result image of PowerMonitor at different wavelengths does not change. The meshgen prompt: WARNING: nan or inf eps at(77,15,0) PowerMonitor coordinates are incorrect, in the cloud mode. StraightWaveguide_X_FDTD_Lossy.py There is no background material of Air displayed in the structure_show. The meshgen prompt: WARNING: nan or inf eps at(77,15,0) Exp_Taper_dummy_1550_l_50.py ERROR: ‘transverse_mesh_setting.maximum_mesh_step_settings.dy is not filled’ Input is “layers” You may want to input one of (‘attrs’, ‘base’, ‘name’, ‘order’, ‘pml_layers’) The correct format name of run_index should be Exp_Taper_dummy_1550_l_50_localx_0. The size of submesh is different in local mode. There have two of mesh refinements in the mesh.json, and its data is incorrect. The start mesh_structure of cell coordinates are incorrect in the local mode. The start mode_info of port coordinates are incorrect in the cloud mode. The start mesh_structure of port coordinates are incorrect in the cloud mode. The mesh_structure of cell and mode_info results are incorrect. The mesh of run_index at x=0 results is incorrect. The horizontal axis coordinate of the EME monitor is incorrect, in the cloud mode. The S parameter is incorrect, caused by the parameter transmit wrongly. LN_EOM.py Anisotropic material reports an error: TypeError: Expected 7 arguments, got 18 When adds a LinearTrapezoid, it reports an error: TypeError: init() got an unexpected keyword argument ‘x_span’ Warning: Exception on ln_up.attrs…: &lt;maxoptics.var.models.meta.LinearTrapezoid.LinearTrapezoidAttrs object at 0x000002638BFCB7C0&gt;: expre_rotate_z=’’ is ignored. TypeError: Dimensions of C (583, 481) are incompatible with X (481) and/or Y (584); see help(pcolormesh) -The calculation mode result of border in the mesh_structure is incorrect. Ineffective warning: expre_rotate_z=’’ is ignored,etc. Ineffective output: Point coordinates LN_MMI_EME.py When adds a Pyramid, it will report an error:TypeError: init() got an unexpected keyword argument ‘x_span’ ERROR: No such file or directory: ‘e:\\develop\\js\\lonely\\maxopt_ofl\\flow\\template\\Pyramid.yaml’ When sets port to TE and TM, the result of eme_propagate:port_mode_info reports an error: passive_eme_port_mode_info_option request failed Incorrect response: {‘success’: False, ‘result’: {‘code’: 50002, ‘msg’: ‘Invalid Parameter: chec k Port 0 is TE and TM’}} Data: {‘target’: ‘intensity’, ‘pub’: {‘taskId’: 560576, ‘monitorIndex’: 0}} The title of monitor should be EME. LN_BENT_FDTD.py When adds a Pyramid, it will report an error:TypeError: init() got an unexpected keyword argument ‘x_span’ ArcWaveguide3D error: z_min = geo[“z”] - geo[“z_span”] / 2 KeyError: ‘z_span’ True is not set in the override_x_mesh/override_y_mesh/override_z_mesh,after adding submesh in the cloud mode. Grating_Coupler.py When adds a LinearTrapezoid, it will report an error: TypeError: init() got an unexpected keyword argument ‘x_span’ When adds a gaussian source, it will report an error: passive_project.create_gaussian_source waveform is necessary for initializing gaussian source Gaussian source error: ind = waveforms_id.index(waveform) ValueError: 0 is not in list Structure_show triggers an error:WARNING: nan or inf eps at (995,72,0) FDTD_Oblique_Input.py The tilt direction of the straight waveguide is opposite in the structure_show. Cloud ERROR: passive_fdtd_mode_source_mode_info_chart request failed Incorrect response: {‘success’: False, ‘result’: {‘code’: 502, ‘msg’: ‘Server Failed’}} Data: {‘target’: ‘intensity’, ‘pub’: {‘taskId’: 558051, ‘monitorIndex’: 0, ‘attribute’: ‘E’, ‘operation’: ‘ABS’}, ‘option’: {‘x’: 0, ‘y’: ‘plotX’, ‘z ‘: ‘plotY’, ‘mode’: 0}} AttributeError: ‘dict’ object has no attribute ‘dict’ EME_PSR.py The coordinates of the source mode calculation are incorrect. The coordinates of the source mode calculation in the mesh_structure are incorrect. The S parameters are incorrect caused by parameter transmit worngly. EME_SSC.py The source mode calculation result is incorrect. The coordinates of the source mode calculation in the mesh_structure are incorrect. The S parameters are incorrect caused by parameter transmit worngly. The two ports in the fde_onely are opposite. "},{"title":"Unrealized/Planning Functions​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#unrealizedplanning-functions-21","content":"FDTD S-Matrix FDE/EME/FDTD parameters sweep Data reading from json files, and public encapsulation method with searching SDK material database does not synchronize with Cloud ‘s material database with Standard, User and Project "},{"title":"Remained Bugs​","type":1,"pageTitle":"Release Log","url":"/my-website/blog/release blog#remained-bugs-21","content":"The Structure_show method does not work, when there have paramid or Arcwaveguide 3D structures in the modeling script. The results of EME and FDTD’s anisotropy are incorrect, caused by LN material parameter wrongly transmit. The FDTD S-Matrix feature has not been verified. There have gaps for structure boundary in the mode calculation result. There has a slight difference of V1.9.0.0 fast_FDTD results in the local and cloud mode with localSDK V1.3.9’s results got in local mode. The title of EME monitor in the result image should be EME. Logic adjustment of back-end parameters to front-end page: The processing logic needs to be clarified, when the mesh type/grading factor/background_ Material exists in both Structure and Simulation. The processing logic needs to be clarified, when the boundary conditions are set in both OBoundary and Simulation, The types of boundary conditions that can be used in FDE/EME and FDTD are different. For example, FDE/EME supports symmetric and antisymmetric boundary conditions, while FDTD does not. At present, no comprehensive verification has been done The boundary conditions can be set in different ways between FDE/EME and FDTD. For example, there is only one PML parameter for FDE/EME, while FDTD supports setting x/y/z’s PML parameters separately. The logic needs to be clarified,in which the must inputting options have no default values. Because of the old version used in the development process, after the new version parameter list is completed, the configuration check of the default value of the must-inputting options is only partially checked, not completely checked. The inkage between parameterslogic has not been completely checked and verified. Due to the support of Python 3.8 for TypingCheck is not good, the implemented spelling check cannot continue to be supported, and will be closed in the next version. Currently， the user cannot know the parameter assignment error in the IDE, and can only view the output in the command line window to check the error. The display of similar materials of the index is not obvious, due to the RGB color of structure_show in the user’s setting material being set according to the index’s real and imaginary auto RGB assignment method. For the result import feature,the feature of auto judgment and creation of the path address of the import file has been developed but wait to be verified. Currently, the run_ index method is based on the 2D mesh created by FDE. When the script is run in cloud mode and viewed in cloud server, finding that there has no results for the index monitor in the result tree. (FDE does not support IndexMonitor in the cloud server) The run index and calculate mode methods will create projects separately according to names passed in, which is not convenient to view in the CloudServer. The lack of timestamp of project_name in the script will override previous local simulation results. There is no limitation for geometry, only (x,x_span) or (x,x_span) can be input, and its linkage logic has not been verified. The method of inputting wavelength_min and wavelength_max into waveform and monitor and inputting frequency method has not been verified. The waist_radius/distance_from_waist settings in the gaussian source do not synchronize with beam_radius/divergence_angle settings. "},{"title":"Modulator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/Active_Device/MOD/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#introduction","content":"​We have developed an electro-optic modulator based on carrier-depletion mechanism in silicon to simulate carrier and index distribution in a global structure. The drift and diffusion of carriers result in depletion at the PN junction. Applying a reverse bias voltage at the cathode broadens the depletion region, altering the carrier concentration and modulating the material's refractive index. Gaussian doping was employed in this model. Modulation efficiency, capacitance, and resistance were calculated to analyze the electro-optic characteristics of the modulator. ​The figure below illustrates the device structure we constructed, wherein the aluminum electrode is applied to the silicon modulator, and the entire device is encapsulated with silicon dioxide material.  "},{"title":"Simulation Structure​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#simulation-structure","content":"​The present structural file provides a comprehensive guide for constructing a simulation structure and establishing a Gaussian doping distribution. Initially, one must construct the geometric structure of the device, incorporate materials and physical models, specify the doping distribution, and simulation boundary conditions, and set the light source and simulation solver. Eventually, the simulation result data should be extracted and output. ​Our simulation is designed with a light source entering along the X-axis, and the primary optoelectronic characteristic analysis takes place within the three-dimensional structure on the YZ plane. The FDE solver is utilized to preview the distribution of effective refractive index, and the OEDevice solver is used to preview the doping distribution of the device. Finally, we generate ad output the distribution map of doping and index in modulator structure. Application Library path: :\\SDK\\V2.3.0.4\\examples\\active_demo\\doping_function\\MOD\\MOD00_structure.py "},{"title":"1. Basic Operations​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#1-basic-operations","content":"It is essential to incorporate materials for structure. Although module of maxoptics_sdk.all provides default values for standard semiconductors, these values can be customized in MOD_material.py . Application Library path: :\\SDK\\V2.3.0.4\\examples\\active_demo\\doping_function\\MOD\\MOD_material.py The module of basic specifies the electron affinity and relative dielectric permittivity of the material. It is crucial to define the model type and parameter values, if another model is used instead of the default. The default mobility model of Silicon is Analytic , but we use the mobility model of Masetti in this modulator. The band module includes the model of bandgap, bandgap narrowing , and recombination of Auger, SRH, and Radiative. elec_Si_properties = {&quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.2-1.11452/2.0, &quot;permitti&quot;: 11.7}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Masetti&quot;, &quot;Masetti&quot;: {&quot;mu_min2_h&quot;: 44.9, &quot;mumax_e&quot;: 1471, &quot;mumax_h&quot;: 470.5, &quot;pc_h&quot;: 0}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;dos_formula&quot;: 2, &quot;nc300&quot;: 3.21657e19, &quot;nv300&quot;: 1.82868e19, # Bandgap &quot;eg0&quot;: 1.16, &quot;chi0&quot;: 4.2-1.16/2, # Bandgap Narrowing &quot;bgn_model&quot;: &quot;OldSlotboom&quot;, &quot;e0_bgn_oldslotboom&quot;: 0.0045, &quot;n0_bgn_oldslotboom&quot;: 1.00e17, &quot;deg0_oldslotboom&quot;: 0, # Auger Recombination &quot;augan&quot;: 2.8e-31, &quot;augap&quot;: 9.9e-32, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 3.3e-6, &quot;taupmax&quot;: 4e-6, &quot;nsrh_n&quot;: 7.1e15, &quot;nsrh_p&quot;: 7.1e15, &quot;nc_f&quot;: 1.5, &quot;nv_f&quot;: 1.5, # Radiative Recombination &quot;c_direct&quot;: 1.6e-14,}, &quot;print&quot;: 1}}  The parameter values of matparas_1550 and matparas_1310 are used for converting carrier distribution to a change in refractive index. matparas_1550 = { &quot;dn_an&quot;: -8.8e-22, &quot;dn_en&quot;: 1, &quot;dn_ap&quot;: -8.5e-18, &quot;dn_ep&quot;: 0.8, &quot;dalpha_an&quot;: 8.5e-18, &quot;dalpha_en&quot;: 1, &quot;dalpha_ap&quot;: 6.0e-18, &quot;dalpha_ep&quot;: 1 } matparas_1310 = { &quot;dn_an&quot;: -6.2e-22, &quot;dn_en&quot;: 1, &quot;dn_ap&quot;: -6e-18, &quot;dn_ep&quot;: 0.8, &quot;dalpha_an&quot;: 6e-18, &quot;dalpha_en&quot;: 1, &quot;dalpha_ap&quot;: 4e-18, &quot;dalpha_ep&quot;: 1 }  "},{"title":"2. Code description​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#2-code-description","content":"2.1 Import Modules​ To begin, we need to use the import command to call the relevant functional modules and parameter values of material from previously defined file. import maxoptics_sdk.all as mo import os import time from maxoptics_sdk.helper import timed from pathlib import Path from MOD_material import matparas_1550, matparas_1310, elec_Si_properties  2.2 Define Parameters​ 2.2.1 General Parameters​ We define these parameters for entire simulation process. wavelength = 1.31 egrid_local = 0.01 ogrid_global_y = 0.02 ogrid_global_z = 0.02 ogrid_local = 0.002 temperature = 300 normal_length = 10000 ssac_amplitude = 0.001 # V run_mode = &quot;local&quot; simu_name = &quot;MOD00_struc&quot;  Parameter\tUnits\tDescriptionwavelength\tum\tSpecifies the optical wavelength of the source beam (in the vacuum) for mono-spectral simulations. egrid_loacal\tum\tSpecifies the appropriate size of mesh in the Y and Z direction for overall region of OEDevice simulation. ogrid_global_y\tum\tSpecifies the mesh spacing in the Y direction for region of optical simulation. ogrid_global_z\tum\tSpecifies the mesh spacing in the Z direction for region of optical simulation. ogrid_local\tum\tSpecifies the mesh spacing in the Y and Z direction for local region of optical simulation. temperature\tK\tSpecifies the temperature in Kelvin. normal_length\tum\tSpecifies the extent of a mesh section in the X direction. ssac_amplitude\tV run_mode Specifies the simulate model. simu_name Specifies this file name to define name of output result folder. Since we explore two communication wavelength, you should define the wavelength, and use next code to choose relavent parameters values, which we defines in MOD_material.py . if wavelength &gt; 1.4: Si_index_vs_doping = matparas_1550 else: Si_index_vs_doping = matparas_1310  2.2.2 Structure Geometry​ You should define the location of material in X, Y and Z direction about the modulator structure. st_x_min = -0.3 st_x_max = 0.3 st_x_mean = 0.5*(st_x_min+st_x_max) st_x_span = st_x_max-st_x_min st_y_min = -5 st_y_max = 5 st_y_mean = 0.5*(st_y_min+st_y_max) st_y_span = st_y_max-st_y_min st_z_min = -0.3 st_z_max = 0.8 slab_height = 0.09 rg_height = 0.22 rg_width = 0.5 elec_height = 0.5 elec_width = 1.2  Parameter\tUnits\tDescriptionx_min, x_max, y_min, y_max, z_min, z_max\tum\tSpecifies the minimum or maximum value in X/Y boundary of modulator structure. x_mean, x_span, y_mean, y_span, z_mean, z_span\tum\tSpecifies the center or spacing value in X/Y boundary of modulator structure. slab_height\tum\tSpecifies the height of slab layer in Z direction. rg_height\tum\tSpecifies the height of RG layer in Z direction. elec_height, elec_width\tum\tSpecifies the Z-direction height and Y-direction width of electron. 2.2.3 Electrical Simulation Boundary​ Specifies the boundary of electrical simulation for OEDevice solver in 3D direction. oe_x_min = -0.3 oe_x_max = 0.3 oe_x_mean = 0.5*(oe_x_min+oe_x_max) oe_x_span = oe_x_max-oe_x_min oe_y_min = -4.9 oe_y_max = 4.9 oe_y_mean = 0.5*(oe_y_min+oe_y_max) oe_y_span = oe_y_max-oe_y_min oe_z_min = -0.3 oe_z_max = 0.8 oe_z_mean = 0.5*(oe_z_min+oe_z_max) oe_z_span = oe_z_max-oe_z_min  Specifies the concentration of uniform doping by constant_con and its boundary throuth center and span in Y-Z plane. constant_y_center = 0 constant_y_span = 10 constant_z_center = 0.1 constant_z_span = 0.3 constant_con = 1e15  Specifies the junction width and peak concentration of gaussian doping by_jw and _con , its boundary throuth center and span in Y-Z plane of slab. p_slab_y_center = -2.575 p_slab_y_span = 4.85 p_slab_z_center = -0.105 p_slab_z_span = 0.39 p_slab_jw = 0.1 p_slab_con = 7e17 n_slab_y_center = 2.575 n_slab_y_span = 4.85 n_slab_z_center = -0.105 n_slab_z_span = 0.39 n_slab_jw = 0.1 n_slab_con = 5e17  Specifies the doping region of high concentration in slab layer, including boundary、junction width and peak concentration. p_plus_y_center = -3.5 p_plus_y_span = 3 p_plus_z_center = -0.04 p_plus_z_span = 0.52 p_plus_jw = 0.1 p_plus_con = 1e19 n_plus_y_center = 3.5 n_plus_y_span = 3 n_plus_z_center = -0.04 n_plus_z_span = 0.52 n_plus_jw = 0.1 n_plus_con = 1e19  Specifies the doping region of high concentration in waveguide structure, including boundary、junction width and peak concentration. p_wg_y_center = -0.12 p_wg_y_span = 0.36 p_wg_z_center = 0.1275 p_wg_z_span = 0.255 p_wg_jw = 0.12 p_wg_con = 5e17 n_wg_y_center = 0.105 n_wg_y_span = 0.29 n_wg_z_center = 0.12 n_wg_z_span = 0.235 n_wg_jw = 0.11 n_wg_con = 7e17  2.2.4 Optical simulation Boundary​ Specifies the boundary of optical simulation for FDE solver in 3D direction. We only consider optical characteristic of Y-Z plane, since the light travels along X-axis. x_min = 0 x_max = 0 x_mean = 0.5*(x_min+x_max) x_span = x_max-x_min y_min = -2.3 y_max = 2.3 y_mean = 0.5*(y_min+y_max) y_span = y_max-y_min z_min = -1.5 z_max = 1.5 z_mean = 0.5*(z_min+z_max) z_span = z_max-z_min  2.3 Define Engineering Function​ To facilitate the calling of other simulation scripts, it is recommended to define a function that can set materials, model, dope, and add boundary conditions. 2.3.1 Create Project​ Create a new simulation project. def mod_project(project_name, run_mode, st_type): pj = mo.Project(name=project_name, location=run_mode)  2.3.2 Set Material​ The electrical and optical parameters of SiO2、Al and Si materials in the material library can be accessed. If the parameters defined in the Si section of MOD_material.py are different from the default parameters in the material library, the former will be prioritized. In the overlapping area of the materials, the material with a higher order value will take precedence over the one with a lower value. If the values are the same, the material defined later will override the one defined earlier. It is worth noting that the material Aluminium will call the PEC material library. mt = pj.Material() mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_lib(name=&quot;mat_al&quot;, data=mo.OE_Material.Al, order=2) mt.add_lib(name=&quot;mat_si&quot;, data=mo.OE_Material.Si, order=2, override=elec_Si_properties) mt[&quot;mat_sio2&quot;].set_optical_material(data=mo.Material.SiO2_Palik) mt[&quot;mat_si&quot;].set_optical_material(data=mo.Material.Si_Palik) mt[&quot;mat_al&quot;].set_optical_material(data=mo.Material.PEC)  2.3.3 Define structure​ To begin with, it is advisable to define the geometric region of the device structure in geometry and add materials to this region by material. The background material, which is usually Air or SiO2, should be added first.  st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.4, background_material=mt[&quot;mat_sio2&quot;]) st.add_geometry(name=&quot;BOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z_min&quot;: st_z_min, &quot;z_max&quot;: slab_height}}) st.add_geometry(name=&quot;SOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: st_z_max}}) st.add_geometry(name=&quot;Slab&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: st_y_span, &quot;z_min&quot;: 0, &quot;z_max&quot;: slab_height}}) st.add_geometry(name=&quot;Rg&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: 0, &quot;y_span&quot;: rg_width, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: rg_height}})  Parameter\tUnits\tDescriptionname Restricts the applicability of the statement to regions with the specified name. material Restricts the applicability of the statement to regions of the specified material. type Specifies the geometry of specified region. geometry Specifies the boundary of specified region in 3D direction We offer several alternative electrode region for establishing the electrical simulation area. if st_type == &quot;normal&quot;: st.add_geometry(name=&quot;Anode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_min, &quot;y_max&quot;: st_y_min + elec_width, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) st.add_geometry(name=&quot;Cathode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_max - elec_width, &quot;y_max&quot;: st_y_max, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) elif st_type == &quot;slab_N&quot;: st.add_geometry(name=&quot;Cathode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_max - elec_width, &quot;y_max&quot;: st_y_max, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) st.add_geometry(name=&quot;Ground&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: rg_width, &quot;z_min&quot;: 0, &quot;z_max&quot;: rg_height}}) elif st_type == &quot;slab_P&quot;: st.add_geometry(name=&quot;Anode&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: st_y_min, &quot;y_max&quot;: st_y_min + elec_width, &quot;z_min&quot;: slab_height, &quot;z_max&quot;: slab_height + elec_height}}) st.add_geometry(name=&quot;Ground&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_al&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: st_y_mean, &quot;y_span&quot;: rg_width, &quot;z_min&quot;: 0, &quot;z_max&quot;: rg_height}}) else: print(&quot;st_type must be chosen from 'normal', 'slab_N', 'slab_P'&quot;) raise  2.3.4 Add Doping​ You should define the basic parameters of doping module, such as type、region and model. Then define source face、junction width、peak concentration and reference concentration in gaussian doping, or only concentration in uniform doping. type specifies the n-type or donor dopant in &quot;n&quot; , and p-type or acceptor dopant in &quot;p&quot; , which may be used with gaussian and uniform profile types. ref_concentration specifies the diffusion boundary of Gaussian doping. st.add_doping(name=&quot;background_doping&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: constant_y_center, &quot;y_span&quot;: constant_y_span, &quot;z&quot;: constant_z_center, &quot;z_span&quot;: constant_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: constant_con}}) st.add_doping(name=&quot;p_slab&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: p_slab_y_center, &quot;y_span&quot;: p_slab_y_span, &quot;z&quot;: p_slab_z_center, &quot;z_span&quot;: p_slab_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_slab_jw, &quot;concentration&quot;: p_slab_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;n_slab&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: n_slab_y_center, &quot;y_span&quot;: n_slab_y_span, &quot;z&quot;: n_slab_z_center, &quot;z_span&quot;: n_slab_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: n_slab_jw, &quot;concentration&quot;: n_slab_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;p_plus&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: p_plus_y_center, &quot;y_span&quot;: p_plus_y_span, &quot;z&quot;: p_plus_z_center, &quot;z_span&quot;: p_plus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_plus_jw, &quot;concentration&quot;: p_plus_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;n_plus&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: n_plus_y_center, &quot;y_span&quot;: n_plus_y_span, &quot;z&quot;: n_plus_z_center, &quot;z_span&quot;: n_plus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: n_plus_jw, &quot;concentration&quot;: n_plus_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;p_wg&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: p_wg_y_center, &quot;y_span&quot;: p_wg_y_span, &quot;z&quot;: p_wg_z_center, &quot;z_span&quot;: p_wg_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;lower_y&quot;, &quot;junction_width&quot;: p_wg_jw, &quot;concentration&quot;: p_wg_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;n_wg&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y&quot;: n_wg_y_center, &quot;y_span&quot;: n_wg_y_span, &quot;z&quot;: n_wg_z_center, &quot;z_span&quot;: n_wg_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_y&quot;, &quot;junction_width&quot;: n_wg_jw, &quot;concentration&quot;: n_wg_con, &quot;ref_concentration&quot;: 1e6}})  2.3.5 Set Optical Simulate Boundry​ You should set the boundry of optical simulation for FDE solver. st.OBoundary(property={ &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;y&quot;: y_mean, &quot;z&quot;: z_mean, &quot;x_span&quot;: x_span, &quot;y_span&quot;: y_span, &quot;z_span&quot;: z_span}, &quot;boundary&quot;: {&quot;y_min&quot;: &quot;PEC&quot;, &quot;y_max&quot;: &quot;PEC&quot;, &quot;z_min&quot;: &quot;PEC&quot;, &quot;z_max&quot;: &quot;PEC&quot;}})  2.3.6 Add Mesh​ When specifying meshes, a balance should be struck between accuracy and numerical efficiency. The accuracy, convergence, and program memory of the subsequent computation are all affected by the quality and size of the elements in the mesh, making mesh partitioning crucial in this module. Achieving accuracy requires a fine mesh that can resolve all significant features of the solution, while numerical efficiency requires a coarse mesh that minimizes the total number of grid points. Due to the relatively simple structure of this modulator, a rough initial mesh can be established for electrical and optical simulation of the entire device. In order to obtain more accurate calculation results and better convergence, the emesh module is employed to refine the mesh of the regions with significant electrical characteristics. st.add_mesh(name=&quot;OMesh_Local&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;x_span&quot;: x_span, &quot;y&quot;: 0, &quot;y_span&quot;: 2*rg_width, &quot;z_min&quot;: -0.5*rg_height, &quot;z_max&quot;: 1.5*rg_height}, &quot;general&quot;: {&quot;dy&quot;: ogrid_local, &quot;dz&quot;: ogrid_local}}) st.add_emesh(name=&quot;EMesh_Local&quot;, property={ &quot;y_min&quot;: st_y_min, &quot;y_max&quot;: st_y_max, &quot;z_min&quot;: st_z_min, &quot;z_max&quot;: st_z_max, &quot;mesh_size&quot;: egrid_local})  2.3.7 Structure Preview Result File​ You should call the previous defined simulation module and define the name and path of the output file. Through invoking the time module and adding it to the file name, the output file of each simulation can be unique, which facilitates accurate file retrieval after multiple simulations. The plot_path will be used as the path for saving extracted results and is set here to the plots folder in the same directory as the script. If this path does not exist, the os.makedirs function needs to be called to create the path. return pj time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) @timed def preview(): pj = mod_project(project_name=simu_name + time_str, run_mode=&quot;local&quot;, st_type=&quot;normal&quot;) plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)  2.3.8 Set Simulate Solver​ Adding electrical and optical silmulation solver, is the prerequisite for output structure file. You can specify solver name and type in name and type module, and then define its other property. The type of AFDE is finite difference eigenmode (FDE) simulation module for active devices, which can be used to investigate the refractive index distribution of a device. This solver solves the single-frequency Maxwell's equations directly on a discretized grid of the waveguide cross-section, enabling exploration of the refractive index distribution of the device. The FDE analysis module can then be used to set the boundary conditions, define the model, mesh structure, and wavelength of the light source for calculation. The type of OEDevice module can be invoked to enable the charge carrier transport solver for analyzing the optoelectronic properties of a device. Since the simulation analysis is conducted in the two-dimensional Y-Z plane that is perpendicular to the X-axis, 2d_x_normal is adopted to define the simulation calculation geometry. We utilize the Newton iteration method for calculation, and the MUMPS direct solver is employed as the linear solver. The max_iterations parameter defines the maximum number of nonlinear iterations. When the number of iterations exceeds this value, the solver reduces the voltage step and starts a new iterative computations. Additionally, we define the length of the three-dimensional X direction and the solution mode and temperature during the composite process. For this study, we set the solver to solve the steady state of the device at room temperature. simu = pj.Simulation() simu.add(name=&quot;preview_fde&quot;, type=&quot;AFDE&quot;, property={ &quot;mesh_settings&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: ogrid_global_y, &quot;dz&quot;: ogrid_global_z}}, &quot;fde_analysis&quot;: {&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: False, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength}, &quot;modulator_analysis&quot;: {&quot;modulator_analysis&quot;: True, &quot;wavelength&quot;: wavelength, &quot;np_path&quot;: &quot;&quot;}}, &quot;other&quot;: {**Si_index_vs_doping}}) simu.add(name=&quot;preview_oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  You can invoke the FDE module to analyze the refractive index distribution of the device. To define the region of the refractive index distribution to be extracted in geometry , which is the coordinate in the two-dimensional Y-Z plane at X-axis equal to 0. Then, define the file name of the result image and save it to the &quot;plot&quot; folder. ​To analyze the doping distribution of the device, the OEDevice module can be invoked. First, define the region from which to extract the refractive index distribution, which is the coordinate in the two-dimensional Y-Z plane where the X-axis equals 0. Then, define the file name for the resulting image and save it to the &quot;plot&quot; folder. Additionally, save the simulation process to the &quot;log&quot; folder in the &quot;project&quot; directory. simu[&quot;preview_oedevice&quot;].run_doping(name=&quot;x_in&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}}, norm=&quot;log&quot;, scale=&quot;equal&quot;, superimpose=False, show=False, material_list=[&quot;Si&quot;], cmin=8e14, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;doping&quot;) simu[&quot;preview_fde&quot;].run_index(name=&quot;index_preview_x_0&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.3, &quot;z_span&quot;: 1}}, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;Index&quot;, export_csv=False, show=False)  "},{"title":"3. Output Result​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#3-output-result","content":"​Here, we present the device geometry as defined in the structure file, along with the P-type and N-type dopant distributions, and the overall doping distribution. ​Application Library path: :examples\\active_demo\\doping\\MOD\\plots\\MOD00_struct_time\\doping Boron Active Doping\tNet Doping\tPhosphorus Active Doping  ​ We can see the distribution of the refractive index in these three directions of device. ​ Application Library path: :examples\\active_demo\\doping\\MOD\\plots\\MOD00_struct_time X-axis\tY-axis\tZ-axis  "},{"title":"Analytic Character​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#analytic-character","content":""},{"title":"1.Modulation efficiency​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#1modulation-efficiency","content":"​The half-wave voltage refers to the applied voltage required by the modulator's optical signal to generate a phase difference of pi radians, directly reflecting the modulation efficiency of the modulator. Usually, the modulation efficiency of a device is represented by multiplying the half-wave voltage with a parameter that represents the length of the modulator required for phase variation. A smaller value of this parameter indicates higher modulation efficiency, resulting in a smaller required device size. ​Application Library path: :\\examples\\active_demo\\doping_function\\MOD\\MOD0A_vpi.py 1.1 Basic Operations​ ​Before analyzing the characteristic parameters of the device, you need to set up the simulation environment in advance and invoke the modules into the file by import . Please refer to the PD documentation for detailed instructions on specific Python commands. 1.2 Code Description​ 1.2.1 Import Modules​ ​To begin, we need to use the import command to call the relevant functional modules. from MOD00_structure import * import time import os from pathlib import Path import numpy as np import sys from matplotlib import pyplot as plt import warnings  ​For specific instructions, see the description document of PD device. ​By adding the runtime function module to the file name, you can ensure the orderly storage of simulation results without data overlay or overwriting during multiple simulation runs. start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime())  1.2.2 Define Parameters​ ​The operational mechanism of the device we simulated in this study primarily revolves around the application of a reverse voltage to modify the width of the depletion region, thereby effectively modifying the carrier concentration and subsequently modulating the refractive index. Hence, it is necessary to specify the voltage of initial、termination and step, with both parameters expressed in volts. It is important to note that vpi_vswing is twice the value of tcad_vstep . tcad_vmin = -0.5 tcad_vmax = 4 tcad_vstep = 0.5 vpi_vswing = 1.0  1.2.3 Set Path​ ​You could define the project name of path, and then define the parameters for path. simu_name = &quot;MOD0A_vpi&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path) neff_real_folder = plot_path + project_name + &quot;neffreal&quot; neff_imag_folder = plot_path + project_name + &quot;neffimag&quot; loss_folder = plot_path + project_name + &quot;loss&quot; vpil_folder = plot_path + project_name + &quot;vpil&quot; vpiloss_folder = plot_path + project_name + &quot;vpiloss&quot;  1.2.4 Confirm swing of voltage​ ​According to the phase change formula, we can determine that the refractive index n is a function of bias voltage, which means that we can change the refractive index of the material by adjusting the bias voltage. To achieve a more precise approximation curve for n-V, we set the vpi_vswing parameter to specify the voltage spacing before and after the voltage transitions, allowing us to make judgments based on user-defined parameters. Δφ=2πλΔn(V)L=2πλdndVΔVL\\Delta\\varphi=\\frac{2\\pi}{\\lambda}\\Delta n(V)L\\\\=\\frac{2\\pi}{\\lambda}\\frac{dn}{dV}\\Delta VLΔφ=λ2π​Δn(V)L=λ2π​dVdn​ΔVL ​With the following formula, when the phase difference is pi: ΔVπL=ΔVΔnλ2\\Delta V_\\pi L=\\frac{\\Delta V}{\\Delta n}\\frac{\\lambda}{2}ΔVπ​L=ΔnΔV​2λ​ di = int(np.round(np.abs(vpi_vswing/tcad_vstep/2))) # Count dot num between volt of vpi and neff. if di &lt; 1: sys.exit(&quot;\\x1b[6;30;41m&quot; + &quot;\\nError: vpi_swing must be &gt;= tcad_vstep.&quot; + &quot;\\x1b[0m&quot;) if np.abs((np.abs(vpi_vswing)-np.abs(di*tcad_vstep*2))/tcad_vstep) &gt; 0.01: warnings.warn(&quot;\\x1b[6;30;43m&quot; + &quot;\\n[Warning: vpi_swing is %(t)sV in program]&quot; % {&quot;t&quot;: di*2*tcad_vstep} + &quot;\\x1b[0m&quot;, UserWarning)  1.2.5 Create Component​ ​You can specify the physical attributes of an electrode. You can set the BC model and scanning method here. The bias voltage range is set for steady-state solutions, and the AC small signal switch is disabled. Detailed information about the Electrode attribute can be found in the appendix of the PD documentation. pj = mod_project(project_name, run_mode, st_type=&quot;normal&quot;) st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  1.2.6 Set Simulation​ ​You can add a physical model solver here. simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}}) simu.add(name=&quot;fde&quot;, type=&quot;AFDE&quot;, property={ &quot;mesh_settings&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: ogrid_global_y, &quot;dz&quot;: ogrid_global_z}}, &quot;fde_analysis&quot;: {&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: False, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength}, &quot;modulator_analysis&quot;: {&quot;modulator_analysis&quot;: True, &quot;wavelength&quot;: wavelength, &quot;mode_select&quot;: 0, &quot;np_path&quot;: &quot;&quot;}}, &quot;other&quot;: {**Si_index_vs_doping}})  1.2.7 Run​ ​It is recommended to include a module that runs the solver and initiates the simulation. The result_device variable stores simulation results for subsequent extraction. result_device = simu[&quot;oedevice&quot;].run() result_fde = simu[&quot;fde&quot;].run()  1.2.8 Extract Parameters​ ​You can extract and export simulation results to the plot folder. result_fde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;real&quot;, show=False, savepath=plot_path + project_name + &quot;neffreal&quot;) result_fde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;imag&quot;, show=False, savepath=plot_path + project_name + &quot;neffimag&quot;) result_fde.extract(data=&quot;loss&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;loss&quot;) result_fde.extract(data=&quot;vpil&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;vpil&quot;) result_fde.extract(data=&quot;vpiloss&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;vpiloss&quot;)  1.2.9 Calculate​ ​This section of the program is dedicated to calculating the parameters VpiL and VpiLoss. ​You should first extract the parameters for transmission loss and the real part of effective refractive index. ​The filename 0_effective index_Real.csv is automatically generated for the n-V data file. The initial 0 indicates the electrode number, which changes when extracting current from different electrodes. Therefore, iterate from 0 to 9 to locate the saved n-V data files. neff_file = os.path.join(neff_real_folder, &quot;0_effective index_Real.csv&quot;) loss_file = os.path.join(loss_folder, &quot;0_loss_Real.csv&quot;) for i in range(10): neff_file = os.path.join(neff_real_folder, str(i) + &quot;_effective index_Real.csv&quot;) if os.path.exists(neff_file): break for i in range(10): loss_file = os.path.join(loss_folder, str(i) + &quot;_loss_Real.csv&quot;) if os.path.exists(loss_file): break rawdata = np.genfromtxt(neff_file, skip_header=3, delimiter=',') neff = rawdata[:,1] volt = rawdata[:,0] rawdata = np.genfromtxt(loss_file, skip_header=3, delimiter=',') loss = rawdata[:,1]  ​Generate the relationship curve and data file for the product of half-wave voltage and effective modulation length (VpiL), the product of half-wave voltage and loss (VpiLoss), as well as VBias, and save them in the respective newly created files. vpil = [] volt_out = [] vpiloss = [] for i in range(di, len(volt)-di): volt_out.append(volt[i]) vpil.append((volt[i+di]-volt[i-di])/(neff[i+di]-neff[i-di])*wavelength/2*1e-4) vpiloss.append(vpil[-1]*loss[i]) vpil_file = os.path.join(vpil_folder, &quot;0_VpiL_Real.csv&quot;) vpil_pic = os.path.join(vpil_folder, &quot;0_VpiL_Real.png&quot;) vpiloss_file = os.path.join(vpiloss_folder, &quot;0_VpiLoss_Real.csv&quot;) vpiloss_pic = os.path.join(vpiloss_folder, &quot;0_VpiLoss_Real.png&quot;) if not os.path.exists(vpil_folder): os.makedirs(vpil_folder) if not os.path.exists(vpiloss_folder): os.makedirs(vpiloss_folder) np.savetxt(vpil_file, np.array((volt_out, vpil)).T, fmt='%f,%.15f', header='voltage,VpiL') np.savetxt(vpiloss_file, np.array((volt_out, vpiloss)).T, fmt='%f,%.15f', header='voltage,VpiLoss')  ​You can use the following program to set up the title and style of the picture. fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(volt_out, vpil, 'b', linewidth=linewidth, label=&quot;VpiL&quot;) ax.plot(volt_out, vpil, 'bo') ax.set_xlabel('VBias[V]') ax.set_ylabel('VpiL[V·cm]') plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1, 2)) ax.grid() plt.savefig(vpil_pic) plt.close() fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(volt_out, vpiloss, 'b', linewidth=linewidth, label=&quot;VpiLoss&quot;) ax.plot(volt_out, vpiloss, 'bo') ax.set_xlabel('VBias[V]') ax.set_ylabel('VpiLoss[V·dB]') plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1, 2)) ax.grid() plt.savefig(vpiloss_pic) plt.close() # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)  1.3 Output Result​ ​Application Library path: :\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD0A_vpi_local_time 1.3.1 Loss​ ​This section displays the variation of losses with bias voltage. 1.3.2 Effective Index​ ​These graphs depict the real and imaginary components of the refractive index as a function of bias voltage. Reffective index real\tReffective index imaginary\t 1.3.3 Modulation efficiency​ ​ These graphs illustrate the relationship between two parameters that represent modulation efficiency as a function of bias voltage. VpiL\tVpiLoss\t "},{"title":"2. Capacitance And Resistance​","type":1,"pageTitle":"Modulator","url":"/my-website/docs/examples/Active_Device/MOD/#2-capacitance-and-resistance","content":"​Capacitance and resistance play crucial roles in determining the performance of devices. Optimal capacitance values enable the modulator to selectively allow or block signals within specific frequency ranges, facilitating signal coupling. Suitable resistance values enable adjustment of signal amplitude and modulation current determination. ​Application Library path: :\\examples\\active_demo\\doping_function\\MOD\\MOD0B_RC.py 2.1 Basic Operations​ ​The simulation program for calculating capacitance and voltage exhibits numerous similarities to the program used for investigating modulation efficiency. Prior to conducting the simulation, it is necessary to import the module in order to invoke the structures and physical models defined in the structure.py . 2.2 Code Description​ 2.2.1 Import Modules​ ​The necessary Python modules for the program are invoked within the process. from MOD00_structure import * import time import os from pathlib import Path import re import numpy as np from matplotlib import pyplot as plt  2.2.2 Define Parameters​ ​The voltages to be applied to the electrodes of the device are specified. tcad_vmin = -0.5 tcad_vmax = 4 tcad_vstep = 0.5  2.2.3 Set Path​ ​You can use the time module for file naming conventions and then store the files in the &quot;plots&quot; folder. start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) simu_name = &quot;MOD0B_RC&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)  2.2.4 Create Component​ ​You can directly invoke the engineering function and device structure created in the structure.py file, and then add the electrodes and their attributes. In this case, a bias voltage ranging from -0.5 V to 4 V with a scan step of 0.5 V is applied to the cathode electrode during small-signal simulation. pj = mod_project(project_name, run_mode, st_type=&quot;normal&quot;) st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;All&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  2.2.5 Set Simulation​ ​You can add a solver for the simulation and define its properties. Furthermore, the properties of the AC small-signal module are defined in this section. The frequency interval is logarithmically defined, specifying the initial frequency, final frequency, and the number of frequencies. The variable ssac_amplitude&quot; represents the amplitude of the small signal. In this instance, three frequency values (1, 100, and 10000 MHz) are selected from the range of 1e6 to 1e10. simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;SSAC&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;small_signal_ac&quot;: {&quot;frequency_spacing&quot;: &quot;log&quot;, &quot;log_start_frequency&quot;: 1e6, &quot;log_stop_frequency&quot;: 1e10, &quot;log_num_frequency_points&quot;: 3, &quot;perturbation_amplitude&quot;: ssac_amplitude}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  2.2.6 Run​ ​It is recommended to include a module to execute the solver and commence the simulation. result_device = simu[&quot;oedevice&quot;].run()  2.2.7 Extract Parameters​ ​Firstly, the names of the folders used to store the extracted data for the real and imaginary components of the refractive index should be defined. Iac_real_folder = plot_path + project_name + &quot;Iac_real&quot; Iac_imag_folder = plot_path + project_name + &quot;Iac_imag&quot; result_device.extract(data=&quot;Iac&quot;, electrode=&quot;cathode&quot;, operation=&quot;real&quot;, export_csv=True, show=False, savepath=Iac_real_folder) result_device.extract(data=&quot;Iac&quot;, electrode=&quot;cathode&quot;, operation=&quot;imag&quot;, export_csv=True, show=False, savepath=Iac_imag_folder)  ​Secondly, the following program can be used to define the output files for the real and imaginary parts of the refractive index, as well as the capacitance and resistance, while also specifying the data content within the files and ensuring proper attention to the frequency units. Iac_real_files = [] Iac_imag_files = [] resistance_files = [] capacitance_files = [] file_regex = r&quot;([0-9]+)_Iac_Real_(.*)\\.csv&quot; for file in os.listdir(Iac_real_folder): if re.match(file_regex, file, re.I): search_group = re.search(file_regex, file, re.I) if search_group != None: Iac_real_files.append(file) Iac_imag_files.append(search_group.group(1) + &quot;_Iac_Imaginary_&quot; + search_group.group(2) + &quot;.csv&quot;) resistance_files.append(search_group.group(1) + &quot;_Resistance_&quot; + search_group.group(2) + &quot;.csv&quot;) capacitance_files.append(search_group.group(1) + &quot;_Capacitance_&quot; + search_group.group(2) + &quot;.csv&quot;) resistance_folder = plot_path + project_name + &quot;Resistance&quot; capacitance_folder = plot_path + project_name + &quot;Capacitance&quot; if not os.path.exists(resistance_folder): os.makedirs(resistance_folder) if not os.path.exists(capacitance_folder): os.makedirs(capacitance_folder) for i in range(len(Iac_real_files)): Iac_real_file = os.path.join(Iac_real_folder, Iac_real_files[i]) Iac_imag_file = os.path.join(Iac_imag_folder, Iac_imag_files[i]) resistance_file = os.path.join(resistance_folder, resistance_files[i]) capacitance_file = os.path.join(capacitance_folder, capacitance_files[i]) Iac_real_data = np.genfromtxt(Iac_real_file, skip_header=3, delimiter=&quot;,&quot;) Iac_imag_data = np.genfromtxt(Iac_imag_file, skip_header=3, delimiter=&quot;,&quot;) with open(Iac_real_file, 'r') as fp: line = fp.readline() line = fp.readline() frequency = float(re.search(r&quot;.*frequency=(.*)\\[MHz\\]&quot;, line, re.I).group(1))*1e6 if len(Iac_real_data.shape) &lt; 2: Iac_real_data.reshape((1, len(Iac_real_data))) Iac_imag_data.reshape((1, len(Iac_imag_data)))  2.2.8 Calculate​ ​Subsequently, the capacitance and voltage can be calculated based on the current and voltage data that have been read.  Vdc = Iac_real_data[:,0] Vac = ssac_amplitude Iac_real = Iac_real_data[:,1] Iac_imag = Iac_imag_data[:,1] Iac = Iac_real + 1j*Iac_imag Z = Vac/Iac R = np.abs(np.real(Z)) C = np.abs(np.imag(1/Z)/(2*np.pi*frequency))  ​Finally, the column names in the previously defined data files can be set, with the first column representing voltage and the second column representing capacitance or resistance. Additionally, the axis titles and styles should be set for the output images.  np.savetxt(resistance_file, np.array((Vdc, R)).T, fmt='%f,%.15e', header='voltage,resistance') np.savetxt(capacitance_file, np.array((Vdc, C)).T, fmt='%f,%.15e', header='voltage,capacitance') resistance_fig = os.path.splitext(resistance_file)[0] + &quot;.jpg&quot; capacitance_fig = os.path.splitext(capacitance_file)[0] + &quot;.jpg&quot; fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(Vdc, R, 'b', linewidth=linewidth, label=&quot;resistance_&quot; + str(frequency*1e-6) + &quot;MHz&quot;) ax.plot(Vdc, R, 'bo') ax.set_xlabel('VBias[V]') ax.set_ylabel('Resistance[Ohm]') plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1, 2)) ax.grid() plt.savefig(resistance_fig) plt.close() fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(Vdc, C, 'b', linewidth=linewidth, label=&quot;capacitance_&quot; + str(frequency*1e-6) + &quot;MHz&quot;) ax.plot(Vdc, C, 'bo') ax.set_xlabel('VBias[V]') ax.set_ylabel('Capacitance[F]') plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1, 2)) ax.grid() plt.savefig(capacitance_fig) plt.close() # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)  2.3 Output Result​ ​Application Library path: :\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD0B_RC_local_time 2.3.1 Small Signal AC Current​ ​This section displays the variations of the real and imaginary components of the AC current with respect to bias voltage at different frequencies. \t1 MHZ\t100 MHZ\t10000 MHZReal Image  2.3.2 Capacitance​ ​This section displays the variations of capacitance with respect to bias voltage at different frequencies. 1 MHZ\t100 MHZ\t10000 MHZ  2.3.3 Resistance​ ​This section displays the variations of resistance with respect to bias voltage at different frequencies. 1 MHZ\t100 MHZ\t10000 MHZ  "},{"title":"Grating Coupler","type":0,"sectionRef":"#","url":"/my-website/docs/examples/GratingCoupler/","content":"","keywords":""},{"title":"Introduction:​","type":1,"pageTitle":"Grating Coupler","url":"/my-website/docs/examples/GratingCoupler/#introduction","content":" Grating devices are diffractive elements with periodic optical properties or periodic spatial structures, enabling flexible functionalities such as phase matching, coupling, beam shaping, and wavelength conversion. They possess advantages of simple structures and ease of integration, making them widely applied in both active and passive components of integrated photonics. The depicted device in the figure represents a grating coupler, designed to facilitate the input and output of optical signals between optical fibers and on-chip waveguides. The primary performance parameters of the grating coupler include coupling efficiency and process tolerance.  "},{"title":"Simulation Methods​","type":1,"pageTitle":"Grating Coupler","url":"/my-website/docs/examples/GratingCoupler/#simulation-methods","content":" By employing the FDTD module, the process of coupling light from an optical fiber to an on-chip waveguide can be simulated. In the simulation, a Gaussian light source with a certain tilt angle is introduced. The monitor will then provide the throughput of the device, indicating the transmission of energy of the fundamental mode in waveguide, as well as the distribution of the optical field intensity during the transmission. After data processing, the coupling efficiency of the grating coupler can be obtained, facilitating the optimization of the grating coupler's design to achieve high-efficiency transmission of optical signals from optical fibers to on-chip waveguides. "},{"title":"Directional Coupler","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/DirectionalCoupler/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#introduction","content":"Directional couplers (DC) are an important category of optical splitters. They are typically composed of two adjacent single-mode waveguides, and the coupling coefficient is determined by both the length of the coupler and the spacing between them. This feature allows for effective control of the splitting ratio. When it comes to directional couplers, we pay close attention to several key parameters, including insertion loss, splitting ratio, device dimensions, and operating bandwidth. \t "},{"title":"Simulation Methods​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#simulation-methods","content":"The FDE module can be used to calculate the symmetric and anti-symmetric mode field distributions of the directional coupler’s two arms. From these calculations, the effective index can be determined, allowing for the theoretical calculation of the coupling length required to achieve the target splitting ratio. And the FDTD module can be used to perform precise calculations of light propagation in the DC. The light field transmission images in the monitor allow for a visual assessment,the related data of which facilitate further optimization and validation of the coupling length and spacing parameters in the DC splitter. After data processing, it can be obtained that the splitting ratio, insertion loss, and operating bandwidth of DC. In designing high-performance directional couplers for various optical communication and integrated photonics applications, these calculations and optimization processes are instrumental. "},{"title":"Directional Coupler(FDE module)​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#directional-couplerfde-module","content":"Using the FDE module, we will calculate symmetric and antisymmetric modes in a Directional Coupler modeled with the SDK. The input light can be considered a combination of the symmetric mode and the antisymmetric mode so that we can precisely calculate the coupling coefficient by effective index from the FDE module. Referring to the Silicon Photonics Design written by Lukas Chrostowski, we build the structure of the Directional coupler in the simulation. "},{"title":"1. Basic Operations​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#1-basic-operations","content":"1.1 Import File​ Once you have installed and configured the environment, import the python code and the GDS layout. The example library and related model code are usually located in the directory : .venv_maxoptics/site-packages/maxoptics_sdk/examples/func_demo. The GDS file is generally imported into the path : .venv_maxoptics/site-packages/maxoptics_sdk/examples/examples_gds 1.2 SDK Initialization​ Create a new terminal and run the code after you import the python script and GDS file. Max-Optics SDK may take some time to initialize on the first simulation. Version of Max-Optics sdk is 2.3.0.4.630.2000 Max-Optics SDK is initializing...  "},{"title":"2. Code Description​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#2-code-description","content":"Now let's learn the meaning of functions and parameters that correspond to the code. 2.1 import Modules​ To begin, we need to use the import command to call the relevant functional modules. For instance, we import the typing , os and time module in python. At the same time ,we import the customized module maxoptics_sdk.all and maxoptics_sdk.helper. from typing import List, Literal, NamedTuple import os import time import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path  The typing module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. The os module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands. The time module provides various functions to work with time-related operations and to measure time intervals. The maxoptics_sdk package provides all in one optical simulation with Python. 2.2 Define Simulation​ Firstly, We define parameters and give them a default value, such as the simulation wavelength and grid accuracy. Note that we can override this value in the following code. def simulation(*, run_mode='local', wavelength=1.55, grid=0.02, number_of_trial_modes=20, run_options: 'RunOptions', **kwargs):  The provided code contains comments that define the simulation parameters. Let's explain each of these parameters. The function simulation is used to define the simulation parameters for the program. The run_mode parameter determines the type of calculation resources to be used. The wavelength parameter specifies the wavelength of the input light in micrometers. The grid parameter represents the grid accuracy in micrometers. Lastly, the number_of_trial_modes parameter sets the number of modes to be calculated. The **kwargs is a special syntax used in function definitions to accept an arbitrary number of keyword arguments as a dictionary. 2.3 Define Parameters​ Define commonly used parameters in region 0, such as the width and height of the simulation boundary, the start time of the simulation, the path and name for the simulation output, the path to the imported GDS layout, and other parameters required for structural parameterized modeling. # region --- 0. General Parameters --- yspan_solver = 5 zspan_solver = 2 time_str = time.strftime('%Y%m%d_%H%M%S', time.localtime()) path = kwargs['path'] simu_name = f'FDE_DC_yspan={yspan_solver}_{time_str}' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + '/examples_gds/DC.gds' project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = kwargs.get('plot_dir', path) + '/plots/' + project_name + '/' kL = [f'0{k}' for k in range(5)] export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} l_bend=5.6 # the length of z bend l_arm=15 # the length of 2 arms l_input=2.5 # the length of input wg # endregion  The code defines several parameters and variables necessary for the simulation process. The yspan_solver parameter represents the width of the simulation boundary specified in micrometers. Similarly, the zspan_solver parameter denotes the height of the simulation boundary in micrometers. The time_str variable is used to obtain the current time as a timestamp for the simulation. The path variable defines the file path for the simulation, while simu_name specifies the name of the simulation file. The gds_file_root_path variable defines the path for importing the GDS layout. The project_name variable assigns a name to the project for the simulation output. The plot_path variable determines the directory where the simulation result plots will be saved. The export_options parameter allows for the definition of options for exporting the simulation results. Lastly, the variables l_bend ,l_arm, and l_input represent the lengths of specific components within the simulation, such as the length of the z-bend, the length of the two arms, and the length of the input waveguide, respectively. These parameters and variables together facilitate the successful execution and organization of the simulation process. 2.4 Define Materials​ Indeed, let's proceed to the next step, where we set up the materials required for the simulation in region 2. In this case, we will directly use relevant materials from the MO material library. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) mt.add_lib(name='SiO2', data=mo.Material.SiO2_Palik, order=2) mt.add_lib(name='Air', data=mo.Material.Air, order=2) # endregion  The add_lib is used to define three parameters name,data and order. The data calls up the property of simulation materials in the MO material library. The Order parameter determines the mesh order for the material during the simulation. Besides, we also support users to customize the material with add_nondispersionfunction. 2.5 Create Model​ Next, we will create the Directional Coupler model in region 3. We have two options for modeling the structure: # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;SiO2&quot;]) st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 6}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}}) st.add_geometry(name=&quot;dc&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (0, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name='slab', type='Rectangle', property={'geometry': {'x_min': -l_input-l_bend-l_arm/2-3, 'x_max':l_input+l_bend+l_arm/2+3, 'y': 0, 'y_span': 8, 'z': 0.045, 'z_span': 0.09}, 'material': {'material': mt['Si'], 'mesh_order': 2}} ) # endregion  Here, we import the DC layout from the GDS file. we can create the DC model directly within the SDK using the Structure function. The name parameter defines the structure name. The type parameter specifies the structure type. The path, cell_name, and layer_name parameters point to the GDS file and specify the relevant layers and cell names used in the layout. The geometry parameter sets the structure's coordinates. The material parameter specifies the material properties The mesh_order parameter sets the mesh order for the simulation. 2.6 Boundary​ After establishing the model, we can add the simulation region in region 4 and define the simulation boundary conditions. This involves specifying the geometry of the simulation region, the boundary conditions in the xyz directions, and detailed parameters. # region --- 4. Boundary --- st.OBoundary(property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': yspan_solver, 'z': 0, 'z_span': zspan_solver}, 'boundary': {'y_min': 'PEC', 'y_max': 'PEC', 'z_min': 'PEC', 'z_max': 'PEC'}}) # endregion  In this case,we use Perfect Electric Conductor(PEC) boundary condition. The PEC boundary condition is a modeling approach used to simulate the behavior of perfectly conducting surfaces or boundaries in electromagnetic wave propagation analyses. This effectively models the behavior of a material with infinite conductivity and perfect electrical shielding. This boundary condition is particularly relevant when dealing with the interaction of light and electromagnetic fields with highly conductive materials, such as metals. Moreover, We also provide the usual boundary condition like Perfectly Matched Layer(PML) and Perfect Magnetic Conductor (PMC), you can change the PEC to PML or PMCof 6 dimensions in the code. 2.7 Add Sub-mesh​ To achieve more accurate calculations of the model's modal fields, we can add a sub-mesh in region 5. # region --- 5. Sub Mesh --- st.add_mesh(name='sub_mesh', property={'general': {'dx': 0.002, 'dy': 0.002, 'dz': 0.002}, 'geometry': {'x': 0, 'x_span': 6, 'y': 0, 'y_span': 2, 'z': 0.11, 'z_span': 0.22}}) # endregion In this code segment, we use the add_mesh function to add a sub-mesh in region 5. The name parameter defines the name of the mesh. The general parameter specifies the grid accuracy in the xyz directions (in this case, 0.002 micrometers in each direction). The geometry parameter sets the coordinates of the sub-mesh. 2.8 FDE Simulation​ In region 6, we add the FDE simulation module to support mode calculations and frequency scans. # region --- 6. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={ # 'general': {'solver_type': '2d_x_normal'}, # default is '2d_x_normal' 'mesh_settings': { 'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'search': 'max_index', # 'n': 2, 'calculate_group_index': False, 'mode_removal': {'threshold': 0.02}, # 'bent_waveguide': {'bent_waveguide': False, 'radius': 1, 'orientation': 0, 'location': 'simulation_center'} }, &quot;frequency_analysis&quot;: { &quot;frequency_analysis&quot;: run_options.run_frequency_sweep, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 2.67, &quot;detailed_dispersion_calculation&quot;: False }}}) # endregion In this code segment, the name parameter defines the name of the simulation module. The general parameter specifies the type of the simulation module within the structure. It supports the following list selection['2d_x_normal','2d_y_normal','2d_z_normal']. The mesh_settings parameter is set to the previously defined sub_mesh. The wavelength parameter sets the wavelength-related parameters for the simulation. The search parameter specifies the mode search type. It supports the following list selection['near_n','max_index']. In this case, we use max_index to automatically search for the mode with max index in the structure. To use the ‘near_n’, we need to set the data in ‘n’. The bent_waveguide parameter can be used to set parameters for a bent waveguide. The frequency_analysis parameter allows us to set parameters for frequency scans or mode calculations with varying wavelengths. 2.9 Structure Image​ In region 7, you can generate an image of the structure which contains the specific coordinates. # region --- 7. Structure Show --- st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}{kL[0]}_{simu_name}', simulation_name=simu_name) # simu[simu_name].show3d(show_with=&quot;local_gui&quot;) # endregion In this code segment, we use the structure_show function to form a picture. The fig_type specifies the type of figure. It supports the following list selection[&quot;png&quot;, &quot;svg&quot;]. The show , which is a switch that controls whether the picture is generated or not. If you have already installed the GUI locally, you can automatically pop up the 3D structural model within the GUI using show_with=&quot;local_gui&quot;. Additionally, you can also use show_with=&quot;matplotlib&quot; to view the structure. 2.10 Index Preview​ And in region 8, you can generate a material refractive index plot for the structure in different cross-sectional directions(x,y,z). # region --- 8. Mesh View --- if run_options.index_preview: k = kL[1] simu[simu_name].run_index(name=f'{simu_name}_x_0', savepath=f'{plot_path}{k}IndexPreview_x=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 2}}) simu[simu_name].run_index(name=f'{simu_name}_y_0', savepath=f'{plot_path}{k}IndexPreview_y=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 4, 'y': 0, 'y_span': 0, 'z': 0, 'z_span': 2}}) simu[simu_name].run_index(name=f'{simu_name}_z_0', savepath=f'{plot_path}{k}IndexPreview_z=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 4, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 0}}) # endregion 2.11 Run Simulation​ In region 9, you can run the simulation. # region --- 9. Run --- result_fde = simu[simu_name].run() # endregion 2.12 Retrieve Results​ In region 10, you can retrieve and store the simulation results. # region --- 10. See Results --- if run_options.extract: # region --- 10.1 calculate_modes --- if run_options.run: k = kL[2] res = result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_neff_table', export_csv=True) print(res.to_string(index=False)) for m in range(len(res)): k = kL[3] result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_mode{m}', attribute='Ey', mode=m, real=True, imag=False, export_options, show=False) # endregion if run_options.run_frequency_sweep: k = kL[4] result_fde.extract(data=&quot;frequency_analysis&quot;, savepath=f'{plot_path}{k}_freq_sweep_neff', attribute=&quot;neff&quot;, real=True, imag=True, export_csv=True, export_mat=True, show=False) # endregion The extract function allows you to extract specific simulation results and store them for further analysis. The attribute parameter specifies the type of simulation results to be extracted. The mode parameter corresponds to the index of the FDE calculation mode. The real and imag parameters are used to extract the real and imaginary parts of the simulation results, respectively. If you run the frenquency sweep to calculate mode at different wavelength, you can also extract the relevant results. As an example above, we extrat the effective index. 2.13 Switches​ In this section of the code, the simulation function is called and executed, which allows you to reset relevant parameters for more convenient parameter scanning and optimization design. We also support control switches for various functionalities at the end of the code, and you can use configuration flags(True or False). These flags can be used to turn specific functionalities on or off, making it easier to check the model and perform efficient calculations. class RunOptions(NamedTuple): index_preview: bool run: bool run_frequency_sweep: bool extract: bool if __name__ == '__main__': simulation( run_mode=&quot;local&quot;, wavelength=1.55, grid=0.02, number_of_trial_modes=20, run_options=RunOptions(index_preview=True, run=True, run_frequency_sweep=True, extract=True) ) By turning on/off the relevant functionalities, you can control the simulation process and obtain the desired results. For example, the index_preview is to control whether to output images of the structural refractive index. run determines whether to run the program. run_frequency_sweep is used to enable frequency scanning, and extract is used to control data extraction. Properly utilizing these switches can help you inspect the simulation effectively. 3. Output Results​ Schematic diagram of the refractive index of the device. The results of the calculation mode will be stored in a CSV format file for subsequent data processing in Python and Excel. mode_order TE ratio neff_real neff_imag ng_real ng_imag wavelength(nm)\tloss(dB/cm)0\t0.98686\t2.593169\t-4.60E-09\t0\t0\t1550\t0.001621 1\t0.987741\t2.542373\t-3.51E-09\t0\t0\t1550\t0.001236 2\t0.940652\t2.129685\t-5.37E-05\t0\t0\t1550\t18.91018 3\t0.200058\t1.733018\t-0.00545\t0\t0\t1550\t1917.539 Image of the Ey electric field component intensity in symmetric and antisymmetric mode modes. According to the effective refractive index of the obtained mode field, Python is used for data processing and drawing. The coupling length under the gap between two waveguides is calculated with the formula: Lx=λ2∣neff1−neff2∣L_x = \\frac{\\lambda}{2|neff_1-neff_2|}Lx​=2∣neff1​−neff2​∣λ​ We can also get the coupling coefficient by the formula: κ=∣sin(πδ(n)Lλ)∣\\kappa = |sin(\\frac{\\pi\\delta(n)L}{\\lambda})|κ=∣sin(λπδ(n)L​)∣ Similarly, we can obtain the relationship between the gap (distance) between two waveguides and the coupling coefficient and the relationship between the wavelength and the coupling length. Directional Coupler(FDTD module)​ Next, we will learn how to model a Directional Coupler using the SDK and calculate the light propagation in the structure using the FDTD module. 1. Basic Operations​ Similarly, after installing and configuring the environment, we import the relevant python code file and the GDS layout for the model. The example library and related model code are typically stored in the directory .venv_maxoptics/site-packages/maxoptics_sdk/examples, and the GDS file is imported into the folder .venv_maxoptics/site-packages/maxoptics_sdk/examples/examples_gds. 2. Code Description​ Next, we will continue to learn about the specific functionalities corresponding to the code. 2.1 Define Parameters​ Like the operations with the FDE module, after configuring the simulation wavelength, grid precision, and other parameters, we need to set the relevant parameters for simulation and parameterized modeling in Region 0. This includes defining the paths and names for the simulation files and output results and specifying the path for importing the GDS layout. # region --- 0. General Parameters --- l_bend=5.6 # the length of z bend l_arm=15 # the length of 2 arms l_input=2.5 # the length of input wg monitor_w = 3.0 monitor_h = 2.0 waveform_name = &quot;wv&quot; + str(round(wavelength * 1000)) time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) path = kwargs[&quot;path&quot;] simu_name = &quot;FDTD_DC&quot; project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/DC.gds&quot; # endregion 2.2 Define Materials​ Subsequently, in Region 2, we ues the materials required for the simulation. We also support users to specify the refractive indices of Si (Silicon) and SiO2 (Silicon Dioxide) materials. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) mt.add_lib(name='SiO2', data=mo.Material.SiO2_Palik, order=2) # mt.add_nondispersion(name=&quot;Si&quot;, data=[(3.472, 0)], order=2) # mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=2) mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) # endregion The add_nondispersion function adds a non-dispersion material to the project in the simulation. The data, is specified as a list, typically in the format [(index real, index imag)]. This list contains the complex refractive index values for the material, enabling the simulation to model its optical properties accurately. The function allows users to incorporate non-dispersion materials into the simulation, contributing to a comprehensive and precise optical analysis of the system under investigation. 2.3 Define Waveform​ In Region 3, we define the parameters relevant to the wavelength. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=wavelength_span) # endregion The Waveform function is used to retrieve the waveform manager for the current project. It allows users to access and manipulate the waveform sources used in the simulation. The name parameter specifies the name of the waveform source. The Wavelength_center parameter defines the center of the wavelength range for the source. The Wavelength_span parameter determines the span of the wavelength range for the source. 2.4 Create Model\\Boundary\\Sub-mesh​ Next, similar to the procedure in the FDE module, in Region 4, we create the model by importing the GDS layout. Subsequently, in Region 5, we establish the boundary conditions. Additionally, in Region 6, we can set the sub-mesh for improved precision. # region --- 4. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;SiO2&quot;]) st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 6}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}}) st.add_geometry(name=&quot;dc&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (0, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name='slab', type='Rectangle', property={'geometry': {'x_min': -l_input-l_bend-l_arm/2-3, 'x_max':l_input+l_bend+l_arm/2+3, 'y': 0, 'y_span': 8, 'z': 0.045, 'z_span': 0.09}, 'material': {'material': mt['Si'], 'mesh_order': 2}} ) # endregion # region --- 5. Boundary --- st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_arm/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}, &quot;boundary&quot;: {&quot;x_min&quot;: &quot;PML&quot;, &quot;x_max&quot;: &quot;PML&quot;, &quot;y_min&quot;: &quot;PML&quot;, &quot;y_max&quot;: &quot;PML&quot;, &quot;z_min&quot;: &quot;PML&quot;, &quot;z_max&quot;: &quot;PML&quot;}, &quot;general_pml&quot;: {&quot;pml_same_settings&quot;: True, &quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 0.8, &quot;pml_layer&quot;: 8, &quot;pml_polynomial&quot;: 3}}) # endregion # region --- 6. Sub Mesh --- st.add_mesh(name=&quot;sub_mesh&quot;, property={&quot;general&quot;: {&quot;dx&quot;: 0.05, &quot;dy&quot;: 0.02, &quot;dz&quot;: 0.02}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_arm/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}}) # endregion In this code segment, we define simulation region using the OBoundary function. First, we define the size of the boundary with the geometry parameter . Next, we define the boundary conditions for the simulation using the boundary dictionary, where the x ,y and the z directions all have PML boundary conditions. Finally, we set detailed parameters for the PML boundary using the general_pml dictionary, specifying the pml_layer,pml_kappa, pml_sigmaand pml_polynomial, which specific the order of the polynomial. 2.5 Source​ Then we need to establish the light source in the input waveguide, as shown in Region 7. # region --- 7. ModeSource --- src = pj.Source() src.add(name=&quot;source&quot;, type=&quot;mode_source&quot;, axis=&quot;x_forward&quot;, property={&quot;general&quot;: {&quot;mode_selection&quot;: &quot;user_select&quot;, &quot;waveform&quot;: {&quot;waveform_id_select&quot;: wv[waveform_name]}}, &quot;geometry&quot;: {&quot;x&quot;: -l_input-l_arm/2-l_bend+2, &quot;x_span&quot;: 0, &quot;y&quot;: 1.35, &quot;y_span&quot;: monitor_w, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}}) # endregion  The Source function is utilized to retrieve the source manager for the current project. The type parameter specifies the type of the source and is formatted as either [&quot;mode_source&quot;] or [&quot;gaussian_source&quot;]. The name parameter represents the name assigned to the source. The axis parameter defines the axis of the source. The property parameter allows for defining specific properties associated with the source. 2.6 Monitor​ In Region 8, we set up the monitors. # region --- 8. Monitor --- # region --- 8.0 GlobalMonitor --- mn = pj.Monitor() mn.add(name=&quot;Global Option&quot;, type=&quot;global_option&quot;, property={&quot;frequency_power&quot;: {&quot;spacing_type&quot;: &quot;wavelength&quot;, &quot;spacing_limit&quot;: &quot;center_span&quot;, # [&quot;min_max&quot;,&quot;center_span&quot;] &quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: , &quot;frequency_points&quot;: 3}}) # endregion # region --- 8.1 input --- mn.add( type=&quot;power_monitor&quot;, name=&quot;input_reflect&quot;, property={&quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength, &quot;wavelength_span&quot;: 0.1, &quot;frequency_points&quot;: 3}}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: -l_input-l_arm/2-l_bend+1.5, &quot;x_span&quot;: 0, &quot;y&quot;: 1.35, &quot;y_span&quot;: monitor_w, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}, 'mode_expansion': {&quot;enable&quot;: True, 'direction': 'positive', 'mode_calculation': {'mode_selection': 'user_select', 'mode_index': [0]}}}) # endregion # endregion  For the global monitor, the Monitor function is utilized to retrieve the monitor manager for the current project, which allows users to access and manage various types of monitors used during simulation. The name parameter represents the name of the Global Option associated with the monitor. The type parameter defines the type of the Global Option and is formatted as a list containing one of several monitor types. The property parameter is used to define and set the relevant parameters specific to the chosen monitor type. These parameters control the monitor's behavior and data collection settings during the simulation. The power monitor is a configuration setting that allows users to specify various simulation parameters. The name parameter assigns a name to the power monitor. The type parameter defines the type of power monitor. The general parameter pertains to settings related to the frequency domain and frequency-dependent behaviors of the simulation. The geometry parameter is used to define the geometric characteristics of the simulated structure. The mode_expansion parameter involves relevant settings for mode expansion simulations. Users can customize the simulation settings by utilizing these input parameters to achieve accurate and comprehensive results based on their specific simulation requirements. 2.7 FDTD Simulation​ In Region 9, we add the FDTD simulation.  # region --- 9. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;FDTD&quot;, property={&quot;general&quot;: {&quot;simulation_time&quot;: 1000}, &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: grids_per_lambda, }, &quot;minimum_mesh_step_settings&quot;: {&quot;min_mesh_step&quot;: 0.01}}}) # endregion  The Simulation manager is critical for setting up and running simulations in the current project. The name parameter allows users to assign a unique name to the simulation for identification purposes. The type parameter defines the type of the simulation. The simulation_time parameter specifies the duration of the simulation. The mesh_settings parameter enables users to configure various settings related to the simulation mesh. The mesh_accuracy parameter controls the precision of the mesh used in the simulation. The cells_per_wavelength parameter determines the wavelength precision used in the simulation. The minimum_mesh_step_settings parameter sets the minimum mesh step, allowing users to define the smallest allowable size for mesh elements. Users can tailor the simulation setup to meet their requirements by utilizing these input parameters, enabling accurate and efficient electromagnetic simulations of complex optical structures. 2.8 Schematic of Structure​ As the same, we generate the device structure of the Directional Coupler in Region 10. # region --- 10. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=plot_path + simu_name, simulation_name=simu_name) # endregion  2.9 Calculate Source​ To calculate the input mode light and save its electric field intensity data in region 11. # region --- 11. Calculate Mode --- if run_options.calculate_modes: simu.add(name=simu_name+&quot;_cal_mode&quot;, type=&quot;mode_selection:user_select&quot;, simulation_name=simu_name, source_name=&quot;source&quot;, property={&quot;modal_analysis&quot;: {&quot;mesh_structure&quot;: True, &quot;calculate_modes&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: 10, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True}}) src_res = simu[simu_name+&quot;_cal_mode&quot;].run() src_res.extract(data=&quot;calculate_modes&quot;, savepath=plot_path + &quot;00_source_modeprofile_fdeonly&quot;, mode=0, attribute=&quot;E&quot;, export_csv=True) # endregion  2.10 Run Simulation​ Then, in Region 12, we run the simulation. We support users to calculate the simulation with GPU by resources to improve the simulation efficiency. # region --- 12. Run --- if run_options.run: fdtd_res = simu[simu_name].run( # resources={&quot;compute_resources&quot;: &quot;gpu&quot;, &quot;gpu_devices&quot;: [{&quot;id&quot;: 0}]} ) # endregion  2.11 Results​ In Region 13, we define the desired output results. Lastly, we control the switches of various functional modules at the end of the Python file. # region --- 13. See Results --- if run_options.extract and run_options.run: # region --- z_normal --- &quot;&quot;&quot; 01_top_profile &quot;&quot;&quot; for λ in [1.5, 1.55, 1.6]: fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;01_top_profile_&quot; + str(λ) + &quot;um&quot;, monitor_name=&quot;z_normal&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, wavelength=str(λ), export_csv=True) # endregion # region --- through --- &quot;&quot;&quot; 01_monitorThrough_modeprofile_fdtd &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;01_monitorThrough_modeprofile_fdtd&quot;, monitor_name=&quot;output_up&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, export_csv=True) &quot;&quot;&quot; 02_Trans_ThroughVsLambda_power &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;02_Trans_ThroughVsLambda_power&quot;, monitor_name=&quot;output_up&quot;, attribute=&quot;T&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) &quot;&quot;&quot; 021_ME_ThroughVsLambda_mode &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:mode_expansion&quot;, savepath=plot_path + &quot;021_ME_ThroughVsLambda_mode&quot;, monitor_name=&quot;output_up&quot;, attribute=&quot;t_forward&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, mode=0, export_csv=True) # endregion # region --- cross --- &quot;&quot;&quot; 01_monitorThrough_modeprofile_fdtd &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;01_monitorCross_modeprofile_fdtd&quot;, monitor_name=&quot;output_down&quot;, target=&quot;intensity&quot;, attribute=&quot;E&quot;, export_csv=True) &quot;&quot;&quot; 02_Trans_ThroughVsLambda_power &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:power_monitor&quot;, savepath=plot_path + &quot;02_Trans_CrossVsLambda_power&quot;, monitor_name=&quot;output_down&quot;, attribute=&quot;T&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) &quot;&quot;&quot; 021_ME_ThroughVsLambda_mode &quot;&quot;&quot; fdtd_res.extract(data=&quot;fdtd:mode_expansion&quot;, savepath=plot_path + &quot;021_ME_CrossVsLambda_mode&quot;, monitor_name=&quot;output_down&quot;, attribute=&quot;t_forward&quot;, target=&quot;line&quot;, plot_x=&quot;wavelength&quot;, mode=0, export_csv=True) # endregion  2.11 Switches​ At the end of all codes, We control the switches of various functional modules. class RunOptions(NamedTuple): index_preview: bool calculate_modes: bool run: bool extract: bool if __name__ == &quot;__main__&quot;: simulation( run_options=RunOptions(index_preview=True, calculate_modes=True, run=True, extract=True))  "},{"title":"3. Output Results​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#3-output-results-1","content":"After running the program, we can obtain a series of corresponding output results: Incident light electric field intensity, CRO output port electric field intensity, and TRU output port electric field intensity.   DC (Directional Coupler) Z-direction electric field intensity at different wavelengths: 1.50 μm, 1.55 μm, and 1.60 μm.   Cross output port and TRU output port transmittance at different wavelengths: 1.50 μm, 1.55 μm, and 1.60 μm. \t TE0 mode transmittance at Cross output port and TRU output port for different wavelengths: 1.50 μm, 1.55 μm, and 1.60 μm. \t Based on the information provided, we can get the following results when propogating wavelength is 1.55 μm and the two arm length of directional couper is equal to 15 μm: 1. Insertion Loss: 0.177 dB; 2. Power Split Ratio: 13.2 : 83.8 (or approximately 13.2% to one port and 83.8% to the other port); 3. Dimensions: Approximately 5 μm X 25 μm. "},{"title":"Supplement​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#supplement","content":"To view a function's definition and supported parameters or a parameter dictionary, you can right-click on its name and select &quot;Go to Definition&quot; or press &quot;Ctrl&quot; while left-clicking on its name to view its definition, showing the available parameters and their descriptions. "},{"title":"References​","type":1,"pageTitle":"Directional Coupler","url":"/my-website/docs/examples/PIC/DirectionalCoupler/#references","content":"Chrostowski, L., &amp; Hochberg, M. (2015). Silicon Photonics Design: From Devices to Systems. Cambridge: Cambridge University Press. doi:10.1017/CBO9781316084168 "},{"title":"Grating Coupler","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/GratingCoupler/","content":"","keywords":""},{"title":"Introduction:​","type":1,"pageTitle":"Grating Coupler","url":"/my-website/docs/examples/PIC/GratingCoupler/#introduction","content":" Grating devices are diffractive elements with periodic optical properties or periodic spatial structures, enabling flexible functionalities such as phase matching, coupling, beam shaping, and wavelength conversion. They possess advantages of simple structures and ease of integration, making them widely applied in both active and passive components of integrated photonics. The depicted device in the figure represents a grating coupler, designed to facilitate the input and output of optical signals between optical fibers and on-chip waveguides. The primary performance parameters of the grating coupler include coupling efficiency and process tolerance.  "},{"title":"Simulation Methods​","type":1,"pageTitle":"Grating Coupler","url":"/my-website/docs/examples/PIC/GratingCoupler/#simulation-methods","content":" By employing the FDTD module, the process of coupling light from an optical fiber to an on-chip waveguide can be simulated. In the simulation, a Gaussian light source with a certain tilt angle is introduced. The monitor will then provide the throughput of the device, indicating the transmission of energy of the fundamental mode in waveguide, as well as the distribution of the optical field intensity during the transmission. After data processing, the coupling efficiency of the grating coupler can be obtained, facilitating the optimization of the grating coupler's design to achieve high-efficiency transmission of optical signals from optical fibers to on-chip waveguides. "},{"title":"Photodetector","type":0,"sectionRef":"#","url":"/my-website/docs/examples/Active_Device/Photodetector","content":"","keywords":""},{"title":"1. Overview​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#1-overview","content":"This example utilizes FDTD simulation to obtain the optical field distribution in the Ge absorption layer. Subsequently, the photo-induced carrier generation rate is calculated based on the optical field, which is then imported into the OEDevice simulation to obtain the photo current. We also provide scripts for dark current, capacitance and resistance, frequency response, and saturation power. These simulations are divided into separate scripts, and they all call a unified script for modeling and material setup, making it convenient for modifications and management.  "},{"title":"2. Modeling​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#2-modeling","content":"The modeling is completed by a callable function in the script file VPD00_structure.py.  "},{"title":"2.1 Import simulation toolkit​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#21-import-simulation-toolkit","content":"First, import maxoptics_sdk and other packages. [1]  import maxoptics_sdk.all as mo import os import time from maxoptics_sdk.helper import timed from pathlib import Path from VPD_material import *  The script file VPD_material.py stores some modified electronic parameters of the materials, which are referenced to override default parameters in the modeling script.  "},{"title":"2.2 Set general parameters​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#22-set-general-parameters","content":"Set some general parameters before modeling. At the beginning are those that need frequent modification during testing and optimization. [2]  # region --- 0. General Parameters --- wavelength_center = 1.55 # um wavelength_span = 0.1 # um source_fraction = 0.001 temperature = 298.15 # K normal_length = 20 # um egrid_local = 0.1 # um egrid_global is not supported so far egrid_genrate = 0.02 # um egrid_interface = 0.002 # um remesh_thickness = 0.004 # um omesh_grid_Ge = 0.02 # um omesh_grid_Si = 0.025 # um cells_per_wavelength = 14 Ge_SiO2_recombination_velocity = 225000 # cm/s run_mode = &quot;local&quot; simu_name = &quot;VPD00_struc&quot;  Wavelength, temperature, the mesh grid size and some other parameters are defined above. They will be detailed in the subsequent settings.  [3]  # --- structure geometry --- SiO2_x_center = 0 SiO2_x_span = 100 SiO2_y_center = 0 SiO2_y_span = 20 SiO2_z_center = 0 SiO2_z_span = 10 input_wg_x_center = -42.5 input_wg_length = 5 input_wg_width = 0.5 Si_z_span = 0.22 Si_y_center = 0 taper_x_min = input_wg_x_center+input_wg_length/2 taper_length = 40 taper_width = 4 Si_slab_length = 22 Si_slab_x_center = taper_x_min+taper_length+Si_slab_length/2 Si_slab_width = 20 Ge_x_center = 10.75 Ge_x_span_bottom = 20 Ge_x_span_top = 19.5 Ge_y_span_bottom = 4 Ge_y_span_top = 3 Ge_z_span = 0.5 Ge_z_center = Si_z_span+Ge_z_span/2 anode_x_center = 10.75 anode_x_span = 19 anode_y_center = 3.7 anode_y_span_top = 2 anode_y_span_bottom = 2 anode_z_span = 1.37 anode_z_center = Si_z_span+anode_z_span/2 cathode_x_center = 10.75 cathode_x_span = 19 cathode_y_center = 0 cathode_y_span_top = 2.2 cathode_y_span_bottom = 2.2 cathode_z_span = 1 cathode_z_center = Si_z_span+Ge_z_span+cathode_z_span/2  These are geometric parameters of the structures.  [4]  # --- electrical simulation boundary --- oe_x_min = 10 oe_x_max = 10 oe_x_mean = 0.5*(oe_x_min+oe_x_max) oe_x_span = oe_x_max-oe_x_min oe_y_min = 0 oe_y_max = 3.7 oe_y_mean = 0.5*(oe_y_min+oe_y_max) oe_y_span = oe_y_max-oe_y_min oe_z_min = -0.15 oe_z_max = 1.25 oe_z_mean = 0.5*(oe_z_min+oe_z_max) oe_z_span = oe_z_max-oe_z_min  These are geometric parameters of the electrical simulation region.  [5]  # --- doping parameters --- p_uniform_x_center = 10.75 p_uniform_x_span = 22.5 p_uniform_y_center = 0 p_uniform_y_span = 15 p_uniform_z_center = Si_z_span/2 p_uniform_z_span = Si_z_span p_uniform_con = 1e15 p_well_x_center = 10.75 p_well_x_span = 22.5 p_well_y_center = 0 p_well_y_span = 15 p_well_z_center = -0.035 p_well_z_span = 0.53 p_well_junction_width = 0.05 p_well_con = 7e18 p_pplus_x_center = 10.75 p_pplus_x_span = 22.5 p_pplus_y_center = 4.75 p_pplus_y_span = 4.5 p_pplus_z_center = 0.1675 p_pplus_z_span = 0.115 p_pplus_junction_width = 0.2 p_pplus_con = 3e19 n_pplus_x_center = 10.75 n_pplus_x_span = 19.7 n_pplus_y_center = 0 n_pplus_y_span = 3 n_pplus_z_center = 0.72 n_pplus_z_span = 0.02 n_pplus_junction_width = 0.02 n_pplus_con = 1e20 n_pplus_ref = 1e16  These are parameters for doping setup, including doping box, concentration and the diffusion junction width.  [6]  # --- optical simulation boundary --- x_min = -43 # light direction x_max = 21 x_mean = 0.5*(x_min+x_max) x_span = x_max-x_min y_min = -3.2 # lateral y_max = 3.2 y_mean = 0.5*(y_min+y_max) y_span = y_max-y_min z_min = -0.5 # vertical z_max = 1 z_mean = 0.5*(z_min+z_max) z_span = z_max-z_min # endregion  These are geometry parameters for the optical simulation region.  "},{"title":"2.3 Define the function for creating a new project​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#23-define-the-function-for-creating-a-new-project","content":"A function is defined for creating a project, setting materials, modeling, doping, setting boundary conditions, etc., which can be called by other simulation script files. [7]  def pd_project(project_name, run_mode, material_property):   2.3.1 Create a new project​ Create a new simulation project. [8]   # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode) # endregion  mo.Project() parameters: name--Project name, which is also the folder name for the project files to be saved.location--The location of the computing resources. The active device simulation only support the option of &quot;local&quot; currently, which means the simulation uses the local computing resources.  2.3.2 Set materials​ [9]   # region --- 2. Material --- if material_property == &quot;normal&quot;: si_override = elec_Si_properties ge_override = elec_Ge_properties elif material_property == &quot;transient&quot;: si_override = elec_Si_properties ge_override = elec_Ge_properties_for_transient else: print(&quot;material_property must be chosen from 'normal', 'transient'&quot;) raise  The elec_Si_properties and elec_Ge_properties are both variables imported from VPD_material.py, storing the modified electronic parameters for Silicon and Germanium respectively. Besides, more physics models for Germanium are applied in transient simulation, with the elec_Ge_properties_for_transient specified for it. The material_property is used to determine which type of material parameters to choose. For details of the physics model and electronic parameter settings, please refer to the appendix.  [10]   mt = pj.Material() mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_lib(name=&quot;mat_air&quot;, data=mo.OE_Material.Air, order=1) mt.add_lib(name=&quot;pec&quot;, data=mo.OE_Material.Al, order=2, override={ &quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.28}, &quot;print&quot;: 1}}) mt.add_lib(name=&quot;mat_si&quot;, data=mo.OE_Material.Si, order=2, override=si_override) mt.add_lib(name=&quot;mat_ge&quot;, data=mo.OE_Material.Ge, order=2, override=ge_override) mt[&quot;mat_sio2&quot;].set_optical_material(data=mo.Material.SiO2_Palik) mt[&quot;mat_air&quot;].set_optical_material(data=mo.Material.Air) mt[&quot;pec&quot;].set_optical_material(data=mo.Material.PEC) mt[&quot;mat_si&quot;].set_optical_material(data=mo.Material.Si_Palik) mt[&quot;mat_ge&quot;].set_optical_material(data=mo.Material.Ge_Palik) # endregion  When adding materials, start by using the add_lib function to add electrical materials from the material library. add_lib() parameters: name--Custom material namedata--Material data, requiring one of the built-in materials in the electrical material library, namely mo.OE_Materialorder--mesh_order of the material, default to be 2override--Override the default electronic parameters by custom values. It's empty by default, which means default models and parameters are applied  Then, use the set_optical_material function to set the optical property for the material. set_optical_material() parameters： data--Optical material property，which can be one of the built-in materials in the optical material library mo.Material, or be from the custom optical material.  Example of using custom optical material properties [11]  mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_nondispersion(name=&quot;mat_sio2_op&quot;, data=[(1.444, 0)], order=1) mt[&quot;mat_sio2&quot;].set_optical_material(data=mt[&quot;mat_sio2_op&quot;].passive_material)   Note: Although the electrical and optical material properties are bound together through a two-step setting, in reality, there is no inherent connection between them. For instance, it is possible to set both the electrical properties of SiO2 and the optical properties of Si for the same material. The simulation will not generate errors or warnings in such cases, so users need to determine by themselves whether the material settings align with physics. The FDTD simulation currently doesn't support metal materials. Therefore, the optical property of metal materials should be set to mo.Material.PEC and the material name should also be &quot;pec&quot;.  2.3.3 Create structures​ First, initialize an object of pj.Structure(). [12]  # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.4, background_material=mt[&quot;mat_sio2&quot;])  pj.Structure() parameters: mesh_type--Type of mesh refinement for optical simulationmesh_factor--The grading factor of non-uniform gridbackground_material--Background material  [13]   st.add_geometry(name=&quot;BOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: SiO2_x_center, &quot;x_span&quot;: SiO2_x_span, &quot;y&quot;: SiO2_y_center, &quot;y_span&quot;: SiO2_y_span, &quot;z_min&quot;: -SiO2_z_span/2, &quot;z_max&quot;: SiO2_z_center}}) st.add_geometry(name=&quot;SOX&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_sio2&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: SiO2_x_center, &quot;x_span&quot;: SiO2_x_span, &quot;y&quot;: SiO2_y_center, &quot;y_span&quot;: SiO2_y_span, &quot;z_min&quot;: SiO2_z_center, &quot;z_max&quot;: SiO2_z_span/2}}) st.add_geometry(name=&quot;Si_input&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: input_wg_x_center, &quot;x_span&quot;: input_wg_length, &quot;y&quot;: Si_y_center, &quot;y_span&quot;: input_wg_width, &quot;z&quot;: Si_z_span/2, &quot;z_span&quot;: Si_z_span}}) st.add_geometry(name=&quot;Si_taper&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;point_1_x&quot;: taper_x_min+taper_length, &quot;point_1_y&quot;: taper_width/2, &quot;point_2_x&quot;: taper_x_min+taper_length, &quot;point_2_y&quot;: -taper_width/2, &quot;point_3_x&quot;: taper_x_min, &quot;point_3_y&quot;: -input_wg_width/2, &quot;point_4_x&quot;: taper_x_min, &quot;point_4_y&quot;: input_wg_width/2, &quot;z_min&quot;: 0, &quot;z_max&quot;: Si_z_span, &quot;x&quot;: 0, &quot;y&quot;: 0}}) st.add_geometry(name=&quot;Si_base&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_si&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: Si_slab_x_center, &quot;x_span&quot;: Si_slab_length, &quot;y&quot;: Si_y_center, &quot;y_span&quot;: Si_slab_width, &quot;z&quot;: Si_z_span/2, &quot;z_span&quot;: Si_z_span}}) st.add_geometry(name=&quot;Ge&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;mat_ge&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: Ge_x_center, &quot;x_span_bottom&quot;: Ge_x_span_bottom, &quot;x_span_top&quot;: Ge_x_span_top, &quot;y&quot;: 0, &quot;y_span_bottom&quot;: Ge_y_span_bottom, &quot;y_span_top&quot;: Ge_y_span_top, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: Ge_z_span}}) st.add_geometry(name=&quot;Cathode&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;pec&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: cathode_x_center, &quot;x_span_bottom&quot;: cathode_x_span, &quot;x_span_top&quot;: cathode_x_span, &quot;y&quot;: cathode_y_center, &quot;y_span_bottom&quot;: cathode_y_span_bottom, &quot;y_span_top&quot;: cathode_y_span_top, &quot;z&quot;: cathode_z_center, &quot;z_span&quot;: cathode_z_span}}) st.add_geometry(name=&quot;Anode&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;pec&quot;]}, &quot;geometry&quot;: {&quot;x&quot;: anode_x_center, &quot;x_span_bottom&quot;: anode_x_span, &quot;x_span_top&quot;: anode_x_span, &quot;y&quot;: anode_y_center, &quot;y_span_bottom&quot;: anode_y_span_bottom, &quot;y_span_top&quot;: anode_y_span_top, &quot;z&quot;: anode_z_center, &quot;z_span&quot;: anode_z_span}})  add_geometry() parameters: name--Structure nametype--Structure typeproperty--Other properties, listed below  Rectangle property list： \tdefault\ttype\tnotesgeometry.x_span float\tRestrained by condition: &gt;0. geometry.x_min float geometry.x_max float geometry.y_span float\tRestrained by condition: &gt;0. geometry.y_min float geometry.y_max float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0.  LinearTrapezoid property list： \tdefault\ttype\tnotesgeometry.point_1_x float geometry.point_1_y float geometry.point_2_x float geometry.point_2_y float geometry.point_3_x float geometry.point_3_y float geometry.point_4_x float geometry.point_4_y float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0.  Pyramid property list： \tdefault\ttype\tnotesgeometry.x_span_bottom float\tRestrained by condition: &gt;=0. geometry.y_span_bottom float\tRestrained by condition: &gt;=0. geometry.x_span_top float\tRestrained by condition: &gt;=0. geometry.y_span_top float\tRestrained by condition: &gt;=0. geometry.theta_x\t0\tfloat geometry.theta_y\t0\tfloat geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0.  Note: The mesh_order of a structure is default to be the mesh order of its material. And the default value will be overridden when the structure's mesh_order is set explicitly.The larger of the mesh_order of a structure, the higher of its priority. With mesh_order of two structures being the same, the structure created later has a higher priority than the one created earlier. When structures overlap, the one with higher priority overrides the one with lower priority.  2.3.4 Add doping​ [14]   st.add_doping(name=&quot;Uniform&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_uniform_x_center, &quot;x_span&quot;: p_uniform_x_span, &quot;y&quot;: p_uniform_y_center, &quot;y_span&quot;: p_uniform_y_span, &quot;z&quot;: p_uniform_z_center, &quot;z_span&quot;: p_uniform_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: p_uniform_con}}) st.add_doping(name=&quot;p_well&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_well_x_center, &quot;x_span&quot;: p_well_x_span, &quot;y&quot;: p_well_y_center, &quot;y_span&quot;: p_well_y_span, &quot;z&quot;: p_well_z_center, &quot;z_span&quot;: p_well_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_well_junction_width, &quot;concentration&quot;: p_well_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;p_pplus&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_pplus_x_center, &quot;x_span&quot;: p_pplus_x_span, &quot;y&quot;: p_pplus_y_center, &quot;y_span&quot;: p_pplus_y_span, &quot;z&quot;: p_pplus_z_center, &quot;z_span&quot;: p_pplus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_pplus_junction_width, &quot;concentration&quot;: p_pplus_con, &quot;ref_concentration&quot;: 1e6}}) st.add_doping(name=&quot;n_pplus&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: n_pplus_x_center, &quot;x_span&quot;: n_pplus_x_span, &quot;y&quot;: n_pplus_y_center, &quot;y_span&quot;: n_pplus_y_span, &quot;z&quot;: n_pplus_z_center, &quot;z_span&quot;: n_pplus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: n_pplus_junction_width, &quot;concentration&quot;: n_pplus_con, &quot;ref_concentration&quot;: n_pplus_ref}})  add_doping() parameters: name--Doping nametype--Doping type. Options are &quot;n&quot; or &quot;p&quot; for n-type, p-type doping respectivelyproperty--Other properties According to the selection of general.distribution_function, doping is divided into constant doping and gaussian doping. Detailed properties are listed below.  Doping property list: \tdefault\ttype\tnotesgeometry.x float geometry.x_span float geometry.y float geometry.y_span float geometry.z float geometry.z_span float geometry.rotate_x float geometry.rotate_y float geometry.rotate_z float geometry.x_min float geometry.x_max float geometry.y_min float geometry.y_max float geometry.z_min float geometry.z_max float general.distribution_function str\tSelections are ['constant', 'gaussian'] general.concentration float general.source_face str\tAvailable when distribution_function is 'gaussian' general.junction_width float\tAvailable when distribution_function is 'gaussian' general.ref_concentration float\tAvailable when distribution_function is 'gaussian' volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' Description: geometry--Set the geometry parameters of doping box general--Set the distribution function, concentration and so on distribution_function: When it's set to &quot;constant&quot;, only concentration is requiredWhen it's set to &quot;gaussian&quot;: concentration, ref_concentration, junction_width, source_face are required concentration--Concentration in the non-diffusion arearef_concentration--Concentration on the edge of diffusion area (edge of doping box)junction_width--Diffusion junction widthsource_face--The doping source face. Options are &quot;lower_x&quot;, &quot;lower_y&quot;, &quot;lower_z&quot;, &quot;upper_x&quot;, &quot;upper_y&quot; or &quot;upper_z&quot;. &quot;lower_x&quot; means the source face is x=x_min. Similarly for the rest. There is no diffusion area on the edge of source face. As for the other edges, there is a diffusion area within the doping box. volume--Set a list of regions or materials to be doped volume_type: When it's set to &quot;all&quot;(by default)，the doping is applied to all the (semiconductor) structures, restricted by the doping box When it's set to &quot;material&quot;, material_list is required, which means the doping is applied to the structures with one of the specified materials and restricted by the doping box When it's set to &quot;region&quot;, region_list is required, which means the doping is applied to the specified structures and restricted by the doping box  Examples for complete doping setting syntax [15]  st.add_doping(name=&quot;p_pplus&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_pplus_x_center, &quot;x_span&quot;: p_pplus_x_span, &quot;y&quot;: p_pplus_y_center, &quot;y_span&quot;: p_pplus_y_span, &quot;z&quot;: p_pplus_z_center, &quot;z_span&quot;: p_pplus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: p_pplus_junction_width, &quot;concentration&quot;: p_pplus_con, &quot;ref_concentration&quot;: 1e6}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat_si&quot;], mt[&quot;mat_ge&quot;]]}}) st.add_doping(name=&quot;n_pplus&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: n_pplus_x_center, &quot;x_span&quot;: n_pplus_x_span, &quot;y&quot;: n_pplus_y_center, &quot;y_span&quot;: n_pplus_y_span, &quot;z&quot;: n_pplus_z_center, &quot;z_span&quot;: n_pplus_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: n_pplus_junction_width, &quot;concentration&quot;: n_pplus_con, &quot;ref_concentration&quot;: n_pplus_ref}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;region&quot;, &quot;region_list&quot;: [&quot;Si_base&quot;, &quot;Ge&quot;]}})   2.3.5 Add surface recombination​ [16]   # surface recombination st.add_surface_recombination(name=&quot;Cathode_Ge&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;MetalOhmicInterface&quot;, &quot;domain_1&quot;: &quot;Cathode&quot;, &quot;domain_2&quot;: &quot;Ge&quot;, &quot;infinite_recombination&quot;: False, &quot;velocity_electron&quot;: 1e7, &quot;velocity_hole&quot;: 1e7}) st.add_surface_recombination(name=&quot;Anode_Si&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;MetalOhmicInterface&quot;, &quot;domain_1&quot;: &quot;Anode&quot;, &quot;domain_2&quot;: &quot;Si_base&quot;, &quot;infinite_recombination&quot;: False, &quot;velocity_electron&quot;: 1e7, &quot;velocity_hole&quot;: 1e7}) st.add_surface_recombination(name=&quot;Ge_SiO2&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;InsulatorInterface&quot;, &quot;domain_1&quot;: &quot;Ge&quot;, &quot;domain_2&quot;: &quot;SOX&quot;, &quot;velocity_electron&quot;: Ge_SiO2_recombination_velocity, &quot;velocity_hole&quot;: Ge_SiO2_recombination_velocity}) st.add_surface_recombination(name=&quot;Ge_Si&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;HeteroJunction&quot;, &quot;domain_1&quot;: &quot;Ge&quot;, &quot;domain_2&quot;: &quot;Si_base&quot;}) # endregion  add_surface_recombination() parameters： name--Custom nameproperty--Other properties  Surface recombination property list: \tdefault\ttype\tnotessurface_type\tdomain_domain\tstring\tSelections are ['domain_domain', 'material_material']. interface_type\tnull\tstring\tSelections are ['null', 'InsulatorInterface', 'HomoJunction', 'HeteroJunction', 'MetalOhmicInterface', 'SolderPad']. infinite_recombination\ttrue\tbool\tAvailable when interface_type is 'MetalOhmicInterface' velocity_hole\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' velocity_electron\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' domain_1 string\tAvailable when surface_type is 'domain_domain' domain_2 string\tAvailable when surface_type is 'domain_domain' material_1 material\tAvailable when surface_type is 'material_material' material_2 material\tAvailable when surface_type is 'material_material' Description: surface_type--Type of selection for the surface When surface_type is &quot;domain_domain&quot;, the surface is the interface between two structures When surface_type is &quot;material_material&quot;`, the surface is the interface between two materials interface_type--Type of contact for the surface &quot;InsulatorInterface&quot;--Semiconductor-insulator interface&quot;HomoJunction&quot;--Homogeneous semiconductor-semiconductor interface&quot;HeteroJunction&quot;--Heterogeneous semiconductor-semiconductor interface&quot;MetalOhmicInterface&quot;--Semiconductor-conductor interface&quot;SolderPad&quot;--Conductor-insulator interface infinite_recombination--Only available when interface_type is &quot;MetalOhmicInterface&quot;. The surface recombination velocity of holes and electrons will be available when infinite_recombination is False velocity_hole, velocity_electron--Surface recombination velocity of holes and electrons. Available when interface_type is &quot;MetalOhmicInterface&quot; or &quot;InsulatorInterface&quot; domain_1, domain_2--Names of the two structures at the interface. They must be set explicitly when surface_type is &quot;domain_domain&quot; material_1, material_2--The two materials at the interface. They must be set explicitly when surface_type is &quot;material_material&quot;  2.3.6 Set waveform​ [17]   # region --- 4. Waveform --- wv = pj.Waveform() wv.add(name=&quot;waveform&quot;, wavelength_center=wavelength_center, wavelength_span=wavelength_span) # endregion  wv.add() parameters： name--Name of the waveformwavelength_center--Center of wavelengthwavelength_span--Span of wavelengthunit--Unit of wavelength. Options are&quot;um&quot; and &quot;nm&quot;，default to be&quot;um&quot;  2.3.7 Set boundary conditions of optical simulation​ [18]   # region --- 5. oboundary --- for FDTD simulation st.OBoundary(property={ &quot;geometry&quot;: {&quot;x&quot;: x_mean, &quot;y&quot;: y_mean, &quot;z&quot;: z_mean, &quot;x_span&quot;: x_span, &quot;y_span&quot;: y_span, &quot;z_span&quot;: z_span}}) # endregion   Boundary conditions of optical simulation property list: \tdefault\ttype\tnotesgeneral_pml.pml_same_settings\ttrue\tbool general_pml.pml_profile\tstandard\tstring general_pml.pml_layer integer general_pml.pml_kappa float general_pml.pml_sigma float general_pml.pml_polynomial integer general_pml.pml_alpha float general_pml.pml_alpha_polynomial integer general_pml.pml_min_layers integer general_pml.pml_max_layers integer geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float boundary.x_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.x_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.y_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.y_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.z_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.z_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. Description: geometry--Set the optical simulation region boundary--Set the optical boundary conditions, default to be &quot;PML&quot; for all the boundaries general_pml--Set pml-related parameters  2.3.8 Set local mesh​ [19]   # region --- 6. mesh --- st.add_mesh(name=&quot;OMesh_Ge&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: x_min+1, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: Ge_z_span}, &quot;general&quot;: {&quot;dz&quot;: omesh_grid_Ge}}) st.add_mesh(name=&quot;OMesh_Si&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: x_min+1, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: Si_z_span/2, &quot;z_span&quot;: Si_z_span}, &quot;general&quot;: {&quot;dz&quot;: omesh_grid_Si}}) st.add_emesh(name=&quot;EMesh_Local&quot;, property={ &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: oe_y_max, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;mesh_size&quot;: egrid_local}) st.add_emesh(name=&quot;EMesh_Genrate&quot;, property={ &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: Ge_y_span_top/2, &quot;z_min&quot;: Si_z_span, &quot;z_max&quot;: Ge_z_span+Si_z_span, &quot;mesh_size&quot;: egrid_genrate}) st.add_emesh(name=&quot;EMesh_Ge_SiO2_Interface&quot;, property={ &quot;y&quot;: 0, &quot;y_span&quot;: Ge_y_span_top, &quot;z&quot;: Si_z_span+Ge_z_span, &quot;z_span&quot;: remesh_thickness, &quot;mesh_size&quot;: egrid_interface}) st.add_emesh(name=&quot;EMesh_Ge_Si_Interface&quot;, property={ &quot;y&quot;: 0, &quot;y_span&quot;: Si_slab_width, &quot;z&quot;: Si_z_span, &quot;z_span&quot;: remesh_thickness, &quot;mesh_size&quot;: egrid_interface}) st.add_emesh_along_line(name=&quot;EMesh_Ge_SiO2_Slope_Interface&quot;, property={ &quot;start_x&quot;: oe_x_mean, &quot;start_y&quot;: Ge_y_span_bottom/2, &quot;start_z&quot;: Si_z_span, &quot;end_x&quot;: oe_x_mean, &quot;end_y&quot;: Ge_y_span_top/2, &quot;end_z&quot;: Si_z_span+Ge_z_span, &quot;mesh_size&quot;: egrid_interface}) # endregion  add_mesh() set the local mesh for optical simulation, parameters: name--Custom nameproperty--Other properties  Optical local mesh property list: \tdefault\ttype\tnotesgeneral.dx float\tRestrained by condition: &gt;0. general.dy float\tRestrained by condition: &gt;0. general.dz float\tRestrained by condition: &gt;0. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t Description: geometry--Set the region of local mesh. When x_span doesn't vanish, the mesh setting will be applied to the range along the x axis. Similarly for the rest general--Set the mesh size in the corresponding direction  add_emesh() set a rectangle region for local mesh of electrical simulation. Parameters: name--Custom nameproperty--Other properties  Local mesh of electrical simulation in rectangle region property list: \tdefault\ttype\tnotesx float x_span float\tRestrained by condition: &gt;=0. x_min float x_max float y float y_span float\tRestrained by condition: &gt;=0. y_min float y_max float z float z_span float\tRestrained by condition: &gt;=0. z_min float z_max float mesh_size float\tmax size of electrical simulation mesh Note: When the simulation region is in the xy plane, only the parameters in the x, y direction are effective, and parameters in the z direction will be ignored. Similarly for the rest.  add_emesh_along_line() set a line region for local mesh of electrical simulation. Parameters： name--Custom nameproperty--Other properties  Local mesh of electrical simulation in line region property list: \tdefault\ttype\tnotesstart_x\t0\tfloat start_y\t0\tfloat\tRestrained by condition: &gt;=0. start_z\t0\tfloat end_x\t1\tfloat end_y\t1\tfloat end_z\t1\tfloat\tRestrained by condition: &gt;=0. mesh_size\t0.01\tfloat\t Note: When the simulation region is in the xy plane, besides start_x, start_y, end_x and end_y, it is also required to set the start_z and end_z, which should both be the same as the z coordinate of the plane. Similarly for the rest.  2.3.9 Set optical sources​ [20]   # region --- 7. source --- src = pj.Source() src.add(name=&quot;Mode Source&quot;, axis=&quot;x_forward&quot;, type=&quot;mode_source&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: x_min+1, &quot;x_span&quot;: 0, &quot;y&quot;: y_mean, &quot;y_span&quot;: y_span, &quot;z&quot;: z_mean, &quot;z_span&quot;: z_span}, &quot;general&quot;: {&quot;mode_selection&quot;: &quot;user_select&quot;, &quot;waveform&quot;: {&quot;waveform_id_select&quot;: wv[&quot;waveform&quot;]}}}) # endregion  src.add() parameters： name--Name of the sourceaxis--Direction of the source. &quot;x_forward&quot; means light propagating along x axis and in the direction of increasing x coordinate. &quot;x_forward&quot; means the opposite direction. Similarly for the resttype--Type of the source. It is mode source in this exampleproperty--Other properties  Mode source property list: \tdefault\ttype\tnotesgeneral.amplitude\t1.0\tfloat general.phase\t0.0\tfloat general.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. general.mode_index\t0\tinteger general.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. general.n\t1.0\tfloat general.number_of_trial_modes\t20\tinteger general.waveform.waveform_id_select any general.rotations.theta\t0\tfloat general.rotations.phi\t0\tfloat general.rotations.rotation_offset\t0\tfloat bent_waveguide.bent_waveguide\tfalse\tbool bent_waveguide.radius\t1\tfloat bent_waveguide.orientation\t20\tfloat bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t Description: geometray--Set geometric parameters of optical source bent_waveguide--Set parameters related to bent waveguide general： mode_selection--Set the type of selection for the eigen mode. When it is &quot;user_select&quot;, the mode of index in mode_index is selectedwaveform--Set the waveform of the source waveform_id_select--Set to be a specified waveform  2.3.10 Set monitors​ [21]   # region ---8.monitor --- mn = pj.Monitor() mn.add(name=&quot;Power Monitor&quot;, type=&quot;power_monitor&quot;, property={ &quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength_center, &quot;wavelength_span&quot;: wavelength_span}}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;3d&quot;, &quot;x_min&quot;: Ge_x_center-Ge_x_span_bottom/2, &quot;x_max&quot;: Ge_x_center+Ge_x_span_bottom/2, &quot;y&quot;: 0, &quot;y_span&quot;: Ge_y_span_bottom, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: Ge_z_span}}) mn.add(name=&quot;y=0&quot;, type=&quot;power_monitor&quot;, property={ &quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength_center, &quot;wavelength_span&quot;: wavelength_span}}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_y_normal&quot;, &quot;x_min&quot;: Ge_x_center-Ge_x_span_bottom/2, &quot;x_max&quot;: Ge_x_center+Ge_x_span_bottom/2, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: Ge_z_span}}) mn.add(name=&quot;z=0.47&quot;, type=&quot;power_monitor&quot;, property={ &quot;general&quot;: {&quot;frequency_profile&quot;: {&quot;wavelength_center&quot;: wavelength_center, &quot;wavelength_span&quot;: wavelength_span}}, &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_min&quot;: Ge_x_center-Ge_x_span_bottom/2, &quot;x_max&quot;: Ge_x_center+Ge_x_span_bottom/2, &quot;y&quot;: 0, &quot;y_span&quot;: Ge_y_span_bottom, &quot;z&quot;: Ge_z_center, &quot;z_span&quot;: 0}}) # endregion  The monitor &quot;Power Monitor&quot; is of the 3D type, set to record the optical field profile in the &quot;Ge&quot; structure, which will be used to calculate the optical generation rate. The monitors &quot;y=0&quot; and &quot;z=0.47&quot; are both of the 2D type, set to visualize the optical field profile at the specified cross-sections. mn.add() parameters： name--Name of the monitortype--Type of the monitorproperty--Other properties  Power monitor property list: \tdefault\ttype\tnotesgeneral.frequency_profile.sample_spacing\tuniform\tstring\tSelections are ['uniform']. general.frequency_profile.use_wavelength_spacing\ttrue\tbool general.frequency_profile.spacing_type\twavelength\tstring\tSelections are ['wavelength', 'frequency']. general.frequency_profile.wavelength_min float general.frequency_profile.wavelength_max float general.frequency_profile.wavelength_center float general.frequency_profile.wavelength_span float general.frequency_profile.frequency_min float general.frequency_profile.frequency_max float general.frequency_profile.frequency_center float general.frequency_profile.frequency_span float general.frequency_profile.frequency_points integer geometry.monitor_type string\tSelections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float advanced.sampling_frequency.min_sampling_per_cycle\t2\tinteger\t Description: geometry--Set the geometric parameters of the monitor, including the dimension and the size general--Set the frequency points of the monitor frequency_profile: sample_spacing--Only support &quot;uniform&quot; currently, which means the frequency points are uniformly sampled in either wavelength or frequency use_wavelength_spacing--Default to be True. When it' True, the frequency points in sampled in wavelength, otherwise, in frequency. spacing_type--Default to be &quot;wavelength&quot;. When it's &quot;wavelength&quot;, the frequency range is set in wavelength; When it's &quot;frequency&quot;, the frequency range is set in frequency frequency_points--Number of frequency points  2.3.11 Preview the structures​  2.3.11.1 Define the preview function​ [22]  # ------------- preview -------------- time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) @timed def preview(): pj = pd_project(project_name=simu_name + time_str, run_mode=&quot;local&quot;, material_property=&quot;normal&quot;) plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)  Call the pd_project function defined earlier to create a new project pj. simu_name is set in the general parameters. time_str is the time stamp when the function started running and is added to the project name, to make the project name unique for each simulation and the simulation results not overwritten by each other. plot_path will be set to the save path of the result extraction. Here, it is set to the 'plots' folder located in the same directory as this script. If the path doesn't exist, os.makedirs() should be called to create it.  2.3.11.2 Add solvers​ Optical and electrical solvers are added within the preview function. The corresponding structure preview is only available when the solvers are present. [23]   simu = pj.Simulation() simu.add(name=&quot;preview_fdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}}) simu.add(name=&quot;preview_oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: &quot;&quot;, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  simu.add() parameters： name--Name of the solvertype--Type of the solver. For active device simulation, the type of FDTD solver is &quot;AFDTD&quot;, and the type of carrier transport solver is &quot;OEDevice&quot;property--Other properties  For AFDTD，mesh_settings.mesh_accuracy.cells_per_wavelength means the number of mesh cells per wavelength. The larger the number, the smaller the mesh size and the longer the simulation time. For OEDevice，other properties are not necessary. So property can be empty. Detailed parameter settings for OEDevice can be found in the appendix.  2.3.11.3 Preview doping profile​ Preview the doping profile by the run_doping function of the OEDevice solver. [24]   simu[&quot;preview_oedevice&quot;].run_doping(name=&quot;x_in&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}}, norm=&quot;log&quot;, scale=&quot;equal&quot;, superimpose=False, show=False, material_list=[&quot;Ge&quot;, &quot;Si&quot;], cmin=8e5, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;doping_x_in&quot;)  run_doping() parameters: name--Custom namenorm--Set the normalization method for the intensity plot, default to be &quot;linear&quot;, which means linear normalization. It can also be set to &quot;log&quot;, which means taking the logarithm of the intensity first, and then performing linear normalization. The net doping is calculated as $N_D-N_A$, where $N_D$ denotes the donor concentration and $N_A$ denotes the acceptor concentrationscale--Set the scaling method of the vertical and horizontal axes, default to be &quot;equal&quot;, which means the two axes are scaled proportional. It can also be set to &quot;auto&quot;, which means the two axes are scaled automaticallysuperimpose--Set whether the structure plot and the doping plot superimpose or not, default to be &quot;True&quot;show--Set whether the result plot should be displayed in a popup window, default to be False, which means not and it will be saved to the savepath automatically. When it is True, the result plot won't pop up and will not be saved unless operated manuallymaterial_list--Specify a list of materials to preview the doping profile. And each item in the list should be the chemical formula of the material. Default to be empty, which means all the materials will be previewedregion_list--Specify a list of structures to preview the doping profile. And each item in the list is the name of the structure. Default to be empty, which means all the structures will be previewed. When it's not empty, it will override the material_list settingcmax--Set the maximum of the colorbar for the intensity plot. When the concentration is greater than this value, it will be displayed as this value. It is ineffective for net dopingcmin--Set the minimum of the colorbar for the intensity plot. When the concentration is smaller than this value, it will be displayed as this value. It is ineffective for net dopingsavepath--The save path for the resultproperty--Other properties  run_doping property list: \tdefault\ttype\tnotesgeometry.dimension string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t Description: geometry--Set the region of doping preview dimension--Set the dimension of doping preview. The electrical simulation only supports the 2D type currently, so the doping and its preview are all considered in a plane. When dimension is &quot;2d_x_normal&quot;, it means the preview is in the yz plane. Similarly for the rest.  Result show of the doping preview  Fig 1. Net doping  2.3.11.4 Preview index profile​ Preview the index profile by the run_index function of the AFDTD solver. [25]   simu[&quot;preview_fdtd&quot;].run_index(name=&quot;index_preview_x_10&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 10, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 4, &quot;z_min&quot;: -0.5, &quot;z_max&quot;: 0.72}}, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;MeshView/&quot; + &quot;x=10&quot;, export_csv=False, show=False) simu[&quot;preview_fdtd&quot;].run_index(name=&quot;index_preview_z_0.11&quot;, property={ &quot;geometry&quot;: {&quot;x_min&quot;: -43, &quot;x_max&quot;: 19, &quot;y&quot;: 0, &quot;y_span&quot;: 6.4, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0}}, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;MeshView/&quot; + &quot;z=0.11&quot;, export_csv=False, show=False)  run_index() parameters： name--Custom nameexport_csv--Whether to export csv file, default to be Falsesavepath--Save path of the result extractionshow--Whether to show the plot in a popup window, default to be Falseexport_n--Whether to export nx, ny, nz, default to be Trueexport_c--Whether to export σx, σy, σz, default to be Falsemax_index--Set the maximum of the intensity plot of index, default to be Nonemax_sigma--Set the maximum of the intensity plot of conductivity, default to be Noneproperty--Other properties  run_index property list： \tdefault\ttype\tnotesgeometry.monitor_type string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t Description: geometry--Set the region of index preview. The run_index function currently only supports the index preview in a 2D plane. If x_span is set to 0, the preview will be performed in the yz plane. Similarly for the rest.  Result show of the index preview  Fig 2. nx  "},{"title":"3. Simulation​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#3-simulation","content":" "},{"title":"3.1 Dark current​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#31-dark-current","content":"This section performs the simulation of dark current in the VPD0B_Id.py script by invoking the pd_project function.  3.1.1 Import simulation toolkit​ [26]  from VPD00_structure import * import time import os from pathlib import Path  All the variables and functions from VPD00_structure.py are imported.  3.1.2 Set general parameters​ [27]  start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # region --- 0. General Parameters --- tcad_vmin = 0 # unit:Volt tcad_vmax = 4 # unit:Volt tcad_vstep = 0.5 # unit:Volt # endregion # ---------------------- set project_path simu_name = &quot;VPD0B_Id&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str material_property = &quot;normal&quot; genrate_file_path = &quot;&quot; # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)   3.1.3 Create a new project​ [28]  pj = pd_project(project_name, run_mode, material_property)   3.1.4 Add electrodes​ [29]  st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  add_electrode() parameters: name--Name of the electrodeproperty--Other properties The detailed property list of electrode can be found in the appendix. Here a range of voltage from 0V to 4V is applied to the electrode &quot;cathode&quot;, and the step of the voltage is 0.5V.  3.1.5 Add the solver​ [30]  # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  Description: The detailed property list of OEDevice solver can be found in the appendix. Here: genrate--Set the properties for optical generation rate genrate_path--It's set to genrate_file_path, which is &quot;&quot;, an empty string. That means no optical generation rate is imported to the OEDevice solver. Therefore, the simulation is for dark current. And the rest properties in genrate is ineffective in this case geometry--Set the geometric parameters for the simulation region dimension--It's set to 2d_x_normal, which means the simulation is in the yz plane general: norm_length--It's set to normal_length, which is 20, meaning that the size of the device in the third dimension is 20μm. That is to say its length in the x-direction is 20μmsolver_mode--It's set to &quot;steady_state&quot;, which means a steady state simulation  3.1.6 Run the solver​ [31]  # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run()  result_device stores the information of the simulation result, which can be used to perform result extraction.  3.1.7 Extract the result​ [32]  # --- Extract --- result_device.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;IV_cathode&quot;)  result_device.extract() parameters： data--Type of the result. Here it's set to &quot;I&quot; to extract the I-V curve from the simulation resultelectrode--Name of an electrode, which means the current data is from the electrodeexport_csv--Whether to export the csv resultshow--Whether to show the plot in a popup windowsavepath--The save path for the result extraction  Result show of the dark current extraction  Fig 3. Dark Current  3.1.8 Print the simulation time​ [33]  print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   "},{"title":"3.2 Resistance​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#32-resistance","content":"This simulation applies a forward bias to the electrode &quot;anode&quot;. And then the I-V curve is extracted and fitted to obtain the resistance. The script is in the VPD0C_Rs.py file.  3.2.1 Simulate and extract the I-V curve​ [34]  from VPD00_structure import * import time import os from pathlib import Path import numpy as np from matplotlib import pyplot as plt # region --- 0. General Parameters --- tcad_vmin = 0 # unit:Volt tcad_vmax = 1.5 # unit:Volt tcad_vstep = 0.25 # unit:Volt # endregion start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # ---------------------- set project_path simu_name = &quot;VPD0C_Rs&quot; material_property = &quot;normal&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str genrate_file_path = &quot;&quot; # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path) # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property) st = pj.Structure() st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}}) # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run() # --- Extract IV --- IV_file_folder = plot_path + project_name + &quot;IV_anode&quot; result_device.extract(data=&quot;I&quot;, electrode=&quot;anode&quot;, export_csv=True, show=False, savepath=IV_file_folder)  A range of voltage from 0V to 1.5V is applied to the electrode &quot;anode&quot;, with a step of 0.25V. No optical generation rate is applied. And a steady state simulation is performed to extract the I-V curve, which is saved to the folder IV_file_folder.  Result show of the I-V curve Fig 4. I-V curve  3.2.2 Fit V-I curve to obtain resistance​  3.2.2.1 Read the saved I-V data​ [35]  # region --- calculate R --- IV_file = os.path.join(IV_file_folder, &quot;0_I_Real.csv&quot;) for i in range(10): IV_file = os.path.join(IV_file_folder, str(i) + &quot;_I_Real.csv&quot;) if os.path.exists(IV_file): break rawdata = np.genfromtxt(IV_file, skip_header=3, delimiter=',') I = rawdata[:,1] V = rawdata[:,0]  &quot;0_I_Real.csv&quot; is filename generated automatically of the I-V result. The &quot;0&quot; in the beginning indicates the index of the electrode. When the I-V curve is from a different electrode, the index will change. Therefore, a iteration from 0 to 9 is applied to find the saved I-V data file.  3.2.2.2 Fit the data to obtain resistance​ [36]  start_idx = len(V)//2 coeffs = np.polyfit(I[start_idx:], V[start_idx:], 1) V_fit = coeffs[0]*I + coeffs[1] R = abs(coeffs[0])  Fit the data after the index start_idx, which is the start index of the approximately linear portion of the curve. A first-order polynomial fitting is performed on the V-I data. Then the coefficient of the first-order term is the device resistance.  3.2.2.3 Save data and plots​ [37]  Rdata_folder = os.path.join(plot_path, project_name, &quot;resistance&quot;) if not os.path.exists(Rdata_folder): os.makedirs(Rdata_folder) Rdata_file = os.path.join(Rdata_folder, &quot;Rdata.dat&quot;) Rdata_fig = os.path.join(Rdata_folder, &quot;resistance.jpg&quot;) with open(Rdata_file, &quot;w&quot;) as fp: fp.write(&quot;Resistance: &quot; + f&quot;{R} Ohm\\n&quot;) fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(I, V, c=&quot;b&quot;, linewidth=linewidth, label=&quot;V-I&quot;) ax.plot(I, V_fit, c=&quot;g&quot;, linewidth=linewidth, label=&quot;V_fit-I&quot;) ax.set_xlabel(&quot;I[A]&quot;) ax.set_ylabel(&quot;V[V]&quot;) plt.legend() plt.ticklabel_format(style=&quot;sci&quot;, scilimits=(-1, 2)) ax.grid() plt.savefig(Rdata_fig) plt.close() # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   Result show of the V-I fitting Fig 5. V-I fitting  "},{"title":"3.3 Capacitance​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#33-capacitance","content":"This section performs a SSAC simulation, and extracts the capacitance. The script is in the VPD0A_C.py file. [38]  from VPD00_structure import * import time import os from pathlib import Path # region --- 0. General Parameters --- tcad_vmin = 0 # unit:Volt tcad_vmax = 3 # unit:Volt tcad_vstep = 0.5 # unit:Volt # endregion start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) simu_name = &quot;VPD0A_C&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path) # ---------------------- set project_path material_property = &quot;normal&quot; genrate_file_path = &quot;&quot; # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property) st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;All&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;SSAC&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;small_signal_ac&quot;: {&quot;frequency_spacing&quot;: &quot;single&quot;, &quot;frequency&quot;: 1e8}, # &quot;small_signal_ac&quot;: {&quot;frequency_spacing&quot;: &quot;log&quot;, &quot;log_start_frequency&quot;: 1e6, &quot;log_stop_frequency&quot;: 1e10, &quot;log_num_frequency_points&quot;: 3}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}}) # ---------------------- run # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run() # ---------------------- extract result_device.extract(data=&quot;C&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;C&quot;) print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)  Description: For OEDevice solver, the detailed properties can be found in the appendix. Here: general: solver_mode--It's set to &quot;SSAC&quot;, which means a SSAC simulation small_signal_ac--Set the frequency points frequency_spacing--It's set to &quot;single&quot;, which means a single frequency point frequency--Set the value of the single frequency  For the electrode &quot;cathode&quot;, a range of voltage from 0V to 3V is applied to it, with a step of 0.5V. apply_AC_small_signal--It's set to All, which means the small signal analysis is applied at each voltage step  For the result extraction: data--It's set to &quot;C&quot;, which is available after the SSAC simulation and is used to extract the capacitance  Result show of the capacitance Fig 6. Capacitance  "},{"title":"3.4 Optical generation rate​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#34-optical-generation-rate","content":"This section performs a FDTD simulation to obtain the optical field profile in the structure of &quot;Ge&quot;, and then calculate the photo-induced carrier generation rate. The average of the optical generation rate in the light propagating direction, which is the x-direction, is then taken to obtain the profile in the yz plane to be imported to the OEDevice simulation. The script is in the VPD01_FDTD.py file.  3.4.1 Import simulation toolkit​ [39]  from VPD00_structure import * import time import os from pathlib import Path   3.4.2 Set general parameters​ [40]  start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # ---------------------- set project_path simu_name = &quot;VPD01_FDTD&quot; material_property = &quot;normal&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; genrate_file_folder = plot_path + project_name + &quot;genrate&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)   3.4.3 Create a new project​ [41]  # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property)   3.4.4 Add the solver​ [42]  # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;fdtd&quot;, type=&quot;FDTD&quot;, property={ &quot;general&quot;: {&quot;simulation_time&quot;: 2000}, &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}}) simu.add(name=&quot;afdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;general&quot;: {&quot;simulation_time&quot;: 2000}, &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}})  The AFDTD solver for active device simulation can be used to extract the optical generation rate, but can't export the optical field profile. And the usage of the FDTD solver is exactly the opposite. Therefore, both solvers are added here to serve the different purposes.  3.4.5 Run and extract the result​ [43]  # --- Run --- # check license and print version before &amp; after simulation. # result_fdtd = simu[&quot;fdtd&quot;].run() # result_fdtd.extract(data=&quot;fdtd:power_monitor&quot;, monitor_name=&quot;y=0&quot;, savepath=plot_path + project_name + &quot;E_y=0&quot;, # attribute=&quot;E&quot;, target=&quot;intensity&quot;, wavelength=str(wavelength_center), export_csv=True) # result_fdtd.extract(data=&quot;fdtd:power_monitor&quot;, monitor_name=&quot;z=0.47&quot;, savepath=plot_path + project_name + &quot;E_z=0.47&quot;, # attribute=&quot;E&quot;, target=&quot;intensity&quot;, wavelength=str(wavelength_center), export_csv=True) result_afdtd = simu[&quot;afdtd&quot;].run() result_genrate = result_afdtd.run_generation_rate_analysis(name=&quot;genrate&quot;, monitor=&quot;Power Monitor&quot;, average_dimension=&quot;x&quot;, light_power=1, coordinate_unit=&quot;m&quot;, field_length_unit=&quot;m&quot;) # unit： m, cm, um, nm #average_dimension: x/y/z result_genrate.extract(data=&quot;generation_rate&quot;, export_csv=True, show=False, log=False, savepath=genrate_file_folder) result_genrate.extract(data=&quot;pabs_total&quot;, export_csv=True, show=False, log=False, savepath=genrate_file_folder) print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)  run_generation_rate_analysis() parameters： name--Custom namemonitor--Name of the power_monitor for calculating optical generation rate. The power_monitor is required to be of 3D typeaverage_dimension--Set the direction to take the average of the optical generate ratelight_power--Set the power of the light source, measured in W. The optical generation rate will be scaled based on the powercoordinate_unit--Set the coordinate unit in the optical generation rate file (gfile)field_length_unit--Set the length unit in the generation rate unit in the optical generation rate file (gfile). If it's set to &quot;m&quot;, the generation rate unit in the gfile will be /m^3/s. Similarly for the rest  result_genrate.extract() parameters： data--Type of the result When data is set to &quot;generation_rate&quot;, besides an image file and a csv file, the result files also include a text file in .gfile format. The coordinate unit in the csv and the image file is um, and the generation rate unit in the two files is /cm^3/s. These units can't be modified when extracting the result. However, the units in the gfile are controlled by coordinate_unit、field_length_unit. And only the gfile can be imported to the OEDevice solverWhen data is set to &quot;pabs_total&quot;, the total absorption power is extracted export_csv--Whether to export csv file show--Whether to show the plot in a popup window log--Whether to apply a logarithmic normalization in the intensity plot savepath--The save path of the result extraction  Result show of the optical generation rate Fig 7. Optical generation rate  "},{"title":"3.5 Photo current​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#35-photo-current","content":"This section imports the optical generation rate to the OEDevice solver, and performs a steady state simulation to obtain the photo current. The script is in the VPD02_Ip.py file.  3.5.1 Import simulation toolkit​ [44]  from VPD00_structure import * import time import os from pathlib import Path   3.5.2 Set general parameters​ [45]  start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # region --- 0. General Parameters --- tcad_vmin = 0 # unit:Volt tcad_vmax = 4 # unit:Volt tcad_vstep = 0.5 # unit:Volt # endregion # ---------------------- set project_path simu_name = &quot;VPD02_Ip&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str material_property = &quot;normal&quot; genrate_file_folder = str(Path(__file__).parent.as_posix()) genrate_file_path = genrate_file_folder + &quot;/VPD01_FDTD.gfile&quot; # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)  genrate_file_path is the absolute path of the gfile to be imported to the OEDevice solver. Here it's set to the absolute path of VPD01_FDTD.gfile in the same directory. And this can be changed to the path of the gfile extracted by the AFDTD simulation.  3.5.3 Create a new project​ [46]  # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property)   3.5.4 Add electrodes​ [47]  st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   3.5.5 Add the solver​ [48]  # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  Description: genrate: genrate_path--Here it's not empty, meaning that the file at the path will be imported to the OEDevice solvercoordinate_unit--Set the coordinate unit in the gfilefield_length_unit--Set the length unit in the generation rate unit in the gfilesource_fraction--Set the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport  3.5.6 Run and extract the result​ [49]  # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run() # --- Extract --- result_device.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=plot_path + project_name + &quot;IV_cathode&quot;) print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   Result show of the photo current Fig 8. Photo current  "},{"title":"3.6 Bandwidth​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#36-bandwidth","content":"This section performs a transient simulation to extract the step response of the photo current. Then the bandwidth is obtained by postprocessing the I-t curve. The script is in the VPD03_bw.py file.  3.6.1 Import simulation toolkit​ [50]  from VPD00_structure import * import time import os from pathlib import Path import numpy as np from scipy import interpolate as scip, fft as scfft from matplotlib import pyplot as plt   3.6.2 Set general parameters​ [51]  start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # region --- 0. General Parameters --- tcad_vbias = 1 # the bias voltage on cathode source_fraction = 1e-4 # the source generation rate is multiplied by this factor # endregion # ---------------------- set project_path simu_name = &quot;VPD03_bw&quot; project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str material_property = &quot;transient&quot; genrate_file_folder = str(Path(__file__).parent.as_posix()) genrate_file_path = genrate_file_folder + &quot;/VPD01_FDTD.gfile&quot; # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path)   3.6.3 Create a new project​ [52]  # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property)   3.6.4 Add electrodes​ [53]  st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: tcad_vbias, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 2.001e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 30e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.001e-12, &quot;time_stop&quot;: 2.01e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 60e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.01e-12, &quot;time_stop&quot;: 2.03e-12, &quot;initial_step&quot;: 60e-18, &quot;max_step&quot;: 2e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.03e-12, &quot;time_stop&quot;: 10e-12, &quot;initial_step&quot;: 2e-15, &quot;max_step&quot;: 50e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 10e-12, &quot;time_stop&quot;: 500e-12, &quot;initial_step&quot;: 50e-15, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}]}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  Description: For the electrode &quot;cathode&quot;: bc_mode--Here it's set to &quot;transient&quot;, which means a transient boundary condition is applied to this electrode. Then the time dependence of the optical generation rate can be set at this electrodevoltage--Here it's set to tcad_vbias, which is 1, meaning that the voltage is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation.v_step_max--Set the max step of the voltage from the equilibrium state to steady state at the bias of voltage.time_table--Set the time dependence of optical generation rate. It's of a list type, whose item is of a dictionary type. In each of its item: time_start--Set the start time point of the range. The value of 0 represents the steady state of the earlier simulation.time_stop--Set the stop time point of the rangeinitial_step--Set the initial time step of the rangemax_step--Set the max time step of the rangeoptical--Set the optical generation rate during the time range enabled--Whether to apply optical generation rate during the time range. The value of 1 means True, and 0 means Falseenvelop--The envelop of the scaling factor of the light power during the time range. When it's set to 0, the envelop is uniformsource_fraction--When envelop is set to0, this value is the scaling factor of the light power during the time range Note: The dependency of scaling factor of light power on time is a step function here.  3.6.5 Add the solver​ [54]  # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: 0}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;transient&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;use_global_max_iterations&quot;: False, &quot;poisson_max_iterations&quot;: 50, &quot;ddm_max_iterations&quot;: 20, &quot;use_quasi_fermi&quot;: &quot;enabled&quot;, &quot;damping&quot;: &quot;potential&quot;, &quot;potential_update&quot;: 2, &quot;relative_tolerance&quot;: 1e-5, &quot;tolerance_relax&quot;: 1e7}})  Description: general: solver_mode--Here it's set to &quot;transient&quot;, which means a transient simulation advanced: use_global_max_iterations--Whether to use global max iterations during the initialization of solving the Poisson equations and the subsequent computing for solving the drift-diffusion equations coupling with Poisson equationspoisson_max_iterations--Set the max iterations during the initialization of solving the Poisson equations, available when use_global_max_iterations is Falseddm_max_iterations--Set the max iterations during the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, available when use_global_max_iterations is Falseuse_quasi_fermi--Whether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. &quot;enabled&quot; means True, and &quot;disabled&quot; means Falsedamping--Set the nonlinear update damping scheme. &quot;potential&quot; means the damping is based on the potential variationpotential_update--Set the threshold potential for potential damping. The large value will reduce the strength of damping effectrelative_tolerance--Set the relative update tolerancetolerance_relax--Set the tolerance relaxation factor for convergence on relative tolerance criteria  3.6.6 Run the solver​ [55]  # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run()   3.6.7 Extract the result​ The I-t curve is extracted. Because the dependency of the light power on time is a step function, the I-t curve here represents the step response of the photo current. [56]  # --- Extract --- It_file_folder = plot_path + project_name + &quot;I&quot; result_device.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, show=False, export_csv=True, savepath=It_file_folder) # result_device.extract(data=&quot;In&quot;, electrode=&quot;cathode&quot;, show=False, export_csv=True, savepath=plot_path + project_name + &quot;In&quot;) # result_device.extract(data=&quot;Ip&quot;, electrode=&quot;cathode&quot;, show=False, export_csv=True, savepath=plot_path + project_name + &quot;Ip&quot;)   Result show of the step response Fig 9. Step response  3.6.8 Postprocess​ By taking the derivative of the step response, the impulse response is obtained. Then the Fast Fourier Transform is applied to the impulse response, resulting in the frequency response, which allows to determine the device bandwidth.  3.6.8.1 Obtain the impulse response​ [57]  # region Calculate 3dB bandwidth It_file = os.path.join(It_file_folder, &quot;0_I_Real.csv&quot;) for i in range(10): It_file = os.path.join(It_file_folder, str(i) + &quot;_I_Real.csv&quot;) if os.path.exists(It_file): break rawdata = np.genfromtxt(It_file, skip_header=3, delimiter=',') I = rawdata[:,1] t = rawdata[:,0]*1e-15 start_idx = 2 t = t[start_idx:] I = I[start_idx:] # Calculate impulse response dI/dt from step response I(t) # Impulse response at t[i] is the average of dI[i-1]/dt[i-1] and dI[i]/dt[i] dt = np.diff(t) dI = np.diff(I) dIdt = (dI[1:] + (dt[1:]/dt[:-1])**2*dI[:-1])/(dt[1:]*(1+dt[1:]/dt[:-1])) delta_t = 1e-13 th = t[1:len(t)-1] nt = int(np.ceil((th[-1]-th[0])/delta_t)) t_interp = np.linspace(th[0], th[-1], nt) interp1d_func = scip.interp1d(th, dIdt) dIdt_interp = interp1d_func(t_interp)  First, take the derivative of the step response to obtain the impulse response. And then uniform time intervals and perform interpolation on the impulse response to facilitate the subsequent application of the Fast Fourier Transform.  3.6.8.2 Export the impulse response result​ [58]  # Output impulse response bandwidth_folder = str(Path(It_file_folder).parent.as_posix()) + &quot;/3dB_bandwidth&quot; if not os.path.exists(bandwidth_folder): os.makedirs(bandwidth_folder) impulse_fig = os.path.join(bandwidth_folder, &quot;impulse_response.jpg&quot;) fontsize = 20 linewidth = 1 plt.rcParams.update({&quot;font.size&quot;: fontsize}) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(t_interp*1e12, dIdt_interp/np.max(np.abs(dIdt_interp)), c='b', linewidth=linewidth, label=&quot;Impulse response&quot;) ax.set_ylabel(&quot;Impulse response&quot;) ax.set_xlabel(&quot;Time [ps]&quot;) ax.grid() plt.legend() plt.ticklabel_format(style='sci', scilimits=(-1,2)) plt.savefig(impulse_fig) plt.close()   Result show of the impulse response Fig 10. Impulse response  3.6.8.3 Obtain the frequency response​ [59]  fresponse = scfft.rfft(dIdt_interp) freq = scfft.rfftfreq(len(t_interp), t_interp[1]-t_interp[0]) fresponse = np.abs(fresponse)/np.max(np.abs(fresponse)) # Calculate 3dB bandwidth by interpolation log_freq = np.log10(freq[1:]) log_fresp = 20*np.log10(np.abs(fresponse[1:])) resp_3dB = -3 log_freq_3dB = scip.interp1d(log_fresp, log_freq)(resp_3dB) bandwidth_GHz = 10**log_freq_3dB*1e-9  Obtain the frequency response by Fast Fourier Transform. And then calculate the 3dB bandwidth by interpolation.  3.6.8.4 Export the frequency response result​ [60]  bandwidth_file = os.path.join(bandwidth_folder, &quot;3dB_bandwidth.txt&quot;) bandwidth_fig = os.path.join(bandwidth_folder, &quot;3dB_bandwidth.jpg&quot;) with open(bandwidth_file, 'w') as fp: fp.write(&quot;3dB bandwidth: &quot; + f&quot;{bandwidth_GHz:.6f} GHz\\n&quot;) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(freq[1:]*1e-9, 20*np.log10(np.abs(fresponse[1:])), 'b', linewidth=linewidth, label=&quot;Normalized response&quot;) ax.plot(freq[1:]*1e-9, resp_3dB*np.ones(len(freq[1:])), 'g', linewidth=linewidth) ax.set_xlim(left = 1, right = 300) ax.set_ylim(bottom = -25) ax.set_xscale('log') ax.set_ylabel('Normalized response [dB]') ax.set_xlabel('Frequency [GHz]') ax.grid(which='both', axis='both') plt.savefig(bandwidth_fig) # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   Result show of the frequency response Fig 11. Frequency response  "},{"title":"3.7 Saturation power​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#37-saturation-power","content":"This section scans the input light power and obtains the I-P curve, thereby roughly determining the saturation light power. The script is in the VPD04_Psat.py file.  3.7.1 Import simulation toolkit​ [61]  from VPD00_structure import * import time import os from pathlib import Path import numpy as np from matplotlib import pyplot as plt   3.7.2 Set general parameters​ [62]  # region --- 0. General Parameters --- sweep_parameter_name = &quot;source_fraction&quot; sweep_value_table = np.linspace(0.001, 0.02, 20) vbias = 1 # unit:Volt, voltage on cathode # endregion start = time.time() time_str = time.strftime(&quot;%Y%m%d_%H%M%S/&quot;, time.localtime()) # --- set path --- plot_path = str(Path(__file__).parent.as_posix()) + &quot;/plots/&quot; if not os.path.exists(plot_path): os.makedirs(plot_path) simu_name = &quot;VPD04_Psat&quot; material_property = &quot;normal&quot; genrate_file_folder = str(Path(__file__).parent.as_posix()) genrate_file_path = genrate_file_folder + &quot;/VPD01_FDTD.gfile&quot;   3.7.3 Define a sweeping function​ [63]  def sweep_simulation(sweep_value):   3.7.3.1 Set the sweeping parameter​ [64]   # ---------------------- set sweep parameter if not sweep_parameter_name in globals(): raise Exception(f&quot;Parameter {sweep_parameter_name} not found!&quot;) exec(f&quot;global {sweep_parameter_name}; {sweep_parameter_name} = sweep_value&quot;)  Using the features of Python, modify the value of parameter source_fraction corresponding to sweep_parameter_name to the value of sweep_value which is passed from the sweep_simulation function.  3.7.3.2 Create a new project​ [65]   # ---------------------- set project_path project_name = simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str + sweep_parameter_name + &quot;_&quot; + str(sweep_value) + &quot;/&quot; # --- Project from pd_structure.py --- pj = pd_project(project_name, run_mode, material_property)   3.7.3.3 Add electrodes​ [66]   st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: vbias, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  Apply a voltage of 1V to the electrode &quot;cathode&quot; to perform a steady state simulation.  3.7.3.4 Add the solver​ [67]   # ---------------------- set simu simu = pj.Simulation() simu.add(name=&quot;oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: oe_x_span, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: genrate_file_path, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})   3.7.3.5 Run the solver​ [68]   # --- Run --- # check license and print version before &amp; after simulation. result_device = simu[&quot;oedevice&quot;].run()   3.7.3.6 Extract and return the I-V result​ [69]   # --- Extract --- IV_file_folder = plot_path + project_name + &quot;IV_cathode&quot; result_device.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=IV_file_folder) IV_file = os.path.join(IV_file_folder, &quot;0_I_Real.csv&quot;) for i in range(10): IV_file = os.path.join(IV_file_folder, str(i) + &quot;_I_Real.csv&quot;) if os.path.exists(IV_file): break data = np.genfromtxt(IV_file, skip_header=3, delimiter=',') return data   3.7.4 Run the sweeping function and export the result​ [70]  # region --- sweep result postprocess --- fontsize = 20 linewidth = 1 sweep_parameter_label = sweep_parameter_name sweep_parameter_unit = &quot;&quot; Isweep = [] voltages = np.zeros(0) for sweep_value in sweep_value_table: data = sweep_simulation(sweep_value) if len(data.shape) == 1: data = data.reshape((1, len(data))) voltages = data[:,0] Isweep.append(data[:, 1]) Isweep_folder = os.path.join(plot_path, simu_name + &quot;_&quot; + run_mode + &quot;_&quot; + time_str + &quot;Isweep&quot;) if not os.path.exists(Isweep_folder): os.makedirs(Isweep_folder) Isweep = np.array(Isweep) sweep_value_table = np.array(sweep_value_table) plt.rcParams.update({&quot;font.size&quot;: fontsize}) for i in range(len(voltages)): Isweep_fig = os.path.join(Isweep_folder, &quot;Isweep_&quot; + str(voltages[i]) + &quot;V.jpg&quot;) Isweep_file = os.path.join(Isweep_folder, &quot;Isweep_&quot; + str(voltages[i]) + &quot;V.csv&quot;) Iresp = Isweep[:,i] with open(Isweep_file, &quot;w&quot;) as fp: fp.write(f&quot;Vbias={voltages[i]}V,\\n&quot;) fp.write(f&quot;{sweep_parameter_name}&quot; + (f&quot;[{sweep_parameter_unit}]&quot; if sweep_parameter_unit else &quot;&quot;) + &quot;,Current[A]\\n&quot;) for j in range(len(Iresp)): fp.write(f&quot;{sweep_value_table[j]:.15e},{Iresp[j]:.15e}\\n&quot;) fig, ax = plt.subplots() fig.set_size_inches(12, 8) ax.plot(sweep_value_table, Iresp, c='b', linewidth=0.5, label=f&quot;Vbias={voltages[i]}V&quot;) ax.plot(sweep_value_table, Iresp, 'bo') ax.set_ylabel(&quot;I[A]&quot;) ax.set_xlabel(f&quot;{sweep_parameter_name}&quot; + (f&quot;[{sweep_parameter_unit}]&quot; if sweep_parameter_unit else &quot;&quot;)) plt.legend() plt.ticklabel_format(style=&quot;sci&quot;, scilimits=(-1, 2)) ax.grid() plt.savefig(Isweep_fig) plt.close() # endregion print(&quot;\\x1b[6;30;42m&quot; + &quot;[Finished in %(t)s mins]&quot; % {&quot;t&quot;: round((time.time() - start)/60, 2)} + &quot;\\x1b[0m&quot;)   Result show of the I-P curve Fig 12. I-P curve  "},{"title":"4. Appendix​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#4-appendix","content":" "},{"title":"4.1 Electronic parameters of the materials​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#41-electronic-parameters-of-the-materials","content":"The parameter settings in the VPD_material.py file: [71]  elec_Si_properties = {&quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.59-1.11452/2.0, &quot;permitti&quot;: 11.7}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Masetti&quot;, &quot;Masetti&quot;: {&quot;mu_min2_h&quot;: 44.9, &quot;mumax_e&quot;: 1471, &quot;mumax_h&quot;: 470.5, &quot;pc_h&quot;: 0}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;dos_formula&quot;: 2, &quot;nc300&quot;: 3.21657e19, &quot;nv300&quot;: 1.82868e19, # Bandgap &quot;eg0&quot;: 1.16, &quot;chi0&quot;: 4.59-1.16/2, # Bandgap Narrowing &quot;bgn_model&quot;: &quot;OldSlotboom&quot;, &quot;e0_bgn_oldslotboom&quot;: 0.0045, &quot;n0_bgn_oldslotboom&quot;: 1.00e17, &quot;deg0_oldslotboom&quot;: 0, # Auger Recombination &quot;augan&quot;: 2.8e-31, &quot;augap&quot;: 9.9e-32, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 1.5e-9, &quot;taupmax&quot;: 1.5e-9, &quot;nsrh_n&quot;: 7.1e15, &quot;nsrh_p&quot;: 7.1e15, &quot;nc_f&quot;: 1.5, &quot;nv_f&quot;: 1.5, # Radiative Recombination &quot;c_direct&quot;: 1.6e-14}, &quot;print&quot;: 1}} elec_Ge_properties = {&quot;model&quot;: {&quot;high_field&quot;: False}, &quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.5-0.65969/2.0, &quot;permitti&quot;: 16.0}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Analytic&quot;, &quot;Analytic&quot;: {&quot;alphan&quot;: 0.56, &quot;alphap&quot;: 1.0, &quot;mun_max&quot;: 3900, &quot;mun_min&quot;: 850, &quot;mup_max&quot;: 1800, &quot;mup_min&quot;: 300, &quot;nrefn&quot;: 2.6e17, &quot;nrefp&quot;: 1e17, &quot;nun&quot;: -1.66, &quot;nup&quot;: -2.33}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;nc300&quot;: 1.0516e19, &quot;nv300&quot;: 3.9189e+18, # Bandgap &quot;eg300&quot;: 0.65969, &quot;chi300&quot;: 4.5-0.65969/2.0, # Bandgap Narrowing &quot;v0_bgn&quot;: 0, # Auger Recombination &quot;augan&quot;: 1e-30, &quot;augap&quot;: 1e-30, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 1.5e-9, &quot;taupmax&quot;: 1.5e-9, &quot;nsrhn&quot;: 7.1e15, &quot;nsrhp&quot;: 7.1e15, # Radiative Recombination &quot;c_direct&quot;: 6.41e-14}, &quot;print&quot;: 1}} elec_Ge_properties_for_transient = {&quot;model&quot;: {&quot;high_field&quot;: True, &quot;mobility_force&quot;: &quot;EQF&quot;}, &quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.5-0.65969/2.0, &quot;permitti&quot;: 16.0}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Masetti&quot;, &quot;Masetti&quot;: {&quot;pc_e&quot;: 0, &quot;mu_min1_e&quot;: 850, &quot;mu_min2_e&quot;: 850, &quot;mu1_e&quot;: 0, &quot;mumax_e&quot;: 3900, &quot;cr_e&quot;: 2.6e17, &quot;alpha_e&quot;: 0.56, &quot;pc_h&quot;: 0, &quot;mu_min1_h&quot;: 300, &quot;mu_min2_h&quot;: 300, &quot;mu1_h&quot;: 0, &quot;mumax_h&quot;: 1800, &quot;cr_h&quot;: 1e17, &quot;alpha_h&quot;: 1}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;nc300&quot;: 1.1372e+19, &quot;nv300&quot;: 3.9189e+18, # Bandgap &quot;eg300&quot;: 0.65969, &quot;chi300&quot;: 4.5-0.65969/2.0, # Bandgap Narrowing &quot;v0_bgn&quot;: 0, # Auger Recombination &quot;augan&quot;: 1e-30, &quot;augap&quot;: 1e-30, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 1.5e-9, &quot;taupmax&quot;: 1.5e-9, &quot;nsrhn&quot;: 7.1e15, &quot;nsrhp&quot;: 7.1e15, # Radiative Recombination &quot;c_direct&quot;: 6.41e-14}, &quot;print&quot;: 1}, &quot;vsat&quot;: {&quot;model&quot;: &quot;Canali&quot;, &quot;Canali&quot;: {&quot;beta0n&quot;: 2, &quot;beta0p&quot;: 1, &quot;betaexpn&quot;: 0, &quot;betaexpp&quot;: 0, &quot;alpha&quot;: 0, &quot;vsatn0&quot;: 6e6, &quot;vsatp0&quot;: 5.4e6, &quot;vsatn_exp&quot;: 0, &quot;vsatp_exp&quot;: 0}, &quot;print&quot;: 1}}  Description: basic--Set the permittivity and affinity band--Set models and parameters of the band and the recombination mobility--Set the model and parameters of mobility model--Set the switch of high field mobility model and Fermi-Dirac statistics model vsat--Set the model and parameters of velocity saturation For the detailed introduction about electronic parameters, please refer to the document examples/active_demo/Physics_Model_in_OEDevice.pdf.  "},{"title":"4.2 OEDevice settings​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#42-oedevice-settings","content":"OEDevice property list： \tdefault\ttype\tnotesgeneral.norm_length\t1.0\tfloat general.solver_mode\tsteady_state\tstring\tSelections are ['steady_state', 'transient', 'SSAC']. general.temperature_dependence\tIsothermal\tstring\tSelections are ['Isothermal']. general.simulation_temperature\t300\tfloat advanced.non_linear_solver\tNewton\tstring\tSelections are ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', 'LU', 'BCGS']. advanced.use_quasi_fermi\tdisabled\tstring\tSelections are ['disabled', 'enabled']. advanced.damping\tnone\tstring\tSelections are ['none', 'potential']. advanced.potential_update\t1.0\tfloat advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. advanced.thread_count\t4\tinteger advanced.max_iterations\t30\tinteger advanced.use_global_max_iterations\ttrue\tbool advanced.poisson_max_iterations\t30\tinteger advanced.ddm_max_iterations\t30\tinteger advanced.relative_tolerance\t1.0e-5\tfloat advanced.tolerance_relax\t1.0e+5\tfloat advanced.divergence_factor\t1.0e+25\tfloat genrate.genrate_path string genrate.source_fraction float genrate.coordinate_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float geometry.z_min float geometry.z_max float small_signal_ac.perturbation_amplitude\t0.001\tfloat small_signal_ac.frequency_spacing\tsingle\tstring\tSelections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat small_signal_ac.start_frequency\t1.0e+06\tfloat small_signal_ac.stop_frequency\t1.0e+09\tfloat small_signal_ac.frequency_interval\t9.9999e+10\tfloat small_signal_ac.num_frequency_points\t2\tinteger small_signal_ac.log_start_frequency\t1.0e+06\tfloat small_signal_ac.log_stop_frequency\t1.0e+10\tfloat small_signal_ac.log_num_frequency_points\t2\tinteger\t Description: geometry： dimension--Set the dimension of the simulation region. Only 2D simulation is supportd currently. When it's set to &quot;2d_x_normal&quot;, the simulation is on the yz plane. Similarly for the rest general: norm_length--Set the length in the third dimension, default to be 1solver_mode--Set the simulation mode. Steady state, transient and SSAC simulations are supportedtemperature--Set the simulation temperaturetemperature_dependence--Set the type of the temperature dependence. Only &quot;Isothermal&quot; is supported currently genrate: genrate_path--Set the absolute path of the optical generation rate file (gfile) When it's set to &quot;&quot; (by default), and empty string , no optical generation rate will be appliedWhen it's not empty, the gfile at the path will be imported to apply the optical generation rate coordinate_unit--Set the coordinate unit in the gfile field_length_unit--Set the length unit in the generation rate unit in the gfile source_fraction--Set the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport small_signal_ac: perturbation_amplitude--Set the voltage amplitude of the small signal frequency_spacing--Set the spacing type of the frequency When it's set to &quot;single&quot;, the frequency point is singleWhen it's set to &quot;linear&quot;, the frequency points are uniformly sampledWhen it's set to &quot;log&quot;，the frequency points are uniformly sampled base on the logarithm of frequency frequency--Set the value of the single frequency start_frequency--Set the start frequency of linear spacing stop_frequency--Set the stop frequency of linear spacing frequency_interval--Set the frequency interval of linear spacing num_frequency_points--Set the number of frequency points of linear spacing log_start_frequency--Set the start frequency of logarithmic spacing log_stop_frequency--Set the stop frequency of logarithmic spacing log_num_frequency_points--Set the number of frequency points of logarithmic spacing advanced: non_linear_solver--Set the non-linear solver, only Newton method is supported currentlylinear_solver--Set the linear solver. Options are &quot;MUMPS&quot;, &quot;LU&quot;, &quot;BCGS&quot;. MUMPS and LU are direct linear solvers which usually give the exact solution. However, MUMPS supports parallel computation while LU doesn't. ；&quot;BCGS&quot; is a Krylov subspace (KSP) iterative solver, which also supports parallel computation and is more efficient but can only give approximate results.use_quasi_fermi--Whether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. &quot;enabled&quot; means True, and &quot;disabled&quot; means Falsedamping--Set the nonlinear update damping scheme. &quot;potential&quot; means the damping is based on the potential variationpotential_update--Set the threshold potential for potential damping. The large value will reduce the strength of damping effectmulti_threads: When it's set to &quot;let_solver_choose&quot;, the solver will determine the number of threads to use. The default maximum number of threads is 4When it's set to &quot;set_thread_count&quot;, the number of threads is set by the user to thread_count thread_count--Custom number of threadsmax_iterations--Set global maximum number of iterations, available when use_global_max_iterations is Trueuse_global_max_iterations--Whether to use global max iterations during the initialization of solving the Poisson equations and the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, default to be Truepoisson_max_iterations--Set the max iterations during the initialization of solving the Poisson equations, available when use_global_max_iterations is Falseddm_max_iterations--Set the max iterations during the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, available when use_global_max_iterations is Falserelative_tolerance--Set the relative update tolerancetolerance_relax--Set the tolerance relaxation factor for convergence on relative tolerance criteriadivergence_factor--Nonlinear solver fault with divergence when each individual function norm exceeds the threshold as its absolute tolerance multiply by this factor  "},{"title":"4.3 Electrode settings​","type":1,"pageTitle":"Photodetector","url":"/my-website/docs/examples/Active_Device/Photodetector#43-electrode-settings","content":"Electrodes are added and set up through the add_electrode function. The format of the function is [72]  st.add_electrode(name, property)  add_electrode() parameters: name--Electrode nameproperty--Other properties  There are two different type of electrical boundary conditions, which are &quot;steady_state&quot;and &quot;transient&quot;, specified by the property bc_mode.  4.3.1 Steady state boundary condition​ When the property bc_mode is set to &quot;steady_state&quot;, the steady state boundary condition is applied.  Property list of steady state boundary condition: \tdefault\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode\tsteady_state\tstring\tSelections are ['steady_state']. apply_AC_small_signal\tnone\tstring\tSelections are ['none', 'All']. sweep_type\tsingle\tstring\tSelections are ['single', 'range', 'value']. voltage\t0\tfloat\tAvailable when sweep_type is 'single' range_start\t0\tfloat\tAvailable when sweep_type is 'range' range_stop\t1\tfloat\tAvailable when sweep_type is 'range' range_interval\t1\tfloat\tAvailable when sweep_type is 'range' range_num_points\t2\tinteger\tAvailable when sweep_type is 'range' []sweep_value_table.index integer\tAvailable when sweep_type is 'value'. []sweep_value_table.number float\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t Description: surface_type--Type of the surface to be set as an electrode. Currently only &quot;solid&quot; is supported, meaning that all the surfaces of a structure are selected solid--Name of the structure to be set as an electrode. Available when surface_type is set to &quot;solid&quot; force_ohmic--Whether the electrode is ohmic, default to be True. Currently only ohmic contact is supported, so force_ohmic can't be set to False bc_mode--Set to &quot;steady_state&quot; for steady state boundary condition apply_AC_small_signal: When it's set to &quot;none&quot; (as default), no AC small signal is applied at each sweeping voltageWhen it's set to &quot;All&quot;, the AC small signal is applied after steady state simulation at each sweeping voltage sweep_type--Type of sweeping voltage. Options are &quot;single&quot;, &quot;range&quot; and &quot;value&quot; When it's set to &quot;single&quot;, voltage is requiredWhen it's set to &quot;range&quot;, range_start, range_stop, and range_interval or range_num_points are requiredWhen it's set to &quot;value&quot;, sweep_value_table is required voltage--Set the value of the single voltage range_start--Set the start value of the voltage range range_stop--Set the stop value of the voltage range range_interval--Set the voltage interval of the voltage range range_num_points--Set the number of points of the voltage range sweep_value_table--Table of voltage values. It's a list, whose item is a dictionay. In each of its item: index--Set the index of the voltage valuenumber--Set the value of the voltage  Example for single voltage [73]  st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   Example for voltage range [74]  st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: 0, &quot;range_stop&quot;: 1, &quot;range_interval&quot;: 0.5, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   Example for voltage table [75]  st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;value&quot;, &quot;sweep_value_table&quot;: [{&quot;index&quot;: 0, &quot;number&quot;: 0}, {&quot;index&quot;: 1, &quot;number&quot;: 0.5}, {&quot;index&quot;: 2, &quot;number&quot;: 1}]})   4.3.2 Transient boundary condition​ When the property bc_mode is set to &quot;transient&quot;, the transient boundary condition is applied.  Property list of transient boundary condition: \tdefault\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode string\tSelections are ['transient']. voltage\t0\tfloat []time_table.time_start float []time_table.time_stop float []time_table.initial_step float []time_table.max_step float []time_table.optical.enabled\t0\tinteger\tSelections are [0, 1] []time_table.optical.envelop integer\tSelections are [0] []time_table.optical.source_fraction float surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t Description: surface_type, solid, force_ohmic--The same as the one in steady state conditionbc_mode--Set to &quot;transient&quot; for transient boundary condition. Then the time dependence of the optical generation rate can be set at this electrodevoltage--Set the voltage that is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation.v_step_max--Set the max step of the voltage from the equilibrium state to steady state at the bias of voltage.time_table--Set the time dependence of optical generation rate. It's a list, whose item is a dictionary. In each of its item: time_start--Set the start time point of the range. The value of 0 represents the steady state of the earlier simulation.time_stop--Set the stop time point of the rangeinitial_step--Set the initial time step of the rangemax_step--Set the max time step of the rangeoptical--Set the optical generation rate during the time range enabled--Whether to apply optical generation rate during the time range. The value of 1 means True, and 0 means Falseenvelop--The envelop of the scaling factor of the light power during the time range. When it's set to 0, the envelop is uniformsource_fraction--When envelop is set to0, this value is the scaling factor of the light power during the time range  Example for transient boundary condition [76]  st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: 1, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 50e-12, &quot;initial_step&quot;: 1e-15, &quot;max_step&quot;: 1e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}, {&quot;time_start&quot;: 50e-12, &quot;time_stop&quot;: 600e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}]})   "},{"title":"Microring Resonator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/MicroringResonator/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#introduction","content":"Microring resonators are important filtering devices in photonic integrated circuits, ideal filters require a wide free spectrum range(FSR) and high quality factor. Obtaining a large spectral range requires the use of a small radius, but too small a radius can cause bending loss and reduce the quality factor. In order to meet the requirements of free spectrum range and quality factor, it is necessary to design the size of the ring and coupling efficiency. In this example, we demonstrate the use of a finite difference eigenmode solver to calculate the group refractive index of an optical waveguide, then calculate the effective refractive index of symmetric and anti symmetric modes in the coupling region between the optical waveguide and the ring resonator, and finally use 3D FDTD simulation to calculate the transmittance of the drop end of the micro ring resonator. "},{"title":"Simulation​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#simulation","content":""},{"title":"1 Code Description​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#1-code-description","content":"1.1 Import Toolkit​ First, we need to import maxoptics_sdk and Python's third-party package. The import module for FDE and FDTD simulation are shown below. from typing import List, Literal, NamedTuple import time import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path  1.2 Define Simulation Function and parameters​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project.Before starting the simulation, you need to define variables to control the parameters. You can refer to the following script. def simulation(*, run_mode, wavelength, grid, number_of_trial_modes, run_options: &quot;RunOptions&quot;, **kwargs): # region --- 0. General Parameters --- time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) path = kwargs[&quot;path&quot;] simu_name = f&quot;Microring_FDE&quot; project_name = f&quot;{simu_name}_{run_mode}_{time_str}&quot; plot_path = f'{kwargs.get(&quot;plot_dir&quot;, path)}/plots/{project_name}/' kL = [f&quot;0{k}&quot; for k in range(5)] export_options = {&quot;export_csv&quot;: True, &quot;export_mat&quot;: True, &quot;export_zbf&quot;: True} # endregion  1.3 Create project​ You can create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion  1.4 Add Material​ Here we demonstrate using the Material function to create material and using the add_lib function to add materials from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_lib(name=&quot;Si&quot;, data=mo.Material.Si_Palik, order=2) mt.add_lib(name=&quot;SiO2&quot;, data=mo.Material.SiO2_Palik, order=2) # endregion  The name is used to define the name of the added material. The data is used to receive refractive index data extracted from the material library. The order is used to set the material priority of the grid. 1.5 Add waveform​ Adding a light source is for simulating in 3D FDTD, and we use Waveform to set the waveform parameters of the light source. # region --- 3. Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1) # endregion  name sets the name of the waveform, wavelength_center sets the center wavelength of the light source, and wavelength_span sets the wavelength range of the light source. 1.6 Add Structure​ A typical micro ring resonator is composed of SOI waveguides, including two straight optical waveguides and a coupled ring-shaped waveguide. In order to meet the requirements of the free spectrum range, the effective circumference of the ring can be set according to the following formula. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select the type from the structural components. The specific properties can be set as follows. st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;SiO2&quot;]) st.add_geometry(name=&quot;ring&quot;, type=&quot;Ring&quot;,property={&quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 3}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22,&quot;inner_radius&quot;: 2.6, &quot;outer_radius&quot;: 3}}) st.add_geometry(name=&quot;waveguide1&quot;, type=&quot;Rectangle&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;:15, &quot;y&quot;: 3.3, &quot;y_span&quot;: 0.4, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;:3}} ) st.add_geometry(name=&quot;waveguide2&quot;, type=&quot;Rectangle&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;:15, &quot;y&quot;: -3.3, &quot;y_span&quot;: 0.4, &quot;z&quot;: 0, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;:3}} ) st.add_geometry(name=&quot;substrate&quot;, type=&quot;Rectangle&quot;, property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;:15, &quot;y&quot;: 0, &quot;y_span&quot;: 10, &quot;z_min&quot;: -3, &quot;z_max&quot;: -0.11}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;:3}} )  Key\tValue\ttype\tDescriptionname\tring\tstring\tname the added geometry type\tRing\tstring\tselect the type of structure x 0 float center position in the x-direction of the geometric structure material\tmt[&quot;Si&quot;]\tmaterial\tselect the material added Materials mesh_order\t3\tinteger\tset the priority of the material x\t0\tfloat\tthe center coordinate of the ring in the x-direction y\t0\tfloat\tthe center coordinate of the ring in the y-direction z\t0\tfloat\tthe center coordinate of the ring in the z-direction z_span\t0\tfloat\tthe thickness of the ring in the z-direction inner_radius\t2.6\tfloat\tthe size of the inner radius of the ring outer_radius\t3\tfloat\tthe size of the outer radius of the ring The properties of Rectangle can refer to the settings of the Ring. Select simulation material by using mesh_order in areas where geometry overlaps, the priority of structural materials needs to be higher than that of background materials 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. Use geometry to set the size and position of the boundary, and use boundary to set the boundary conditions at the boundary. The properties are shown below. # region --- 4. Boundary --- if run_options.run_fde: st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: -4, &quot;x_span&quot;: 0, &quot;y&quot;: -3.3, &quot;y_span&quot;: 3, &quot;z&quot;: 0, &quot;z_span&quot;: 3}, &quot;boundary&quot;: {&quot;y_min&quot;: &quot;PEC&quot;, &quot;y_max&quot;: &quot;PEC&quot;, &quot;z_min&quot;: &quot;PEC&quot;, &quot;z_max&quot;: &quot;PEC&quot;}}) if run_options.run_fdtd: st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 9, &quot;y&quot;: 0, &quot;y_span&quot;: 9, &quot;z&quot;: 0, &quot;z_span&quot;: 3}, &quot;boundary&quot;: {&quot;x_min&quot;: &quot;PML&quot;, &quot;x_max&quot;: &quot;PML&quot;, &quot;y_min&quot;:&quot;PML&quot;, &quot;y_max&quot;:&quot;PML&quot;, &quot;z_min&quot;: &quot;PML&quot;, &quot;z_max&quot;: &quot;PML&quot;}}) # endregion  1.8 Add source​ Create a light source using Source and add a light source using Add. The settings for the light source are as follows. region --- 5. Source --- src = pj.Source() if run_options.run_fdtd: src.add(name=&quot;modesource&quot;,type=&quot;mode_source&quot;,axis=&quot;x_forward&quot;,property={ &quot;general&quot;:{&quot;mode_selection&quot;:&quot;user_select&quot;,&quot;waveform&quot;:{&quot;waveform_id_select&quot;:wv[waveform_name]}}, &quot;geometry&quot;:{&quot;x&quot;:-4,&quot;x_span&quot;:0,&quot;y&quot;:3.3,&quot;y_span&quot;:2,&quot;z&quot;:0,&quot;z_span&quot;:2}})  endregion Use type to select the type of light source, and axis to set the direction of the mode light source. 1.9 Add Solver​ We use the `Simulation` function to create a simulation and the `add` function to add a solver. The property settings of the solver are as follows.  # region --- 6. Simulation --- simu = pj.Simulation() if run_options.run_fde: simu.add(name=simu_name, type=&quot;FDE&quot;, property={ &quot;general&quot;: {&quot;solver_type&quot;: &quot;2d_x_normal&quot;}, # default is &quot;2d_x_normal&quot; [&quot;2d_x_normal&quot;,&quot;2d_y_normal&quot;,&quot;2d_z_normal&quot;] &quot;mesh_settings&quot;: { &quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}, # &quot;minimum_mesh_step_settings&quot;: {&quot;min_mesh_step&quot;: 1.0e-4} }, &quot;fde_analysis&quot;: { &quot;modal_analysis&quot;: { &quot;calculate_modes&quot;: run_options.run_fde, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength, &quot;wavelength_offset&quot;: 0.0001, &quot;number_of_trial_modes&quot;: number_of_trial_modes, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True, &quot;mode_removal&quot;: {&quot;threshold&quot;: 0.02}}}}) if run_options.run_fdtd: simu.add(name=simu_name, type='FDTD', property={'general': {'simulation_time': 5000 }, 'mesh_settings': {'mesh_type': 'auto_non_uniform', 'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}, 'minimum_mesh_step_settings': {'min_mesh_step': 1e-4}}, 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-4, 'down_sample_time': 200}}, 'thread_setting': {'thread': 12} }) # endregion  Key\tValue\tType\tDescriptionsolver_type\t2d_x_normal\tstring dy\tgrid\tfloat dz\tgrid\tfloat calculate_modes\trun_options.run_fde\tbool mesh_structure\tFalse\tbool wavelength\twavelength\tfloat wavelength_offset\t0.0001\tfloat number_of_trail_modes\tnumber_of_trail_modes\tfloat search\tmax_index\tstring calculate_group_index\tTrue\tbool threshold\t0.02\tfloat\t Key\tValue\tType\tDescriptionsimulation_time\t5000\tfloat mesh_type\tauto_non_uniform\tstring cells_per_wavelength\tgrids_per_lambda min_mesh_step\t1e-4\tfloat auto_shutoff_min\t1.e-4\tfloat down_sample_time\t200\tfloat thread\t12\tint\t In the settings of the FDE solver, use calculate_ Modes controls whether to calculate the mode. Note that we need to calculate the group refractive index of the waveguide and set the calculate_ group_index to True. In the setting of the FDTD solver, s is used to control the simulation time. We set the simulation time to 5000fs, which is greater than the default value of 1000fs. The micro ring resonator is a resonance with a high quality factor. If the simulation time is set too small and the simulation stops before the field decays, the results obtained are incorrect. 1.10 Add Monitor​ In the simulation, Monitorfunction is used to create monitor and add function is used to add a monitor. By using type to select a power monitor, the transmittance and field distribution of the cross-section can be obtained. It is necessary to add a time monitor to check the field strength at the end of the simulation to determine the accuracy of the simulation results. # region --- 9. Monitor --- mn = pj.Monitor() mn.add(name='time_monitor1', type='time_monitor', property={'general': { 'stop_method': 'end_of_simulation', 'start_time': 0, 'stop_time': 100, 'number_of_snapshots': 0}, 'geometry': {'monitor_type': 'point', 'x': 0, 'x_span': 0, 'y': 0, 'y_span': 0, 'z': 0, 'z_span': 0}, 'advanced': {'sampling_rate': {'min_sampling_per_cycle': 10}}}) mn.add(name='x_normal', type='power_monitor',property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 300}, }, 'geometry': {'monitor_type': '2d_x_normal', 'x': -4, 'x_span': 0, 'y': -3.3, 'y_span': 2, 'z': 0, 'z_span': 2}}) mn.add(name='z_normal', type='power_monitor',property={'general': { 'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 100}, }, 'geometry': {'monitor_type': '2d_z_normal', 'x': 0, 'x_span': 9, 'y': 0, 'y_span': 9, 'z': 0, 'z_span': 0}}) #endregion  Key\tValue\tType\tDescriptionstop_method\tend_of_simulation\tstring start_time\t0\tfloat stop_time\t100\tfloat number_of_snapshots\t0\tfloat\t 1.12 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=plot_path + simu_name, simulation_name=simu_name, celldisplay=True, xyratio=(1, 40)) #simu[simu_name].show3d() # endregion  1.14 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation. # region --- 11. Run --- eme_res = simu[simu_name].run() # endregion  1.15 Run and Extract Results​ Extract data using extract, where data is the calculation result data, savepath is the storage path, target is the classification of the data, and monitor_name is the name of the monitor. # region --- 10. See Results --- if run_options.extract: if run_options.run_fde: k = kL[1] res = results.extract(data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_neff_table&quot;, export_csv=True) print(res.to_string(index=False)) for m in range(len(res)): k = kL[2] results.extract(data=&quot;calculate_modes&quot;, savepath=f&quot;{plot_path}{k}_mode{m}&quot;, attribute=&quot;Ey&quot;, mode=m, real=True, imag=False, **export_options, show=False) if run_options.run_fdtd: res = results.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[3]}_profile', monitor_name='x_normal', target='line', plot_x='wavelength', attribute='T', real=True, imag=False, **export_options, show=False) res = results.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[4]}_profile', monitor_name='z_normal', target='intensity', plot_x='x', plot_y='y', attribute='E', real=True, imag=True, **export_options, show=False) # endregion  1.16 Control Switch​ We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code.In a simulation, only one solver will be enabled. When using the FDE solver, set &quot;run_fde&quot; to True and &quot;run_fdtd&quot; to False; When using the FDTD solver, set &quot;run_fdtd&quot; to True and &quot;run_fde&quot; to False. class RunOptions(NamedTuple): index_preview: bool run_fde: bool run_fdtd: bool extract: bool if __name__ == &quot;__main__&quot;: simulation( run_mode=&quot;local&quot;, wavelength=1.55, grid=0.01, grids_per_lambda=14, number_of_trial_modes=5, run_options=RunOptions(index_preview=False,run_fde=False,run_fdtd=True,extract=True))  "},{"title":"2. Output results​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#2-output-results","content":"Length of ring​ We use an FDE solver to calculate the group refractive index of the SOI optical waveguide fundamental mode. The effective length(2πR) of the ring can be calculated using the following formula. FSR=λ2/(2πRng)FSR = {\\lambda}^2/(2{\\pi}Rn_g)FSR=λ2/(2πRng​) Couple length and gap​ transmission​ Use three-dimensional fdtd to calculate the transmittance of the drop end and the field distribution at the resonant frequency. "},{"title":"Analysis and Disscuss​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#analysis-and-disscuss","content":"After the light that meets the resonance conditions is coupled from the waveguide into the ring resonator, it passes through the drop end. As shown in the figure below, there is the maximum electric field at the drop end at the resonant wavelength. Scan the wavelength to find the wavelength with the highest transmission at the drop end.  "},{"title":"References​","type":1,"pageTitle":"Microring Resonator","url":"/my-website/docs/examples/PIC/MicroringResonator/#references","content":"Hammer, M. and Hiremath, K.R. and Stoffer, R. (2004) Analytical approaches to the description of optical microresonator devices. (Invited) In: Microresonators as Building Blocks for VLSI Photonics, 18-25 October 2003, Erice, Italy. pp. 48-71. AIP Conference Proceedings 709. Springer. ISSN 0094-243X ISBN 978-0-7354-0184-6. "},{"title":"1X2 MMI","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/MMI/","content":"","keywords":""},{"title":"Introduction:​","type":1,"pageTitle":"1X2 MMI","url":"/my-website/docs/examples/PIC/MMI/#introduction","content":" Multi-mode interferometer, due to their advantages of low insertion loss, wide bandwidth, simple fabrication process, and good tolerance, have been widely used in important optical devices such as optical switches and wavelength-division multiplexers. The main performance parameters of multi-mode interference couplers include insertion Loss, imbalance, device dimensions, operating bandwidth.  "},{"title":"Simulation Methods​","type":1,"pageTitle":"1X2 MMI","url":"/my-website/docs/examples/PIC/MMI/#simulation-methods","content":" With the EME module, the corresponding cell groups and cell numbers can be set up with the structure, and a parameter sweep can be performed in the propagation sweep to obtain the S-parameters of the device. This parameter sweep helps optimize the core dimensions of the multi-mode interferometer, ensuring desired performance characteristics. Alternatively, FDTD module can be conducted to obtain the intensity distribution of the optical field and the transmittance at each port. This allows the verification of the optimized results for the multi-mode interferometer. After data processing, performance parameters such as the imbalance, insertion loss, and bandwidth of the device can be determined. "},{"title":"Spot size converter","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/ssc/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Spot size converter","url":"/my-website/docs/examples/PIC/ssc/#introduction","content":"The spot size converter (SSC) is an important device for connecting silicon photonic integrated chips and external optical fibers, which can couple the light transmitted in silicon waveguides with low loss into the waveguide. As shown in the figure, SSC has a tapered silicon waveguide with gradually thinning ends and a low refractive index waveguide covered with SiON, and the entire waveguide device is placed in a silicon dioxide environment [1]. The mode field size in a low refractive index waveguide is similar to that in a fiber, so it can effectively couple light from the waveguide into the fiber. Eigenmode expansion (EME) method has great advantages in calculating long tapered waveguide. By dividing multiple elements in the cross-sectional variation area, and then calculating the modes at the interface of the elements and the bidirectional transmission of the modes, the s-matrix of the conical waveguide transmission can be quickly obtained. When using length sweep, only the bidirectional transmission part needs to be calculated to obtain the S parameter of length sweep. "},{"title":"Simulation​","type":1,"pageTitle":"Spot size converter","url":"/my-website/docs/examples/PIC/ssc/#simulation","content":""},{"title":"1. Code Description​","type":1,"pageTitle":"Spot size converter","url":"/my-website/docs/examples/PIC/ssc/#1-code-description","content":"1.1 Import Toolkit​ First, we need to import maxoptics_sdk and Python's third-party package. The import module for EME simulation is shown below. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple  1.2 Define Simulation Function​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. def simulation(*, run_mode=&quot;local&quot;, wavelength=1.55, grid=0.08, number_of_modes=10, run_options: &quot;RunOptions&quot;, **kwargs):  The run_mode variable parameter is used to define the location of the simulation run. The wavelength variable is defined as wavelength of the optical source. The grid variable is defined as grid size. The number_of_modes variable is used to define the number of modes of calculation. 1.3 Define Parameters​ Before starting the simulation, we can define parameters to facilitate modeling and parameterization sweep. The defined parameters are as follows. # region --- 0. General Parameters --- path = kwargs[&quot;path&quot;] simu_name = &quot;EME_SSC&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/SSC.gds&quot; # endregion  The path variable is used to store the path of this Python file. The simu_name variable is used to store simulation names. The time_str variable is used to store the timestamp. The project_name variable is used to store the project name. The plot_path variable is used to store the result path. The gds_file variable is used to store the file path of GDS. 1.4 Create project​ You can create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion  1.5 Add Material​ Here we demonstrate using the Material function to create material and using the add_nondispersion function to add non dispersive materials, as well as using the add_lib function to add materials from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_nondispersion(name=&quot;Si&quot;, data=[(3.476, 0)], order=2) mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.465, 0)], order=2) mt.add_nondispersion(name=&quot;SiON&quot;, data=[(1.50, 0)], order=2) mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) # endregion  The name is used to define the name of the added material. The data is used to input the real and imaginary parts of the refractive index of the material. The order is used to set the grid order of the material. 1.6 Add Structure​ The structure is composed of silicon dioxide substrate, tapered silicon waveguide and polymer covered waveguide. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select &quot;gds_file&quot; in type to establish the model by importing the GDS file. The properties of GDS modeling are shown in the table below. # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;SiO2&quot;]) st.add_geometry(name=&quot;sub&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;SSC&quot;, &quot;layer_name&quot;: (1, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: -1.5, &quot;z_span&quot;: 3}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}}) st.add_geometry(name=&quot;ssc&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;SSC&quot;, &quot;layer_name&quot;: (2, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.1, &quot;z_span&quot;: 0.2}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name=&quot;cover&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;SSC&quot;, &quot;layer_name&quot;: (3, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 1.5, &quot;z_span&quot;: 3}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiON&quot;], &quot;mesh_order&quot;: 1}}) # endregion  Key\tValue\ttype\tDescriptionname\tsub\tstring\tname the added geometry type\tgds_file\tstring\tselect the type of structure path\tgds_file\tstring\tfile path of GDS file cell_name\tSSC\tstring\tname of the GDS cell layer_name\t(1,0)\tlist\tname of the GDS layer x 0 float center position in the x-direction of the geometric structure y\t0\tfloat\tcenter position in the y-direction of the geometric structure z\t-1.5\tfloat\tcenter position in the z-direction of the geometric structure z_span\t3\tfloat\tlength of the geometric structure in the z-direction material\tmt[&quot;Si&quot;]\tmaterial\tselect the material in Material mesh_order\t2\tinteger\tset the priority of the mesh Select simulation material by using mesh_order in areas where geometry overlaps, the higher the number of mesh_order, the higher the priority of the material. 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. The properties are shown below. # region --- 4. Boundary --- st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) # endregion  1.8 Add Sub Mesh​ After light passes through tapered silicon waveguide gradually becoming smaller, the mode field is strongly limited to a very small range. Therefore, it is necessary to use add_mesh to add a transverse grid to accurately calculate the limited light field. Add local mesh as shown below. # region --- 5. Sub Mesh --- st.add_mesh( name=&quot;sub_mesh&quot;, property={&quot;general&quot;: {&quot;dx&quot;: grid, &quot;dy&quot;: grid, &quot;dz&quot;: grid}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) # endregion  The dx,dy,dz are the mesh sizes in the x, y, and z directions, respectively. 1.9 Add EME port​ You can use the port function to create a port and use the &quot;source_port&quot; property to set the location of the source port. You can use the add function to add ports and the properties of port are shown in the table below. # region --- 6. Port --- pjp = pj.Port(property={&quot;source_port&quot;: &quot;left_port&quot;}) pjp.add(name=&quot;left_port&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;}, &quot;advanced&quot;: {&quot;number_of_trial_modes&quot;: 15}}}) pjp.add(name=&quot;right_port&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE&quot;}, &quot;advanced&quot;: {&quot;number_of_trial_modes&quot;: 15}}}) # endregion  key\tvalue\ttype\tdescriptionname\tleft_port\tstring\tthe name of port type\teme_port\tstring\tselect type of port port_location\tleft\tstring\tselect the location of the port y\t0\tfloat\tcenter position of port width y_span\t5.5\tfloat\tport width y\t0.5\tfloat\tcenter position of port height z_span\t7\tfloat\tport height mode_selection\tfundamental_TE\tstring\tselect the mode of port number_of_trial_modes 15 string set the mode of port  1.10 Add Monitor​ In the simulation, Monitorfunction is used to create monitor and add function is used to add a monitor. Select profile_monitor type monitor from the added monitors to view the mode field distribution. # region --- 7. Monitor --- mn = pj.Monitor() for i, _pos in enumerate([-102, -99, 102]): mn.add(name=&quot;section&quot;+str(i+1), type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: _pos, &quot;x_span&quot;: 0, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) mn.add(name=&quot;y_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_y_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}}) mn.add(name=&quot;z_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 5.5, &quot;z&quot;: 0.1, &quot;z_span&quot;: 0}}) # endregion  1.11 Add EME solver​ We use the Simulation function to create a simulation and the add function to add a solver. Select the EME solver in the type, and the properties of the solver are shown in the table below. # region --- 8. solver --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: 15, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: 15, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 200, &quot;cell_number&quot;: 50, &quot;number_of_modes&quot;: 15, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 3, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: 15, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_length_sweep, &quot;parameter&quot;: &quot;group_span_3&quot;, &quot;start&quot;: 50, &quot;stop&quot;: 250, &quot;number_of_points&quot;: 100}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) # endregion  key\tvalue\ttype\tdescriptionname\tsimu_name string name of simulation type\tEME\tstring\tselect the type of solver wavelength\t1.5\tfloat\twavelength of mode use_wavelength_sweep\tTrue\tbool\tselect to enable wavelength sweep span\t2\tfloat\tthe span of cell group cell_number\t1\tfloat\tnumber of cell in the cell group number_of_modes\t15\tfloat\tCalculate the number of modes per cell sc\tnone\tstring\tselect to enable subcell method dy\t0.05\tfloat\thorizontal mesh of cross-section dz\t0.05\tfloat\tLongitudinal mesh of cross-section eme _propagate\tTrue\tbool\tselect to enable EME propagation propagation_sweep True\tbool\tselect to enable length sweep parameter\tgrop_span_3\tstring\tthe area of length sweep start\t50\tfloat\tstarting length of sweep stop\t250\tfloat\tstoping length of sweep number_of_points\t50\tfloat\tnumber of sweep lengths phase\t0\tfloat\tthe initial phase of optical source select_mode\tTE\tstring\tmode of optical source According to different structures and materials, the SSC is divided into four cell groups using cell_group_definition. Set the length of the cell group in span, use cell_number to set the number of cell. The divided cell structure is shown in the following figure. Use number_of_modes to set the number of modes calculated at the interface of adjacent units, and it is necessary to set a sufficient number of modes to obtain the correct results. The area where the structure has not changed, the number of cell_number is set to 1, and sc is set to &quot;none&quot;. In the area of structural changes, multiple cell number need to be used to characterize the structure and the &quot;sub_cell&quot; method is used to reduce the staircase effect caused by discrete changes in the cross-section.  1.12 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, show=False, savepath=plot_path + simu_name, simulation_name=simu_name, celldisplay=True, xyratio=(1, 40)) #simu[simu_name].show3d() # endregion  The celldisplay control whether to display the boundaries of the divided cells. The xyration controls the aspect ratio of the image. 1.13 Calculate Mode​ You can create a new simulation using simu.add function and run the simulation using simu.add function. The type of simulation needs to be selected as &quot;mode_selection:user_select&quot;, and its properties are shown in the table below. Before running EME simulation calculations, we can calculate the mode field distribution of the port by setting the type of mode selection to True and other simulations to False. # region --- 10. Calculate Mode --- if run_options.calculate_modes: for port in [&quot;left_port&quot;, &quot;right_port&quot;]: simu.add(name=port + &quot;_cal_mode&quot;, simulation_name=simu_name, source_name=port, type=&quot;mode_selection:user_select&quot;, property={&quot;modal_analysis&quot;: { &quot;mesh_structure&quot;: True, &quot;calculate_modes&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: number_of_modes, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True, &quot;bent_waveguide&quot;: {&quot;bent_waveguide&quot;: False, &quot;radius&quot;: 1, &quot;orientation&quot;: 0, &quot;location&quot;: &quot;simulation_center&quot;}}}) port_res = simu[port + &quot;_cal_mode&quot;].run() for m in [0, 1]: port_res.extract(data=&quot;calculate_modes&quot;, savepath=plot_path + &quot;00_modeprofile_fdeonly_&quot; + port + &quot;_mode#&quot; + str(m), mode=m, attribute=&quot;E&quot;, real=True, imag=True, export_csv=False, show=False) # endregion  key\tValue\tType\tDescriptionmesh_structure\tTrue\tbool\tselect to view the refractive index distribution of the port calculate_modes True bool select to calculate the mode of cross-section Wavelength\twavelength\tfloat\tcalculate the wavelength of the mode number_of_trial_modes\tnumber_of_modes\tfloat\tnumber of calculation modes search\t&quot;max_index&quot;\tfloat\tmethod of calculating mode calculate_group_index\tTrue\tbool\tselect to calculate group refractive index bent_waveguide\tFalse\tbool\tselect to enable bent waveguide in calculation mode radius\t1\tfloat\tset the radius of the bent waveguide orientation\t0\tfloat\tset the bending direction of the waveguide location\t&quot;simulation_center&quot;\tstring\tset the position of the bent waveguide 1.14 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation. # region --- 11. Run --- eme_res = simu[simu_name].run() # endregion  1.15 Run and Extract Results​ Extract data using extract, where data is the calculation result data, savepath is the storage path, target is the classification of the data, and monitor_name is the name of the monitor. # region --- 12. see result --- eme_res = simu[simu_name].run() eme_res.extract(data=&quot;eme_propagate:facet_data&quot;, savepath=plot_path, real=True, imag=True, export_csv=True) eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) eme_res.extract( data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_y_normal&quot;, monitor_name=&quot;y_normal&quot;, attribute=&quot;E&quot;, export_csv=True) eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;014_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True) for i in range(3): eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;0&quot;+str(15+i)+&quot;_eme_section&quot;+str(i+1), monitor_name=&quot;section&quot;+str(i+1), attribute=&quot;E&quot;, export_csv=True) # --- EME Propagation Sweep Results --- if run_options.run_length_sweep: eme_res.extract(data=&quot;propagation_sweep:sweep&quot;, savepath=plot_path + &quot;10_length_sweep&quot;, export_csv=True) # endregion  The &quot;eme_propagate:facet_data&quot; stores the calculation mode of cells and ports and the total S-matrix. The &quot;eme_propagate:smatrix&quot; stores the S-matrix after bidirectional transmission of the calculation port mode. The &quot;propagation_sweep:sweep&quot; stores the S-matrix corresponding to each length after sweeping. 1.16 Control Switch​ We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code. class RunOptions(NamedTuple): calculate_modes: bool run: bool run_length_sweep: bool extract: bool if __name__ == &quot;__main__&quot;: simulation(run_mode=&quot;local&quot;, wavelength=1.5, grid=0.02, number_of_modes=20, run_options=RunOptions(calculate_modes=True, run=True, run_length_sweep=True, extract=True))  "},{"title":"2 Output Results​","type":1,"pageTitle":"Spot size converter","url":"/my-website/docs/examples/PIC/ssc/#2-output-results","content":"2.1 ModeProfile​ We extracted the first two modes of the input port, and the mode field distribution is shown in the following figure.After the propagation calculation is completed, the extracted results can be viewed in the storage path, and the extraction of the results can only be set before the program runs. As shown in the following figure, it is clearly observed in the monitor that the incident mode field is larger than the emitted mode field. 2.2 EME Propagation​ The EME solver first calculates the mode of the cell boundary cross-section, and then obtains the scattering matrix for each cross-section by matching the tangential electric and magnetic fields. After bidirectional transmission of the scattering matrix for each cross-section, the S-matrix of the entire device can be obtained. To ensure the accuracy of the calculation results, the number of calculated modes in the cross-section can be gradually increased until the results converge. After bidirectional transmission calculation of mode, the electric field distribution in the transmission direction can be constructed. The distribution of the electric field is shown in the following figure. The EME propagation calculation all modes, but only returns the S-matrix of the port mode. As shown in the figure below, the S-matrix is a 2∙2 matrix, where S21 represents the absolute value of the transmission coefficient from port 1 input to port 2 output. Due to the symmetry of the transmission behavior, S12=S21. "},{"title":"Analysis and Discuss​","type":1,"pageTitle":"Spot size converter","url":"/my-website/docs/examples/PIC/ssc/#analysis-and-discuss","content":"When calculating the area of structural change in EME, it is necessary to divide the structure into multiple cells, and the calculated mode is located at interface between adjacent units. The more cells divided, the more accurate the characterization of the structure. In the long tapered waveguide region, the number of cells divided is too small, and the calculated cross-sectional area varies greatly, resulting in a strong staircase effect. Therefore, before calculating EME, it is necessary to divide the structure into enough cells to ensure the accuracy of the results. It should be noted that when calculating the EME transmission of conical waveguides, we need to use the &quot;sub_cell&quot; method, which can reduce the non physical reflection caused by the step change of the unit cross-section. Within the range of input and output straight waveguides, the cross-section of the waveguide remains unchanged, and the &quot;none&quot; method is used to calculate the transmission. We set &quot;run_length_sweep&quot; to True and conducted a length sweep of 50-250 um on the tapered silicon waveguide area. The number of cells divided in the region where the silicon waveguide changes is 50. As shown in the following figure. When the sweeping length is greater than 100 um, the transmission coefficient S21 will fluctuate with the increase of length. When we increase the number of tapered silicon waveguides to 150, the transmission coefficient curve between the sweeping length of 50-250 um becomes smooth. Therefore, in addition to ensuring the number of modes in the unit cross-section, the EME simulation should also have sufficient number of cells.  If you need to sweep the wavelength, you can use &quot;wavelength_sweep&quot; to turn on wavelength sweep. Similar to length sweep, it is necessary to input the starting and ending wavelength and the number of wavelength points in the EME simulation. At each frequency point, the modes of all cell interfaces and EME propagation parts are also calculated. Therefore, wavelength sweep will take longer than length sweep. "},{"title":"References​","type":1,"pageTitle":"Spot size converter","url":"/my-website/docs/examples/PIC/ssc/#references","content":"[1] T. Tsuchizawa et al, “Microphotonics devices based on silicon microfabrication technology”, IEEE J. Select. Topics Quantum Electron. 11, 2005, 232-240 "},{"title":"Polarization split rotator","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/PolarizationSplitRotator/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Polarization split rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitRotator/#introduction","content":"绝缘体上的硅波导具有强的双折射效应，但是很多光学器件对光的偏振十分敏感，因此在光子集成回路常需要增加偏振分束与旋转的设计来获得高性能的器件。 在本例中，我们演示了使用EME求解器计算模式耦合与转换器件的仿真流程。利用非对称的定向耦合器结构将正交偏振的光耦合分开，然后将旋转到我们需要的结构。 Silicon waveguides on insulators have strong birefringence effects, but many optical devices are very sensitive to the polarization of light. Therefore, in photonic integrated circuits, it is often necessary to increase the design of polarization splitting and rotation to obtain high-performance devices. In this example, we demonstrated the simulation process of using an EME solver to calculate mode coupling and conversion devices. Using an asymmetric directional coupler structure to separate the orthogonal polarized light coupling, and then rotate it to the desired structure. "},{"title":"Simulation​","type":1,"pageTitle":"Polarization split rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitRotator/#simulation","content":""},{"title":"1. Code Description​","type":1,"pageTitle":"Polarization split rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitRotator/#1-code-description","content":"1.1 Import Toolkit​ First, we need to import maxoptics_sdk and Python's third-party package. The import module for EME simulation is shown below. import maxoptics_sdk.all as mo from maxoptics_sdk.helper import timed, with_path import os import time from typing import NamedTuple  1.2 Define Simulation Function​ To facilitate parameter changes, we can define function to encapsulate the entire simulation project. def simulation(*, run_mode, wavelength=1.54, global_mesh_grid=0.02, local_mesh_grid=0.01, number_of_modes=10, run_options: &quot;RunOptions&quot;, **kwargs):  The run_mode variable parameter is used to define the location of the simulation run. The wavelength variable is defined as wavelength of the optical source. The grid variable is defined as grid size. The number_of_modes variable is used to define the number of modes of calculation. 1.3 Define Parameters​ Before starting the simulation, we can define parameters to facilitate modeling and parameterization sweep. The defined parameters are as follows. # region --- 0. General Parameters --- cell_number = 72 wavelength_start = 1.50 wavelength_stop = 1.58 wavelength_points = 3 path = kwargs[&quot;path&quot;] simu_name = &quot;EME_PSR&quot; time_str = time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime()) project_name = f'{simu_name}_{run_mode}_{time_str}' plot_path = f'{path}/plots/{project_name}/' gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/PSR.gds&quot; # endregion  The path variable is used to store the path of this Python file. The simu_name variable is used to store simulation names. The time_str variable is used to store the timestamp. The project_name variable is used to store the project name. The plot_path variable is used to store the result path. The gds_file variable is used to store the file path of GDS. 1.4 Create project​ You can create a new project using the Project function of Max's software development toolkit. # region --- 1. Project --- pj = mo.Project(name=project_name, location=run_mode,) # endregion  1.5 Add Material​ Here we demonstrate using the Material function to create material and using the add_nondispersion function to add non dispersive materials, as well as using the add_lib function to add materials from the material library. You can refer to the following script to set material. # region --- 2. Material --- mt = pj.Material() mt.add_nondispersion(name=&quot;Si&quot;, data=[(3.454996, 0)], order=2) mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444991, 0)], order=2) mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2) # endregion  The name is used to define the name of the added material. The data is used to input the real and imaginary parts of the refractive index of the material. The order is used to set the grid order of the material. 1.6 Add Structure​ The structure is composed of silicon dioxide substrate, tapered silicon waveguide and polymer covered waveguide. We use Structure to create structure , where mesh_type is the type of mesh, mesh_factor is the growth factor of the mesh, and background_material is the background material of the structure. Use the add_geometry function to add geometric structures and select &quot;gds_file&quot; in type to establish the model by importing the GDS file. The properties of GDS modeling are shown in the table below. # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.2, background_material=mt[&quot;Air&quot;]) st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;PSR&quot;, &quot;layer_name&quot;: (1, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: -2, &quot;z_span&quot;: 4}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 2}}) st.add_geometry(name=&quot;psr&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;PSR&quot;, &quot;layer_name&quot;: (2, 0)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.22}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}}) # endregion  Key\tValue\ttype\tDescriptionname\tsub\tstring\tname the added geometry type\tgds_file\tstring\tselect the type of structure path\tgds_file\tstring\tfile path of GDS file cell_name\tSSC\tstring\tname of the GDS cell layer_name\t(1,0)\tlist\tname of the GDS layer x 0 float center position in the x-direction of the geometric structure y\t0\tfloat\tcenter position in the y-direction of the geometric structure z\t-1.5\tfloat\tcenter position in the z-direction of the geometric structure z_span\t3\tfloat\tlength of the geometric structure in the z-direction material\tmt[&quot;Si&quot;]\tmaterial\tselect the material in Material mesh_order\t2\tinteger\tset the priority of the mesh Select simulation material by using mesh_order in areas where geometry overlaps, the higher the number of mesh_order, the higher the priority of the material. 1.7 Set Boundary​ Set the boundary size of the simulation structure using optical boundary condition OBoundary. The properties are shown below. # region --- 4. Boundary --- st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 6.05, &quot;x_span&quot;: 73.1, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;boundary&quot;: {&quot;y_min&quot;: &quot;PEC&quot;, &quot;y_max&quot;: &quot;PEC&quot;, &quot;z_min&quot;: &quot;PEC&quot;, &quot;z_max&quot;: &quot;PEC&quot;}, &quot;general_pml&quot;: {&quot;pml_same_settings&quot;:True,&quot;pml_kappa&quot;: 1, &quot;pml_sigma&quot;: 5, &quot;pml_layer&quot;: 10, &quot;pml_polynomial&quot;: 3}}) # endregion  1.8 Add Sub Mesh​ After light passes through tapered silicon waveguide gradually becoming smaller, the mode field is strongly limited to a very small range. Therefore, it is necessary to use add_mesh to add a transverse grid to accurately calculate the limited light field. Add local mesh as shown below. # region --- 5. Sub Mesh --- st.add_mesh( name=&quot;sub_mesh&quot;, property={&quot;general&quot;: {&quot;dy&quot;: local_mesh_grid, &quot;dz&quot;: local_mesh_grid}, &quot;geometry&quot;: {&quot;x&quot;: 6.05, &quot;x_span&quot;: 73.1, &quot;y&quot;: 1.256, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0.4}}) # endregion  The dx,dy,dz are the mesh sizes in the x, y, and z directions, respectively. 1.9 Add EME port​ You can use the port function to create a port and use the &quot;source_port&quot; property to set the location of the source port. You can use the add function to add ports and the properties of port are shown in the table below.  # region --- 6. Port --- pjp = pj.Port(property={&quot;source_port&quot;: &quot;input_te_tm&quot;}) # region --- input_te_tm --- pjp.add(name=&quot;input_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;use_full_simulation_span&quot;: True, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1}, &quot;advanced&quot;: {&quot;offset&quot;: 0.1, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # region --- output_up_te_tm --- pjp.add(name=&quot;output_up_te_tm&quot;, type=&quot;eme_port&quot;, property={ &quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: 2.6785, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # region --- output_down_te_tm --- pjp.add(name=&quot;output_down_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;right&quot;, &quot;use_full_simulation_span&quot;: False, &quot;y&quot;: 0, &quot;y_span&quot;: 2, &quot;z&quot;: 0.11, &quot;z_span&quot;: 2}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1, &quot;search&quot;: &quot;max_index&quot;}, &quot;advanced&quot;: {&quot;offset&quot;: 0, &quot;number_of_trial_modes&quot;: number_of_modes}}}) # endregion # endregion  key\tvalue\ttype\tdescriptionname\tleft_port\tstring\tthe name of port type\teme_port\tstring\tselect type of port port_location\tleft\tstring\tselect the location of the port y\t0\tfloat\tcenter position of port width y_span\t5.5\tfloat\tport width y\t0.5\tfloat\tcenter position of port height z_span\t7\tfloat\tport height mode_selection\tfundamental_TE\tstring\tselect the mode of port number_of_trial_modes 15 string set the mode of port  1.10 Add Monitor​ In the simulation, Monitorfunction is used to create monitor and add function is used to add a monitor. Select profile_monitor type monitor from the added monitors to view the mode field distribution. # region --- 7. Monitor --- mn = pj.Monitor() mn.add(name=&quot;z_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 6.05, &quot;x_span&quot;: 73.1, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0}}) for i, pos in enumerate([-29.5, 17.5, 23.5, 34.5, 39.5]): mn.add(name=&quot;section&quot;+str(i+1), type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: pos, &quot;x_span&quot;: 0, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}}) # endregion  1.11 Add EME solver​ We use the Simulation function to create a simulation and the add function to add a solver. Select the EME solver in the type, and the properties of the solver are shown in the table below. # region --- 8. Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 6, &quot;cell_number&quot;: 6, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 30, &quot;cell_number&quot;: 6, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 12, &quot;cell_number&quot;: 6, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 8.9, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 5, &quot;cell_number&quot;: 10, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 5.2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 5, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: global_mesh_grid, &quot;dz&quot;: global_mesh_grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;wavelength_sweep&quot;: { &quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: wavelength_start, &quot;stop&quot;: wavelength_stop, &quot;number_of_wavelength_points&quot;: wavelength_points}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}}) # endregion  key\tvalue\ttype\tdescriptionname\tsimu_name string name of simulation type\tEME\tstring\tselect the type of solver wavelength\t1.5\tfloat\twavelength of mode use_wavelength_sweep\tTrue\tbool\tselect to enable wavelength sweep span\t2\tfloat\tthe span of cell group cell_number\t1\tfloat\tnumber of cell in the cell group number_of_modes\t15\tfloat\tCalculate the number of modes per cell sc\tnone\tstring\tselect to enable subcell method dy\t0.05\tfloat\thorizontal mesh of cross-section dz\t0.05\tfloat\tLongitudinal mesh of cross-section eme _propagate\tTrue\tbool\tselect to enable EME propagation propagation_sweep True\tbool\tselect to enable length sweep parameter\tgrop_span_3\tstring\tthe area of length sweep start\t50\tfloat\tstarting length of sweep stop\t250\tfloat\tstoping length of sweep number_of_points\t50\tfloat\tnumber of sweep lengths phase\t0\tfloat\tthe initial phase of optical source select_mode\tTE\tstring\tmode of optical source According to different structures and materials, the SSC is divided into four cell groups using cell_group_definition. Set the length of the cell group in span, use cell_number to set the number of cell. The divided cell structure is shown in the following figure. Use number_of_modes to set the number of modes calculated at the interface of adjacent units, and it is necessary to set a sufficient number of modes to obtain the correct results. The area where the structure has not changed, the number of cell_number is set to 1, and sc is set to &quot;none&quot;. In the area of structural changes, multiple cell number need to be used to characterize the structure and the &quot;sub_cell&quot; method is used to reduce the staircase effect caused by discrete changes in the cross-section. 1.12 View Structure​ You can use the structure_show function to view the top view of the structure, or use the simu[simu_name].show3d() call gui to view the structure. # region --- 9. Structure Show --- st.structure_show(fig_type=&quot;png&quot;, savepath=plot_path + simu_name, simulation_name=simu_name, celldisplay=True, xyratio=(1, 5), disabled_components=(&quot;box.coordinate&quot;,), show=False) #simu[simu_name].show3d() # endregion  The celldisplay control whether to display the boundaries of the divided cells. The xyration controls the aspect ratio of the image. 1.13 Calculate Mode​ You can create a new simulation using simu.add function and run the simulation using simu.add function. The type of simulation needs to be selected as &quot;mode_selection:user_select&quot;, and its properties are shown in the table below. Before running EME simulation calculations, we can calculate the mode field distribution of the port by setting the type of mode selection to True and other simulations to False. # region --- 10. Calculate Mode --- if run_options.calculate_modes: for port in [&quot;input_te_tm&quot;, &quot;output_up_te_tm&quot;, &quot;output_down_te_tm&quot;]: simu.add(name=simu_name+&quot;_&quot;+port+&quot;_cal_mode&quot;, simulation_name=simu_name, source_name=port, type=&quot;mode_selection:user_select&quot;, property={&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: True, &quot;mesh_structure&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: number_of_modes, &quot;calculate_group_index&quot;: True}}) port_res = simu[simu_name+&quot;_&quot;+port+&quot;_cal_mode&quot;].run() for m in range(number_of_modes): port_res.extract(data=&quot;calculate_modes&quot;, savepath=plot_path + &quot;00_modeprofile_fdeonly_&quot; + port + &quot;_mode#&quot; + str(m), mode=m, attribute=&quot;E&quot;, export_csv=False) # endregion  key\tValue\tType\tDescriptionmesh_structure\tTrue\tbool\tselect to view the refractive index distribution of the port calculate_modes True bool select to calculate the mode of cross-section Wavelength\twavelength\tfloat\tcalculate the wavelength of the mode number_of_trial_modes\tnumber_of_modes\tfloat\tnumber of calculation modes search\t&quot;max_index&quot;\tfloat\tmethod of calculating mode calculate_group_index\tTrue\tbool\tselect to calculate group refractive index bent_waveguide\tFalse\tbool\tselect to enable bent waveguide in calculation mode radius\t1\tfloat\tset the radius of the bent waveguide orientation\t0\tfloat\tset the bending direction of the waveguide location\t&quot;simulation_center&quot;\tstring\tset the position of the bent waveguide 1.14 Run​ Pass in the name of the simulation and use simu[simu_name].run function to run the simulation. # region --- 11. Run --- eme_res = simu[simu_name].run() # endregion  1.15 Run and Extract Results​  # region --- 12. See Results -- if run_options.extract: # region --- 12.1 EME Results -- if run_options.run: # region --- facet data --- eme_res.extract(data='eme_propagate:facet_data', savepath=plot_path, real=True, imag=True, export_csv=True) # endregion # region --- smatrix_intensity --- eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True) # endregion # region --- monitor --- eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True) for i in range(5): eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_section&quot;+str(i+1), monitor_name=&quot;section&quot;+str(i+1), attribute=&quot;E&quot;, export_csv=True) # endregion # endregion # region --- 12.2 EME Wavelength Sweep Results --- if run_options.run_wavelength_sweep: &quot;&quot;&quot; 20_wavelength_sweep &quot;&quot;&quot; eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) # endregion # endregion  1.16 Control Switch​ We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code. class RunOptions(NamedTuple): calculate_modes: bool run: bool run_wavelength_sweep: bool extract: bool if __name__ == &quot;__main__&quot;: simulation(run_mode=&quot;local&quot;, wavelength=1.50, global_mesh_grid=0.05, local_mesh_grid=0.03, number_of_modes=15, run_options=RunOptions(calculate_modes=True, run=True, run_wavelength_sweep=True, extract=True))  "},{"title":"2 Output Results​","type":1,"pageTitle":"Polarization split rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitRotator/#2-output-results","content":"2.1 ModeProfile​ 2.2 EME Propagation​  "},{"title":"Analysis and Discuss​","type":1,"pageTitle":"Polarization split rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitRotator/#analysis-and-discuss","content":"其中一个模式在特定波导截面的宽度时，满足模式匹配条件的偏振光耦合进入附近的波导中，另一个偏振模式的光则不满足模式匹配条件继续沿着波导传输。 "},{"title":"References​","type":1,"pageTitle":"Polarization split rotator","url":"/my-website/docs/examples/PIC/PolarizationSplitRotator/#references","content":""},{"title":"Y branch","type":0,"sectionRef":"#","url":"/my-website/docs/examples/PIC/ybranch/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Y branch","url":"/my-website/docs/examples/PIC/ybranch/#introduction","content":" The Y-junction splitter is a fundamental component of integrated optics. Its primary function is to split the incoming light from a single input waveguide into two separate waveguides (splitter). Likewise, it can also combine light from two waveguides into a single waveguide (combiner). The main performance parameters of the Y-junction splitter include insertion loss, device dimensions, *and operating bandwidth.  "},{"title":"Simulation Methods​","type":1,"pageTitle":"Y branch","url":"/my-website/docs/examples/PIC/ybranch/#simulation-methods","content":" Through the FDTD module or EME module, the Y-junction splitter‘s structure can be optimized to obtain the transmittance of fundamental mode or S-parameters of each output port. This optimization process aims to improve the Y-junction splitter's insertion loss and bandwidth performance. "},{"title":"Installation","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Installation","content":"","keywords":""},{"title":"怎样安装软件Max-Optics GUI？​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#怎样安装软件max-optics-gui","content":"Max-Optics Studio Local Passive Software Installation 1. Open the Installation Package​ Find the Setup.exe package, double-click to open the MOPassive-x.x.x.x+build.xxxxxxxx-setup installation package.  If there is a pop-up window come out, please press the “Run” button and wait to run.  Check the contents and click &quot;I Accept The Agreement&quot; item, then click &quot;Next&quot;.  2. Select Destination Location​ User can custom destination location by pressing “Browse...” button , or just use the auto-default location, then press the “Next” button.  3. Select Start Menu Folder &amp; Create a Shortcut​ In the &quot;Select Start Menu Folder&quot; window, users can either click the &quot;Next&quot; button directly or customize the location for shortcuts by clicking the &quot;Browse...&quot; button.  In the &quot;Select Additional Tasks&quot; window, users can choose to create a desktop shortcut by selecting the &quot;Create a desktop shortcut&quot; option, and then proceed by clicking the &quot;Next&quot; button. Alternatively, users can simply uncheck the option and click the &quot;Next&quot; button directly.  4. Ready to Install​ In the &quot;Ready to Install&quot; window, click the &quot;Install&quot; button to proceed with the installation. 5. Installing​ Please wait, until installation is complete.  6. Restart​ Check either the “yes, restart the computer now” or “No, I will restart the computer later” to invoke the software. Then press “Finish” button.  7. Complete​ Once the installation is complete, the user can find a shortcut to the software on their desktop.  Notes: User can double click the shortcut to invoke the software; User also can double click a .passive file to open the software automatically "},{"title":"怎样安装软件 Max-Optics SDK​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#怎样安装软件-max-optics-sdk","content":"1. 安装Python​  AIO SDK仅支持Python3.8.x，如已安装Python，请确认Python的版本。如安装了多个版本的Python，请确认环境变量中PATH里的Python版本是否为Python3.8.x。如未安装Python，请根据下面引导进行操作。 ①打开试用包中的&quot;python-3.8.X-amd64.exe&quot;；  ②选择“Customize installation”； ③勾选“Add Python 3.8 to PATH”；  注意：自定义安装路径时，请确认安装路径的文件夹命名没有空格。空格会导致SDK无法找到Python路径（代码语法的原因）。建议使用的安装路径：''D:\\Python\\Python38''，此路径与SDK中settings.json默认设置路径一致。 2. 安装VScode​  Python代码环境下，使用代码编辑器利于SDK仿真脚本结果的管理。这里，我们选择免费代码编辑器Visual Studio Code（vscode）作为SDK脚本编辑器。此部分为vscode的安装引导流程及注意事项。 ① 安装&quot;VSCodeUserSetup-x64-1.74.3.exe&quot;，选择默认设置即可；  ② 在扩展中搜索并安装python插件，使vscode更好地支持Python编译环境。  注意：之后SDK的安装和后续模型仿真，均在vscode的界面中完成。 3. 安装SDK​ SDK的目录结构： ├─.vscode │ settings.json │ tasks.json │ ├─ci │ requirements.txt │ └─wheels SDK的依赖包.whl  .vscode为使SDK支持VSCode中运行任务的配置文件；ci中的requirements.txt为安装SDK所需的依赖及版本信息；wheels为安装SDK所需的所有所有依赖； P.S.依赖为SDK实现各种功能所需的各种模块包。 3.1 存放SDK文件夹  将SDK文件夹放在希望管理模型脚本和仿真数据的目录中；建议放在D盘根目录。 3.2 使用vscode打开SDK文件夹 （1）单击vscode的&quot;文件&quot;; （2）在下拉框中选择“打开文件夹”； （3）选择AIO_SDK文件夹。 3.3 配置SDK所需的vscode环境 （1）在vscode的资源管理器中打开“.vscode”文件中的settings.json文件；  （2）在编辑区将路径设为python3.8.x.exe所在路径；默认路径为&quot;D:\\Python\\Python38\\python.exe&quot;。详见python安装部分的说明。  3.4 创建Python虚拟环境的原因  虚拟环境是独立于整个电脑操作系统的环境。在虚拟环境中安装、运行AIO_SDK，可以保证AIO_SDK调用依赖时，不与Windows环境中已存在的依赖产生冲突。依赖冲突可能导致SDK无法正常运行。  我们已配置好生成虚拟环境并安装AIO_SDK的脚本（tasks.json)，但是Windows为了保证系统安全，可能会阻止该配置脚本的运行。因此这里我们先修改Windows脚本的运行策略，保证后续的步骤能顺利进行。 3.5 修改Windows脚本的运行策略 (1) 以管理员身份运行“Windows PowerShell”；  (2) 输入&quot;Set-ExecutionPolicy RemoteSigned&quot;后按回车键。如提示是否变换策略，请输入&quot;Y&quot;并回车。此时，Windows脚本运行安全策略已改变。  3.6 通过Create PIP任务进行创建。  点击终端，在下拉菜单中点击运行任务；后会在vscode中弹出新的菜单；在该菜单中选择Create PIP。    VSCode会自动打开终端进行SDK的安装, 安装结束后, 按任意键退出。  4. 启用虚拟环境​  通过上面的步骤，在vscode资源管理器中应出现.venv_maxoptics的文件夹；我们需要调用安装好SDK的虚拟环境进行仿真，下面是配置步骤。  （1）在vscode中单击F1键，弹出菜单栏，如图所示。  (2) 单击Python：选择解释器；在新的菜单中选择如图所示的解释器。此解释器即为安装好SDK的虚拟环境。  (3) 启动新的终端，在终端栏看到出现（.venv_maxoptics）的虚拟环境标识，即成功启动虚拟环境。  5. 查看Handbook的方法​  在VSCode中打开一个终端, 此时会激活.venv_maxoptics虚拟环境, 通过输入“mo.sdk doc“命令即可查看手册。此步骤亦可作为软件正确安装的测试方法。   6. Copy Examples的方法​  在VSCode中打开一个终端, 此时会激活.venv_maxoptics虚拟环境, 通过输入”mo.sdk init -n examples”命令，可导入仿真模型案例。  其中, -n为要拷贝的目标文件夹名称   此时, 会在AIO_SDK文件夹下创建一份名为examples的脚本样例。  7. Run File​  在examples文件夹中，打开一个案例脚本的.py文件, 在终端中运行Run File任务，即可执行脚本，进行仿真。  8. License配置​  注意：试用License与无源单机版相同，如已配置好无源单机版的License，无需重复配置。 （1）在线方式激活授权码 ①打开授权管理工具“MaxOpticsSDK__LicenseManager_x64.exe”； ②点击激活（左上第一个按钮），选择“通过联网方式自动激活“，确定； （2）离线方式激活授权码 ①打开授权管理工具“MaxOpticsSDK__LicenseManager_x64.exe”； ②点击激活（左上第一个按钮），选择“不能连接互联网，通过离线方式激活“，确定； ③选择“使用激活文件“，将文件类型换为*.txt，打开”ZAKT5VW6LY37KNU7-pre.txt“文件； ④弹出授权成功对话框，并提示保存确定文件。点击确定选择任意文件夹保存“确认文件”。 "},{"title":"Create PIP时报错找不到相应版本怎么办？​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#create-pip时报错找不到相应版本怎么办","content":" 如果您在安装SDK的过程中Creat PIP时出现报错： ERROR: Could not find a version that satisfies the requirement max_optics_sdk~   您需要先检查一下Python的版本号是否是3.8.*，目前我们不支持除此之外的版本。其次wheel文件夹中是否包含以下三个文件： max_optics_local_sdk-2.3.0.4.630.2001-cp38-cp38-win_amd64.whl max_optics_sdk-2.3.0.4.630.2000-py3-none-any.whl max_optics_whale-2.3.0.4.630.2003-cp38-cp38-win_amd64.whl  最后再查看一下requirements.txt中的版本信息是否与以上三个文件中的版本信息相符。 "},{"title":"安装软件后首次打开时报错Tunnel Breakoff怎么办？​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#安装软件后首次打开时报错tunnel-breakoff怎么办","content":" 您可以检查是否将软件误装在中文路径下，是否已关闭不支持安装使用的杀毒软件目前腾讯管家和Windows Defender支持MO软件使用），并且检查是否已启动服务。  然后重启电脑，重装软件检查是否装在C盘（部分用户C盘权限不够）。  最后以管理员身份运行..\\MOService\\bin\\Release\\mol-mid-pas-console.exe（中间件服务）。 "},{"title":"怎样去配置和使用集团服务？​","type":1,"pageTitle":"Installation","url":"/my-website/docs/faq/Installation#怎样去配置和使用集团服务","content":" 我们Max-Optics系列产品采用集团授权服务来提供安全又可靠的软件保护和授权管理方案，并且在用户端具有相同的license配置方法。由于单机有源软件产品中涉及并使用到第三方软件，需要单独配置第三方软件的license。 集团授权是指部署在集团用户的局域网内部，并且用户需要安装单独的集团授权服务程序，来为集团内用户提供整体授权支持。  在安装好相应的Max-Optics软件产品之后，配置集团服务的过程如下： 1、首先你需要向贵公司的管理员获取License服务器IP地址和端口号，形式如：192.168.91.67:8273。 2、在软件安装包中找到BitAnswer用户端配置软件，一般是在BitAnswer文件夹下。  3、双击配置软件，打开配置界面。  4、你可以选择“自动查找”或“手动设置”的方式配置License服务地址。 (1)自动查找 ①在“集团服务器列表”中选择对应的IP地址行，如果没有对应的IP地址，点“刷新”按钮。  ②在“集团服务器列表”中选择对应的IP地址行，点“应用”按钮  ③提示“服务器设置成功”，点“确定”按钮。  ④在“集团服务器设置工具”窗口，点“退出”按钮，至此配置完成。  （2）手动设置 ①在“设置集团服务器地址”窗口，输入你获得的IP地址和端口，点“设置”按钮。  ②在“集团服务器设置工具”窗口，点“退出”按钮，至此配置完成。  4、Max-Optics Studio有源单机版及有源SDK额外配置  Max-Optics Studio有源单机版及有源SDK产品由于用到了第三方的软件，需要额外配置第三方的软件的license文件，其提供的license文件分试用版和正式版。其中试用版是指license文件可支持多人使用，供用户在正式购买前试用。正式版是指license文件只支持用户绑定唯一物理机地址使用。 如同时安装Max-Optics Studio有源单机版和有源SDK，第三方软件的license只需配置一次。 （1）配置方法一  首先放置license文件，其次再配置环境变量。这种配置方法仅适用试用版license文件。 ①先将license文件，放在一个路径下，这个路径客户可以根据自己习惯设置，本文作者设置路径如下图：  ②打开系统环境变量配置界面，在系统变量中配置个新的变量，变量名为“LM_LICENSE_FILE”（必须是这个名字），变量的值就是license文件的绝对路径。 打开“搜索”窗口，输入“环境变量”，可以找到“编辑系统环境变量”，选中打开窗口。  选择“高级”标签，选择“环境变量”按钮。  选择“新建”按钮。  填写“变量名”和“变量值”后，点“确定”按钮，返回上级界面。  在界面上，点“确定”按钮，返回上级界面。  在界面上，点“确定”按钮，至此设置完成。  （1）配置方法二  正式版license文件只适用配置方法二，试用版license也可以用配置方法二。 ①查看本机信息  在命令行中运行 ipconfig /all ，查看Windows IP配置，记录主机名、以太网适配器的物理地址这两个数据，接下来的步骤要用。  ②修改license文件 需要修改提供给你的license文件（*.lic）内容，正常内容如下：   第一行请根据本机情况，修改相应的数据，其中 MG-SE-limao-01为本机的主机名，1C697AF3CF58 为本机的物理地址（输入时不要带上“-”）；第二行必须是VENDOR COGENDA, 请和上图保持一致；第三行必须是 USE_SERVER, 请和上图保持一致。 ③双击启动shell.bat脚本  找到你安装第三方软件的目录（默认安装路径：C:\\Program Files\\Genius），进入Bin文件夹，将你修改过的license文件拷贝到这里，之后双击启动同目录下的shell.bat。  ④输入激活服务的命令 在启动窗口中，输入：lmgrd -c license文件名.lic；其中-c 选项是第三方软件的证书地址路径。  验证成功后会跳出两个窗口，使用第三方软件时请勿关闭这些窗口。   集团授权只服务支持特定数量的用户，当使用人数达到上限时，会提示“激活的机器数量已达上限，授权码不能再更多的机器上使用”，具体常见问题和错误信息请访问网址：https://bit.bitanswer.cn/doc/?t=welcome  如在使用过程中遇到问题，请联系贵公司的管理员或曼光的技术支持人员。 电话: 150 6666 1688邮箱: sales@max-optics.com "},{"title":"General","type":0,"sectionRef":"#","url":"/my-website/docs/faq/General","content":"","keywords":""},{"title":"What is Max-Optics?​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#what-is-max-optics","content":" "},{"title":"公司简介：​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#公司简介","content":"上海曼光信息科技有限公司，成立于2018年8月。公司依托山东大学科研团队力量，凭借坚实的电磁场仿真与分析理论与技术基础，以及完备的自动化设备设计与制造、软件设计与开发能力研发出覆盖微波及光学频段的电磁场可视化软硬件产品，为客户提供完善的电磁场相关的仿真、设计、分析、测量解决方案。 公司业务面向5G、光通信、光电传感、光计算、工业物联网、国防安全等领域，主要涵盖电磁场仿真与测量两大业务。电磁仿真业务主要产品包括无源/有源光电芯片及系统仿真设计软件、光电芯片仿真设计服务、微波/射频天线仿真设计服务。电磁场测量业务光电子器件测量与参数提取平台；微波毫米波测量业务主要产品包括5G NR OTA测试系统、平面/柱面/球面近远场天线测试系统；公司以客户为中心，从客户直接需求出发，完成涵盖自动化测量设备软硬件定制化设计、制造、开发、交付的交钥匙工程，并提供电磁场相关设计与测量分析增值服务。 "},{"title":"Company Profile:​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#company-profile","content":"Shanghai Max-Optics Information Technology Co.,Ltd was established in August 2018. With the support of the research team from Shandong University, the company has developed electromagnetic field visualization software and hardware products covering microwave and optical frequency bands, based on solid electromagnetic field simulation and analysis theory and technology foundation, as well as comprehensive capabilities in automated equipment design and manufacturing, software design and development. These products provide customers with comprehensive solutions for electromagnetic field simulation, design, analysis, and measurement. The company's business focuses on 5G, optical communication, optoelectronic sensing, optical computing, industrial IoT, and defense security. It mainly covers two major businesses: electromagnetic field simulation and measurement. The electromagnetic simulation business includes simulation design software for passive/active optoelectronic chips and systems, optoelectronic chip simulation design services, and microwave/radio frequency antenna simulation design services. The electromagnetic field measurement business includes optoelectronic device measurement and parameter extraction platforms. The microwave millimeter wave measurement business mainly includes 5G NR OTA testing systems, planar/cylindrical/spherical near-field and far-field antenna testing systems. The company is customer-oriented, starting from the direct needs of customers, and completes turnkey projects that cover customized design, manufacturing, development, and delivery of automated measurement equipment hardware and software. It also provides value-added services for electromagnetic field design and measurement analysis. "},{"title":"我们具有哪些优势？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#我们具有哪些优势","content":"​ 我们是第一家基于“本地+云”计算平台的光子集成电路(PIC)仿真软件公司，能够为行业提供随时随地的软件+资源+技术支持的一站式服务。 软件仿真的重要性： ​ 随着半导体器件向更小尺寸和更复杂结构方向发展，采用仿真软件解决方案相较于实验室测量法具有众多优势，在研发半导体器件过程中发挥着关键作用。通过高度精确的算法能够快速建模仿真器件，而且能够观察到器件内部的物理过程。客户通过仿真软件不仅可以设计新型复杂的器件结构，还可以通过改变器件的工作条件或者器件模型中各种物理量及其参数，来提出优化器件性能的方案。光电集成芯片模拟设计到从材料到系统的不同领域的不同类型的模拟，使用仿真软件不仅能够降低生产成本、缩短开发周期并提高生产力，而且清晰简明的结果数据也方便不同领域的研究人员们共同交流协作完成较为复杂的工程。 软件独特性： ​ 我们推出了基于“本地+云”的两种软件形式，一种是基于python脚本的软件开发工具包SDK，具有建模、仿真、后处理和数据显示的功能，能够调用所有模块并且简单易学易扩展；另一种是GUI用户页面，您可以利用两者的交互来进行仿真。同时我们还搭配先进的网格优化和GPU加速功能来缩短仿真时间。我们还推出了虚拟机版本和Windows版本用于满足客户不同的仿真搭建环境。 产品优势： ​ 我们目前结合多种仿真算法为无源器件和有源器件提供高效、可靠的一站式解决方案。我们的仿真具有跟行业领先相媲美的精度和速度。 "},{"title":"我们目前有哪些产品？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#我们目前有哪些产品","content":"​ 我们目前支持的器件包括无源器件、调制器、探测器和激光器。我们改进经典CEM算法来分析光的行为，并且基于“本地+云”的新颖UI配置将无源模块用于模拟光波导和无源光学器件。并且将载流子输运仿真算法和电磁仿真算法相结合，为光电有源器件的仿真提供了高效可靠的一站式解决方案。 ​ 若希望了解更多相关器件产品的具体信息，请移步网站的 &quot;Example Library&quot;模块查看相关器件的案例说明。​ 若希望了解更多相关软件产品SDK的具体信息，请移步网站的 &quot;Max-Optics SDK&quot;模块查看相关器件的案例说明 "},{"title":"无源器件仿真有哪些功能？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#无源器件仿真有哪些功能","content":"我们改进经典CEM算法和基于“本地+云”的新颖UI配置将无源模块用于模拟光波导和无源光学器件。以下是无源器件支持的模块。 FDTD模块\t共享模块\tEME模块• Mode/Gaussian/Import source • PML/PEC boundary • 0D/1D/2D/3D frequency monitor • 0D/1D/2D/3D time monitor • Early Shutoff • Transmission calculation • Mode expansion • S-parameters calculation • Global parameter sweeping • Multi-threaded computing\t• 3D Modeling• GDS import • Tilt slope of waveguide profile • Non-Uniform/Uniform Mesh • Conformal Mesh Refinement • Standard material library • Custom isotropic/diagonally anisotropic materials • Far field\t• Effective Index Calculation • Group Index Calculation • Arbitrary port settings • PEC/PMC/PML boundary • 2D frequency domain monitor • S-parameter calculation • Frequency Sweeping • Group span quick sweeping • Overlap Analysis • Multi-threaded Computing "},{"title":"有源器件仿真有哪些功能？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#有源器件仿真有哪些功能","content":"我们有源模块将光模块和电模块真正集成在一起，结合载流子输运仿真算法和电磁仿真算法，通过一次建模实现多次不同仿真为光电有源器件的仿真提供了高效可靠的一站式解决方案。以下是有源器件支持的模块。 AFDTD模块\tAFDE模块\tOEDevice模块• Mode Source • PML/PEC Boundary • 0D/1D/2D/3D Frequency Monitor • Early Shutoff • Transmission Calculation • Multi-thread Computing • Generation Rate Extraction\t• Effective Index Calculation • Group Index Calculation • VpiL, VpiLoss Extraction\t• Steady State / SSAC / Transient Simulation • Physical Models and Parameters of Electrical • Materials • Multi-thread Computing • Convergence Control • Carrier / Potential / Band Profile Monitor • Doping Import • Generation Rate Import 共享模块\tAFDTD与AFDE共享模块• 3D Modeling • GDS Import\t• Non-Uniform/Uniform Mesh • Conformal Mesh Refinement • Standard Material Library • Custom Isotropic Optical Materials "},{"title":"应用到的仿真模块有哪些？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#应用到的仿真模块有哪些","content":"​ 我们对器件结构和掺杂、仿真区域划分网格并采用有限差分的数值方法，用差分代替微分进行近似求解。使用有限差分本征模（FDE）方法探究本征模的场分布以及器件的折射率和损耗。时域有限差分法（FDED）探究小中型器件的传输速率、反射率和损耗等特性。使用本征模扩展算法（EME）讨论较长型器件的传输速率、反射率和损耗等特性。 1、Max-Optics Studio-FDTD  ​ Max-Optics Studio FDTD 是国产微纳光电子器件仿真利器。具有领先的 GPU 加速能力，可高速求解三维 / 二维麦克斯韦方程。能够精确分析各种具有亚波长结构的微纳光电子器件、材料中的电磁场传播以及光和物质的相互作用，同时支持图形界面和脚本操作，是您光电子创新的得力助手。 独有 FDTD 实时场图叠加功能，将光场迭代进度直接叠加在 3D CAD 结构上，仿真进度一目了然。 产品关键特性：  —— GPU加速技术  曼光独有的 GPU FDTD 算法加速技术，通过更高效率的线程管理以及访存规划，充分利用 GPU 众核心资源，将 FDTD 运算速度提升十倍以上。 2、Max-Optics Studio-EME  Max-Optics Studio EME 是一款高效计算长距离传输器件的仿真工具，支持有限差分算法下的模式分析 FDE 以及本征模展开，传播重叠积分计算。 产品关键特性：  —— Curve Mesh网格技术  曼光独有的 3D curve mesh 网格技术可在使用六面体网格情况下对曲面（曲线）结构进行精确等效，降低网格密度的条件下，不丢失运算精度，进而提高运算效率、 —— Curve Mesh网格技术  • EME 模块所需计算模式数量减少 50%，计算结果稳定性更高 3、Max-Optics Studio-OE Device  OE Device 是一站式求解有源光电器件中电磁场和载流子运动的便利工具。可自洽求解电磁场（麦克斯韦方程），静电势（泊松方程）和自由载流子密度（漂移 - 扩散方程）整个建模到仿真过程在一个界面中一次完成。 4、Max-Optics Studio-MO Link  MO Link 是光子芯片的链路级仿真工具，支持多模、双向、多通道的仿真。 ​ 若希望了解更多仿真算法的详细信息，请移步网站的 &quot;Tutorials&quot;模块查看。 "},{"title":"我们具有哪些产品形态？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#我们具有哪些产品形态","content":"​ 我们推出了两种形式的软件支持离线模式或者云端使用，其中离线模拟只需要本地计算程序。一种是软件开发工具包SDK，另一种是GUI用户界面。SDK 基于python脚本可以统一规范调用所有模块并且支持GDS文件导入。当你在SDK中搭建仿真时，可以生成GUI文件以提供较为直观的仿真方式。 产品形态\t网页版\t单机版\tSDK页面显示 功能\t• 支持跨平台登录 • 支持灵活调度云上算力资源 • 本地算力资源 •操作习惯，简洁传统 • 全3D建模界面 •仿真历史自动保存回看 • 支持任意输入框中设定全局变量的运算表达式 • 支持仿真结构的非等比例缩放 •支持脚本建模 • 支持GDS Ⅱ导入 • 对接丰富的Python第三方开源库 • 支持调用本地、云上算力资源 • 方便和第三方工具交互工作 • 内置示例代码，快速上手  ​ 若希望了解更多关于SDK的安装和使用说明等详细信息，请移步网站的 &quot;Max-Optics SDK&quot;模块查看。 "},{"title":"我们提供哪些服务？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#我们提供哪些服务","content":"公司主营业务主要涵盖光电集成芯片仿真软件与芯片和系统测试两大业务板块，光电集成芯片仿真软件主要产品包 括无源 / 有源光电集成芯片及系统仿真设计软件，光电集成芯片测试系统解决方案和测试服务，光电集成芯片仿真 流程定制服务，微波 / 射频仿真和测试系统定制服务，相关产品和解决方案已经成功应用到国内头部客户，确保国 内产业的业务延续性，在业界取得了良好的声誉。 特别是光电集成芯片仿真设计软件领域，曼光打破了光电芯片核心算法及“know-how”的国际技术壁垒，率先提 出并建立了基于云架构的光电芯片仿真设计平台，可为光通信、光计算、光传感、量子计算、光显示提供高效的 光电集成芯片仿真设计工具，服务于 5G、人工智能、国防安全等领域。 教学与培训： ​ 我们在官网提供器件仿真和软件安装相关的常规问题，您可以自主进行在线查询。我们具有详细且典型的器件案例库，并且搭配有教学视频和说明文档，方便用户了解半导体物理和软件使用的专业知识。关于器件案例和计算方法的详细信息，请移步本网站的&quot;Example Library&quot;和“Tutorials”模块。相关软件安装和使用问题请移步本网站的“Max-Optics SDK”模块。 技术支持团队： ​ 我们的技术支持团队拥有丰富的专业知识，能够理解、诊断和解决技术相关的问题。我们致力于利用经验证的器件建模方法解决技术开发和制造方面的问题的方式来优化器件，为客户提供了校准、仿真、模型开发和咨询服务。 ​ 对于独特半导体器件建模需求但没有时间或资源在公司内部使用SDK软件的用户，我们可以提供建模服务，为您提供完整、快速、准确的解决方案。交付内容包括但不限于：图形输出（结构图和特性图）、结构（器件结构和网格）、器件特性数据。您可以网页在线提交反馈的问题，或者通过致电和邮件的方式联系我们。 软件支持团队： ​ 我们的软件支持团队由经验丰富的工程师组成，致力于软件产品功能和算法的开发，同时为客户提供许可证验证、软件和计算平台安装的服务。 ​ 欢迎致电或邮件联系我们： ​ 电话：150 6666 1688 ​ 邮箱：sales@max-optics.com "},{"title":"怎样获得技术支持服务？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#怎样获得技术支持服务","content":"​ When you need technical support or have inquiries related to using Max-Optics, you can follow these steps to obtain support and write a request for assistance: Clearly State the Issue or Requirement:​ Describe the issue or requirement concisely. Use clear language to explain the specific support you are seeking. Provide Detailed Information:​ Provide as much relevant information as possible about the issue, such as error messages, steps taken, software version, operating system, etc. This will assist the support personnel in analyzing and diagnosing the problem. Include Screenshots or Log Files: If applicable, attach relevant screenshots or log files to supplement the problem description. These visual aids provide additional context and facilitate the identification and resolution of the issue. List Attempted Solutions: If you have already attempted some solutions without success, mention them in your request. Provide details of the steps you have taken and the outcomes. This will help the support team understand the efforts you have already made and avoid repetition. Be Polite and Clear: Maintain a polite and clear tone when writing your support request. Use professional language and appropriate etiquette to express your issue or requirement and express gratitude for the support team's assistance. User Feedback： Please enter your question and feedback below:   Thank you for your feedback! We will address your question as soon as possible. If you need further assistance, please contact our customer support team. Contact Information: Phone: 150 6666 1688Email: sales@max-optics.com "},{"title":"个人在出差或居家办公时该如何设置授权并使用软件？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#个人在出差或居家办公时该如何设置授权并使用软件","content":"​ 如果贵公司采用集团授权的方式，将服务器布置在公司内网。本问题解答了个人想要脱离内网异地办公的时候应该如何设置授权从而成功使用我们的软件。 ​ 您可以使用VPN从异地接入公司网络进行使用。如果没有VPN访问权限，可以向贵公司内部的授权服务器申请开放一个公网访问的权限（有一个公网IP和端口），然后在软件设置中将服务器的IP地址填写为新申请的公网地址。 ​ 或者我们可以辅导客户里面的授权服务器管理人员，采用“集团授权借出模式”，将其采购的所有license数量中分出来一个license，做成临时离线license。具体操作如以下流程所示。 集团授权借出模式设置： （1）登录 https://bit.bitanswer.cn （2）左侧任务栏选择业务选项  （3）在右侧授权信息中选择授权借出  "},{"title":"如何为AIO SDK 配置 Jupyter 环境?​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#如何为aio-sdk-配置-jupyter-环境","content":"​ 在命令行中，activate All-in-One SDK所在的虚拟环境，然后进行如下操作： （1）安装 ipykernel  pip install ipykernel  （2）将环境写入notebook的kernel中  python -m ipykernel install --user --name &quot;mang1903&quot; --display-name &quot;mang1903&quot;  （3）打开jupyter notebook  jupyter notebook  （4）点击新建ipynb文件，可看到内核可选”mang1903”，(“mang1903”为之前设置的”mang1903”虚拟环境的display-name，用户可以自行设定)  "},{"title":"Python安装路径中有空格怎么办？​","type":1,"pageTitle":"General","url":"/my-website/docs/faq/General#python安装路径中有空格怎么办","content":"​ 如果Python安装路径中有空格，在安装AIO的第一步创建虚拟环境的时候就会报错，系统会把空格前的路径错误识别为一个命令。这种情况下如果不能修改python安装路径怎么办？ ​ 您可以使用双引号或原生字符串对路径进行包含，如下所示： path = &quot;C:/Program files/Python/python.exe&quot;  "},{"title":"Obtain Technical Support","type":0,"sectionRef":"#","url":"/my-website/docs/faq/ObtainTechnicalSupport","content":"","keywords":""},{"title":"Clearly State the Issue or Requirement:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#clearly-state-the-issue-or-requirement","content":"Describe the issue or requirement concisely. Use clear language to explain the specific support you are seeking. "},{"title":"Provide Detailed Information:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#provide-detailed-information","content":"Provide as much relevant information as possible about the issue, such as error messages, steps taken, software version, operating system, etc. This will assist the support personnel in analyzing and diagnosing the problem. "},{"title":"Include Screenshots or Log Files:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#include-screenshots-or-log-files","content":"If applicable, attach relevant screenshots or log files to supplement the problem description. These visual aids provide additional context and facilitate the identification and resolution of the issue. "},{"title":"List Attempted Solutions:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#list-attempted-solutions","content":"If you have already attempted some solutions without success, mention them in your request. Provide details of the steps you have taken and the outcomes. This will help the support team understand the efforts you have already made and avoid repetition. "},{"title":"Others:​","type":1,"pageTitle":"Obtain Technical Support","url":"/my-website/docs/faq/ObtainTechnicalSupport#others","content":"If you have other suggestions for designing software features or optimizing physical modules, we look forward to talking to you. User Feedback Please enter your question and feedback below:   Thank you for your feedback! We will address your question as soon as possible. If you need further assistance, please contact our customer support team. Contact Information: Phone: 150 6666 1688Email: sales@max-optics.com "},{"title":"How to set boundary condition?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/BC","content":"","keywords":""},{"title":"1.PML​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#1pml","content":"The intensity of the light field after entering the PML will decay, which can be used to absorb the electromagnetic field at the boundary. You can set the absorption of PML through the following parameters. Number of layers of PML.Kappa Alpha and Sigma are the orders of polynomials.Increasing Kappa will enhance the absorption of evanescent waves and weaken the absorption of guided modes.Increasing Sigma will reduce reflection and increase dispersion error.Increasing the value of Alpha/Sigma improves the stability of absorption, but the absorption effect will decrease.Increasing Alpha/Sigma increases stability and reduces absorption capacity. The light on the PML interface also generates reflections, which can be reduced by extending the structure through the boundary region.For the EME solver, Max-Optics optimized PML to improve mode orthogonality, which resulted in reduced absorption of guided modes. The general PML parameters of FDTD are as follows: {&quot;pml_layer&quot;:8,&quot;pml_kappa:2,&quot;pml_sigma&quot;:0.8,&quot;pml_polynomial&quot;:3,&quot;pml_alpha&quot;:0,&quot;pml_alpha_polynomial&quot;:1}. "},{"title":"2.PEC​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#2pec","content":"The conductivity of PEC is infinite and the penetration depth is almost zero, used to reflect electromagnetic fields. It reflects almost 100% without any energy loss. In FDE/EME simulation, the default boundary condition is PEC, and it can greatly reduce simulation time. "},{"title":"3.Symmetric​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#3symmetric","content":"When there is a symmetry plane in the structure, certain field components must be zero on the symmetry plane. The use of symmetric boundary conditions can make the horizontal component of the electric field and the vertical component of the magnetic field zero. In periodic structures, using symmetric boundary conditions at the boundary where the source polarization is tangent can shorten the simulation time by half. "},{"title":"4.Anti-Symmetric​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#4anti-symmetric","content":"Similarly, using asymmetric boundary conditions can make the vertical component of the electric field and the horizontal component of the magnetic field zero. In periodic structures, asymmetric boundary conditions are used at the boundary perpendicular to the source polarization. If used together with symmetric boundary conditions, it can save four times the time. "},{"title":"What situations require strengthening the absorption of PML?​","type":1,"pageTitle":"How to set boundary condition?","url":"/my-website/docs/faq/Physics/BC#what-situations-require-strengthening-the-absorption-of-pml","content":"The default parameters of PML are more accurate for the simulation results of (Bragg grating, spot size converter), and parameter settings that increase guided mode absorption are needed for radiation devices. For the FDTD solver, the absorption parameters of the PML layer are consistent with the Gloden software. Grating coupler is a device with strong radiation, which requires an increase in PML during simulation_ Sigma to improve absorption capacity.Users can moderately increase PML as needed_ The number of layers, but having too many layers can greatly increase simulation time.The PML boundary is calculated in the complex domain, so the calculation time and memory are generally more than twice that of the PEC/PML boundary. "},{"title":"About the basic concept","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/basic concept","content":"","keywords":""},{"title":"Mode​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#mode","content":"Modes refer to the stable transmission of electromagnetic waves in a waveguide, with each mode corresponding to a characteristic solution of Maxwell's equation in the waveguide. Each mode has a stable field distribution and different modes are orthogonal to each other. "},{"title":"Propagation constant​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#propagation-constant","content":"The real part of the propagation constant represents the phase velocity, while the imaginary part represents the loss or gain. "},{"title":"Effective refractive index​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#effective-refractive-index","content":"The direction and velocity of propagation vary with wavelength, medium structure, and refractive index. The ratio of propagation constant to vacuum wave vector is defined as the effective refractive index of the propagation direction. β=neff2πλβ = n_eff \\frac{2π}{λ}β=ne​ffλ2π​ "},{"title":"Phase velocity​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#phase-velocity","content":"The propagation speed of light of a certain mode at a single frequency. Vp=cneffV_p = \\frac{c}{n_eff}Vp​=ne​ffc​ "},{"title":"Group refractive index​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#group-refractive-index","content":"A type of average refractive index formed by changes in the speed and direction of light propagation due to factors such as non-uniformity of the propagation medium and wavelength of light. ng=neff−λdndλn_g=n_eff-λ\\frac{dn}{dλ}ng​=ne​ff−λdλdn​ "},{"title":"Coupling​","type":1,"pageTitle":"About the basic concept","url":"/my-website/docs/faq/Physics/basic concept#coupling","content":"When power transmission occurs within or between waveguides, it is called coupling between two modes. Two conditions need to be met: The mode overlap integral is not zero.the phase matching condition. "},{"title":"How to set up EME scanning?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/EME wavelength sweep","content":"","keywords":""},{"title":"EME length sweep​","type":1,"pageTitle":"How to set up EME scanning?","url":"/my-website/docs/faq/Physics/EME wavelength sweep#eme-length-sweep","content":"EME has great advantages in scanning calculation in the length direction, it does not need to repeatedly calculate the modes at the interface of the divided units, and can quickly obtain the transmitted S-matrix. Open the &quot;length sweep&quot; in the EME solver, select the length range of the scanning area, the number of scanning points, and the mode of the light source to obtain the s matrix transmitted by this mode. "},{"title":"EME wavelength sweep​","type":1,"pageTitle":"How to set up EME scanning?","url":"/my-website/docs/faq/Physics/EME wavelength sweep#eme-wavelength-sweep","content":"Due to the variation of mode distribution and effective refractive index with wavelength, wavelength scanning of EME is not suitable for scenarios with high material dispersion and mode dispersion. Taking the classic core size 500∙200 nm^2 SOI waveguide as an example, the accuracy of wavelength scanning is within 5% in the ±40 nm wavelength range. However, this result varies depending on the size, structure, and material of the waveguide, and requires users to judge and verify based on the usage scenario. In order to improve the calculation speed, this feature is disabled by default and can be opened in the settings of the solver EME with the option &quot;use wavelength sweep&quot;. "},{"title":"How to set the position of the light source and monitor?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/location","content":"How to set the position of the light source and monitor? To reduce simulation errors caused by grid accuracy, the Source and Monitor should be placed in the position of the straight waveguide. The calculation of &quot;mode source&quot; in FDTD is based on the position and size of the mode light source, so the calculated mode is suitable for stable transmission on cross-sections of the same size. If the position of the light source set by the user is in an area with structural changes, numerical errors may occur when encountering other waveguide cross-sections of different sizes without forming stable transmission due to the discretization of the Yee grid. Therefore, it is recommended that at least 3 grids around the Source be in the straight waveguide region, and the Monitor will also have the same problem when detecting mode energy. It is also recommended that at least 3 grids around the Monitor be in the straight waveguide region.","keywords":""},{"title":"What is Mode expansion monitor?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/mode expansion monitor","content":"What is Mode expansion monitor? The pattern expansion monitor, as a sub attribute of the power monitor, inherits the position, size, wavelength range, and frequency points of the power monitor. The meaning of each option in mode selection? In the user selection feature, the mode index starts from 0, and users can customize the number of monitoring modes by entering a list [0, 1, 2, 3,...]. &quot;Fundamental Mode&quot; represents the selection of the first given mode, &quot;Fundamental TE Mode&quot; represents the selection of the first TE mode, which is usually TE0 mode in the 2D waveguide section, &quot;Fundamental TM Mode&quot; represents the selection of the first TM mode, which is usually TM0 in the 2D waveguide section, and &quot;User Select&quot; represents user-defined &quot;. Frequency points can be set separately and will solve for the specified number of FDE modes. Before simulation, FDE calculations will be performed on each frequency point of the mode monitor. When is the mode extension monitor enabled? If there are too many frequency points in the mode monitor, it will increase the simulation time. If the input and output waveguides of the device are both single-mode waveguides, the distance between waveguides is relatively long, and the coupling is weak, and the device does not have polarization and mode conversion, the mode extension of the power monitor can not be enabled.In the presence of polarization, mode conversion, or overlap in the monitoring area of the power monitor in the device, it is necessary to enable mode unfolding of the power monitor to obtain more accurate simulation results.The settings for mode deployment monitoring can refer to (examples\\precision\\FDTD_HalfRing.py).","keywords":""},{"title":"How to set mesh?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/mesh","content":"","keywords":""},{"title":"1 Mesh type​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#1-mesh-type","content":"Solver\tFDE\tEME\tFDTD\tdescriptionuniform\t√\t√\t√\tThe grid size in the x, y, and z directions are the same in the structure. auto non-uniform √ The size of the non-uniform grid is determined by &quot;cells per wavelength&quot;, and the grid size is the wavelength in the structure divided by &quot;cells per wavelength&quot;. "},{"title":"1.1 Uniform​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#11-uniform","content":"The uniform type of grid is evenly distributed in the x, y, and z directions, and the step size of the grid is set by the user. "},{"title":"1.2 Auto non-uniform​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#12-auto-non-uniform","content":"Global automatic non-uniform grid distribution, with &quot;cells per wavelength&quot; determining the grid size at different positions. The grid division uses the same &quot;cells per wavelength&quot;, so the grid step size is smaller in areas with high refractive index. "},{"title":"2 Mesh type refinement​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#2-mesh-type-refinement","content":"According to the different ways in which the refractive index of materials is filled in hexahedral and rectangular grids, they can be divided into &quot;staircase&quot; and &quot;curve mesh&quot; types of grids. "},{"title":"2.1Staircase​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#21staircase","content":"When multiple materials appear in a grid, one of them will be selected as the filling material for the grid. The size of the divided grid is too large, which can easily create a stepped shape in curved structures. As shown in the figure below, the refractive index distribution of the structure is observed, and a stepped shape appears at the boundary of the curved waveguide. "},{"title":"2.2 Curve mesh​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#22-curve-mesh","content":"In the case of multiple materials in the grid, the equivalent refractive index within the grid is calculated based on the electromagnetic field equation at the boundary, and then filled into the grid. Using &quot;curve mesh&quot; can significantly improve the accuracy of calculations with the same grid accuracy. The refractive index of different materials in the &quot;staircase&quot; type of mesh varies directly at the interface, while the interface of the &quot;curve mesh&quot; material is gradient.Under the same grid size, using a &quot;curve mesh&quot; type of grid is more accurate in characterizing the structure, and the accuracy of the calculation results is significantly improved. From the following example, it can be seen that using a grid size of &quot;cells per wavelength&quot; of 15 for the &quot;curve mesh&quot; type mesh is equivalent to using a grid size of &quot;cells per wavelength&quot; of 22 for the &quot;staircase&quot; type mesh, but the simulation time is saved by four times.The “curve mesh” is applicable to FDE, EME, and FDTD solvers. "},{"title":"3 Mesh accuracy​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#3-mesh-accuracy","content":"The mesh accuracy represents the size of the mesh, and the commonly used grid accuracy is shown in the table below. Mesh Accuracy of &quot;Gloden&quot;\t1\t2\t3\t4\t5 cells per wavelength of &quot;Max-optics&quot; 6 10 14 18 22  To meet the accuracy requirements of the calculation, it is recommended to set &quot;cells per wavelength&quot; to 14 or above.If we only focus on the transmission rate, it is not necessary to set &quot;cells per wavelength&quot; above 22. Generally, the transmission rate set to 18 is within ±0.01 of the transmission rate error for higher grid accuracy.If more accurate reflectivity (-60 dB) is required, &quot;cells per wavelength&quot; should be set to be greater than 26. "},{"title":"4 Mesh factor​","type":1,"pageTitle":"How to set mesh?","url":"/my-website/docs/faq/Physics/mesh#4-mesh-factor","content":"The grid growth factor is only applicable to non-uniform grids and is used to control the rate of grid size change at the junction of different sizes of grids.To ensure the accuracy of the calculation results, the change rate of the grid should not be too large, and the default value of mesh factor is 1.2. In the area where the global mesh and local mesh are connected, the gradient trend of grid size with different growth factors is as follows. It is obvious that the larger the growth factor, the faster the grid change rate in the connected areas, and the corresponding number of meshs is smaller. If the size of the local area network grid is a, the size of the global grid is b, and the grid factor is m, then there will be a grid gradient process of a, a∙m, a∙m^2, a∙m^3, ...b in the connected areas. The mesh factor cannot be too small. If the mesh factor is 1, the grid will be evenly distributed throughout the entire space without any changes in size, and the number of meshs will increase significantly. "},{"title":"What is the process of simulation?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/Simulation process","content":"","keywords":""},{"title":"FDE​","type":1,"pageTitle":"What is the process of simulation?","url":"/my-website/docs/faq/Physics/Simulation process#fde","content":"The Finite Difference Eigenmode (FDE ) is a numerical solution algorithm that discretizes the Maxwell equations and solves the constructed feature matrix. The solution process for FDE is as follows. Calculate the propagation of electromagnetic waves and the field distribution of harmonic modes with high accuracy.The calculation cost is relatively low. The mode profile of the waveguide using FDE is shown in the following figure. "},{"title":"EME​","type":1,"pageTitle":"What is the process of simulation?","url":"/my-website/docs/faq/Physics/Simulation process#eme","content":"The Eigenmode Expansion Method (EME) calculates the bidirectional transmission of interface modes in partitioned units to obtain the transfer matrix, which has significant advantages over FDTD in simulating length scanning photonic devices. Calculate the transmission characteristics of the device and quickly scan and optimize the device.Compared to FDTD methods, the treatment of nonlinearity and dispersion equivalence has certain disadvantages. Calculate the electric field distribution of silicon waveguide and silicon nitride waveguide using EME, as shown in the following figure. "},{"title":"FDTD​","type":1,"pageTitle":"What is the process of simulation?","url":"/my-website/docs/faq/Physics/Simulation process#fdtd","content":"Finite Difference Time Domain (FDTD) represents the solution of a partial differential equation as discrete points in time and space, and then uses finite difference to solve the partial differential equation.The simulation process of FDTD is as follows. No approximation was used when solving partial differential equations.By using time-domain solutions, it is convenient to observe the propagation of light.Obtain the broadband response of the device through a single calculation in the time domain. Using FDTD to calculate light field transmission, the electric field distribution in the power monitor is shown in the following figure. "},{"title":"What is the difference between Staircase and Subcell methods?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/Subcell","content":"","keywords":""},{"title":"Staircase approximation​","type":1,"pageTitle":"What is the difference between Staircase and Subcell methods?","url":"/my-website/docs/faq/Physics/Subcell#staircase-approximation","content":"The Staircase approximation simply uses the mode field of discrete points to represent the mode field of the entire element, which has high computational efficiency. When the cell undergoes discontinuous changes, it can cause non physical reflections at the interface of the cell. The Staircase approximation method is applicable to staircase waveguides, mosaic type photonic devices, and square wave modulated waveguide gratings. "},{"title":"Subcell approximation​","type":1,"pageTitle":"What is the difference between Staircase and Subcell methods?","url":"/my-website/docs/faq/Physics/Subcell#subcell-approximation","content":"The Subcell approximation calculates the mode at the interface of each cell as a first-order interpolation of adjacent cells, and can simulate continuously changing photonic structures with smaller cells.The Subcell approximation method is suitable for gradient waveguides, tapers, and sinusoidal modulated waveguide gratings. When using the Subcell method, it is important to perform convergence analysis on the number of cells in the structural change area to ensure that the number of slices is sufficient. "},{"title":"How to set simulation time?","type":0,"sectionRef":"#","url":"/my-website/docs/faq/Physics/Simulation time","content":"How to set simulation time? When either the maximum simulation time is reached or the energy in the simulation area is less than the convergence threshold, the simulation project will end. In order to obtain convergence results, the simulation time should be set long enough, and it is recommended that the simulation time be no less than 1000 fs. Relationship between structural dimensions and simulation time The estimated time required for simulating and calculating non resonant devices is: L𝑛_𝑔/c;For SOI devices with a 100 micron length and a group refractive index of 4.23, the simulation time should be at least 1410 fs;For SiN devices with a 100 micron length and a group refractive index of 2.01, the simulation time is at least 670fs.In general, we need the light field energy in the simulation to converge below 1e-4. In order to ensure that the energy at the end of the simulation is less than 1e-4, the simulation time should be set sufficiently large. What is the relationship between the 'step. 0.39%' printed during the simulation process and the simulation time? At the beginning of the simulation, a maximum simulation time will be estimated based on the number of grid points, simulation time, and current computer performance, corresponding to the sum of &quot;elapsed&quot; and &quot;remaining&quot; times in each row of the following figure. After each iteration, the program will calculate the current elapsed time elapsed time and the maximum required simulation time remaining time until the end of the simulation. When the simulation time is set sufficiently large, the Early shutdown condition will be triggered when the energy of light in the simulation area decreases to the convergence level, and the simulation time used is less than 100%. step = elapsed_time/(elapsed_time + remain_time) ","keywords":""},{"title":"Passive Device Simulation","type":0,"sectionRef":"#","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation","content":"","keywords":""},{"title":"1. 怎样新建一个SDK仿真项目？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#1-怎样新建一个sdk仿真项目","content":" 首先，我们需要导入SDK包来进行光学仿真计算。 import maxoptics_sdk.all as mo   随后如下列中所示，新建一个仿真项目。其中name为项目名字；location为服务器的位置/运行模式，此时run_mode=&quot;local&quot;或run_mode=&quot;cloud&quot;。 # region --- Project --- pj = mo.Project(name=project_name, location=run_mode) # endregion  "},{"title":"2. 怎样在SDK仿真中添加材料?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#2-怎样在sdk仿真中添加材料","content":" 接下来，我们需要添加仿真过程中所用到的材料，代码如下中所示。其中其中name为材料名字；data为材料库的材料对象；order为材料覆盖的优先级，在不同材料的结构发生重叠时，大order数值的材料能覆盖小数值材料，当数值相同时，则默认后来居上。 # region --- Material --- mt = pj.Material() mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2) # endregion  "},{"title":"2.1 怎样添加一个非色散材料？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#21-怎样添加一个非色散材料","content":" 此外，可以通过add_nondispersion添加非色散材料。data=[(real, imag)]中的数据为折射率的实部和虚部。 mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=1)  "},{"title":"2.2 怎样添加一个色散材料？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#22-怎样添加一个色散材料","content":" 通过add_dispersion添加色散材料，代码如下所示。data=[(wavelength, real, imag)]为不同波长下的折射率实部和虚部。可以通过fitting对不同波长下的材料折射率进行拟合 mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;,data=[(1.55e-06, 1.444, 0), (1.30e-06, 1.81, 0.227)], order=1)  "},{"title":"2.3 怎样添加一个各向异性材料？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#23-怎样添加一个各向异性材料","content":" 通过add_anisotropy来添加各向异性材料。其中data=[ (wavelength, nx_real, nx_imag, ny_real, ny_imag, nz_real, nz_imag ) ]代表不同波长下，材料的各向异性折射率实部和虚部。同样的，也可以通过fitting进行拟合。 mt = pj.Material() mt.add_anisotropy(name=&quot;LN&quot;, fitting=None, data=[(wavelength * 1e-6, 2.211, 0, 2.138, 0, 2.211, 0)], order=2 )  "},{"title":"3. 怎样在SDK仿真中添加几何结构？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#3-怎样在sdk仿真中添加几何结构","content":" 下面我们学习如何在SDK中新建一个几何结构。 "},{"title":"3.1 怎样添加背景折射率？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#31-怎样添加背景折射率","content":" 如下所示在Structure中定义背景折射率，background_material 为背景材料；mesh_type为材料的网格类型，可选&quot;curve_mesh&quot; 和 &quot;staircase&quot;；mesh_factor为可以生成最大网格梯度。 # region --- 3. Structure --- st = pj.Structure(mesh_type=&quot;curve_mesh&quot;, mesh_factor=1.4, background_material=mt[&quot;Air&quot;]) # endregion  "},{"title":"3.2 怎样添加一个矩形结构？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#32-怎样添加一个矩形结构","content":" 如下代码所示，在Structure函数内通过add_geometry来添加结构。使用代码type='Rectangle' 即可添加一个矩形结构，其中material为之前定义过的材料种类，mesh_order为材料的覆盖优先级，和之前添加材料部分中的的order作用相同。在geometry的参数列表下，x/y/z为三个方向上结构的中心坐标；x_span/y_span/z_span为三个方向上结构的宽度。 st.add_geometry(name=&quot;rectangle&quot;, type=&quot;Rectangle&quot;, property={&quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: size, &quot;y&quot;: space, &quot;y_span&quot;: wg_width, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, }})  "},{"title":"3.3 怎样添加一个圆弧波导？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#33-怎样添加一个圆弧波导","content":" 同样的，我们可以在SDK中添加一个圆弧波导结构。在geometry中，inner_radius/out_radius分别为圆弧结构的内部半径和外部半径；angle为弯曲角度，角度的正负分别为顺时针方向和逆时针方向；xyz为三个方向上结构的中心位置，z_span为波导的厚度。 st.add_geometry(name=&quot;arc&quot;, type=&quot;ArcWaveguide&quot;, property={&quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;inner_radius&quot;: size-wg_width/2, &quot;outer_radius&quot;: size+wg_width/2, &quot;angle&quot;: 90, &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}})  "},{"title":"3.4 怎样添加一个圆形结构？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#34-怎样添加一个圆形结构","content":" 接下来，我们在下列代码中学习如何添加一个圆形结构。其中radius为园形的半径，x/y为圆心坐标。 st.add_geometry(name=&quot;circle&quot;, type=&quot;Circle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: size, &quot;x&quot;: 4*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}})  "},{"title":"3.6 怎样添加一个拉锥Taper结构？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#36-怎样添加一个拉锥taper结构","content":" 在add_geometry调用type=&quot;LinearTrapezoid&quot;来建立一个Taper拉锥结构，其中point_{1,2,3,4} _{x,y}分别为拉锥结构的四个顶点坐标；x/y/z为拉锥结构的的3D参考点，z_span为拉锥波导厚度。 st.add_geometry(name=&quot;linear_trapezoid&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size/2, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size, &quot;point_4_x&quot;: size, &quot;point_4_y&quot;: 0, &quot;x&quot;: 2*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, }})  "},{"title":"3.7 怎样添加一个自定义函数的几何结构？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#37-怎样添加一个自定义函数的几何结构","content":" 以一个自定义函数曲线的拉锥结构为例，在add_geometry调用type=&quot;AnalyticalWaveguide&quot;来使用该功能。其中equation1为波导边界函数表达式；x/y/z 为中心坐标；x span/y span为定义域范围；resolution为分辨率；nonsymmetric定义了结构是否上下对称；tilt_location决定了梯形拉伸位置；tilt_angle为结构的倾角。 st.add_geometry(name=&quot;taper_symmetric&quot;, type=&quot;AnalyticalWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: L, &quot;y&quot;: 0, &quot;y_span&quot;: taper_width, &quot;z&quot;: 0, &quot;z_sapn&quot;: 0.22, &quot;equation1&quot;: f'{str(A)*({str(L/2)}-x)^{str(m)}+1.5, &quot;nonsymmetric&quot;: False, &quot;tilt_location&quot;: &quot;user_defined&quot;, &quot;tilt_angle&quot;: 80, &quot;user_defined&quot;: 0.5, &quot;resolutionn&quot;: 1000 }}})  "},{"title":"3.8 怎样在SDK中通过导入gds文件并建立相应模型？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#38-怎样在sdk中通过导入gds文件并建立相应模型","content":" 下面代码案例给出了如何在SDK中，通过导入gds文件建立相应结构的代码。其中，获取了gds_filegds文件完整的路径名后；通过add_geometry函数下的type=&quot;gds_file&quot;导入来相应的gds文件；path为gds文件对应的完整路径名；cell_name为待导入gds的cell名，layer_name为待导入的图层类型和数据类型，material为结构对应的材料。 gds_file_root_path = os.path.abspath(os.path.join(path, '..')) gds_file = gds_file_root_path + &quot;/examples_gds/DC.gds&quot; st.add_geometry(name=&quot;box&quot;, type=&quot;gds_file&quot;, property={&quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;TOP&quot;, &quot;layer_name&quot;: (1, 1)}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0.11, &quot;z_span&quot;: 6}, &quot;material&quot;: {&quot;material&quot;: mt[&quot;SiO2&quot;], &quot;mesh_order&quot;: 1}})   在导入gds文件建模的过程中，需要注意材料mesh_order的设置，确保重叠结构的覆盖顺序是正确的。 "},{"title":"4. 怎样在SDK中设置FDE仿真？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#4-怎样在sdk中设置fde仿真","content":""},{"title":"4.1 怎样设置FDE仿真中各个参数？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#41-怎样设置fde仿真中各个参数","content":" 下面我们学习在SDK中通过Simulation添加一个FDE仿真并设置其仿真参数。  首先，需要通过OBoundary设置边界条件，geometry为边界几何参数，boundary为截面仿真边界参数。 随后，在simu.add下分别设置仿真名称name，仿真类型type，以及仿真的各项参数property。property中通过general设置仿真求解器的类型，默认值为2d_x_normal；在mesh_settings下设置网格参数，通过global_mesh_uniform_grid设置各方向上的网格大小。 calculate_modes确定是否计算模式； mesh_structure确定是否计算折射率轮廓；wavelength为 频域波长；通过wavelength_offset计算群折射率的波长偏移；number_of_trial_modes为FDE计算的模式数；通过search 寻找模式折射率，可选用[‘max_index’, ‘near n’]两种方式；calculate_group_index 确定 是否计算群折射率；bent_waveguide为是否计算弯曲波导的模式；radius为波导的弯曲半径；orientation确定波导管弯曲的方向。 可以通过frequency_analysis计算各个频率下的模式，其中start_wavelength，stop_wavelength，number_of_points，分别为起始扫描波长，结束扫描波长和扫描取点个数。 # region --- Boundary --- st.OBoundary(property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': yspan_solver, 'z': 0, 'z_span': zspan_solver}, 'boundary': {'y_min': 'PEC', 'y_max': 'PEC', 'z_min': 'PEC', 'z_max': 'PEC'}, }) # endregion # region --- Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={ # 'general': {'solver_type': '2d_x_normal'}, # default is '2d_x_normal' ['2d_x_normal','2d_y_normal','2d_z_normal'] 'mesh_settings': { 'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'search': 'max_index', # ['near_n','max_index'] # 'n': 2, 'calculate_group_index': False, 'mode_removal': {'threshold': 0.02}, # 'bent_waveguide': {'bent_waveguide': False, 'radius': 1, 'orientation': 0, 'location': 'simulation_center'} }, &quot;frequency_analysis&quot;: { &quot;frequency_analysis&quot;: run_options.run_frequency_sweep, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 2.67, &quot;detailed_dispersion_calculation&quot;: False }}}) # endregion  "},{"title":"4.2 怎样在FDE仿真中进行overlap的计算？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#42-怎样在fde仿真中进行overlap的计算","content":" 可以通过下列代码中将如下图所示模式光和高斯光源进行overlap。 if run_options.run: fde_res = simu[simu_name].run() if run_options.run_overlap: if run_options.run_beam: beam_res = simu[simu_name].run_fde_beam_and_extract( property={ &quot;define_gaussian_beam_by&quot;: &quot;waist_size_and_position&quot;, # [waist_size_and_position,beam_size_and_divergence], &quot;waist_radius&quot;: 10, &quot;distance_from_waist&quot;: 0, &quot;refractive_index&quot;: 1, &quot;theta&quot;: 0, &quot;phi&quot;: 0, &quot;polarization_angle&quot;: 0, &quot;sample_span&quot;: 10, &quot;sample_resolution&quot;: 200}, savepath=plot_path + 'beam_heatmap') overlap_res = simu[simu_name].run_fde_overlap_and_extract( property={&quot;add_global_mode&quot;: {&quot;task_path&quot;: beam_res.task_path, &quot;mode&quot;: 0}, &quot;mode&quot;: 0, &quot;optimize_position&quot;: True}, export_csv=True, savepath=plot_path + 'overlap') if not run_options.run_beam: overlap_res = simu[simu_name].run_fde_overlap_and_extract( property={&quot;add_global_mode&quot;: {&quot;mode&quot;: 0}, &quot;mode&quot;: 0}, export_csv=True, savepath=plot_path + 'overlap')  "},{"title":"4.3 怎样在FDE/FDTD/EME模块中查看折射率轮廓？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#43-怎样在fdefdtdeme模块中查看折射率轮廓","content":" 如下代码中所示为如何对器件截面进行run_index仿真，首先假设我们对器件x方向上截面计算折射率轮廓，通过x=0确定截面在x方向上的位置，并设置x_span=0；随后设置截面轮廓图计算区域的中心点y/z坐标,以及截面尺寸y_span/z_span的数值。y/z方向上截面折射率轮廓计算区域的设置同上。 simu[simu_name].run_index(name=f'{simu_name}_x_0', savepath=f'{plot_path}{k}IndexPreview_x=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 2}})  "},{"title":"4.4 怎样在SDK中的FDE模块中获取仿真数据？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#44-怎样在sdk中的fde模块中获取仿真数据","content":" 首先通过result_fde.extract下的data='calculate_modes'来获取仿真模场并保存在savepath路径下，通过export_csv确定是否导出模场数据的csv格式文件；设置attribute，mode，real，imag来提取所需要模式相关数据。当使用FDE模块中频率扫描功能时，通过data='frequency_analysis'提取数据。如代码中所示，可以提取&quot;neff&quot;, &quot;loss&quot;, &quot;group_index&quot;, &quot;polarization&quot;等等各个分量。 # region --- See Results --- if run_options.extract: # region --- calculate_modes --- if run_options.run: k = kL[2] res = result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_neff_table', export_csv=True) print(res.to_string(index=False)) for m in range(len(res)): k = kL[3] result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_mode{m}', attribute='E', mode=m, real=True, imag=True, **export_options, show=False) # endregion if run_options.run_frequency_sweep: attr_selections: List[Literal[&quot;neff&quot;, &quot;loss&quot;, &quot;group_index&quot;, &quot;polarization&quot;]] = [&quot;neff&quot;, &quot;loss&quot;, &quot;group_index&quot;, &quot;polarization&quot;] for i, a in enumerate(attr_selections): k = kL[4] result_fde.extract(data=&quot;frequency_analysis&quot;, savepath=f'{plot_path}{k}_freq_sweep_{a}}', attribute=&quot;a&quot;, real=True, imag=True, export_csv=True, export_mat=True, show=False) # endregion  "},{"title":"5. 怎样在SDK中设置EME仿真？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#5-怎样在sdk中设置eme仿真","content":""},{"title":"5.1 怎样设置EME仿真中添加边界条件和端口？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#51-怎样设置eme仿真中添加边界条件和端口","content":" 首先需要通过OBoundary对边界条件进行设置，再用geometry，boundary分别对边界的几何尺寸和各个维度的边界参数进行设置。 随后需要通过Port对EME的端口进行设置，add能够添加一个新端口。port_location为端口的位置；可通过mode_selection选择该端口的模式，如fundamental_TE或者fundamental_TM；此外，还支持user_select自定义端口的模式，通过mode_index选定端口模式的阶数，需要保证是正整数；use_full_simulation_span 为是否使用全仿真区域；offset为端口相对仿真边界的偏移；number_of_trial_modes 为EME求解模式。 # region --- Boundary --- st.OBoundary(property={'geometry': {'x': 0, 'x_span': 2, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 3}, 'boundary': {'y_min': 'PEC', 'y_max': 'PEC', 'z_min': 'PEC', 'z_max': 'PEC'} }) # region --- Port --- pjp = pj.Port(property={'source_port': 'eme_in'}) # region --- eme_in --- pjp.add(name='eme_in', type='eme_port', property={'geometry': {'port_location': 'left', # 'use_full_simulation_span': True, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 3}, 'eme_port': { 'general': {'mode_selection': 'fundamental_TE', # 'mode_index': 0, 'search': 'max_index' }, 'advanced': {'offset': 0, 'number_of_trial_modes': number_of_modes, # 'mode_removal': {'is_used': False, 'threshold': 0.01} }}}) # endregion # region --- eme_out --- pjp.add(name='eme_out', type='eme_port', property={'geometry': {'port_location': 'right', # 'use_full_simulation_span': True, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 3}, 'eme_port': { 'general': {'mode_selection': 'fundamental_TE', # 'mode_index': 0, 'search': 'max_index' }, 'advanced': {'offset': 0, 'number_of_trial_modes': number_of_modes, # 'mode_removal': {'is_used': False, 'threshold': 0.01} }}}) # endregion # endregion  "},{"title":"5.2 怎样在EME仿真中添加一个profile monitor？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#52-怎样在eme仿真中添加一个profile-monitor","content":" 如下方代码所示，首先需要通过add添加一个新的监视器，再用type='profile_monitor'调用不同种类的监视器。在property中对监视器各个参数进行设置，如monitor_type设置监视器的方向；x/y/z以及x_span/y_span/z_span确定监视器的坐标和尺寸且监视器法向span宽度需要为零。 此外，还需要注意的是，监视器的区域需要小于等于仿真区域的大小，对于XY平面的profile monitor，一般令其监视区域尺寸与仿真区域相同。FDTD的profile monitor设置与此相同。 # region --- Monitor --- mn = pj.Monitor() mn.add(name='x_normal', type='profile_monitor', property={'geometry': {'monitor_type': '2d_x_normal', # 'x_resolution': 100, 'x': 0.9, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 3}}) # endregion  "},{"title":"5.3 怎样设置EME仿真的参数？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#53-怎样设置eme仿真的参数","content":" 接下来我们学习如何在EME仿真模块中设置相应的参数，代码如下所示。其中general参数列表下的wavelength为EME仿真波长。随后在通过cell_group_definition进行对EME仿真cell的定义，其中span为cell的长度，cell_number确定该长度均分为多少个cell， number_of_modes为计算时求解的模式数，sub_cell_method确定了计算cell之间S矩阵的方法。在transverse_mesh_setting中进行横向网格设置。在eme_analysis下，eme_propagate确定是否计算eme传播，propagation_sweep为是否进行eme长度扫描，wavelength_sweep为是否进行eme波长扫描。 # region --- Simulation --- simu = pj.Simulation() simu.add(name=simu_name, type='EME', property={ 'general': {'wavelength': wavelength, 'wavelength_offset': 0.0003 }, 'eme_setup': {'cell_geometry': { 'cell_group_definition': [ {'span': 2, 'cell_number': cell_number, 'number_of_modes': number_of_modes, 'sc': 'sub_cell'}]}}, 'transverse_mesh_setting': {'global_mesh_uniform_grid': {'dy': grid, 'dz': grid} }, 'eme_analysis': { 'eme_propagate': run_options.run, 'propagation_sweep': {'propagation_sweep': run_options.run_length_sweep, 'parameter': 'group_span_1', 'start': 0, 'stop': 5, 'number_of_points': 6}, 'wavelength_sweep': {'wavelength_sweep': run_options.run_wavelength_sweep, 'start': wavelength - 0.5, 'stop': wavelength + 0.5, 'number_of_wavelength_points': 3} }}) # endregion  "},{"title":"5.4 怎样设置预览EME仿真结构图像？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#54-怎样设置预览eme仿真结构图像","content":" 通过structure_show可以预览EME仿真结构和图像。如下案例代码所示，其中fig_type为生成图片类型，通常为&quot;png&quot;，通过show来确认是否生成图像，savepath为结果图像的路径，simulation_name为结果图像名，celldisplay确认图像中是否生成cell，xyratio为图像中x坐标和y坐标的比例，默认值为 (1,1)。 # region --- Structure Show --- st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}{kL[0]}{simu_name}', simulation_name=simu_name, celldisplay=True, xyratio=(1, 1)) # simu[simu_name].show3d(show_with=&quot;local_gui&quot;) # endregion  "},{"title":"5.5 怎样获取EME端口的模式结果？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#55-怎样获取eme端口的模式结果","content":" 通过eme_res.extract获取仿真计算后的结果。如下案例代码所示，从结果中提取端口模式，其中设置data='eme_propagate:port_mode_info'确定所需获取结果为EME端口模式，save_path为数据保存路径，用attribute确定提取数据内容。plot_x/ plot_y为画线图或热度图的x, y轴纵坐标。real, imag控制输出数据：全为False时，运行程序将报错&quot;real and imag are both false&quot;，无法输出结果；全为True时，结果值取abs；有一个为True时，输出对应的实部/虚部。show控制是否显示图片，export_csv 为是否保存数据为csv文件。 for port_name in ['eme_in', 'eme_out']: res = eme_res.extract(data='eme_propagate:port_mesh_structure', savepath=f'{plot_path} {kL[3]}_eme_structure_{port_name}', port_name=port_name, target='intensity', attribute=&quot;E&quot;, # plot_x='y', plot_y='z', real=True, imag=True, # export_csv=False, show=False )  "},{"title":"5.6 怎样获取EME/FDTD的模场图？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#56-怎样获取emefdtd的模场图","content":" 同样的，我们可以通过eme_res.extract获取仿真计算后的结果。如下案例代码所示，设置data='eme_propagate:monitor'确定所需获取监视器结果，save_path为数据保存路径，用attribute确定提取数据内容。plot_x/ plot_y为画线图或热度图的x, y轴纵坐标。real, imag控制输出数据：全为False时，运行程序将报错&quot;real and imag are both false&quot;，无法输出结果；全为True时，结果值取abs；有一个为True时，输出对应的实部/虚部。show控制是否显示图片，export_csv 为是否保存数据为csv文件。 eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, # plot_x='y', plot_y='z', # real=True, imag=True, # export_csv=False, show=False )  "},{"title":"5.7 怎样进行EME长度扫描？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#57-怎样进行eme长度扫描","content":" 如下代码所示，通过data=&quot;propagation_sweep:sweep&quot;生成N × N张S参数矩阵长度扫描图，N为端口数。 # region --- EME Propagation Sweep Results --- if run_options.run_length_sweep: eme_res.extract(data=&quot;propagation_sweep:sweep&quot;, savepath=plot_path + &quot;10_length_sweep&quot;, export_csv=True) # endregion  "},{"title":"5.8 怎样进行EME波长扫描？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#58-怎样进行eme波长扫描","content":" 如下代码所示，通过data=&quot;wavelength_sweep:sweep&quot;生成N × N张S参数矩阵波长扫描图，N为端口数。 # region --- EME Wavelength Sweep Results --- if run_options.run_wavelength_sweep: eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True) # endregion  "},{"title":"5.9 EME仿真时，重复扫描波长是否会重新计算Overlap?​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#59-eme仿真时重复扫描波长是否会重新计算overlap","content":" 在进行EME 计算的时候，工作流是先算好所有Cell中的Mode，Sweep的时候再计算Overlap和归一化。如果重复扫描长度，不需要重新计算overlap, 程序只会计算一次。 "},{"title":"6. 怎样在SDK中设置FDTD仿真？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#6-怎样在sdk中设置fdtd仿真","content":""},{"title":"6.1 怎样设置FDTD仿真中波长？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#61-怎样设置fdtd仿真中波长","content":" Waveform支持定义波长、波长跨度等相关参数，并提供常见的1550nm、1310nm通信波段以及可见光波段。name为waveform 的名字，wavelength_center为中心波长，wavelength_span为带宽。 # region --- Waveform --- wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1) wv_struct = wv[waveform_name] # endregion  "},{"title":"6.2 怎样设置FDTD仿真光源？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#62-怎样设置fdtd仿真光源","content":" 通过source设置FDTD的仿真光源，代码如下所示。其中，type定义光源类型，在波导中常用模式源，在自由空间中常用高斯源；axis确定光的参考轴，其可选参数列表有xyz三个方向，即x_forward/x_forward/x_forward；通过mode_selection, mode_index选择特定的模式；waveform可选择特定的waveform；geometry设置光源几何尺寸。 src = pj.Source() src.add(name='source', type='mode_source', axis='x_forward', property={'general': { # 'amplitude': 1, 'phase': 0, 'mode_index': 0, 'rotations': {'theta': 0, 'phi': 0, 'rotation_offset': 0} 'mode_selection': 'user_select', 'waveform': {'waveform_id_select': wv_struct} }, 'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}})  "},{"title":"6.3 怎样设置FDTD的监视器？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#63-怎样设置fdtd的监视器","content":" 下面简单介绍FDTD监视器的设置，包含全局监视器、功率监视以及模式展开监视器的设置。如下代码所示，其中通过type='global_option'选取为全局监视器，wavelength_center为监视器获取波长中心值，wavelength_span为波长范围，frequency_points为监视器在该波段下所取点数。 mn = pj.Monitor() mn.add(name='Global Option', type='global_option', property={'frequency_power': { # 'sample_spacing': 'uniform', 'use_wavelength_spacing': True, # ['min_max','center_span'] 'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.1, }})   如下列代码所示，通过代码type='power_monitor'设置FDTD仿真中功率监视器和模式展开监视器。其中name为监视器名称。在property中设置监视器的各个参数，如波长相关参数wavelength_center、wavelength_span以及frequency_points；通过geometry下monitor_type、x/y/z、x_span/y_span/z_span的设置监视器的朝向、位置以及尺寸。 mn.add(name='through', type='power_monitor', property={'general': {'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}, }, 'geometry': {'monitor_type': '2d_x_normal', 'x': ports['op_1']['position'][0], 'x_span': 0, 'y': ports['op_1']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'mode_expansion': {&quot;enable&quot;: True, 'direction': 'positive', 'mode_calculation': { 'mode_selection': 'user_select', 'mode_index': [0, 1, 2, 3], 'override_global_monitor_setting': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}}}})  "},{"title":"6.4 怎样设置FDTD的Port相关参数？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#64-怎样设置fdtd的port相关参数","content":" 如下列代码所示，设置FDTD仿真中端口的相关参数。其中waveform_id确定输入光波长，source_port确定输入端口。随后在add下通过type='fdtd_port'添加相应的port，name为port名，在property中设置其相关参数，在geometry中设置端口的位置和尺寸，modal_properties设置输入光的相关属性，如inject_axis入射光光轴，direction入射光方向，mode_selection光的模式选择。 pt = pj.Port(property={'waveform_id': wv_struct, 'source_port': 'port_left'}) if run_options.matrix_sweep: pt.add(name='port_left', type='fdtd_port', property={'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'forward', 'mode_selection': 'fundamental', }}}) pt.add(name='port_right', type='fdtd_port', property={'geometry': {'x': ports['op_1']['position'][0], 'x_span': 0, 'y': ports['op_1']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'backward', 'mode_selection': 'fundamental', }}})  "},{"title":"6.5 怎样抽取FDTD的相关结果？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#65-怎样抽取fdtd的相关结果","content":" 如下列代码，savepath 为保存的路径，target='line'为线图，target='intensity'为强度图像，attribute确定了需要提取的参数，wavelength指定波长。  提取功率监视器的某一个波长下的模场： fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[3]}_monitorT_modeprofile_fdtd', monitor_name='through', target='intensity', plot_x='y', plot_y='z', attribute='E', wavelength=f'{wavelength}', real=True, imag=False, export_csv=True, show=False)   提取功率监视器的不同波长下的透过率: fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[7]}_RlVsLambda_power', monitor_name='reflection', target='line', plot_x='wavelength', attribute='T', real=True, imag=False, export_csv=True, export_mat=True, show=False)   提取模式展开监视器对某个功率监视器某个模式的响应的结果: fdtd_res.extract(data='fdtd:mode_expansion', savepath=f'{plot_path}{kL[5]}_TransVsLambda_mode=0', monitor_name='through', target='line', plot_x='wavelength', mode=0, attribute='T_forward', real=True, imag=True, export_csv=True, export_mat=True, show=False)   提取FDTD的S矩阵结果： smatrix_res.extract(data='smatrix_sweep', savepath=f'{plot_path}{kL[8]}_smatrix_sweep', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"6.6 为什么FDTD的Smatrix会出现大于1的情况？​","type":1,"pageTitle":"Passive Device Simulation","url":"/my-website/docs/faq/SimulationSetup/PassiveDeviceSimulation#66-为什么fdtd的smatrix会出现大于1的情况","content":" 当FDTD仿真区域存在光源时，会导致Smatrix矩阵会出现错误结果，例如某些端口响应大于1。在进行Smatrix的计算时，需要保证仿真区域中不存在光源。 "},{"title":"Active Device Simulation","type":0,"sectionRef":"#","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation","content":"","keywords":""},{"title":"1. How to perform an active device simulation​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#1-how-to-perform-an-active-device-simulation","content":"Follow the steps below to perform an electrical simulation Create a simulation projectAdd materials and modify the parametersAdd structures and specify the materialAdd dopingAdd electrodesAdd local mesh, surface recombination, electrical monitorsAdd an OEDevice solver, including simulation region, solver mode, generation rate, and convergence control settingsRun solverExtract results  Note: If optical simulation is still required, after adding materials, you need to bind optical material properties to each material and add other optical simulation-related settings.For electrical simulation, materials, structures, electrode settings, and an OEDevice solver are essential. Doping, local mesh, surface recombination, and electrical monitors can be set as needed.  "},{"title":"2. How to set up doping​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#2-how-to-set-up-doping","content":"Doping is added and set up through the add_doping function. The format of the function is st.add_doping(name, type, property)  add_doping() parameters: name--Doping nametype--Doping type. Options are &quot;n&quot;, &quot;p&quot; and &quot;file&quot;. property--Other properties  "},{"title":"2.1 Function doping​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#21-function-doping","content":"When type is set to &quot;n&quot; or &quot;p&quot;, function doping is applied. In this case, type also means the doping species, with &quot;n&quot; for donor and &quot;p&quot; for acceptor.  Property list of function doping: \tdefault\ttype\tnotesgeometry.x float geometry.x_span float geometry.y float geometry.y_span float geometry.z float geometry.z_span float geometry.x_min float geometry.x_max float geometry.y_min float geometry.y_max float geometry.z_min float geometry.z_max float general.distribution_function str\tSelections are ['constant', 'gaussian'] general.concentration float general.source_face str\tAvailable when distribution_function is 'gaussian' general.junction_width float\tAvailable when distribution_function is 'gaussian' general.ref_concentration float\tAvailable when distribution_function is 'gaussian' volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' Description: geometry--Set the geometry parameters of doping box general--Set the distribution function, concentration and so on distribution_function: When it's set to &quot;constant&quot;, constant doping is applied and only concentration is requiredWhen it's set to &quot;gaussian&quot;, Gaussian function doping is applied, and concentration, ref_concentration, junction_width, source_face are required concentration--Concentration in the non-diffusion arearef_concentration--Concentration on the edge of diffusion area (edge of doping box)junction_width--Diffusion junction widthsource_face--The doping source face. Options are &quot;lower_x&quot;, &quot;lower_y&quot;, &quot;lower_z&quot;, &quot;upper_x&quot;, &quot;upper_y&quot; or &quot;upper_z&quot;. &quot;lower_x&quot; means the source face is x=x_min. Similarly for the rest. There is no diffusion area on the edge of source face. As for the other edges, there is a diffusion area respectively within the doping box. volume--Set a list of regions or materials to be doped volume_type:When it's set to &quot;all&quot;(by default)，the doping is applied to all the (semiconductor) structures, restricted by the doping boxWhen it's set to &quot;material&quot;, material_list is required, which means the doping is applied to the structures of the specified materials and restricted by the doping boxWhen it's set to &quot;region&quot;, region_list is required, which means the doping is applied to the specified structures and restricted by the doping box  Gaussian doping explanation​  Fig 1. Gaussian doping As shown above, for Gaussian doping, there is a partition of constant doping profile in the doping box, and the constant concentration is the value of concentration. The width from the edge of constant area to the edge of doping box is junction_width. Concentration on the edge of doping box is the value of ref_concentration. (Note: There is no junction at the edge of source face.)  Example for function doping​ st.add_doping(name=&quot;p_constant&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 1, &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: 1e16}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat1&quot;], mt[&quot;mat2&quot;]]}}) st.add_doping(name=&quot;n_diffusion&quot;, type=&quot;n&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 1, &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;gaussian&quot;, &quot;source_face&quot;: &quot;upper_z&quot;, &quot;junction_width&quot;: 0.1, &quot;concentration&quot;: 1e18, &quot;ref_concentration&quot;: 1e6}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;region&quot;, &quot;region_list&quot;: [&quot;Structure1&quot;, &quot;Structure2&quot;]}})   "},{"title":"2.2 Imported doping​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#22-imported-doping","content":"When type is set to &quot;file&quot;, doping is imported from a file.  Property list for imported doping: \tdefault\ttype\tnotesgeneral.format str\tSelections are ['DOP'] general.file_path str general.species str\tSelections are ['n', 'p'] volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' Description: general: format--Set the format of doping file. Only &quot;DOP&quot; is supported currently When it's set to &quot;DOP&quot;, the doping file is a text file that stores a doping profile in rectangular grid. There are three columns in the file, which are the first dimension coordinate [um], the second dimension coordinate [um] and the doping concentration [cm^-3] respectively. Doping concentration should be non-negative. file_path--The absolute path of the doping filespecies--Set the doping species. Option are &quot;n&quot; and &quot;p&quot;, with &quot;n&quot; for donor and &quot;p&quot; for acceptor. volume--Set a list of regions or materials to be doped, which is exactly the same as the case of function doping.  Example for imported doping​ st.add_doping(name=&quot;p_imported&quot;, type=&quot;file&quot;, property={ &quot;general&quot;: {&quot;format&quot;: &quot;DOP&quot;, &quot;file_path&quot;: p_file_path, &quot;species&quot;: &quot;p&quot;}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat1&quot;], mt[&quot;mat2&quot;]]}})   "},{"title":"3. How to set up electrical boundary condition​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#3-how-to-set-up-electrical-boundary-condition","content":"Electrodes and electrical boundary conditions are set up through the add_electrode function. The format of the function is st.add_electrode(name, property)  add_electrode() parameters: name--Electrode nameproperty--Other properties  There are two different type of electrical boundary conditions, which are &quot;steady_state&quot;and &quot;transient&quot;, specified by the property bc_mode.  "},{"title":"3.1 Steady state boundary condition​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#31-steady-state-boundary-condition","content":"When the property bc_mode is set to &quot;steady_state&quot;, the steady state boundary condition is applied.  Property list of steady state boundary condition: \tdefault\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode\tsteady_state\tstring\tSelections are ['steady_state']. apply_AC_small_signal\tnone\tstring\tSelections are ['none', 'All']. sweep_type\tsingle\tstring\tSelections are ['single', 'range', 'value']. voltage\t0\tfloat\tAvailable when sweep_type is 'single' range_start\t0\tfloat\tAvailable when sweep_type is 'range' range_stop\t1\tfloat\tAvailable when sweep_type is 'range' range_interval\t1\tfloat\tAvailable when sweep_type is 'range' range_num_points\t2\tinteger\tAvailable when sweep_type is 'range' []sweep_value_table.index integer\tAvailable when sweep_type is 'value'. []sweep_value_table.number float\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t Description: surface_type--Type of the surface to be set as an electrode. Currently only &quot;solid&quot; is supported, meaning that all the surfaces of a structure are selected solid--Name of the structure to be set as an electrode. Available when surface_type is set to &quot;solid&quot; force_ohmic--Whether the electrode is ohmic, default to be True. Currently only ohmic contact is supported, so force_ohmic can't be set to False bc_mode--Set to &quot;steady_state&quot; for steady state boundary condition apply_AC_small_signal: When it's set to &quot;none&quot; (as default), no AC small signal is applied at each sweeping voltageWhen it's set to &quot;All&quot;, the AC small signal is applied after steady state simulation at each sweeping voltage sweep_type--Type of sweeping voltage. Options are &quot;single&quot;, &quot;range&quot; and &quot;value&quot; When it's set to &quot;single&quot;, voltage is requiredWhen it's set to &quot;range&quot;, range_start, range_stop, and range_interval or range_num_points are requiredWhen it's set to &quot;value&quot;, sweep_value_table is required voltage--Set the value of the single voltage range_start--Set the start value of the voltage range range_stop--Set the stop value of the voltage range range_interval--Set the voltage interval of the voltage range range_num_points--Set the number of points of the voltage range sweep_value_table--Table of voltage values. It's a list, whose item is a dictionay. In each of its item: index--Set the index of the voltage valuenumber--Set the value of the voltage  Example for single voltage​ st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   Example for voltage range​ st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: 0, &quot;range_stop&quot;: 1, &quot;range_interval&quot;: 0.5, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})   Example for voltage table​ st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;value&quot;, &quot;sweep_value_table&quot;: [{&quot;index&quot;: 0, &quot;number&quot;: 0}, {&quot;index&quot;: 1, &quot;number&quot;: 0.5}, {&quot;index&quot;: 2, &quot;number&quot;: 1}]})   "},{"title":"3.2 Transient boundary condition​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#32-transient-boundary-condition","content":"When the property bc_mode is set to &quot;transient&quot;, the transient boundary condition is applied.  Property list of transient boundary condition: \tdefault\ttype\tnotesforce_ohmic\ttrue\tbool bc_mode string\tSelections are ['transient']. voltage\t0\tfloat []time_table.time_start float []time_table.time_stop float []time_table.initial_step float []time_table.max_step float []time_table.optical.enabled\t0\tinteger\tSelections are [0, 1] []time_table.optical.envelop integer\tSelections are [0] []time_table.optical.source_fraction float surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t Description: surface_type, solid, force_ohmic--The same as the one in steady state conditionbc_mode--Set to &quot;transient&quot; for transient boundary condition. Then the time dependence of the optical generation rate can be set at this electrodevoltage--Set the voltage that is applied to the electrode and a steady state simulation is performed first. The transient simulation is based on the steady state result. The optical generation rate is not applied during the steady state simulation.v_step_max--Set the max step of the voltage from the equilibrium state to steady state at the bias of voltage.time_table--Set the time dependence of optical generation rate. It's a list, whose item is a dictionary. In each of its item: time_start--Set the start time point of the range. The value of 0 represents the steady state of the earlier simulation.time_stop--Set the stop time point of the rangeinitial_step--Set the initial time step of the rangemax_step--Set the max time step of the rangeoptical--Set the optical generation rate during the time range enabled--Whether to apply optical generation rate during the time range. The value of 1 means True, and 0 means Falseenvelop--The envelop of the scaling factor of the light power during the time range. When it's set to 0, the envelop is uniformsource_fraction--When envelop is set to0, this value is the scaling factor of the light power during the time range  Example for transient boundary condition​ st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: 1, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 50e-12, &quot;initial_step&quot;: 1e-15, &quot;max_step&quot;: 1e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}, {&quot;time_start&quot;: 50e-12, &quot;time_stop&quot;: 600e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: 1e-3}}]})   "},{"title":"3.3 Set up the appropriate boundary condition​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#33-set-up-the-appropriate-boundary-condition","content":"When solving the frequency response of optical signal for the device, transient simulation should be performed. In this case, the bc_mode of the corresponding electrode should be set to &quot;transient&quot;, and the solver_mode of OEDevice solver should be set to &quot;transient&quot;, too. In most of other cases, steady state or SSAC simulation is needed, the bc_mode of electrodes should be &quot;steady_state&quot;. When solving capacitance and resistance with respect to frequency, SSAC simulation is required. The solver_mode of OEDevice solver should be set to &quot;SSAC&quot;, and the apply_AC_small_signal of the corresponding electrode should be set to &quot;All&quot;.When running steady state simulation, just set the solver_mode of OEDevice solver to &quot;steady_state&quot;.  "},{"title":"4. How to set up surface recombination​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#4-how-to-set-up-surface-recombination","content":"Surface recombination is added and set up through add_surface_recombination function. The format of the function is st.add_surface_recombination(name, property)  add_surface_recombination() parameters: name--Name of the surface recombinationproperty--Other properties  Property list of surface recombination: \tdefault\ttype\tnotessurface_type\tdomain_domain\tstring\tSelections are ['domain_domain', 'material_material']. interface_type\tnull\tstring\tSelections are ['null', 'InsulatorInterface', 'HomoJunction', 'HeteroJunction', 'MetalOhmicInterface', 'SolderPad']. infinite_recombination\ttrue\tbool\tAvailable when interface_type is 'MetalOhmicInterface' velocity_hole\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' velocity_electron\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' domain_1 string\tAvailable when surface_type is 'domain_domain' domain_2 string\tAvailable when surface_type is 'domain_domain' material_1 material\tAvailable when surface_type is 'material_material' material_2 material\tAvailable when surface_type is 'material_material' Description: surface_type--Type of selection for the surface When surface_type is &quot;domain_domain&quot;, the surface is the interface between two structures When surface_type is &quot;material_material&quot;`, the surface is the interface between two materials interface_type--Type of contact for the surface &quot;InsulatorInterface&quot;--Semiconductor-insulator interface&quot;HomoJunction&quot;--Homogeneous semiconductor-semiconductor interface&quot;HeteroJunction&quot;--Heterogeneous semiconductor-semiconductor interface&quot;MetalOhmicInterface&quot;--Semiconductor-conductor interface&quot;SolderPad&quot;--Conductor-insulator interface infinite_recombination--Only available when interface_type is &quot;MetalOhmicInterface&quot;. The surface recombination velocity of holes and electrons will be available when infinite_recombination is Falsevelocity_hole, velocity_electron--Surface recombination velocity of holes and electrons. Available when interface_type is &quot;MetalOhmicInterface&quot; or &quot;InsulatorInterface&quot;domain_1, domain_2--Names of the two structures at the interface. They must be set explicitly when surface_type is &quot;domain_domain&quot;material_1, material_2--The two materials at the interface. They must be set explicitly when surface_type is &quot;material_material&quot;  "},{"title":"5. How to simulate 3dB bandwidth of photodetector​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#5-how-to-simulate-3db-bandwidth-of-photodetector","content":"The OEDevice solver doesn’t support simulations for the small signal of optical generation currently. Therefore, the frequency response of photo detector can only be obtained by transient simulation.  "},{"title":"5.1 Introduction for obtaining frequency response through transient simulation​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#51-introduction-for-obtaining-frequency-response-through-transient-simulation","content":"First, obtain current-time (I-t) curve after applying optical generation in transient simulation. And then postprocess the I-t curve to get the frequency response. Note: Please take the chapter “3.2 Transient boundary condition” above as reference for transient simulation setup;Optical generation is applied at one time point, and keeps until the photo current goes stable. That is, the dependency of optical generation rate on time is a step function and the I-t curve is the step response of photo current;The transient time ranges from the start of optical generation applying, to the time the photo current goes stable;At the beginning when optical generation is turned on, the photo current ramps up very rapidly, so small time step is needed during the period. When photo current varies slowly, the time step can be increased appropriately to shorten the simulation time;The high field mobility model of the material can be applied for a more accurate result of bandwidth;It is often desirable to set up the convergence control parameters to enhance the convergence of transient simulations.  "},{"title":"5.2 Comparison between transient simulation and small signal simulation​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#52-comparison-between-transient-simulation-and-small-signal-simulation","content":"Transient simulation is fully nonlinear and can capture all the effects generated by a signal. In contrast, small-signal simulation is a linear approximation performed on a steady-state result. Consequently, all nonlinear effects caused by large signals are lost in this mode. During small-signal simulation, the accuracy increases as the signal amplitude decreases. However, the accuracy of transient simulation is not affected by the signal amplitude. With appropriate settings, the accuracy of transient simulation can be higher than that of small-signal simulation.  "},{"title":"6. How to set up materials​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#6-how-to-set-up-materials","content":" "},{"title":"6.1 Material setup​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#61-material-setup","content":"When performing optical and electrical simulations, it usually takes two steps to set up a material. First, add an electrical material through add_lib function. The format of the function is mt.add_lib(name, data, order, override)  add_lib() parameters: name--Custom material namedata--Material data, requiring one of the built-in materials in the electrical material library, namely mo.OE_Materialorder--mesh_order of the material, default to be 2override--Override the default electronic parameters by custom values. It's empty by default, which means default models and parameters are applied  Second, use the set_optical_material function to set the optical property for the material. The format of set_optical_material is set_optical_material(data)  set_optical_material() parameters： data--Optical material property，which can be one of the built-in materials in the optical material library mo.Material, or be from the custom optical material.  Example of material setup​ mt.add_lib(name=&quot;mat_ge&quot;, data=mo.OE_Material.Ge, order=2, override=elec_Ge_properties) # elec_Ge_properties is a variable storing the modified electronic parameters for Germanium mt[&quot;mat_ge&quot;].set_optical_material(data=mo.Material.Ge_Palik)   Example of using custom optical material properties​ mt.add_lib(name=&quot;mat_sio2&quot;, data=mo.OE_Material.SiO2, order=1) mt.add_nondispersion(name=&quot;mat_sio2_op&quot;, data=[(1.444, 0)], order=1) mt[&quot;mat_sio2&quot;].set_optical_material(data=mt[&quot;mat_sio2_op&quot;].passive_material)  Note: Although the electrical and optical material properties are bound together through a two-step setting, in reality, there is no inherent connection between them. For instance, it is possible to set both the electrical properties of SiO2 and the optical properties of Si for the same material. The simulation will not generate errors or warnings in such cases, so users need to determine by themselves whether the material settings align with the physics. The FDTD simulation currently doesn't support metal materials. Therefore, the optical property of metal materials should be set to mo.Material.PEC and the material name should also be &quot;pec&quot;.  "},{"title":"6.2 Electronic parameters of materials​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#62-electronic-parameters-of-materials","content":"Semiconductor Si and Ge support basic，band，mobility，velocity saturation and high field setting. Taking Ge as an example, the variable elec_Ge_properties below can be used to override its default electronic parameters. elec_Ge_properties = {&quot;model&quot;: {&quot;high_field&quot;: True, &quot;mobility_force&quot;: &quot;EQF&quot;}, &quot;basic&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: {&quot;affinity&quot;: 4.5-0.65969/2.0, &quot;permitti&quot;: 16.0}, &quot;print&quot;: 1}, &quot;mobility&quot;: {&quot;model&quot;: &quot;Masetti&quot;, &quot;Masetti&quot;: {&quot;pc_e&quot;: 0, &quot;mu_min1_e&quot;: 850, &quot;mu_min2_e&quot;: 850, &quot;mu1_e&quot;: 0, &quot;mumax_e&quot;: 3900, &quot;cr_e&quot;: 2.6e17, &quot;alpha_e&quot;: 0.56, &quot;pc_h&quot;: 0, &quot;mu_min1_h&quot;: 300, &quot;mu_min2_h&quot;: 300, &quot;mu1_h&quot;: 0, &quot;mumax_h&quot;: 1800, &quot;cr_h&quot;: 1e17, &quot;alpha_h&quot;: 1}, &quot;print&quot;: 1}, &quot;band&quot;: {&quot;model&quot;: &quot;Default&quot;, &quot;Default&quot;: { # DOS &quot;nc300&quot;: 1.1372e+19, &quot;nv300&quot;: 3.9189e+18, # Bandgap &quot;eg300&quot;: 0.65969, &quot;chi300&quot;: 4.5-0.65969/2.0, # Bandgap Narrowing &quot;v0_bgn&quot;: 0, # Auger Recombination &quot;augan&quot;: 1e-30, &quot;augap&quot;: 1e-30, &quot;augbn&quot;: 0, &quot;augbp&quot;: 0, &quot;augcn&quot;: 0, &quot;augcp&quot;: 0, &quot;aughn&quot;: 0, &quot;aughp&quot;: 0, # SRH Recombination &quot;taunmax&quot;: 1.5e-9, &quot;taupmax&quot;: 1.5e-9, &quot;nsrhn&quot;: 7.1e15, &quot;nsrhp&quot;: 7.1e15, # Radiative Recombination &quot;c_direct&quot;: 6.41e-14}, &quot;print&quot;: 1}, &quot;vsat&quot;: {&quot;model&quot;: &quot;Canali&quot;, &quot;Canali&quot;: {&quot;beta0n&quot;: 2, &quot;beta0p&quot;: 1, &quot;betaexpn&quot;: 0, &quot;betaexpp&quot;: 0, &quot;alpha&quot;: 0, &quot;vsatn0&quot;: 6e6, &quot;vsatp0&quot;: 5.4e6, &quot;vsatn_exp&quot;: 0, &quot;vsatp_exp&quot;: 0}, &quot;print&quot;: 1}}  Description: basic--Set the permittivity and affinity band--Set models and parameters of the band and the recombination mobility--Set the model and parameters of mobility model--Set the switch of high field mobility model and Fermi-Dirac statistics model vsat--Set the model and parameters of velocity saturation For the detailed introduction about electronic parameters, please refer to the document examples/active_demo/Physics_Model_in_OEDevice.pdf.  "},{"title":"7. How to set up OEDevice solver​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#7-how-to-set-up-oedevice-solver","content":"The OEDevice solver is added and set up through simu.add function. The format of the function is simu.add(name, type, property)  simu.add() parameters: name--Name of the solvertype--Type of the solver. For active device simulation, the type of carrier transport solver is &quot;OEDevice&quot;property--Other properties  Property list of OEDevice solver: \tdefault\ttype\tnotesgeneral.norm_length\t1.0\tfloat general.solver_mode\tsteady_state\tstring\tSelections are ['steady_state', 'transient', 'SSAC']. general.temperature_dependence\tIsothermal\tstring\tSelections are ['Isothermal']. general.simulation_temperature\t300\tfloat advanced.non_linear_solver\tNewton\tstring\tSelections are ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', 'LU', 'BCGS']. advanced.use_quasi_fermi\tdisabled\tstring\tSelections are ['disabled', 'enabled']. advanced.damping\tnone\tstring\tSelections are ['none', 'potential']. advanced.potential_update\t1.0\tfloat advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. advanced.thread_count\t4\tinteger advanced.max_iterations\t30\tinteger advanced.use_global_max_iterations\ttrue\tbool advanced.poisson_max_iterations\t30\tinteger advanced.ddm_max_iterations\t30\tinteger advanced.relative_tolerance\t1.0e-5\tfloat advanced.tolerance_relax\t1.0e+5\tfloat advanced.divergence_factor\t1.0e+25\tfloat genrate.genrate_path string genrate.source_fraction float genrate.coordinate_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float geometry.z_min float geometry.z_max float small_signal_ac.perturbation_amplitude\t0.001\tfloat small_signal_ac.frequency_spacing\tsingle\tstring\tSelections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat small_signal_ac.start_frequency\t1.0e+06\tfloat small_signal_ac.stop_frequency\t1.0e+09\tfloat small_signal_ac.frequency_interval\t9.9999e+10\tfloat small_signal_ac.num_frequency_points\t2\tinteger small_signal_ac.log_start_frequency\t1.0e+06\tfloat small_signal_ac.log_stop_frequency\t1.0e+10\tfloat small_signal_ac.log_num_frequency_points\t2\tinteger\t Description: geometry： dimension--Set the dimension of the simulation region. Only 2D simulation is supportd currently. When it's set to &quot;2d_x_normal&quot;, the simulation is on the yz plane. Similarly for the rest general: norm_length--Set the length in the third dimension, default to be 1solver_mode--Set the simulation mode. Steady state, transient and SSAC simulations are supportedtemperature--Set the simulation temperaturetemperature_dependence--Set the type of the temperature dependence. Only &quot;Isothermal&quot; is supported currently genrate: genrate_path--Set the absolute path of the optical generation rate file (gfile) When it's set to &quot;&quot; (by default), and empty string , no optical generation rate will be appliedWhen it's not empty, the gfile at the path will be imported to apply the optical generation rate coordinate_unit--Set the coordinate unit in the gfile field_length_unit--Set the length unit in the generation rate unit in the gfile source_fraction--Set the scaling factor for the light power. The imported optical generation rate will be multiplied by this factor first, and then be used to solve the carrier transport small_signal_ac: perturbation_amplitude--Set the voltage amplitude of the small signal frequency_spacing--Set the spacing type of the frequency When it's set to &quot;single&quot;, the frequency point is singleWhen it's set to &quot;linear&quot;, the frequency points are uniformly sampledWhen it's set to &quot;log&quot;，the frequency points are uniformly sampled base on the logarithm of frequency frequency--Set the value of the single frequency start_frequency--Set the start frequency of linear spacing stop_frequency--Set the stop frequency of linear spacing frequency_interval--Set the frequency interval of linear spacing num_frequency_points--Set the number of frequency points of linear spacing log_start_frequency--Set the start frequency of logarithmic spacing log_stop_frequency--Set the stop frequency of logarithmic spacing log_num_frequency_points--Set the number of frequency points of logarithmic spacing advanced: non_linear_solver--Set the non-linear solver, only Newton method is supported currentlylinear_solver--Set the linear solver. Options are &quot;MUMPS&quot;, &quot;LU&quot;, &quot;BCGS&quot;. MUMPS and LU are direct linear solvers which usually give the exact solution. However, MUMPS supports parallel computation while LU doesn't. ；&quot;BCGS&quot; is a Krylov subspace (KSP) iterative solver, which also supports parallel computation and is more efficient but can only give approximate results.use_quasi_fermi--Whether to directly solve for the quasi-Fermi potential instead of carrier concentration as unkowns. &quot;enabled&quot; means True, and &quot;disabled&quot; means Falsedamping--Set the nonlinear update damping scheme. &quot;potential&quot; means the damping is based on the potential variationpotential_update--Set the threshold potential for potential damping. The large value will reduce the strength of damping effectmulti_threads: When it's set to &quot;let_solver_choose&quot;, the solver will determine the number of threads to use. The default maximum number of threads is 4When it's set to &quot;set_thread_count&quot;, the number of threads is set by the user to thread_count thread_count--Custom number of threadsmax_iterations--Set global maximum number of iterations, available when use_global_max_iterations is Trueuse_global_max_iterations--Whether to use global max iterations during the initialization of solving the Poisson equations and the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, default to be Truepoisson_max_iterations--Set the max iterations during the initialization of solving the Poisson equations, available when use_global_max_iterations is Falseddm_max_iterations--Set the max iterations during the subsequent computing for solving the drift-diffusion equations coupling with Poisson equations, available when use_global_max_iterations is Falserelative_tolerance--Set the relative update tolerancetolerance_relax--Set the tolerance relaxation factor for convergence on relative tolerance criteriadivergence_factor--Nonlinear solver fault with divergence when each individual function norm exceeds the threshold as its absolute tolerance multiply by this factor  "},{"title":"8. How to set up electrical monitors​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#8-how-to-set-up-electrical-monitors","content":"Electrical monitors are added and set up through mn.add function. The format is mn.add(name, type, property)  mn.add() parameters: name--Monitor nametype--Monitor type. Options are &quot;charge_monitor&quot;, &quot;electric_monitor&quot;and &quot;band_monitor&quot;, which are for recording carrier concentration, electric field and potential, band structure respectivelyproperty--Other properties  Property list of electrical monitors: \tdefault\ttype\tnotesgeometry.monitor_type\tpoint\tstring\tSelections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t0\tinteger\t Description: geometry: monitor_type--Set the dimension type of the monitor. For electrical monitors, only 1D type and 2D type are available currently When it's charge_monitor or electric_monitor, Options &quot;linear_x&quot;, &quot;linear_y&quot;, &quot;linear_z&quot;, &quot;2d_x_normal&quot;, &quot;2d_y_normal&quot;, &quot;2d_z_normal&quot; are available. &quot;linear_x&quot; means the monitor is of 1D type and is along the x-direction, so the y_span and z_span should be 0. &quot;2d_x_normal&quot; means the monitor is of 2D type and is in the yz plane, so the x_span should be 0. Similarly for the rest interpolate_accuracy--Set the accuracy of the rectangular grid for extracting the monitor result. Its value ranges from 1 to 10, where 1 means the grid size is 10nm, and 10 means the grid size is 1nm, and the grid size varies uniformly with the variation in interpolate_accuracy.  Examples of add electrical monitors​ mn.add(name=&quot;electric_2d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y_min&quot;: -1, &quot;y_max&quot;: 1, &quot;z_min&quot;: -1, &quot;z_max&quot;: 1, &quot;interpolate_accuracy&quot;: 4}}) mn.add(name=&quot;electric_1d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_z&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: -1, &quot;z_max&quot;: 1, &quot;interpolate_accuracy&quot;: 4}}) mn.add(name=&quot;band_1d&quot;, type=&quot;band_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_x&quot;, &quot;x&quot;: 0, &quot;x_span&quot;: 2, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: 0, &quot;z_max&quot;: 0, &quot;interpolate_accuracy&quot;: 4}})   "},{"title":"9. How to set up eletrical local mesh​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#9-how-to-set-up-eletrical-local-mesh","content":" "},{"title":"9.1 Electrical local mesh in a rectangle region​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#91-electrical-local-mesh-in-a-rectangle-region","content":"Electrical local mesh in a rectangle region is added and set up through add_emesh function. The format is st.add_emesh(name, property)  add_emesh() parameters: name--Custom nameproperty--Other properties Property list of electrical local mesh in a rectangle region: \tdefault\ttype\tnotesx float x_span float\tRestrained by condition: &gt;=0. x_min float x_max float y float y_span float\tRestrained by condition: &gt;=0. y_min float y_max float z float z_span float\tRestrained by condition: &gt;=0. z_min float z_max float mesh_size float\tmax size of electrical simulation mesh Description: mesh_size--Set the max size of electrical mesh grid in the region Note: When the simulation region is in the xy plane, only the parameters in the x, y direction are effective, and parameters in the z direction will be ignored. Similarly for the rest.  Example of electrical local mesh in a region setting​ st.add_emesh(name=&quot;local_mesh&quot;, property={ &quot;y&quot;: 0, &quot;y_span&quot;: 1, &quot;z&quot;: 0, &quot;z_span&quot;: 1, &quot;mesh_size&quot;: 0.01})   "},{"title":"9.2 Electrical local mesh along a line​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#92-electrical-local-mesh-along-a-line","content":"Electrical local mesh along a line is added and set up through add_emesh_alone_line function. The format is st.add_emesh_alone_line(name, property)  add_emesh_alone_line() parameters: name--Custom nameproperty--Other properties Property list of electrical local mesh along a line: \tdefault\ttype\tnotesstart_x\t0\tfloat start_y\t0\tfloat\tRestrained by condition: &gt;=0. start_z\t0\tfloat end_x\t1\tfloat end_y\t1\tfloat end_z\t1\tfloat\tRestrained by condition: &gt;=0. mesh_size\t0.01\tfloat\t Description: start_x--Set x coordinate of the start point. Similarly for the restmesh_size--Set the max size of electrical mesh grid in the range Note: When the simulation region is in the xy plane, besides start_x, start_y, end_x and end_y, it is also required to set the start_z and end_z, which should both be the same as the z coordinate of the plane. Similarly for the rest.  Example of electrical local mesh along a line setting​ st.add_emesh_along_line(name=&quot;local_mesh_along_line&quot;, property={ &quot;start_x&quot;: 0, &quot;start_y&quot;: -1, &quot;start_z&quot;: -1, &quot;end_x&quot;: 0, &quot;end_y&quot;: 1, &quot;end_z&quot;: 1, &quot;mesh_size&quot;: 0.01})   "},{"title":"10. How to extract electrical result​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#10-how-to-extract-electrical-result","content":"The simulation results are extracted by the extract function in SDK.  "},{"title":"10.1 Extract generation rate​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#101-extract-generation-rate","content":"Generation Rate is extracted from result_afdtd (result of AFDTD simulation). The format is result_generate = result_afdtd.run_generation_rate_analysis(name, monitor, average_dimension, light_power, coordinate_unit, field_length_unit) result_generate.extract(data, export_csv, show, log, savepath)  result_afdtd.run_generation_rate_analysis() parameters: name--Custom namemonitor--Name of the power_monitor for calculating optical generation rate. The power_monitor is required to be of 3D typeaverage_dimension--Set the direction to take the average of the optical generate ratelight_power--Set the power of the light source, measured in W. The optical generation rate will be scaled based on the powercoordinate_unit--Set the coordinate unit in the optical generation rate file (gfile). Options are &quot;m&quot;, &quot;cm&quot;, &quot;um&quot; and &quot;nm&quot;field_length_unit--Set the length unit in the generation rate unit in the optical generation rate file (gfile). Options are &quot;m&quot;, &quot;cm&quot;, &quot;um&quot; and &quot;nm&quot;. If it's set to &quot;m&quot;, the generation rate unit in the gfile will be /m^3/s. Similarly for the rest  result_genrate.extract() parameters： data--Type of the result When data is set to &quot;generation_rate&quot;, besides an image file and a csv file, the result files also include a text file in .gfile format. The coordinate unit in the csv and the image file is um, and the generation rate unit in the two files is /cm^3/s. These units can't be modified when extracting the result. However, the units in the gfile are controlled by coordinate_unit、field_length_unit. And only the gfile can be imported to the OEDevice solverWhen data is set to &quot;pabs_total&quot;, the total absorption power is extracted export_csv--Whether to export csv file show--Whether to show the plot in a popup window log--Whether to apply a logarithmic normalization in the intensity plot savepath--The save path of the result extraction  Example of extracting generation rate​ result_generate = result_afdtd.run_generation_rate_analysis(name='genrate', monitor=3D_power_monitor_name, average_dimension='x', light_power=1, coordinate_unit='m', field_length_unit='m') result_generate.extract(data='generation_rate', export_csv=True, show=False, log=False, savepath=savepath)   "},{"title":"10.2 Extract electrode result​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#102-extract-electrode-result","content":"The results of electrode are extracted from result_oedevice (result of OEDevice simulation). The format is result_oedevice.extract(data, electrode, operation, export_csv, show, savepath)  Extraction of electrode result parameters: data--Type of result When it's steady state simulation or SSAC simulation, options &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot; are available, which means the current at the electrode versus voltage is extracted, with &quot;I&quot; for the total current&quot;In&quot; for the electron current&quot;Ip&quot; for the hole current When it's SSAC simulation, options &quot;Iac&quot; and &quot;C&quot; are available, which means the AC current or capacitance at the electrode versus voltage at different frequency points is extracted, with &quot;Iac&quot; for the total AC current&quot;C&quot; for the capacitance When it's transient simulation, options &quot;I&quot;, &quot;In&quot;, &quot;Ip&quot; are available, which means the current at the electrode versus time is extracted, with &quot;I&quot; for the total current&quot;In&quot; for the electron current&quot;Ip&quot; for the hole current electrode--Name of the electrodeoperation--Options are &quot;real&quot; (by default), &quot;imag&quot;, &quot;abs&quot;, &quot;abs2&quot;. For a result whose value is a real number, this parameter can be omitted. Bur for a result whose value is a complex number, like &quot;Iac&quot;, it must be used to extract the real and imaginary part of the result respectivelyexport_csv--Whether to export csv fileshow--Whether to show the plot in a popup windowsavepath--The save path of the result extraction  Example of extracting electrode result​ result_oedevice.extract(data=&quot;I&quot;, electrode=&quot;cathode&quot;, export_csv=True, show=False, savepath=savepath) result_oedevice.extract(data=&quot;Iac&quot;, electrode=&quot;cathode&quot;, operation=&quot;real&quot;, export_csv=True, show=False, savepath=savepath)   "},{"title":"10.3 Extract results of electrical monitor​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#103-extract-results-of-electrical-monitor","content":"The electrical monitor result extraction is similar to the electrode result extraction, but a monitor instead of an electrode is required to be specified. The format is result_oedevice.extract(data, monitor, operation, export_csv, show, log, savepath)  Extraction of electrode result parameters: data--Type of result When the monitor is charge_monitor, options &quot;n&quot;, &quot;p&quot; are available, which means the concentration of carriers is extracted, with &quot;n&quot; for the electron&quot;p&quot; for the hole When the monitor is electric_monitor, options &quot;electric_field&quot;, &quot;ex&quot;, &quot;ey&quot;, &quot;ez&quot;, &quot;potential&quot; are available, which means the concentration of carriers is extracted, with &quot;electric_field&quot; for the absolute value of the electric field&quot;ex&quot; for the x component of the electric field&quot;ey&quot; for the y component of the electric field&quot;ez&quot; for the z component of the electric field&quot;potential&quot; for the electrostatic potential When the monitor is band_monitor, options &quot;conduction_band&quot;, &quot;valence_band&quot;, &quot;equasi_fermi&quot;, &quot;hquasi_fermi&quot; are available, which means the band structure is extracted, with &quot;conduction_band&quot; for the conduction band energy level&quot;valence_band&quot; for the valence band energy level&quot;equasi_fermi&quot; for the electron quasi-Fermi potential&quot;hquasi_fermi&quot; for the hole quasi-Fermi potential operation--Options are &quot;real&quot; (by default), &quot;imag&quot;, &quot;abs&quot;, &quot;abs2&quot; export_csv--Whether to export csv file. When the monitor is of 2D type, the result is a distribution in a 2D region, and the plot is an intensity image; When the monitor is of 1D type, the result is a distribution along a 1D range, and the plot is a curve show--Whether to show the plot in a popup window log--Whether to take the logarithm of the result savepath--The save path of the result extraction  Example of extracting electrical monitor result​ result_device.extract(data=&quot;n&quot;, monitor=&quot;charge_2d&quot;, export_csv=True, show=False, log=True, savepath=savepath) result_device.extract(data=&quot;p&quot;, monitor=&quot;charge_1d&quot;, export_csv=True, show=False, log=False, savepath=savepath) result_device.extract(data=&quot;electric_field&quot;, monitor=&quot;electric_2d&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;ex&quot;, monitor=&quot;electric_2d&quot;, operation=&quot;abs&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;potential&quot;, monitor=&quot;electric_1d&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;conduction_band&quot;, monitor=&quot;band_1d&quot;, export_csv=True, show=False, savepath=savepath) result_device.extract(data=&quot;hquasi_fermi&quot;, monitor=&quot;band_1d&quot;, export_csv=True, show=False, savepath=savepath)   "},{"title":"10.4 Extract results of modulator analysis​","type":1,"pageTitle":"Active Device Simulation","url":"/my-website/docs/faq/SimulationSetup/ActiveDeviceSimulation#104-extract-results-of-modulator-analysis","content":"The results of modulator analysis are extracted from result_afde (result of AFDE). The format is result_afde.extract(data, operation, export_csv, show, savepath)  result_afde.extract() parameters: data--Type of result. Options are &quot;effective_index&quot;, &quot;loss&quot;, which means the effective index or loss versus voltage is extractedoperation--Options are &quot;real&quot; (by default), &quot;imag&quot;, &quot;abs&quot;, &quot;abs2&quot;. For a result whose value is a real number, this parameter can be omitted. Bur for a result whose value is a complex number, like &quot;effective_index&quot;, it must be used to extract the real and imaginary part of the result respectivelyexport_csv--Whether to export csv fileshow--Whether to show the plot in a popup windowsavepath--The save path of the result extraction  Example of extracting modulator analysis result​ result_afde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;real&quot;, show=False, savepath=savepath) result_afde.extract(data=&quot;effective_index&quot;, export_csv=True, operation=&quot;imag&quot;, show=False, savepath=savepath) result_afde.extract(data=&quot;loss&quot;, export_csv=True, show=False, savepath=savepath)   "},{"title":"曼光介绍","type":0,"sectionRef":"#","url":"/my-website/docs/intro","content":"曼光介绍","keywords":""},{"title":"parameter","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/all/parameter","content":"parameter","keywords":""},{"title":"versions","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/all/versions","content":"versions","keywords":""},{"title":"maxoptics_sdk.console","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/console/","content":"","keywords":""},{"title":"maxoptics_sdk.console.ConsoleCommands​","type":1,"pageTitle":"maxoptics_sdk.console","url":"/my-website/docs/test/core/console/#maxoptics_sdkconsoleconsolecommands","content":"class maxoptics_sdk.console.ConsoleCommands  Bases: object static activate(command)¶ static doc(command) static init(command) static linuxpre(command) static new(parser) static run(command)  "},{"title":"maxoptics_sdk.console.run​","type":1,"pageTitle":"maxoptics_sdk.console","url":"/my-website/docs/test/core/console/#maxoptics_sdkconsolerun","content":"maxoptics_sdk.console.run()  "},{"title":"maxoptics_sdk.helper","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/helper/","content":"","keywords":""},{"title":"maxoptics_sdk.helper.json_load(file_path)​","type":1,"pageTitle":"maxoptics_sdk.helper","url":"/my-website/docs/test/core/helper/#maxoptics_sdkhelperjson_loadfile_path","content":""},{"title":"maxoptics_sdk.helper.timed(f: Callable[..., R]) → Callable[..., R]​","type":1,"pageTitle":"maxoptics_sdk.helper","url":"/my-website/docs/test/core/helper/#maxoptics_sdkhelpertimedf-callable-r--callable-r","content":"Add timer prints for wrapped function. Parameters\tf-Function Returns\tWrapped function  @timed def f(): import time time.sleep(1) f() [Finished in 0.02 mins]  "},{"title":"maxoptics_sdk.helper.with_path(f: Callable[..., R]) → Callable[..., R]​","type":1,"pageTitle":"maxoptics_sdk.helper","url":"/my-website/docs/test/core/helper/#maxoptics_sdkhelperwith_pathf-callable-r--callable-r","content":"Add path input path keyword-argument for wrapped function. Value is file’s directory path. Parameters\tf-Function Returns\tWrapped function  @with_path def f(*, path): return path f()  "},{"title":"interface","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/material/interface","content":"","keywords":""},{"title":"1. add_anisotropy​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#1-add_anisotropy","content":""},{"title":"Syntax​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#syntax","content":"abstract add_anisotropy(*, name: str, data: List[Tuple[float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float]], color: str | None = None, alpha: float | None = None, fitting: Literal[None, 'linear'], order: int = 2) abstract add_anisotropy(*, name: str, data: List[Tuple[float, float, float, float, float, float, float]], color: str | None = None, alpha: float | None = None, fitting: Literal[None, 'linear'], order: int = 2) "},{"title":"Usage​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#usage","content":"Add a project anisotropy material. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#parameters-and-returns","content":"Parameters\tExplanation name\tmaterial name data\tMaterial data. Format is [(wavelength, xx index real, xx index imag, yy index real, yy index imag, zz index real, zz index imag), …] or [(wavelength, xx index real, xx index imag, xy index real, xy index imag, …), …]. color\tMaterial color. If not filled, color will be calculated from index parameters. fitting\tMaterial fitting mode. order\tMaterial mesh order.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#example","content":"mt = pj.Material() mt.add_anisotropy(name=&quot;LN&quot;, fitting=None, data=[(wavelength * 1e-6, 2.211, 0, 2.138, 0, 2.211, 0)], order=2 )  "},{"title":"2. add_dispersion​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#2-add_dispersion","content":""},{"title":"Syntax​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#syntax-1","content":"abstract add_dispersion(*, name: str, data: List[Tuple[float, float, float]], color: str | None = None, alpha: float | None = None, fitting: Literal[None, 'linear'], order: int = 2) "},{"title":"Usage​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#usage-1","content":"Add a project dispersion material. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#parameters-and-returns-1","content":"Parameters\tExplanation name\tmaterial name data\tMaterial data. Format is [(wavelength, index real, index imag), …]. color\tMaterial color. If not filled, color will be calculated from index parameters. fitting\tMaterial fitting mode. order\tMaterial mesh order.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#example-1","content":"mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.55e-06, 1.444, 0), (1.30e-06, 1.81, 0.227)], order=1 )  "},{"title":"3. add_lib​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#3-add_lib","content":""},{"title":"Syntax​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#syntax-2","content":"abstract add_lib(*, name: str, data: Any, override: dict | None = None, color: str | None = None, alpha: float | None = None, order: int = 2) "},{"title":"Usage​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#usage-2","content":"Add a project material with existing material in library. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#parameters-and-returns-2","content":"Parameters\tExplanation name\tmaterial name data\tA existing material in library. override\toverride. color\tMaterial color. If not filled, color will be calculated from index parameters. order\tMaterial mesh order.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#example-2","content":"mt = pj.Material() mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2)  "},{"title":"4. add_nondispersion​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#4-add_nondispersion","content":""},{"title":"Syntax​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#syntax-3","content":"abstract add_nondispersion(*, name: str, data: List[Tuple[float, float]], color: str | None = None, alpha: float | None = None, order: int = 2) "},{"title":"Usage​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#usage-3","content":"Add a project non-dispersion material. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#parameters-and-returns-3","content":"Parameters\tExplanation name\tmaterial name data\tMaterial data. Format is [(index real, index imag)]. color\tMaterial color. If not filled, color will be calculated from index parameters. order\tMaterial mesh order.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/material/interface#example-3","content":"mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=1)  "},{"title":"MonitorInterface","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/interface","content":"","keywords":""},{"title":"1. add a monitor​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#1-add-a-monitor","content":""},{"title":"Syntax​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#syntax","content":"abstract add(*, type: Literal['electric_monitor'], name: str, property: PostProcessElectricMonitor) abstract add(*, type: Literal['current_monitor'], name: str, property: PostProcessCurrentMonitor) abstract add(*, type: Literal['charge_monitor'], name: str, property: PostProcessChargeMonitor) abstract add(*, type: Literal['band_monitor'], name: str, property: PostProcessBandMonitor) abstract add(*, type: Literal['profile_monitor'], name: str, property: PostProcessProfileMonitor) abstract add(*, type: Literal['global_monitor', 'global_option'], name: str, property: PostProcessGlobalMonitor) abstract add(*, type: Literal['time_monitor'], name: str, property: PostProcessTimeMonitor) abstract add(*, type: Literal['power_monitor'], name: str, property: PostProcessPowerMonitor) abstract add(*, type: Literal['mode_expansion'], name: str, property: PostProcessModeExpansion) "},{"title":"Usage​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#usage","content":"Add a monitor to current project. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#parameters-and-returns","content":"Parameters\tExplanation name\tMonitor name type\tMonitor type. property\tMonitor property  Returns:\tNo return. "},{"title":"MODE_EXPANSION​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#mode_expansion","content":"\tdefault\ttype\tnotes geometry.monitor_type string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.rotate_settings.theta\t0\tfloat\tRestrained by condition: &gt;-90,&lt;90. geometry.rotate_settings.phi\t0\tfloat\tRestrained by condition: &gt;=0,&lt;=360. geometry.rotate_settings.rotation_offset\t0\tfloat\tRestrained by condition: &gt;=-1e30,&lt;=1e30. mode_expansion.[].monitors_for_expansion.name string mode_expansion.[].monitors_for_expansion.frequency_monitor string mode_expansion.direction\tpositive\tstring\tSelections are ['positive', 'negative']. mode_expansion.mode_calculation.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'user_select']. mode_expansion.mode_calculation.mode_index list mode_expansion.mode_calculation.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. mode_expansion.mode_calculation.n\t1.0\tfloat mode_expansion.mode_calculation.number_of_trial_modes\t20\tinteger mode_expansion.mode_calculation.override_global_options\tfalse\tbool mode_expansion.mode_calculation.override_global_monitor_setting.sample_spacing\tuniform\tstring\tSelections are ['uniform']. mode_expansion.mode_calculation.override_global_monitor_setting.use_wavelength_spacing\ttrue\tbool mode_expansion.mode_calculation.override_global_monitor_setting.spacing_type\twavelength\tstring\tSelections are ['wavelength', 'frequency']. mode_expansion.mode_calculation.override_global_monitor_setting.spacing_limit\tmin_max\tstring\tSelections are ['min_max', 'center_span']. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_min float mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_max float mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_center float mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_span float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_min float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_max float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_center float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_span float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_points integer mode_expansion.mode_calculation.bent_waveguide.bent_waveguide\tfalse\tbool mode_expansion.mode_calculation.bent_waveguide.radius\t1.0\tfloat mode_expansion.mode_calculation.bent_waveguide.orientation\t0.0\tfloat mode_expansion.mode_calculation.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. "},{"title":"GLOBAL_MONITOR​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#global_monitor","content":"\tdefault\ttype\tnotes frequency_power.sample_spacing\tuniform\tstring\tSelections are ['uniform']. frequency_power.use_wavelength_spacing\ttrue\tbool frequency_power.spacing_type\twavelength\tstring\tSelections are ['wavelength', 'frequency']. frequency_power.spacing_limit\tmin_max\tstring\tSelections are ['min_max', 'center_span']. frequency_power.wavelength_min float frequency_power.wavelength_max float frequency_power.wavelength_center float frequency_power.wavelength_span float frequency_power.frequency_min float frequency_power.frequency_max float frequency_power.frequency_center float frequency_power.frequency_span float frequency_power.frequency_points\t5\tinteger advanced.min_sampling_per_cycle\t2\tinteger\t "},{"title":"PROFILE_MONITOR​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#profile_monitor","content":"\tdefault\ttype\tnotes geometry.monitor_type string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. geometry.x_resolution\t100\tinteger geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t "},{"title":"TIME_MONITOR​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#time_monitor","content":"\tdefault\ttype\tnotes general.stop_method\tend_of_simulation\tstring\tSelections are ['end_of_simulation', 'choose_stop_time', 'choose_number_of_snapshots']. general.start_time\t0\tfloat general.stop_time\t1000\tfloat general.number_of_snapshots\t0\tinteger geometry.monitor_type string\tSelections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float advanced.sampling_rate.min_sampling_per_cycle\t10\tinteger\t "},{"title":"POWER_MONITOR​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#power_monitor","content":"\tdefault\ttype\tnotes general.override_global_options\tfalse\tbool general.frequency_profile.sample_spacing\tuniform\tstring\tSelections are ['uniform']. general.frequency_profile.use_wavelength_spacing\ttrue\tbool general.frequency_profile.spacing_type\twavelength\tstring\tSelections are ['wavelength', 'frequency']. general.frequency_profile.spacing_limit\tmin_max\tstring\tSelections are ['min_max', 'center_span']. general.frequency_profile.wavelength_min float general.frequency_profile.wavelength_max float general.frequency_profile.wavelength_center float general.frequency_profile.wavelength_span float general.frequency_profile.frequency_min float general.frequency_profile.frequency_max float general.frequency_profile.frequency_center float general.frequency_profile.frequency_span float general.frequency_profile.frequency_points integer geometry.monitor_type string\tSelections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float advanced.sampling_frequency.min_sampling_per_cycle\t2\tinteger mode_expansion.enable\tfalse\tbool mode_expansion.direction\tpositive\tstring\tSelections are ['positive', 'negative']. mode_expansion.mode_calculation.mode_selection\tfundamental\tstring\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'user_select']. mode_expansion.mode_calculation.mode_index list mode_expansion.mode_calculation.override_global_options\tfalse\tbool mode_expansion.mode_calculation.override_global_monitor_setting.sample_spacing\tuniform\tstring\tSelections are ['uniform']. mode_expansion.mode_calculation.override_global_monitor_setting.use_wavelength_spacing\ttrue\tbool mode_expansion.mode_calculation.override_global_monitor_setting.spacing_type\twavelength\tstring\tSelections are ['wavelength', 'frequency']. mode_expansion.mode_calculation.override_global_monitor_setting.spacing_limit\tmin_max\tstring\tSelections are ['min_max', 'center_span']. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_min float mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_max float mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_center float mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_span float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_min float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_max float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_center float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_span float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_points integer mode_expansion.mode_calculation.bent_waveguide.bent_waveguide\tfalse\tbool mode_expansion.mode_calculation.bent_waveguide.radius\t1.0\tfloat mode_expansion.mode_calculation.bent_waveguide.orientation\t0.0\tfloat mode_expansion.mode_calculation.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. "},{"title":"BAND_MONITOR​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#band_monitor","content":"\tdefault\ttype\tnotes general.record_ec\ttrue\tbool general.record_ev\ttrue\tbool general.record_ei\ttrue\tbool general.record_efn\ttrue\tbool general.record_efp\ttrue\tbool general.record_evac\ttrue\tbool geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: [1,10]. "},{"title":"CHARGE_MONITOR​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#charge_monitor","content":"\tdefault\ttype\tnotes general.record_electrons\ttrue\tbool general.record_holes\ttrue\tbool general.integrate_total_charge\ttrue\tbool\tAvailable when monitor_type is in ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: [1,10] "},{"title":"ELECTRIC_MONITOR​","type":1,"pageTitle":"MonitorInterface","url":"/my-website/docs/test/core/monitors/interface#electric_monitor","content":"\tdefault\ttype\tnotes general.record_electrics_field\ttrue\tbool general.record_electrostatic_potential\ttrue\tbool general.calculate_net_charge\ttrue\tbool\tAvailable when monitor_type is in ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: [1,10]. "},{"title":"post_process_band_monitor_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/post_process_band_monitor_typing","content":"post_process_band_monitor_typing","keywords":""},{"title":"post_process_charge_monitor_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/post_process_charge_monitor_typing","content":"post_process_charge_monitor_typing","keywords":""},{"title":"post_process_current_monitor_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/post_process_current_monitor_typing","content":"post_process_current_monitor_typing","keywords":""},{"title":"post_process_electric_monitor_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/post_process_electric_monitor_typing","content":"post_process_electric_monitor_typing","keywords":""},{"title":"post_process_global_monitor_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/post_process_global_monitor_typing","content":"post_process_global_monitor_typing","keywords":""},{"title":"post_process_mode_expansion_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/post_process_mode_expansion_typing","content":"","keywords":""},{"title":"PostProcessModeExpansion​","type":1,"pageTitle":"post_process_mode_expansion_typing","url":"/my-website/docs/test/core/monitors/post_process_mode_expansion_typing#postprocessmodeexpansion","content":"PostProcessModeExpansion class maxoptics_sdk.core.monitors.post_process_mode_expansion_typing.PostProcessModeExpansion(*args, **kwargs)  Bases: dict geometry: PostProcessModeExpansionGeometry frequency_power: PostProcessModeExpansionModeExpansion  "},{"title":"PostProcessModeExpansionGeometry​","type":1,"pageTitle":"post_process_mode_expansion_typing","url":"/my-website/docs/test/core/monitors/post_process_mode_expansion_typing#postprocessmodeexpansiongeometry","content":"class maxoptics_sdk.core.monitors.post_process_mode_expansion_typing.PostProcessModeExpansionGeometry(*args, **kwargs)  Bases: dict Parameters\tExplanation monitor_type\tLiteral['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z'] rotate_settings\tPostProcessModeExpansionGeometryRotateSettings x\tfloat | int | FloatParameter | FloatParameterExpression x_max\tfloat | int | FloatParameter | FloatParameterExpression x_min\tfloat | int | FloatParameter | FloatParameterExpression x_span\tfloat | int | FloatParameter | FloatParameterExpression y\tfloat | int | FloatParameter | FloatParameterExpression y_max\tfloat | int | FloatParameter | FloatParameterExpression y_min\tfloat | int | FloatParameter | FloatParameterExpression y_span\tfloat | int | FloatParameter | FloatParameterExpression z\tfloat | int | FloatParameter | FloatParameterExpression z_max\tfloat | int | FloatParameter | FloatParameterExpression z_min\tfloat | int | FloatParameter | FloatParameterExpression z_span\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessModeExpansionGeometryRotateSettings​","type":1,"pageTitle":"post_process_mode_expansion_typing","url":"/my-website/docs/test/core/monitors/post_process_mode_expansion_typing#postprocessmodeexpansiongeometryrotatesettings","content":"class maxoptics_sdk.core.monitors.post_process_mode_expansion_typing.PostProcessModeExpansionGeometryRotateSettings(*args, **kwargs)  Bases: dict Parameters\tExplanation phi\tfloat | int | FloatParameter | FloatParameterExpression rotation_offset\tfloat | int | FloatParameter | FloatParameterExpression theta\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessModeExpansionModeExpansion​","type":1,"pageTitle":"post_process_mode_expansion_typing","url":"/my-website/docs/test/core/monitors/post_process_mode_expansion_typing#postprocessmodeexpansionmodeexpansion","content":"class maxoptics_sdk.core.monitors.post_process_mode_expansion_typing PostProcessModeExpansionModeExpansion(*args, **kwargs)  Bases: dict Parameters\tExplanation direction\tLiteral['positive', 'negative'] mode_calculation\tPostProcessModeExpansionModeExpansionModeCalculation monitors_for_expansion\tList[PostProcessModeExpansionModeExpansionmonitorsForExpansion]  "},{"title":"PostProcessModeExpansionModeExpansionModeCalculation​","type":1,"pageTitle":"post_process_mode_expansion_typing","url":"/my-website/docs/test/core/monitors/post_process_mode_expansion_typing#postprocessmodeexpansionmodeexpansionmodecalculation","content":"class maxoptics_sdk.core.monitors.post_process_mode_expansion_typing PostProcessModeExpansionModeExpansionModeCalculation(*args, **kwargs)  Bases: dict Parameters\tExplanation bent_waveguide\tPostProcessModeExpansionModeExpansionModeCalculationBentWaveguide mode_index\tTuple[Any, ...] | List[Any] mode_selection\tLiteral['fundamental', 'fundamental_TE', 'fundamental_TM', 'user_select'] n\tfloat | int | FloatParameter | FloatParameterExpression number_of_trial_modes\tint override_global_monitor_setting\tPostProcessModeExpansionModeExpansionModeCalculationOverrideGlobalMonitorSetting override_global_options\tbool search\tLiteral['near_n', 'max_index']  "},{"title":"PostProcessModeExpansionModeExpansionModeCalculationBentWaveguide​","type":1,"pageTitle":"post_process_mode_expansion_typing","url":"/my-website/docs/test/core/monitors/post_process_mode_expansion_typing#postprocessmodeexpansionmodeexpansionmodecalculationbentwaveguide","content":"class maxoptics_sdk.core.monitors.post_process_mode_expansion_typing.PostProcessModeExpansionModeExpansionModeCalculationBentWaveguide(*args, **kwargs)  Bases: dict Parameters\tExplanation bent_waveguide\tbool location\tLiteral['simulation_center'] orientation\tfloat | int | FloatParameter | FloatParameterExpression radius\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessModeExpansionModeExpansionModeCalculationOverrideGlobalMonitorSetting​","type":1,"pageTitle":"post_process_mode_expansion_typing","url":"/my-website/docs/test/core/monitors/post_process_mode_expansion_typing#postprocessmodeexpansionmodeexpansionmodecalculationoverrideglobalmonitorsetting","content":"class maxoptics_sdk.core.monitors.post_process_mode_expansion_typing.PostProcessModeExpansionModeExpansionModeCalculationOverrideGlobalMonitorSetting(*args, **kwargs)  Bases: dict Parameters\tExplanation frequency_center\tfloat | int | FloatParameter | FloatParameterExpression frequency_max\tfloat | int | FloatParameter | FloatParameterExpression frequency_min\tfloat | int | FloatParameter | FloatParameterExpression frequency_points\tint frequency_span\tfloat | int | FloatParameter | FloatParameterExpression sample_spacing\tLiteral['uniform'] spacing_limit\tLiteral['min_max', 'center_span'] spacing_type\tLiteral['wavelength', 'frequency'] use_wavelength_spacing\tbool wavelength_center\tfloat | int | FloatParameter | FloatParameterExpression wavelength_max\tfloat | int | FloatParameter | FloatParameterExpression wavelength_min\tfloat | int | FloatParameter | FloatParameterExpression wavelength_span\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessModeExpansionModeExpansionmonitorsForExpansion​","type":1,"pageTitle":"post_process_mode_expansion_typing","url":"/my-website/docs/test/core/monitors/post_process_mode_expansion_typing#postprocessmodeexpansionmodeexpansionmonitorsforexpansion","content":"class maxoptics_sdk.core.monitors.post_process_mode_expansion_typing.PostProcessModeExpansionModeExpansionmonitorsForExpansion(*args, **kwargs)  Bases: dict Parameters\tExplanation frequency_monitor\tstr name\tstr "},{"title":"post_process_power_monitor_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing","content":"","keywords":""},{"title":"PostProcessPowerMonitor​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitor","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitor(*args, **kwargs)  Bases: dict advanced: PostProcessPowerMonitorAdvanced general: PostProcessPowerMonitorGeneral geometry: PostProcessPowerMonitorGeometry mode_expansion: PostProcessPowerMonitorModeExpansion "},{"title":"PostProcessPowerMonitorAdvanced​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitoradvanced","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitorAdvanced(*args, **kwargs)  Bases: dict sampling_frequency: PostProcessPowerMonitorAdvancedSamplingFrequency "},{"title":"PostProcessPowerMonitorAdvancedSamplingFrequency​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitoradvancedsamplingfrequency","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitorAdvancedSamplingFrequency(*args, **kwargs)  Bases: dict min_sampling_per_cycle: int "},{"title":"PostProcessPowerMonitorGeneral​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitorgeneral","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitorGeneral(*args, **kwargs)  Bases: dict frequency_profile: PostProcessPowerMonitorGeneralFrequencyProfile override_global_options: bool "},{"title":"PostProcessPowerMonitorGeneralFrequencyProfile​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitorgeneralfrequencyprofile","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitorGeneralFrequencyProfile(*args, **kwargs)  Bases: dict Parameters\tExplanation frequency_center\tfloat | int | FloatParameter | FloatParameterExpression frequency_max\tfloat | int | FloatParameter | FloatParameterExpression frequency_min\tfloat | int | FloatParameter | FloatParameterExpression frequency_points\tint frequency_span\tfloat | int | FloatParameter | FloatParameterExpression sample_spacing\tLiteral['uniform'] spacing_limit\tLiteral['min_max', 'center_span'] spacing_type\tLiteral['wavelength', 'frequency'] use_wavelength_spacing\tbool wavelength_center\tfloat | int | FloatParameter | FloatParameterExpression wavelength_max\tfloat | int | FloatParameter | FloatParameterExpression wavelength_min\tfloat | int | FloatParameter | FloatParameterExpression wavelength_span\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessPowerMonitorGeometry​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitorgeometry","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitorGeometry(*args, **kwargs)  Bases: dict Parameters\tExplanation monitor_type\tLiteral['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d'] x\tfloat | int | FloatParameter | FloatParameterExpression x_max\tfloat | int | FloatParameter | FloatParameterExpression x_min\tfloat | int | FloatParameter | FloatParameterExpression x_span\tfloat | int | FloatParameter | FloatParameterExpression y\tfloat | int | FloatParameter | FloatParameterExpression y_max\tfloat | int | FloatParameter | FloatParameterExpression y_min\tfloat | int | FloatParameter | FloatParameterExpression y_span\tfloat | int | FloatParameter | FloatParameterExpression z\tfloat | int | FloatParameter | FloatParameterExpression z_max\tfloat | int | FloatParameter | FloatParameterExpression z_min\tfloat | int | FloatParameter | FloatParameterExpression z_span\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessPowerMonitorModeExpansion​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitormodeexpansion","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitorModeExpansion(*args, **kwargs)  Bases: dict Parameters\tExplanation direction\tLiteral['positive', 'negative'] enable\tbool mode_calculation\tPostProcessPowerMonitorModeExpansionModeCalculation  "},{"title":"PostProcessPowerMonitorModeExpansionModeCalculation​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitormodeexpansionmodecalculation","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitorModeExpansionModeCalculation(*args, **kwargs)  Bases: dict Parameters\tExplanation bent_waveguide\tPostProcessPowerMonitorModeExpansionModeCalculationBentWaveguide mode_index\tTuple[Any, ...] | List[Any] mode_selection\tLiteral['fundamental', 'fundamental_TE', 'fundamental_TM', 'user_select'] n\tfloat | int | FloatParameter | FloatParameterExpression number_of_trial_modes\tint override_global_monitor_setting\tPostProcessPowerMonitorModeExpansionModeCalculationOverrideGlobalMonitorSetting override_global_options\tbool search\tLiteral['near_n', 'max_index'] "},{"title":"PostProcessPowerMonitorModeExpansionModeCalculationBentWaveguide​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitormodeexpansionmodecalculationbentwaveguide","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitorModeExpansionModeCalculationBentWaveguide(*args, **kwargs)  Bases: dict Parameters\tExplanation bent_waveguide\tbool location\tLiteral['simulation_center'] orientation\tfloat | int | FloatParameter | FloatParameterExpression radius\tfloat | int | FloatParameter | FloatParameterExpression "},{"title":"PostProcessPowerMonitorModeExpansionModeCalculationOverrideGlobalMonitorSetting​","type":1,"pageTitle":"post_process_power_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_power_monitor_typing#postprocesspowermonitormodeexpansionmodecalculationoverrideglobalmonitorsetting","content":"class maxoptics_sdk.core.monitors.post_process_power_monitor_typing.PostProcessPowerMonitorModeExpansionModeCalculationOverrideGlobalMonitorSetting(*args, **kwargs)  Bases: dict Parameters\tType frequency_center\tfloat | int | FloatParameter | FloatParameterExpression frequency_max\tfloat | int | FloatParameter | FloatParameterExpression frequency_min\tfloat | int | FloatParameter | FloatParameterExpression frequency_points\tint frequency_span\tfloat | int | FloatParameter | FloatParameterExpression sample_spacing\tLiteral['uniform'] spacing_limit\tLiteral['min_max', 'center_span'] spacing_type\tLiteral['wavelength', 'frequency'] use_wavelength_spacing\tbool wavelength_center\tfloat | int | FloatParameter | FloatParameterExpression wavelength_max\tfloat | int | FloatParameter | FloatParameterExpression wavelength_min\tfloat | int | FloatParameter | FloatParameterExpression wavelength_span\tfloat | int | FloatParameter | FloatParameterExpression "},{"title":"post_process_profile_monitor_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/post_process_profile_monitor_typing","content":"","keywords":""},{"title":"PostProcessProfileMonitor​","type":1,"pageTitle":"post_process_profile_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_profile_monitor_typing#postprocessprofilemonitor","content":"class maxoptics_sdk.core.monitors.post_process_profile_monitor_typing.PostProcessProfileMonitor(*args, **kwargs)  Bases: dict geometry: PostProcessProfileMonitorGeometry "},{"title":"PostProcessProfileMonitorGeometry​","type":1,"pageTitle":"post_process_profile_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_profile_monitor_typing#postprocessprofilemonitorgeometry","content":"class maxoptics_sdk.core.monitors.post_process_profile_monitor_typing.PostProcessProfileMonitorGeometry(*args, **kwargs)  Bases: dict Parameters\tType monitor_type\tLiteral['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z'] x\tfloat | int | FloatParameter | FloatParameterExpression x_max\tfloat | int | FloatParameter | FloatParameterExpression x_min\tfloat | int | FloatParameter | FloatParameterExpression x_resolution\tint x_span\tfloat | int | FloatParameter | FloatParameterExpression y\tfloat | int | FloatParameter | FloatParameterExpression y_max\tfloat | int | FloatParameter | FloatParameterExpression y_min\tfloat | int | FloatParameter | FloatParameterExpression y_span\tfloat | int | FloatParameter | FloatParameterExpression z\tfloat | int | FloatParameter | FloatParameterExpression z_max\tfloat | int | FloatParameter | FloatParameterExpression z_min\tfloat | int | FloatParameter | FloatParameterExpression z_span\tfloat | int | FloatParameter | FloatParameterExpression "},{"title":"post_process_time_monitor_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/monitors/post_process_time_monitor_typing","content":"","keywords":""},{"title":"PostProcessTimeMonitor​","type":1,"pageTitle":"post_process_time_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_time_monitor_typing#postprocesstimemonitor","content":"class maxoptics_sdk.core.monitors.post_process_time_monitor_typing.PostProcessTimeMonitor(*args, **kwargs)  Bases: dict advanced: PostProcessTimeMonitorAdvanced general: PostProcessTimeMonitorGeneral geometry: PostProcessTimeMonitorGeometry "},{"title":"PostProcessTimeMonitorAdvanced​","type":1,"pageTitle":"post_process_time_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_time_monitor_typing#postprocesstimemonitoradvanced","content":"class maxoptics_sdk.core.monitors.post_process_time_monitor_typing.PostProcessTimeMonitorAdvanced(*args, **kwargs)  Bases: dict sampling_rate: PostProcessTimeMonitorAdvancedSamplingRate "},{"title":"PostProcessTimeMonitorAdvancedSamplingRate​","type":1,"pageTitle":"post_process_time_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_time_monitor_typing#postprocesstimemonitoradvancedsamplingrate","content":"class maxoptics_sdk.core.monitors.post_process_time_monitor_typing.PostProcessTimeMonitorAdvancedSamplingRate(*args, **kwargs)  Bases: dict min_sampling_per_cycle: int "},{"title":"PostProcessTimeMonitorGeneral​","type":1,"pageTitle":"post_process_time_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_time_monitor_typing#postprocesstimemonitorgeneral","content":"class maxoptics_sdk.core.monitors.post_process_time_monitor_typing.PostProcessTimeMonitorGeneral(*args, **kwargs)  Bases: dict Parameters\tExplanation number_of_snapshots\tint start_time\tfloat | int | FloatParameter | FloatParameterExpression stop_method\tLiteral['end_of_simulation', 'choose_stop_time', 'choose_number_of_snapshots'] stop_time\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessTimeMonitorGeometry​","type":1,"pageTitle":"post_process_time_monitor_typing","url":"/my-website/docs/test/core/monitors/post_process_time_monitor_typing#postprocesstimemonitorgeometry","content":"class maxoptics_sdk.core.monitors.post_process_time_monitor_typing.PostProcessTimeMonitorGeometry(*args, **kwargs)  Bases: dict Parameters\tExplanation monitor_type\tLiteral['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d'] x\tfloat | int | FloatParameter | FloatParameterExpression x_max\tfloat | int | FloatParameter | FloatParameterExpression x_min\tfloat | int | FloatParameter | FloatParameterExpression x_span\tfloat | int | FloatParameter | FloatParameterExpression y\tfloat | int | FloatParameter | FloatParameterExpression y_max\tfloat | int | FloatParameter | FloatParameterExpression y_min\tfloat | int | FloatParameter | FloatParameterExpression y_span\tfloat | int | FloatParameter | FloatParameterExpression z\tfloat | int | FloatParameter | FloatParameterExpression z_max\tfloat | int | FloatParameter | FloatParameterExpression z_min\tfloat | int | FloatParameter | FloatParameterExpression z_span\tfloat | int | FloatParameter | FloatParameterExpression "},{"title":"PortInterface","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/ports/interface","content":"","keywords":""},{"title":"add a port​","type":1,"pageTitle":"PortInterface","url":"/my-website/docs/test/core/ports/interface#add-a-port","content":""},{"title":"Syntax​","type":1,"pageTitle":"PortInterface","url":"/my-website/docs/test/core/ports/interface#syntax","content":"abstract add(*, type: Literal['eme_port'], name: str, property: PostProcessEmePort) abstract add(*, type: Literal['fdtd_port'], name: str, property: PostProcessFdtdPort) "},{"title":"Usage​","type":1,"pageTitle":"PortInterface","url":"/my-website/docs/test/core/ports/interface#usage","content":"Add a port to current project. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"PortInterface","url":"/my-website/docs/test/core/ports/interface#parameters-and-returns","content":"Parameters\tExplanation name Port name type\tPort type. property Port property  Returns:\tNo return. "},{"title":"FDTD_PORT​","type":1,"pageTitle":"PortInterface","url":"/my-website/docs/test/core/ports/interface#fdtd_port","content":"\tdefault\ttype\tnotes geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float modal_properties.general.inject_axis\tx_axis\tstring\tSelections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. modal_properties.general.direction\tforward\tstring\tSelections are ['forward', 'backward']. modal_properties.general.amplitude\t1\tfloat modal_properties.general.phase\t0\tfloat modal_properties.general.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. modal_properties.general.mode_removal.threshold float modal_properties.general.mode_index\t1\tinteger modal_properties.general.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. modal_properties.general.n\t1.0\tfloat modal_properties.general.number_of_trial_modes\t20\tinteger modal_properties.bent_waveguide.bent_waveguide\tfalse\tbool modal_properties.bent_waveguide.radius\t1\tfloat modal_properties.bent_waveguide.orientation\t20\tfloat modal_properties.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. "},{"title":"EME_PORT​","type":1,"pageTitle":"PortInterface","url":"/my-website/docs/test/core/ports/interface#eme_port","content":"\tdefault\ttype\tnotes geometry.port_location string\tSelections are ['left', 'right']. geometry.use_full_simulation_span\ttrue\tbool geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float eme_port.general.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. eme_port.general.mode_index\t1\tinteger eme_port.general.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. eme_port.general.n\t1.0\tinteger eme_port.bent_waveguide.bent_waveguide\tfalse\tbool eme_port.bent_waveguide.radius\t1\tfloat eme_port.bent_waveguide.orientation\t20\tfloat eme_port.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. eme_port.advanced.offset\t0\tfloat eme_port.advanced.number_of_trial_modes\t20\tinteger eme_port.advanced.mode_removal.threshold float\t "},{"title":"post_process_eme_port_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/ports/post_process_eme_port_typing","content":"","keywords":""},{"title":"PostProcessEmePort​","type":1,"pageTitle":"post_process_eme_port_typing","url":"/my-website/docs/test/core/ports/post_process_eme_port_typing#postprocessemeport","content":"class maxoptics_sdk.core.ports.post_process_eme_port_typing.PostProcessEmePort(*args, **kwargs)  Bases: dict eme_port: PostProcessEmePortEmePort geometry: PostProcessEmePortGeometry  "},{"title":"PostProcessEmePortEmePort​","type":1,"pageTitle":"post_process_eme_port_typing","url":"/my-website/docs/test/core/ports/post_process_eme_port_typing#postprocessemeportemeport","content":"class maxoptics_sdk.core.ports.post_process_eme_port_typing.PostProcessEmePortEmePort(*args, **kwargs)  Bases: dict advanced: PostProcessEmePortEmePortAdvanced bent_waveguide: PostProcessEmePortEmePortBentWaveguide general: PostProcessEmePortEmePortGeneral  "},{"title":"PostProcessEmePortEmePortAdvanced​","type":1,"pageTitle":"post_process_eme_port_typing","url":"/my-website/docs/test/core/ports/post_process_eme_port_typing#postprocessemeportemeportadvanced","content":"class maxoptics_sdk.core.ports.post_process_eme_port_typing.PostProcessEmePortEmePortAdvanced(*args, **kwargs)  Bases: dict mode_removal: PostProcessEmePortEmePortAdvancedModeRemoval number_of_trial_modes: int offset: float | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessEmePortEmePortAdvancedModeRemoval​","type":1,"pageTitle":"post_process_eme_port_typing","url":"/my-website/docs/test/core/ports/post_process_eme_port_typing#postprocessemeportemeportadvancedmoderemoval","content":"class maxoptics_sdk.core.ports.post_process_eme_port_typing.PostProcessEmePortEmePortAdvancedModeRemoval(*args, **kwargs)  Bases: dict threshold: float | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessEmePortEmePortBentWaveguide​","type":1,"pageTitle":"post_process_eme_port_typing","url":"/my-website/docs/test/core/ports/post_process_eme_port_typing#postprocessemeportemeportbentwaveguide","content":"class maxoptics_sdk.core.ports.post_process_eme_port_typing.PostProcessEmePortEmePortBentWaveguide(*args, **kwargs)  Bases: dict Parameters\tType bent_waveguide\tbool location\tLiteral['simulation_center'] orientation\tfloat | int | FloatParameter | FloatParameterExpression radius\tfloat | int | FloatParameter | FloatParameterExpression   "},{"title":"PostProcessEmePortEmePortGeneral​","type":1,"pageTitle":"post_process_eme_port_typing","url":"/my-website/docs/test/core/ports/post_process_eme_port_typing#postprocessemeportemeportgeneral","content":"class maxoptics_sdk.core.ports.post_process_eme_port_typing.PostProcessEmePortEmePortGeneral(*args, **kwargs)  Bases: dict Parameters\tType mode_index\tint mode_selection\tLiteral['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import'] n\tfloat | int | FloatParameter | FloatParameterExpression search\tLiteral['near_n', 'max_index']   "},{"title":"PostProcessEmePortGeometry​","type":1,"pageTitle":"post_process_eme_port_typing","url":"/my-website/docs/test/core/ports/post_process_eme_port_typing#postprocessemeportgeometry","content":"class maxoptics_sdk.core.ports.post_process_eme_port_typing.PostProcessEmePortGeometry(*args, **kwargs)  Bases: dict Parameters\tType port_location\tLiteral['left', 'right'] use_full_simulation_span\tbool y\tfloat | int | FloatParameter | FloatParameterExpression y_max\tfloat | int | FloatParameter | FloatParameterExpression y_min\tfloat | int | FloatParameter | FloatParameterExpression y_span\tfloat | int | FloatParameter | FloatParameterExpression z\tfloat | int | FloatParameter | FloatParameterExpression z_max\tfloat | int | FloatParameter | FloatParameterExpression z_min\tfloat | int | FloatParameter | FloatParameterExpression z_span\tfloat | int | FloatParameter | FloatParameterExpression "},{"title":"post_process_fdtd_port_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/ports/post_process_fdtd_port_typing","content":"","keywords":""},{"title":"PostProcessFdtdPort​","type":1,"pageTitle":"post_process_fdtd_port_typing","url":"/my-website/docs/test/core/ports/post_process_fdtd_port_typing#postprocessfdtdport","content":"class maxoptics_sdk.core.ports.post_process_fdtd_port_typing.PostProcessFdtdPort(*args, **kwargs)  Bases: dict geometry: PostProcessFdtdPortGeometry modal_properties: PostProcessFdtdPortModalProperties  "},{"title":"PostProcessFdtdPortGeometry​","type":1,"pageTitle":"post_process_fdtd_port_typing","url":"/my-website/docs/test/core/ports/post_process_fdtd_port_typing#postprocessfdtdportgeometry","content":"class maxoptics_sdk.core.ports.post_process_fdtd_port_typing.PostProcessFdtdPortGeometry(*args, **kwargs)  Bases: dict Parameters\tType x\tfloat | int | FloatParameter | FloatParameterExpression x_max\tfloat | int | FloatParameter | FloatParameterExpression x_min\tfloat | int | FloatParameter | FloatParameterExpression x_span\tfloat | int | FloatParameter | FloatParameterExpression y\tfloat | int | FloatParameter | FloatParameterExpression y_max\tfloat | int | FloatParameter | FloatParameterExpression y_min\tfloat | int | FloatParameter | FloatParameterExpression y_span\tfloat | int | FloatParameter | FloatParameterExpression z\tfloat | int | FloatParameter | FloatParameterExpression z_max\tfloat | int | FloatParameter | FloatParameterExpression z_min\tfloat | int | FloatParameter | FloatParameterExpression z_span\tfloat | int | FloatParameter | FloatParameterExpression   "},{"title":"PostProcessFdtdPortModalProperties​","type":1,"pageTitle":"post_process_fdtd_port_typing","url":"/my-website/docs/test/core/ports/post_process_fdtd_port_typing#postprocessfdtdportmodalproperties","content":"class maxoptics_sdk.core.ports.post_process_fdtd_port_typing.PostProcessFdtdPortModalProperties(*args, **kwargs)  Bases: dict Parameters\tType bent_waveguide\tPostProcessFdtdPortModalPropertiesBentWaveguide general\tPostProcessFdtdPortModalPropertiesGeneral  "},{"title":"PostProcessFdtdPortModalPropertiesBentWaveguide​","type":1,"pageTitle":"post_process_fdtd_port_typing","url":"/my-website/docs/test/core/ports/post_process_fdtd_port_typing#postprocessfdtdportmodalpropertiesbentwaveguide","content":"class maxoptics_sdk.core.ports.post_process_fdtd_port_typing.PostProcessFdtdPortModalPropertiesBentWaveguide(*args, **kwargs)  Bases: dict Parameters\tType bent_waveguide\tbool location\tLiteral['simulation_center'] orientation\tfloat | int | FloatParameter | FloatParameterExpression radius\tfloat | int | FloatParameter | FloatParameterExpression   "},{"title":"PostProcessFdtdPortModalPropertiesGeneral​","type":1,"pageTitle":"post_process_fdtd_port_typing","url":"/my-website/docs/test/core/ports/post_process_fdtd_port_typing#postprocessfdtdportmodalpropertiesgeneral","content":"class maxoptics_sdk.core.ports.post_process_fdtd_port_typing.PostProcessFdtdPortModalPropertiesGeneral(*args, **kwargs)  Bases: dict Parameters\tType amplitude\tfloat | int | FloatParameter | FloatParameterExpression direction\tLiteral['forward', 'backward'] inject_axis\tLiteral['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z'] mode_index\tint mode_removal\tPostProcessFdtdPortModalPropertiesGeneralModeRemoval mode_selection\tLiteral['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import'] n\tfloat | int | FloatParameter | FloatParameterExpression number_of_trial_modes\tint phase\tfloat | int | FloatParameter | FloatParameterExpression search\tLiteral['near_n', 'max_index']   "},{"title":"PostProcessFdtdPortModalPropertiesGeneralModeRemoval​","type":1,"pageTitle":"post_process_fdtd_port_typing","url":"/my-website/docs/test/core/ports/post_process_fdtd_port_typing#postprocessfdtdportmodalpropertiesgeneralmoderemoval","content":"class maxoptics_sdk.core.ports.post_process_fdtd_port_typing.PostProcessFdtdPortModalPropertiesGeneralModeRemoval(*args, **kwargs)  Bases: dict Parameters\tType threshold\tfloat | int | FloatParameter | FloatParameterExpression "},{"title":"PostProcessPortGroupProperty","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/ports/post_process_port_group_property_typing","content":"","keywords":""},{"title":"PostProcessPortGroupProperty​","type":1,"pageTitle":"PostProcessPortGroupProperty","url":"/my-website/docs/test/core/ports/post_process_port_group_property_typing#postprocessportgroupproperty-1","content":"class maxoptics_sdk.core.ports.post_process_port_group_property_typing.PostProcessPortGroupProperty(*args, **kwargs)  Bases: dict Parameters\tType calculate_group_delay\tbool fractional_offset_for_group_delay\tfloat | int | FloatParameter | FloatParameterExpression source_port\tstr waveform_id\tWaveform wavelength_center\tfloat | int | FloatParameter | FloatParameterExpression wavelength_span\tfloat | int | FloatParameter | FloatParameterExpression "},{"title":"interface","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/project/interface","content":"","keywords":""},{"title":"StructureProperty​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/project/interface#structureproperty","content":"maxoptics_sdk.core.project.interface module "},{"title":"ProjectInterface​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/project/interface#projectinterface","content":"class maxoptics_sdk.core.project.interface.ProjectInterface(*args, **kwargs)  Bases: Protocol "},{"title":"Common Use​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/project/interface#common-use","content":" Method\tExplanation\tReturns Material() → MaterialInterface\tGet material manager for current project\tMaterial manager Monitor() → MonitorInterface\tGet monitor manager for current project.\tMonitor manager Port(*, property: PostProcessPortGroupProperty | None = None) → PortInterface\tGet port manager for current project.\tPort manager. Simulation() → SimulationInterface\tGet simulation manager for current project.\tSimulation manager. Source() → SourceInterface\tGet source manager for current project.\tSource manager Waveform() → WaveformInterface\tGet waveform manager for current project.\tWaveform manager  "},{"title":"Structure​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/project/interface#structure","content":""},{"title":"Syntax​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/project/interface#syntax","content":"Structure(*, mesh_type: Literal['curve_mesh', 'staircase'] = 'curve_mesh', mesh_factor: float = 1.2, background_material: MaterialType | None = None) → StructureInterface "},{"title":"Usage​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/project/interface#usage","content":"Get structure manager for current project. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/project/interface#parameters-and-returns","content":"Parameters\tExplanation mesh_type Mesh type of structures. Default as curve_mesh. mesh_factor\tMesh factor. Default as 1.2. background_material Background material. If not filled, program will create a material with Air in lib.  Returns:\tStructure manager "},{"title":"PortGroupProperty​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/project/interface#portgroupproperty","content":"\tdefault\ttype\tnotes source_port string waveform_id waveform calculate_group_delay\tfalse\tbool fractional_offset_for_group_delay\t0.0001\tfloat\t "},{"title":"StructureProperty​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/project/interface#structureproperty-1","content":"\tdefault\ttype\tnotes mesh_type\tcurve_mesh\tstring\tSelections are ['curve_mesh', 'staircase']. mesh_factor\t1.2\tfloat background_material\tmt['Air']\tmaterial\t "},{"title":"maxoptics_sdk.core.simulation.simu_res.interface module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/simulation/interface","content":"","keywords":""},{"title":"1. calculate​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#1-calculate","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#syntax","content":"abstract calculate(*, simulation_name: str, monitor_name: str, property: FdtdCalculateMethodPropertyProcess, cmp_f: Callable | None = None) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#usage","content":"Calculate basing on the simulation result. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#parameters-and-returns","content":"Parameters\tExplanation monitor_name\tmonitor name property\tproperties for calculation simulation_name\tsimulation name cmp_f\tcompare function, defaults to None  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#example","content":"None  "},{"title":"2. extract​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#2-extract","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#syntax-1","content":"abstract extract(*, data: Literal['calculate_modes'], attribute: Literal['TEratio', 'neff_real', 'neff_imag', 'ng_real', 'ng_imag', 'wavelength_nm', 'loss_dBpcm', None] = None, export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = 'a', mode: int | None = None) → DataFrame abstract extract(*, data: Literal['farfield_fde'], attribute: Literal['E', 'Ex', 'Ey', 'Ez', 'H', 'Hx', 'Hy', 'Hz', 'Px', 'Py', 'Pz', 'Energy density'], show=False, export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = 'a', mode: int) → DataFrame abstract extract(*, data: Literal['calculate_modes'], attribute: Literal['E', 'Ex', 'Ey', 'Ez', 'H', 'Hx', 'Hy', 'Hz', 'Px', 'Py', 'Pz', 'Energy density'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', mode: int) → List[DataFrame] abstract extract(*, data: Literal['mesh_structure'], savepath: Any = 'a', target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False) → List[DataFrame] abstract extract(*, target: Literal['line'] = 'line', data: Literal['frequency_analysis'], attribute: Literal['neff', 'group_index', 'loss', 'polarization'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:facet_data'], export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = 'a') → None abstract extract(*, data: Literal['eme_propagate:monitor', 'propagation_sweep:monitor', 'wavelength_sweep:monitor'], attribute: Literal['E', 'Ex', 'Ey', 'Ez', 'H', 'Hx', 'Hy', 'Hz', 'Px', 'Py', 'Pz', 'Energy density'], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:smatrix'], target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['propagation_sweep:sweep', wavelength_sweep:sweep'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:port_mode_info'], target: Literal['intensity'] = 'intensity', attribute: Literal['E', 'H'], port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None, mode: Any = None) → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:port_mesh_structure'], port_name: str, target: Literal['line', 'intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:port_effective_index', 'eme_propagate:port_ng'], port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a') → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:port_overlap'], target: Literal['line'] = 'line', port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:cell_mesh_structure'], target: Literal['intensity', 'line'], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, target: Literal['intensity'] = 'intensity', data: Literal['eme_propagate:cell_mode_info'], attribute: Literal['E', 'H'], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None, mode: Any = None) → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:prop_field'], attribute: Literal['E', 'Ex', 'Ey', 'Ez', 'H', 'Hx', 'Hy', 'Hz', 'Px', 'Py', 'Pz', 'Energy density'], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:internal_s'], target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['eme_propagate:cell_p_matrix', 'eme_propagate:cell_overlap', 'eme_propagate:cell_s', 'eme_propagate:prop_s'], target: Literal['intensity'] = 'intensity', cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['fdtd:power_monitor', 'fdtd:time_monitor'], target: Literal['intensity', 'line'], attribute: Literal['E', 'Ex', 'Ey', 'Ez', 'H', 'Hx', 'Hy', 'Hz', 'Px', 'Py', 'Pz', 'Energy density'] | Literal['T'], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None, wavelength: Any | None = None) → List[DataFrame] abstract extract(*, data: Literal['fdtd:mode_expansion'], target: Literal['intensity', 'line'], attribute: Literal['a', 'b', 'n', 'p', 'N', 'P', 't_forward', 't_backward', 'T_forward', 'T_backward'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, plot_y: str | None = None, mode: Any | None = None, wavelength: Any | None = None, monitor_name: str, mode_expansion_name: str) → List[DataFrame] abstract extract(*, data: Literal['fdtd:port_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', port_name: str, mode: Any = None, plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['fdtd:mode_source_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', source_name: str, mode: Any = None, plot_x: str | None = None, plot_y: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['fdtd:mode_expansion_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', monitor_name: str, mode_expansion_name: str, plot_x: str | None = None, plot_y: str | None = None, mode: Any = None, wavelength: Any = None) → List[DataFrame] abstract extract(*, data: Literal['smatrix_sweep'], target: Literal['intensity', 'line'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None) → List[DataFrame] abstract extract(*, data: Literal['sweep'], target: Literal['intensity', 'line'], attribute: str, monitor_name: str | None = None, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', plot_x: str | None = None, **kwargs) → List[DataFrame] abstract extract(*, data: Literal['mode_expansion'], target: Literal['line'], attribute: Literal['a', 'b', 'n', 'p', 'N', 'P', 't_forward', 't_backward', 'T_forward', 'T_backward'], monitor_name: str | None = None, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath: Any = 'a', wavelength=None, plot_x: str | None = None, **kwargs) → List[DataFrame] "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#usage-1","content":"Extract a result from completed simulation. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#parameters-and-returns-1","content":"Parameters\tExplanation data\tWhich type/field data will be extracted. export_csv\tWhether to export a csv. Default as False. show\tWhether to show the picture. If set to False, the picture will be saved instead. Default as False. savepath\tPicture save path. Default as ‘a’. target\tHow the data is organized/displayed. Default as None. attribute\tWhich attribute will extracted, in few cases this parameter is not needed. Default as None. real\tWhether to add real part of data. Default as True. imag\tWhether to add imag part of data. If both real and imag is activate, ‘ABS’ data will be extracted. Default as True. plot_x\tselection of x axis of heatmap or line plot. plot_y\tselection of y axis of heatmap. kwargs\tOther visualization parameters. ‘monitor_name’ and ‘mode_expansion_name’ for ‘fdtd:mode_expansion’ for example.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_res.interface module","url":"/my-website/docs/test/core/simulation/interface#example-1","content":"For detailed usage instruction, please view examples  "},{"title":"maxoptics_sdk.core.simulation.interface module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/simulation/simu_res","content":"","keywords":""},{"title":"1. add​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#1-add","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#syntax","content":"abstract add(*, name: str, type: Literal['FDE'], property: FdePostProcess) → SimulationTaskInterface abstract add(*, name: str, type: Literal['AFDE'], property: AfdePostProcess) → SimulationTaskInterface abstract add(*, name: str, type: Literal['OEDevice'], property: OeDevicePostProcess) → SimulationTaskInterface abstract add*, name: str, type: Literal['EME'], property: EmePostProcess) → SimulationTaskInterface abstract add(*, name: str, type: Literal['FDTD'], property: FdtdPostProcess) → SimulationTaskInterface abstract add(*, name: str, type: Literal['FDTD:sweep', 'FDE:sweep', 'EME:sweep'], property: AnyParameterSweepPostProcess) → SimulationTaskInterface abstract add(*, name: str, type: Literal['AFDTD'], property: FdtdPostProcess) → SimulationTaskInterface abstract add(*, name: str, simulation_name: str, source_name: str = '', cell_group_index: int = 0, type: Literal['mode_selection:user_select'], property: ModeSelectionUserSelectPostProcess) → SimulationTaskInterface abstract add(*, name: str, type: Literal['FDTD:smatrix'], property: FdtdSmatrixPostProcess) → SimulationTaskInterface "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#usage","content":"Add a simulation. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#parameters-and-returns","content":"Parameters\tExplanation name\tSimulation name. type\tSimulation type. location\tSimulation run mode, cloud or local. property\tSimulation property. kwargs\tOther simulation parameters. “source_name” is needed for “mode_selection:user_select” type simulation.  Returns:\tSimulation runner. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#example","content":"None  "},{"title":"FDTD_SMATRIX​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#fdtd_smatrix","content":"\tDefault\tType\tNotessimulation_name string []s_matrix_setup.port string []s_matrix_setup.active\ttrue\tbool\t "},{"title":"FDTD​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#fdtd","content":"\tDefault\tType\tNotesextra.fdtd_port_group.source_port string general.dimension\t3d\tstring\tSelections are ['3d']. general.using_optical_path_estimate_time\tfalse\tbool general.simulation_time\t1000\tinteger mesh_settings.mesh_type\tauto_non_uniform\tstring\tSelections are ['auto_non_uniform', 'uniform']. mesh_settings.mesh_accuracy.cells_per_wavelength\t15\tinteger mesh_settings.mesh_step_settings.dx\t0.1\tfloat mesh_settings.mesh_step_settings.dy\t0.1\tfloat mesh_settings.mesh_step_settings.dz\t0.1\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat advanced_options.auto_shutoff.use_early_shutoff\ttrue\tbool advanced_options.auto_shutoff.auto_shutoff_min\t1.0e-4\tfloat advanced_options.auto_shutoff.down_sample_time\t100\tfloat advanced_options.live_slice_filed_display_settings.show_field\ttrue\tbool advanced_options.live_slice_filed_display_settings.select_field_section\t2d_z_normal\tstring\tSelections are ['2d_y_normal', '2d_z_normal']. advanced_options.live_slice_filed_display_settings.select_component\tex\tstring\tSelections are ['ex', 'ey', 'ez']. advanced_options.live_slice_filed_display_settings.time_interval\t200\tfloat advanced_options.live_slice_filed_display_settings.position\t0\tfloat thread_setting.thread\t4\tinteger\t "},{"title":"FDE​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#fde","content":"\tDefault\tType\tNotesgeneral.solver_type\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. mesh_settings.global_mesh_uniform_grid.dx\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dy\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dz\t0.02\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat thread_setting.thread\t4\tinteger fde_analysis.modal_analysis.mesh_structure\tfalse\tbool fde_analysis.modal_analysis.calculate_modes\tfalse\tbool fde_analysis.modal_analysis.[]far_field_settings.calculate\ttrue\tbool fde_analysis.modal_analysis.[]far_field_settings.mode_selection integer fde_analysis.modal_analysis.[]far_field_settings.projection_method\tplanar\tstring\tSelections are ['planar']. fde_analysis.modal_analysis.[]far_field_settings.farfield_filter\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.material_index\t1.4\tfloat fde_analysis.modal_analysis.[]far_field_settings.projection_distance\t4430.65\tfloat fde_analysis.modal_analysis.[]far_field_settings.points_in_x\t50\tfloat fde_analysis.modal_analysis.[]far_field_settings.points_in_y\t50\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_x\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_x_span\t26.1834\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_y\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_y_span\t18.1231\tfloat fde_analysis.modal_analysis.wavelength\t1.55\tfloat fde_analysis.modal_analysis.wavelength_offset\t0.002\tfloat fde_analysis.modal_analysis.number_of_trial_modes\t5\tinteger fde_analysis.modal_analysis.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. fde_analysis.modal_analysis.n\t1\tfloat fde_analysis.modal_analysis.calculate_group_index\tfalse\tbool fde_analysis.modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool fde_analysis.modal_analysis.bent_waveguide.radius\t0.0\tfloat fde_analysis.modal_analysis.bent_waveguide.orientation\t0.0\tfloat fde_analysis.modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. fde_analysis.modal_analysis.mode_removal.threshold float fde_analysis.frequency_analysis.frequency_analysis\tfalse\tbool fde_analysis.frequency_analysis.start_wavelength\t1.55\tfloat fde_analysis.frequency_analysis.stop_wavelength\t1.49896\tfloat fde_analysis.frequency_analysis.number_of_points\t10\tinteger fde_analysis.frequency_analysis.effective_index\t1.0\tfloat fde_analysis.frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\t "},{"title":"ANY_PARAMETER_SWEEP​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#any_parameter_sweep","content":"\tDefault\tType\tNotessimulation_name string sweep_type\tranges\tstring\tSelections are ['ranges', 'values']. []parameters.variable float []parameters.start float []parameters.stop float []parameters.number_of_points integer []parameters.values list []result.name string []result.result string []result.component string\t "},{"title":"EME​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#eme","content":"\tDefault\tType\tNotesgeneral.wavelength float general.wavelength_offset\t0.002\tfloat general.use_wavelength_sweep\tfalse\tbool eme_setup.cell_geometry.energy_conservation\tmake_passive\tstring\tSelections are ['none', 'make_passive']. eme_setup.cell_geometry.display_cells\tfalse\tbool eme_setup.cell_geometry.display_groups\tfalse\tbool eme_setup.cell_geometry.[]cell_group_definition.span float eme_setup.cell_geometry.[]cell_group_definition.cell_number integer eme_setup.cell_geometry.[]cell_group_definition.number_of_modes integer eme_setup.cell_geometry.[]cell_group_definition.sc\tnone\tstring\tSelections are ['none', 'sub_cell', 'sc']. eme_setup.cell_geometry.[]cell_group_definition.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. eme_setup.cell_geometry.[]cell_group_definition.n\t1.0\tfloat transverse_mesh_setting.global_mesh_uniform_grid.dx\t0.02\tfloat transverse_mesh_setting.global_mesh_uniform_grid.dy\t0.02\tfloat transverse_mesh_setting.global_mesh_uniform_grid.dz\t0.02\tfloat transverse_mesh_setting.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat advanced.eme_settings.max_stored_modes\t1000\tinteger thread_settings.thread\t4\tinteger eme_analysis.eme_propagate\tfalse\tbool eme_analysis.periodicity.periodicity\tfalse\tbool eme_analysis.periodicity.[]periodic_group_definition.start_cell_group integer eme_analysis.periodicity.[]periodic_group_definition.end_cell_group integer eme_analysis.periodicity.[]periodic_group_definition.periods integer eme_analysis.propagation_sweep.propagation_sweep\tfalse\tbool eme_analysis.propagation_sweep.parameter\tgroup_span_1\tstring eme_analysis.propagation_sweep.start\t0\tfloat eme_analysis.propagation_sweep.stop\t1\tfloat eme_analysis.propagation_sweep.number_of_points\t3\tinteger eme_analysis.wavelength_sweep.wavelength_sweep\tfalse\tbool eme_analysis.wavelength_sweep.start\t1.5\tfloat eme_analysis.wavelength_sweep.stop\t1.6\tfloat eme_analysis.wavelength_sweep.number_of_wavelength_points\t3\tinteger eme_analysis.select_source.phase\t0\tfloat eme_analysis.select_source.select_mode\tTE\tstring\tSelections are ['TE', 'TM']. "},{"title":"AFDTD​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#afdtd","content":"\tDefault\tType\tNotesextra.fdtd_port_group.source_port string general.dimension\t3d\tstring\tSelections are ['3d']. general.using_optical_path_estimate_time\tfalse\tbool general.simulation_time\t1000\tinteger mesh_settings.mesh_type\tauto_non_uniform\tstring\tSelections are ['auto_non_uniform', 'uniform']. mesh_settings.mesh_accuracy.cells_per_wavelength\t15\tinteger mesh_settings.mesh_step_settings.dx\t0.1\tfloat mesh_settings.mesh_step_settings.dy\t0.1\tfloat mesh_settings.mesh_step_settings.dz\t0.1\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat advanced_options.auto_shutoff.use_early_shutoff\ttrue\tbool advanced_options.auto_shutoff.auto_shutoff_min\t1.0e-4\tfloat advanced_options.auto_shutoff.down_sample_time\t100\tfloat advanced_options.live_slice_filed_display_settings.show_field\ttrue\tbool advanced_options.live_slice_filed_display_settings.select_field_section\t2d_z_normal\tstring\tSelections are ['2d_y_normal', '2d_z_normal']. advanced_options.live_slice_filed_display_settings.select_component\tex\tstring\tSelections are ['ex', 'ey', 'ez']. advanced_options.live_slice_filed_display_settings.time_interval\t200\tfloat advanced_options.live_slice_filed_display_settings.position\t0\tfloat thread_setting.thread\t4\tinteger\t "},{"title":"AFDE​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#afde","content":"\tDefault\tType\tNotesgeneral.solver_type\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. mesh_settings.number_of_mesh_cells_without_override_regions.mesh_cells_x\t50\tinteger mesh_settings.number_of_mesh_cells_without_override_regions.mesh_cells_y\t50\tinteger mesh_settings.number_of_mesh_cells_without_override_regions.mesh_cells_z\t50\tinteger mesh_settings.global_mesh_uniform_grid.dx\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dy\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dz\t0.02\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat thread_setting.thread\t4\tinteger fde_analysis.modal_analysis.mesh_structure\tfalse\tbool fde_analysis.modal_analysis.calculate_modes\tfalse\tbool fde_analysis.modal_analysis.wavelength float fde_analysis.modal_analysis.wavelength_offset\t0.002\tfloat fde_analysis.modal_analysis.number_of_trial_modes\t5\tinteger fde_analysis.modal_analysis.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. fde_analysis.modal_analysis.n\t1\tfloat fde_analysis.modal_analysis.calculate_group_index\tfalse\tbool fde_analysis.modulator_analysis.modulator_analysis\tfalse\tbool fde_analysis.modulator_analysis.interp_vstep_mv\t0.0\tfloat fde_analysis.modulator_analysis.wavelength float fde_analysis.modulator_analysis.number_of_trial_modes\t5\tinteger fde_analysis.modulator_analysis.mode_select\t0\tinteger fde_analysis.modulator_analysis.np_path string other.simulation_temperature\t300\tfloat other.material\t0\tinteger other.model\tSoref_and_Bennett\tstring\tSelections are ['Soref_and_Bennett']. other.coefficients\t0\tinteger other.dn_an float other.dn_en float other.dn_ap float other.dn_ep float other.dalpha_an float other.dalpha_en float other.dalpha_ap float other.dalpha_ep float\t "},{"title":"OEDevice​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#oedevice","content":"Parameter\tDefault\tType\tNotes general.simulation_region\tDevice_Region\tstring\tSelections are ['Device_Region']. general.norm_length\t1\tfloat general.solver_mode\tsteady_state\tstring\tSelections are ['steady_state', 'transient', 'SSAC']. general.temperature_dependence\tIsothermal\tstring\tSelections are ['Isothermal']. general.simulation_temperature\t300\tfloat advanced.non_linear_solver\tNewton\tstring\tSelections are ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', ' LU', ' BCGS']. advanced.use_quasi_fermi\tdisabled\tstring\tSelections are ['disabled', ' enabled']. advanced.damping\tnone\tstring\tSelections are ['none', ' potential']. advanced.potential_update\t1\tinteger advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. advanced.thread_count\t4\tinteger advanced.max_iterations\t30\tinteger advanced.use_global_max_iterations\tfalse\tinteger\tSelections are ['false', 'true'] advanced.poisson_max_iterations\t30\tinteger advanced.ddm_max_iterations\t30\tinteger advanced.relative_tolerance\t1.0e-5\tfloat advanced.tolerance_relax\t1.0e+5\tfloat advanced.divergence_factor\t1.0e+25\tfloat genrate.genrate_path string genrate.source_fraction float genrate.coordinate_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float geometry.z_min float geometry.z_max float small_signal_ac.perturbation_amplitude\t0.001\tfloat small_signal_ac.frequency_spacing\tsingle\tstring\tSelections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat small_signal_ac.start_frequency\t1.0e+06\tfloat small_signal_ac.stop_frequency\t1.0e+09\tfloat small_signal_ac.frequency_interval\t9.9999e+10\tfloat small_signal_ac.num_frequency_points\t2\tinteger small_signal_ac.log_start_frequency\t1.0e+06\tfloat small_signal_ac.log_stop_frequency\t1.0e+10\tfloat small_signal_ac.log_num_frequency_points\t2\tinteger\t "},{"title":"2. load_history_result​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#2-load_history_result","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#syntax-1","content":"load_history_result(*, result_path: str, simu_type: MainSimulationTypeSelection) → SimulationResultInterface "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#usage-1","content":"Load history simulation result from result_path. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#parameters-and-returns-1","content":"Parameters\tExplanation result_path\tPath of history simulation result. Includes * to match abitrary number of characters. If multiple results are matched, the last one will be loaded and a warning will be raised. simu_type\tType of simulation result. This is used to determine which class to load the result.  Returns:\tSimulation result object. "},{"title":"3. simulations​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#3-simulations","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.interface module","url":"/my-website/docs/test/core/simulation/simu_res#syntax-2","content":"simulations: Dict[str, Any] "},{"title":"maxoptics_sdk.core.simulation.simu_task.interface module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/simulation/simu_task","content":"","keywords":""},{"title":"parameter​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameter","content":"Parameters\tExplanation chart\tTaskFile mode_area\tFDEBeamResultHandler.ModeAreaResult props\tDict[str, Any] task_id\tint | str task_path\tstr "},{"title":"SimulationTaskInterface​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#simulationtaskinterface","content":"class maxoptics_sdk.core.simulation.simu_task.interface.SimulationTaskInterface(*args, **kwargs)  Bases: Protocol "},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#syntax","content":"abstract build() → Tuple[MosProject, Dict[str, bool]] props: Dict[str, Any] abstract run() → SimulationResultInterface Returns: Simulation result manager. abstract run_doping(name: str, property: RunDopingPostProcess, norm: str, scale: str, superimpose: bool, show: bool, material_list: list, cmin: float, savepath: str) → SimulationTaskInterface "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#usage","content":"Run doping. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters-and-returns","content":"Parameters\tExplanation property\tDoping preview properties. See below name\tDoping preview name. show\tShow figure or not. Default as False. savepath\tSave path for picture. Required. norm\tColorbar normalization. Selections are ['linear', 'log']. Default as 'linear'. scale\tScale type. Selections are ['equal', 'auto']. Default as 'equal'. superimpose\tSuperimpose doping on structure or not. Default as True. material_list\tSpecified material type list. Default as []. region_list\tSpecified region name list. Default as []. Superior to material_list when not empty. cmax\tMaximum concentration of heatmap colorbar. Default as None. cmin\tMinimum concentration of heatmap colorbar. Default as None.  "},{"title":"RUN_DOPING​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#run_doping","content":""},{"title":"Parameters​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters","content":"Default\tType\tNotes geometry.dimension\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\tfloat geometry.x_span\tfloat\tRestrained by condition: &gt;=0. geometry.x_min\tfloat geometry.x_max\tfloat geometry.y\tfloat geometry.y_span\tfloat\tRestrained by condition: &gt;=0. geometry.y_min\tfloat geometry.y_max\tfloat geometry.z\tfloat geometry.z_span\tfloat\tRestrained by condition: &gt;=0. geometry.z_min\tfloat geometry.z_max\tfloat\t  "},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#syntax-1","content":"abstract run_fde_beam_and_extract(*, property, export_csv=False, show=False, savepath='') → BeamResult "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#usage-1","content":"Run fde beam and extract result immediately. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters-and-returns-1","content":"Parameters\tExplanation property\tBeam settings export_csv\tWhether to save csv, defaults to False savepath Save path of heatmap and csv, defaults to “”  Returns:\tHas attribute “chart”, which is a TaskFile object "},{"title":"RUN_FDE_BEAM_AND_EXTRACT​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#run_fde_beam_and_extract","content":""},{"title":"Parameters​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters-1","content":"Default\tType\tNotes define_gaussian_beam_by\twaist_size_and_position\tstring\tSelections are ['waist_size_and_position', 'beam_size_and_divergence']. waist_radius\t10\tfloat distance_from_waist\t0\tfloat beam_radius\t10\tfloat divergence_angle\t2.83063\tfloat refractive_index\t1\tfloat theta\t0\tfloat phi\t0\tfloat polarization_angle\t0\tfloat wavelength_offset\t0.0001\tfloat solved_number_of_trial_modes\t0\tfloat sample_span\t10\tfloat sample_resolution\t200\tinteger "},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#syntax-2","content":"abstract run_fde_overlap_and_extract(*, property, savepath='a', export_csv=False) → OverlapResult "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#usage-2","content":"Run fde overlap and extract result immediately. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters-and-returns-2","content":"Parameters\tExplanation property\tOverlap settings savepath\tSave path of csv, defaults to “a” export_csv Whether to export csv, defaults to False  Returns:\tHas attribute “result”, which is a float number. "},{"title":"RUN_FDE_OVERLAP_AND_EXTRACT​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#run_fde_overlap_and_extract","content":""},{"title":"Parameters​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters-2","content":"Default\tType\tNotes add_global_mode.task_path\tstring add_global_mode.mode\tinteger task_path\tstring mode\tinteger optimize_position\tfalse\tboolean. Priority over shifts. x_shift\t0\tfloat y_shift\t0\tfloat z_shift\t0\tfloat "},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#syntax-3","content":"abstract run_index(*, property: RunIndex, name: str, export_csv: bool = False, show: bool = False, savepath: str = 'a', export_n: bool = True, export_c: bool = False, max_index: int | None = None, max_sigma: int | None = None) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#usage-3","content":"Run index. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters-and-returns-3","content":"Parameters\tExplanation property\tIndex monitor properties. See below. name\tMonitor name. export_csv\tExport csv or not. Default as False. show\tShow figure or not. Default as False. savepath\tSave path for csv and picture. Default as 'a'. export_n\tWhether to export nx, ny, nz... . Default as True. export_c\tWhether to export σx, σy, σz... . Default as False. max_index\tMaximum index of heatmap colorbar. Default as None. max_sigma\tMaximum sigma of heatmap colorbar. Default as None.  "},{"title":"RUN_INDEX​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#run_index","content":""},{"title":"Parameters​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters-3","content":"Default\tType\tNotes geometry.monitor_type\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\tfloat geometry.x_span\tfloat\tRestrained by condition: &gt;=0. geometry.x_min\tfloat geometry.x_max\tfloat geometry.y\tfloat geometry.y_span\tfloat\tRestrained by condition: &gt;=0. geometry.y_min\tfloat geometry.y_max\tfloat geometry.z\tfloat geometry.z_span\tfloat\tRestrained by condition: &gt;=0. geometry.z_min\tfloat geometry.z_max\tfloat\t "},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#syntax-4","content":"abstract run_index_sweep(*, property: RunIndex, name: str, export_csv: bool = False, show: bool = False, savepath: str = 'a', export_n: bool = True, export_c: bool = False) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#usage-4","content":"Run index sweep. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters-and-returns-4","content":"Parameters\tExplanation property\tIndex monitor properties. See below. name\tMonitor name. export_csv\tExport csv or not. Default as False. show\tShow figure or not. Default as False. savepath\tSave path for csv and picture. Default as 'a'. export_n\tWhether to export nx, ny, nz... . Default as True. export_c\tWhether to export σx, σy, σz... . Default as False. "},{"title":"RUN_INDEX​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#run_index-1","content":""},{"title":"Pamameters​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#pamameters","content":"Default\tType\tNotes geometry.monitor_type\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\tfloat geometry.x_span\tfloat\tRestrained by condition: &gt;=0. geometry.x_min\tfloat geometry.x_max\tfloat geometry.y\tfloat geometry.y_span\tfloat\tRestrained by condition: &gt;=0. geometry.y_min\tfloat geometry.y_max\tfloat geometry.z\tfloat geometry.z_span\tfloat\tRestrained by condition: &gt;=0. geometry.z_min\tfloat geometry.z_max\tfloat\t "},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#syntax-5","content":"abstract show3d(show_with: Literal['webviewer', 'matplotlib'] = 'webviewer') "},{"title":"Uasge​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#uasge","content":"Show 3d structure in a pop up windows. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.simulation.simu_task.interface module","url":"/my-website/docs/test/core/simulation/simu_task#parameters-and-returns-5","content":"Parameters\tExplanation show_with “webviewer” will start a server and toggle a browser windows. “matplotlib” will toggle a Axes3D windows. Default as “webviewer”.  task_type: SimulationTypeSelection "},{"title":"interface","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/source/interface","content":"","keywords":""},{"title":"SourceInterface​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/source/interface#sourceinterface","content":"class maxoptics_sdk.core.source.interface.SourceInterface(*args, **kwargs)  Bases: Protocol "},{"title":"Syntax​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/source/interface#syntax","content":"abstract add(*, type: Literal['mode_source'], name: str, axis: Literal['x_forward', 'y_forward', 'z_forward', 'x_backward', 'y_backward', 'z_backward'], property: PostProcessModeSource) abstract add(*, type: Literal['gaussian_source'], name: str, axis: Literal['x_forward', 'y_forward', 'z_forward', 'x_backward', 'y_backward', 'z_backward'], property: PostProcessGaussianSource) "},{"title":"Usage​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/source/interface#usage","content":"Add a source to current project Parameters\tExplanation name\tSource name type\tSource type axis\tSource axis property\tSource property "},{"title":"MODE_SOURCE​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/source/interface#mode_source","content":"Parameters\tdefault\ttype\tnotes general.inject_axis\tx_axis\tstring\tSelections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. general.direction\tforward\tstring\tSelections are ['forward', 'backward']. general.amplitude\t1.0\tfloat general.phase\t0.0\tfloat general.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. general.mode_removal.threshold float general.mode_index\t0\tinteger general.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. general.n\t1.0\tfloat general.number_of_trial_modes\t20\tinteger general.waveform.waveform_id_select any general.rotations.theta\t0\tfloat general.rotations.phi\t0\tfloat general.rotations.rotation_offset\t0\tfloat geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t "},{"title":"GAUSSIAN_SOURCE​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/source/interface#gaussian_source","content":"Parameters\tDefault\tType\tNotes general.inject_axis\tx_axis\tstring\tSelections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. general.direction\tforward\tstring\tSelections are ['forward', 'backward']. general.amplitude\t1.0\tfloat general.phase\t0.0\tfloat general.waveform.waveform_id_select waveform general.angle_theta\t0\tfloat general.angle_phi\t0\tfloat general.rotation_offset\t0\tfloat general.polarization_angle\t0\tfloat general.beam_settings.calculation_method\tuse_scalar_approximation\tstring\tSelections are ['use_scalar_approximation', 'use_vector_approximation']. general.beam_settings.beam_parameters\twaist_size_and_position\tstring\tSelections are ['waist_size_and_position', 'beam_size_and_divergence']. general.beam_settings.waist_radius float general.beam_settings.distance_from_waist float general.beam_settings.beam_radius float general.beam_settings.divergence_angle float geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t "},{"title":"post_process_gaussian_source_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/source/post_process_gaussian_source_typing","content":"","keywords":""},{"title":"PostProcessGaussianSource​","type":1,"pageTitle":"post_process_gaussian_source_typing","url":"/my-website/docs/test/core/source/post_process_gaussian_source_typing#postprocessgaussiansource","content":"class maxoptics_sdk.core.source.post_process_gaussian_source_typing.PostProcessGaussianSource(*args, **kwargs)  Bases: dict general: PostProcessGaussianSourceGeneral geometry: PostProcessGaussianSourceGeometry  "},{"title":"PostProcessGaussianSourceGeneral​","type":1,"pageTitle":"post_process_gaussian_source_typing","url":"/my-website/docs/test/core/source/post_process_gaussian_source_typing#postprocessgaussiansourcegeneral","content":"class maxoptics_sdk.core.source.post_process_gaussian_source_typing.PostProcessGaussianSourceGeneral(*args, **kwargs)  Bases: dict Parameter\tType amplitude\tfloat | int | FloatParameter | FloatParameterExpression angle_phi\tfloat | int | FloatParameter | FloatParameterExpression angle_theta\tfloat | int | FloatParameter | FloatParameterExpression beam_settings\tPostProcessGaussianSourceGeneralBeamSettings direction\tLiteral['forward', 'backward'] inject_axis\tLiteral['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z'] phase\tfloat | int | FloatParameter | FloatParameterExpression polarization_angle\tfloat | int | FloatParameter | FloatParameterExpression rotation_offset\tfloat | int | FloatParameter | FloatParameterExpression waveform\tPostProcessGaussianSourceGeneralWaveform  "},{"title":"PostProcessGaussianSourceGeneralBeamSettings​","type":1,"pageTitle":"post_process_gaussian_source_typing","url":"/my-website/docs/test/core/source/post_process_gaussian_source_typing#postprocessgaussiansourcegeneralbeamsettings","content":"class maxoptics_sdk.core.source.post_process_gaussian_source_typing.PostProcessGaussianSourceGeneralBeamSettings(*args, **kwargs)  Bases: dict Parameter\tType beam_parameters\tLiteral['waist_size_and_position', 'beam_size_and_divergence'] beam_radius\tfloat | int | FloatParameter | FloatParameterExpression calculation_method\tLiteral['use_scalar_approximation', 'use_vector_approximation'] distance_from_waist\tfloat | int | FloatParameter | FloatParameterExpression divergence_angle\tfloat | int | FloatParameter | FloatParameterExpression waist_radius\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessGaussianSourceGeneralWaveform​","type":1,"pageTitle":"post_process_gaussian_source_typing","url":"/my-website/docs/test/core/source/post_process_gaussian_source_typing#postprocessgaussiansourcegeneralwaveform","content":"class maxoptics_sdk.core.source.post_process_gaussian_source_typing.PostProcessGaussianSourceGeneralWaveform(*args, **kwargs)  Bases: dict Parameters\tExplanation waveform_id_select\tWaveform  "},{"title":"PostProcessGaussianSourceGeometry​","type":1,"pageTitle":"post_process_gaussian_source_typing","url":"/my-website/docs/test/core/source/post_process_gaussian_source_typing#postprocessgaussiansourcegeometry","content":"class maxoptics_sdk.core.source.post_process_gaussian_source_typing.PostProcessGaussianSourceGeometry(*args, **kwargs)  Bases: dict Parameter\tType x\tfloat | int | FloatParameter | FloatParameterExpression x_max\tfloat | int | FloatParameter | FloatParameterExpression x_min\tfloat | int | FloatParameter | FloatParameterExpression x_span\tfloat | int | FloatParameter | FloatParameterExpression y\tfloat | int | FloatParameter | FloatParameterExpression y_max\tfloat | int | FloatParameter | FloatParameterExpression y_min\tfloat | int | FloatParameter | FloatParameterExpression y_span\tfloat | int | FloatParameter | FloatParameterExpression z\tfloat | int | FloatParameter | FloatParameterExpression z_max\tfloat | int | FloatParameter | FloatParameterExpression z_min\tfloat | int | FloatParameter | FloatParameterExpression z_span\tfloat | int | FloatParameter | FloatParameterExpression "},{"title":"post_process_mode_source_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/source/post_process_mode_source_typing","content":"","keywords":""},{"title":"PostProcessModeSource​","type":1,"pageTitle":"post_process_mode_source_typing","url":"/my-website/docs/test/core/source/post_process_mode_source_typing#postprocessmodesource","content":"class maxoptics_sdk.core.source.post_process_mode_source_typing.PostProcessModeSource(*args, **kwargs)  Bases: dict Parameter\tType bent_waveguide\tPostProcessModeSourceBentWaveguide general\tPostProcessModeSourceGeneral geometry\tPostProcessModeSourceGeometry  "},{"title":"PostProcessModeSourceBentWaveguide​","type":1,"pageTitle":"post_process_mode_source_typing","url":"/my-website/docs/test/core/source/post_process_mode_source_typing#postprocessmodesourcebentwaveguide","content":"class maxoptics_sdk.core.source.post_process_mode_source_typing.PostProcessModeSourceBentWaveguide(*args, **kwargs)  Bases: dict Parameter\tType bent_waveguide\tbool location\tLiteral['simulation_center'] orientation\tfloat | int | FloatParameter | FloatParameterExpression radius\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessModeSourceGeneral​","type":1,"pageTitle":"post_process_mode_source_typing","url":"/my-website/docs/test/core/source/post_process_mode_source_typing#postprocessmodesourcegeneral","content":"class maxoptics_sdk.core.source.post_process_mode_source_typing.PostProcessModeSourceGeneral(*args, **kwargs)  Bases: dict Parameter\tType amplitude\tfloat | int | FloatParameter | FloatParameterExpression direction\tLiteral['forward', 'backward'] inject_axis\tLiteral['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z'] mode_index\tint mode_removal\tPostProcessModeSourceGeneralModeRemoval mode_selection\tLiteral['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import'] n\tfloat | int | FloatParameter | FloatParameterExpression number_of_trial_modes\tint phase\tfloat | int | FloatParameter | FloatParameterExpression rotations\tPostProcessModeSourceGeneralRotations search\tLiteral['near_n', 'max_index'] waveform\tPostProcessModeSourceGeneralWaveform  "},{"title":"PostProcessModeSourceGeneralModeRemoval​","type":1,"pageTitle":"post_process_mode_source_typing","url":"/my-website/docs/test/core/source/post_process_mode_source_typing#postprocessmodesourcegeneralmoderemoval","content":"class maxoptics_sdk.core.source.post_process_mode_source_typing.PostProcessModeSourceGeneralModeRemoval(*args, **kwargs)¶  Bases: dict Parameter\tType phi\tfloat | int | FloatParameter | FloatParameterExpression rotation_offset\tfloat | int | FloatParameter | FloatParameterExpression theta\tfloat | int | FloatParameter | FloatParameterExpression  "},{"title":"PostProcessModeSourceGeneralWaveform​","type":1,"pageTitle":"post_process_mode_source_typing","url":"/my-website/docs/test/core/source/post_process_mode_source_typing#postprocessmodesourcegeneralwaveform","content":"class maxoptics_sdk.core.source.post_process_mode_source_typing.PostProcessModeSourceGeneralWaveform(*args, **kwargs)  Bases: dict Parameter\tExplanation waveform_id_select\tAny  "},{"title":"PostProcessModeSourceGeometry​","type":1,"pageTitle":"post_process_mode_source_typing","url":"/my-website/docs/test/core/source/post_process_mode_source_typing#postprocessmodesourcegeometry","content":"class maxoptics_sdk.core.source.post_process_mode_source_typing.PostProcessModeSourceGeometry(*args, **kwargs)  Bases: dict Parameter\tType x\tfloat | int | FloatParameter | FloatParameterExpression x_max\tfloat | int | FloatParameter | FloatParameterExpression x_min\tfloat | int | FloatParameter | FloatParameterExpression x_span\tfloat | int | FloatParameter | FloatParameterExpression y\tfloat | int | FloatParameter | FloatParameterExpression y_max\tfloat | int | FloatParameter | FloatParameterExpression y_min\tfloat | int | FloatParameter | FloatParameterExpression y_span\tfloat | int | FloatParameter | FloatParameterExpression z\tfloat | int | FloatParameter | FloatParameterExpression z_max\tfloat | int | FloatParameter | FloatParameterExpression z_min\tfloat | int | FloatParameter | FloatParameterExpression z_span\tfloat | int | FloatParameter | FloatParameterExpression "},{"title":"add_emesh_along_line_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/add_emesh_along_line_typing","content":"add_emesh_along_line_typing","keywords":""},{"title":"add_surface_recombination_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/add_surface_recombination_typing","content":"add_surface_recombination_typing","keywords":""},{"title":"boundary_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/boundary_typing","content":"boundary_typing","keywords":""},{"title":"doping_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/doping_typing","content":"doping_typing","keywords":""},{"title":"electrode_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/electrode_typing","content":"electrode_typing","keywords":""},{"title":"Max-Optics SDK","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/1","content":"","keywords":""},{"title":"1. Material​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#1-material","content":"The purpose of this section of code instructions is to assist you in adding the required simulation materials to meet your simulation needs. We can use this module with code mt = pj.Material() . These instructions enable you to incorporate dispersion/non-dispersion materials and anisotropic materials into the simulation. Additionally, you have the option to directly access the necessary materials from the Max-Optics material library. "},{"title":"1.1 add_anisotropy​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#11-add_anisotropy","content":"Add a project non-dispersion material. add_anisotropy( self, *, name: str, data: List[ Tuple[ float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float], ], color: Optional[str] = None, alpha: Optional[float] = None, fitting: Literal[None, &quot;linear&quot;], order: int = 2, )  Parameters\tDescriptionname\tMaterial name. data\tMaterial data. Format is [(wavelength, xx index real, xx index imag, yy index real, yy index imag, zz index real, zz index imag), …] or [(wavelength, xx index real, xx index imag, xy index real, xy index imag, …), …]. color\tMaterial color. If not filled, color will be calculated from index parameters. fitting\tMaterial fitting mode. order\tMaterial mesh order. Example: mt = pj.Material() mt.add_anisotropy(name=&quot;LN&quot;, fitting=None, data=[(wavelength * 1e-6, 2.211, 0, 2.138, 0, 2.211, 0)], order=2 )  "},{"title":"1.2 add_dispersion​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#12-add_dispersion","content":"Add a project dispersion material. add_dispersion( self, *, name: str, data: List[ Tuple[float, float, float], ], color: Optional[str] = None, alpha: Optional[float] = None, fitting: Literal[None, &quot;linear&quot;], order: int = 2 )  Parameters\tDescriptionname\tMaterial name. data\tMaterial data. Format is [(wavelength, index real, index imag), …]. color\tMaterial color. If not filled, color will be calculated from index parameters. fitting\tMaterial fitting mode. order\tMaterial mesh order. Example: mt = pj.Material() mt.add_dispersion(name=&quot;SiO2&quot;, data=[(1.55e-06, 1.444, 0), (1.30e-06, 1.81, 0.227)], order=1 )  "},{"title":"1.3 add_lib​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#13-add_lib","content":"Add a project material with existing material in library. add_lib( self, *, name: str, data: Any, override: Optional[dict]=None, color: Optional[str] = None, alpha: Optional[float] = None, order: int = 2 )  Parameters\tDescriptionname\tMaterial name. data\tA existing material in library. override\toverride. color\tMaterial color. If not filled, color will be calculated from index parameters. order\tMaterial mesh order. Example: mt = pj.Material() mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2)  "},{"title":"1.4 add_nondispersion​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#14-add_nondispersion","content":"Add a project non-dispersion material. add_nondispersion( self, *, name: str, data: List[Tuple[float, float]], color: Optional[str] = None, alpha: Optional[float] = None, order: int = 2 )  Parameters\tDescriptionname\tMaterial name. data\tMaterial data. Format is [(index real, index imag)]. color\tMaterial color. If not filled, color will be calculated from index parameters. order\tMaterial mesh order. Example: mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=1)  "},{"title":"2. Structure​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#2-structure","content":"The code within the &quot;Structure&quot; section is designed to assist you in incorporating the necessary structures and doping characteristics during the simulation process. st = pj.Structure(mesh_type, mesh_factor, background_material )  Parameters\tDefault\tType\tNotesmesh_type\tcurve_mesh\tstring\tSelections are ['curve_mesh', 'staircase']. mesh_factor\t1.2\tfloat\tRestrained by condition: &gt;=1.05,&lt;=1.6. background_material material\t You can create models using GDS format files and also utilize various methods such as Bézier curves, tapering, and circular rings for structural modeling. "},{"title":"2.1 Add doping​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#21-add-doping","content":"Add a project doping property. We provide support for importing doping data from files and customizing doping regions. add_doping( self, *, name: str, type: &quot;StructureDopingTypeSelection&quot;, property: &quot;StructureDopingPropertyDict&quot; )  Parameters\tDescriptionname\tDoping name type\tDoping type property\tDoping property For instance, the code for importing doping from a file is demonstrated as follows. st.add_doping(name=&quot;import_n&quot;, type=&quot;file&quot;, property={ &quot;general&quot;: {&quot;format&quot;: &quot;DOP&quot;, &quot;file_path&quot;: n_dop_file, &quot;species&quot;: &quot;n&quot;}})  You can configure parameters related to importing doping files by adjusting settings under the property.general sections. Parameters\tDefault\tType\tNotesgeneral.format str\tSelections are ['DOP'] general.file_path str general.species str\tSelections are ['n', 'p'] volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' The code for utilizing custom region doping is provided below. st.add_doping(name=&quot;Uniform&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_uniform_x_center, &quot;x_span&quot;: p_uniform_x_span, &quot;y&quot;: p_uniform_y_center, &quot;y_span&quot;: p_uniform_y_span, &quot;z&quot;: p_uniform_z_center, &quot;z_span&quot;: p_uniform_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: p_uniform_con}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat_si&quot;]]}})  Parameters\tDefault\tType\tNotesgeometry.x float geometry.x_span float geometry.y float geometry.y_span float geometry.z float geometry.z_span float geometry.rotate_x float geometry.rotate_y float geometry.rotate_z float geometry.x_min float geometry.x_max float geometry.y_min float geometry.y_max float geometry.z_min float geometry.z_max float general.distribution_function str\tSelections are ['constant', 'gaussian'] general.concentration float general.source_face str\tAvailable when distribution_function is 'gaussian' general.junction_width float\tAvailable when distribution_function is 'gaussian' general.ref_concentration float\tAvailable when distribution_function is 'gaussian' volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' "},{"title":"2.2 Add electrode​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#22-add-electrode","content":"Add an electrode to current project. add_electrode( self, *, name: str, property: StructureElectrodeProperty, )  Parameters\tDescriptionname\tElectric boundary condition name. property\tElectric boundary condition property. 2.2.1 Example: steady state ​ st = pj.Structure() st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  Parameters\tDefault\tType\tNotesforce_ohmic\ttrue\tbool bc_mode\tsteady_state\tstring\tSelections are ['steady_state']. apply_AC_small_signal\tnone\tstring\tSelections are ['none']. sweep_type\tsingle\tstring\tSelections are ['single', 'range', 'value']. v_step_max\t0.5\tfloat voltage\t0\tfloat\tAvailable when sweep_type is 'single' range_start\t0\tfloat\tAvailable when sweep_type is 'range' range_stop\t1\tfloat\tAvailable when sweep_type is 'range' range_interval\t1\tfloat\tAvailable when sweep_type is 'range' range_num_points\t2\tinteger\tAvailable when sweep_type is 'range' []sweep_value_table.index integer\tAvailable when sweep_type is 'value'. []sweep_value_table.number float\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t 2.2.2 Example: transient ​ st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: tcad_vbias, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 2.001e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 30e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.001e-12, &quot;time_stop&quot;: 2.01e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 60e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.01e-12, &quot;time_stop&quot;: 2.03e-12, &quot;initial_step&quot;: 60e-18, &quot;max_step&quot;: 2e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.03e-12, &quot;time_stop&quot;: 10e-12, &quot;initial_step&quot;: 2e-15, &quot;max_step&quot;: 50e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 10e-12, &quot;time_stop&quot;: 500e-12, &quot;initial_step&quot;: 50e-15, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}]}) st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  Parameters\tDefault\tType\tNotesforce_ohmic\ttrue\tbool bc_mode string\tSelections are ['transient']. voltage\t0\tfloat []time_table.time_start float []time_table.time_stop float []time_table.initial_step float []time_table.max_step float []time_table.optical.enabled\t0\tinteger\tSelections are [0, 1] []time_table.optical.envelop integer\tSelections are [0] []time_table.optical.source_fraction float surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t "},{"title":"2.3 Add surface recombination​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#23-add-surface-recombination","content":"Add surface recombination. add_surface_recombination( self, *, name: str, property: AddSurfaceRecombination, )  Parameters\tDescriptionname\tSurface recombination name. property\tSurface recombination property. Example: st.add_surface_recombination(name=&quot;Cathode_Si&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;MetalOhmicInterface&quot;, &quot;domain_1&quot;: &quot;Cathode&quot;, &quot;domain_2&quot;: &quot;Si_base&quot;, &quot;infinite_recombination&quot;: False, &quot;velocity_electron&quot;: 1e7, &quot;velocity_hole&quot;: 1e7})  Parameters\tDefault\tType\tNotessurface_type\tdomain_domain\tstring\tSelections are ['domain_domain', 'material_material']. interface_type\tnull\tstring\tSelections are ['null', 'InsulatorInterface', 'HomoJunction', 'HeteroJunction', 'MetalOhmicInterface', 'SolderPad']. infinite_recombination\ttrue\tbool\tAvailable when interface_type is 'MetalOhmicInterface' velocity_hole\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' velocity_electron\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' domain_1 string\tAvailable when surface_type is 'domain_domain' domain_2 string\tAvailable when surface_type is 'domain_domain' material_1 material\tAvailable when surface_type is 'material_material' material_2 material\tAvailable when surface_type is 'material_material' "},{"title":"2.4 Add geometry​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#24-add-geometry","content":"Add a geometry(structure) to current project. add_geometry( self, *, name: str, type: str, property: &quot;StructureGeometryPropertyDict&quot; )  Parameters\tDescriptionname\tGeometry name. type\tGeometry type. property\tGeometry property. 2.2.1 GDS file/GDS file3D​ The following code supports the import of GDS layout files. Example: st.add_geometry(name=&quot;gds_file&quot;, type=&quot;gds_file&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 3 * space, &quot;y&quot;: 2 * space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}, &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;EXTEND_1&quot;, &quot;layer_name&quot;: (3, 0)}})  Parameters\tDefault\tType\tNotesgeometry.x\t0\tfloat geometry.y\t0\tfloat geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. general.path string general.cell_name string general.layer_name list\t Meanwhile, we also offer support for basic operations on GDS layout modeling using type=&quot;gds_file3D&quot;. The code for this is provided below: st.add_geometry(name=&quot;gds_file_3D&quot;, type=&quot;gds_file3D&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;EXTEND_1&quot;, &quot;layer_name&quot;: (3, 0)}, &quot;geometry&quot;: {&quot;tilt_angle&quot;: 60,&quot;tilt_location&quot;: &quot;bottom&quot;, &quot;x&quot;: 4*space, &quot;y&quot;: 2*space, &quot;z&quot;: 0.05, &quot;z_span&quot;: 0.1, &quot;mirror_normal_z&quot;: 0,&quot;mirror_plane_z0&quot;: 0,&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.x\t0\tfloat geometry.y\t0\tfloat geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.tilt_angle\t90\tfloat geometry.tilt_location\ttop\tstring\tSelections are ['top', 'TOP', 'Top', 'bottom', 'BOTTOM', 'Bottom', 'middle', 'MIDDLE', 'Middle', 'user_defined']. geometry.user_defined\t1\tfloat geometry.mirror_normal_z\t0\tfloat geometry.mirror_plane_z0\t0\tfloat geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. general.path string general.cell_name string general.layer_name list general.construct_method string\tSelections are ['method1', 'method2'] 2.2.2 Arc waveguide/Arc waveguide 3D​ To create an arc waveguide within the project using code type=&quot;ArcWaveguide&quot;. Example: st.add_geometry(name=&quot;arc&quot;, type=&quot;ArcWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;inner_radius&quot;: size-wg_width/2, &quot;outer_radius&quot;: size+wg_width/2, &quot;angle&quot;: 90, &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.inner_radius float\tRestrained by condition: &gt;0. geometry.outer_radius float\tRestrained by condition: &gt;0. geometry.angle float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. Similarly, we offer support for using code type=&quot;ArcWaveguide3D&quot; to adjust the arc waveguide structure in the thickness direction. st.add_geometry(name=&quot;arc_3d&quot;, type=&quot;ArcWaveguide3D&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: size, &quot;angle&quot;: 180, &quot;base_height&quot;: wg_height, &quot;top_width&quot;: wg_width_top, &quot;bottom_width&quot;: wg_width, &quot;x&quot;: space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.radius float\tRestrained by condition: &gt;0. geometry.angle float\tRestrained by condition: &gt;0,&lt;=360. geometry.base_height float\tRestrained by condition: &gt;0. geometry.top_width float\tRestrained by condition: &gt;0. geometry.bottom_width float\tRestrained by condition: &gt;0. geometry.x float geometry.y float geometry.z float geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.3 Bézier curve/ Bézier curve 3D​ In the project, add a Bézier curve structure using code type=&quot;BezierCurve&quot;. Example: st.add_geometry(name=&quot;bezier&quot;, type=&quot;BezierCurve&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 2*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;width&quot;: wg_width, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size/2, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size/2, &quot;point_4_x&quot;: size, &quot;point_4_y&quot;: size}})  Parameters\tDefault\tType\tNotesgeometry.point_1_x float geometry.point_1_y float geometry.point_2_x float geometry.point_2_y float geometry.point_3_x float geometry.point_3_y float geometry.point_4_x float geometry.point_4_y float geometry.width float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. Similarly, we offer support for using code type=&quot;BezierCurve3D&quot; to adjust the Bézier curve structure in the thickness direction. st.add_geometry(name=&quot;bezier_3d&quot;, type=&quot;BezierCurve3D&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 3*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;base_height&quot;: wg_height, &quot;top_width&quot;: wg_width_top, &quot;bottom_width&quot;: wg_width, &quot;control_points&quot;: [{&quot;x&quot;: 0, &quot;y&quot;: 0}, {&quot;x&quot;: 0, &quot;y&quot;: size/2}, {&quot;x&quot;: size, &quot;y&quot;: size/2}, {&quot;x&quot;: size, &quot;y&quot;: size}]}})  Parameters\tDefault\tType\tNotesgeometry.base_height float\tRestrained by condition: &gt;0. geometry.top_width float\tRestrained by condition: &gt;0. geometry.bottom_width float\tRestrained by condition: &gt;0. geometry.[]control_points.x float geometry.[]control_points.y float geometry.x float geometry.y float geometry.z float geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.4 Circle​ Add a circular structure into the simulation project with type=&quot;Circle&quot; . Example: st.add_geometry(name=&quot;circle&quot;, type=&quot;Circle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;radius&quot;: size, &quot;x&quot;: 4*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}})  Parameters\tDefault\tType\tNotesgeometry.radius float\tRestrained by condition: &gt;0. geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.5 Custom polygon​ With the code type=&quot;CustomPolygon&quot; , we can add a custom polygon to the project. Example: st.add_geometry(name=&quot;custom_polygon&quot;, type=&quot;CustomPolygon&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;size&quot;: size, &quot;sides&quot;: 6, &quot;x&quot;: 4*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.size float\tRestrained by condition: &gt;0. geometry.sides integer\tRestrained by condition: &gt;=3. geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.6 Ellipse​ Add an ellipse into the project using code type=&quot;Ellipse&quot;. Example: st.add_geometry(name=&quot;ellipse&quot;, type=&quot;Ellipse&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x_radius&quot;: size, &quot;y_radius&quot;: 1.5*size, &quot;x&quot;: 3*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.x_radius float\tRestrained by condition: &gt;0. geometry.y_radius float\tRestrained by condition: &gt;0. geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.7 Linear trapezoid​ Add a linear trapezoid into the project using code type=&quot;LinearTrapezoid&quot;. Example: st.add_geometry(name=&quot;linear_trapezoid&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size/2, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size, &quot;point_4_x&quot;: size, &quot;point_4_y&quot;: 0, &quot;x&quot;: 2*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.point_1_x float geometry.point_1_y float geometry.point_2_x float geometry.point_2_y float geometry.point_3_x float geometry.point_3_y float geometry.point_4_x float geometry.point_4_y float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.8 Pyramid​ Add a pyramid into the project using code type=&quot;Pyramid&quot;. Example: st.add_geometry(name=&quot;pyramid&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;x&quot;: space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;theta_x&quot;: 0, &quot;theta_y&quot;: 0, &quot;x_span_bottom&quot;: 2*size, &quot;x_span_top&quot;: size, &quot;y_span_bottom&quot;: 2*size, &quot;y_span_top&quot;: size}})  Parameters\tDefault\tType\tNotesgeometry.x_span_bottom float\tRestrained by condition: &gt;=0. geometry.y_span_bottom float\tRestrained by condition: &gt;=0. geometry.x_span_top float\tRestrained by condition: &gt;=0. geometry.y_span_top float\tRestrained by condition: &gt;=0. geometry.theta_x\t0\tfloat geometry.theta_y\t0\tfloat geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.9 Analytical waveguide​ Add an analytical waveguide into the project using code type='AnalyticalWaveguide'. Example: st.add_geometry(name='taper_symmetric_test', type='AnalyticalWaveguide', property={'geometry': {'x': 0, 'x_span': L, 'y': 0, 'y_span': taper_width, 'z': 0, 'z_span': 0.22, 'equation1': f'{str(A)}*({str(L/2)}-x)^{str(m)}+1.5', 'nonsymmetric': False, 'tilt_location': 'user_defined', 'tilt_angle': 80, 'user_defined': 0.5, 'resolution': 1000}, 'material': {'material': mt['Si'], 'mesh_order': 2}})  Parameters\tDefault\tType\tNotesgeometry.x_span float\tRestrained by condition: &gt;0. geometry.x_min float geometry.x_max float geometry.y_span float\tRestrained by condition: &gt;0. geometry.y_min float geometry.y_max float geometry.equation1 string geometry.equation2\t1\tstring geometry.nonsymmetric\tfalse\tbool geometry.resolution\t10\tinteger geometry.tilt_angle\t90\tfloat geometry.tilt_location\ttop\tstring\tSelections are ['top', 'TOP', 'Top', 'bottom', 'BOTTOM', 'Bottom', 'middle', 'MIDDLE', 'Middle', 'user_defined']. geometry.user_defined\t1\tfloat geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.10 Rectangle​ Add a rectangle into the project using code type=&quot;Rectangle&quot;. Example: st.add_geometry(name=&quot;rectangle&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;x&quot;: 0, &quot;x_span&quot;: size, &quot;y&quot;: space, &quot;y_span&quot;: wg_width, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, }})  Parameters\tDefault\tType\tNotesgeometry.x_span float\tRestrained by condition: &gt;0. geometry.x_min float geometry.x_max float geometry.y_span float\tRestrained by condition: &gt;0. geometry.y_min float geometry.y_max float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.11 Ring​ Add a ring into the project using code type=&quot;Ring&quot;. Example: st.add_geometry(name=&quot;ring&quot;, type=&quot;Ring&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 2*space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;inner_radius&quot;: size-wg_width/2, &quot;outer_radius&quot;: size+wg_width/2,}})  Parameters\tDefault\tType\tNotesgeometry.inner_radius float\tRestrained by condition: &gt;0. geometry.outer_radius float\tRestrained by condition: &gt;0. geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.12 Sector​ Add a sector into the project using code type=&quot;Sector&quot;. Example: st.add_geometry(name=&quot;sector&quot;, type=&quot;Sector&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: size, &quot;angle&quot;: 75, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;x&quot;: space, &quot;y&quot;: 2*space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}})  Parameters\tDefault\tType\tNotesgeometry.radius float\tRestrained by condition: &gt;0. geometry.angle float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. 2.2.13 Triangle​ Add a triangle into the project using code type=&quot;Triangle&quot;. Example: st.add_geometry(name=&quot;triangle&quot;, type=&quot;Triangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size, &quot;x&quot;: 2*space, &quot;y&quot;: 2*space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.point_1_x float geometry.point_1_y float geometry.point_2_x float geometry.point_2_y float geometry.point_3_x float geometry.point_3_y float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"3. Boundary/Mesh​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#3-boundarymesh","content":""},{"title":"3.1 Boundary​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#31-boundary","content":"You can use the code in this section to add a set of default optical boundary's property to current project. OBoundary( self, *, pml_same_settings: bool = True, property: Union['OBoundarySameSettingsPostProcess', 'OBoundaryNotSameSettingsPostProcess'], )  Parameters\tDescriptionproperty\tDefault optical boundary property. pml_same_settings\tUse same pml settings on every directions or not. As demonstrated in the following examples, we also provide support for customizing boundary conditions in different directions. Example: st.OBoundary(property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': yspan_solver, 'z': 0, 'z_span': zspan_solver}, 'boundary': {'y_min': 'PML', 'y_max': 'PML', 'z_min': 'PML', 'z_max': 'PML'}, 'general_pml': {'pml_layer': 12, 'pml_kappa': 1, 'pml_sigma': 15, 'pml_polynomial': 3} })  Parameters\tDefault\tType\tNotesgeneral_pml.pml_same_settings\ttrue\tbool general_pml.pml_profile\tstandard\tstring general_pml.pml_layer integer general_pml.pml_kappa float general_pml.pml_sigma float general_pml.pml_polynomial integer general_pml.pml_alpha float general_pml.pml_alpha_polynomial integer general_pml.pml_min_layers integer general_pml.pml_max_layers integer geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float boundary.x_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.x_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.y_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.y_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.z_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.z_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. Parameters\tDefault\tType\tNotesgeneral_pml.pml_same_settings\ttrue\tbool general_pml.x_min_bc.pml_profile\tstandard\tstring general_pml.x_min_bc.pml_layer integer general_pml.x_min_bc.pml_kappa float general_pml.x_min_bc.pml_sigma float general_pml.x_min_bc.pml_polynomial integer general_pml.x_min_bc.pml_alpha float general_pml.x_min_bc.pml_alpha_polynomial integer general_pml.x_min_bc.pml_min_layers integer general_pml.x_min_bc.pml_max_layers integer general_pml.x_max_bc.pml_profile\tstandard\tstring general_pml.x_max_bc.pml_layer integer general_pml.x_max_bc.pml_kappa float general_pml.x_max_bc.pml_sigma float general_pml.x_max_bc.pml_polynomial integer general_pml.x_max_bc.pml_alpha float general_pml.x_max_bc.pml_alpha_polynomial integer general_pml.x_max_bc.pml_min_layers integer general_pml.x_max_bc.pml_max_layers integer general_pml.y_min_bc.pml_profile\tstandard\tstring general_pml.y_min_bc.pml_layer integer general_pml.y_min_bc.pml_kappa float general_pml.y_min_bc.pml_sigma float general_pml.y_min_bc.pml_polynomial integer general_pml.y_min_bc.pml_alpha float general_pml.y_min_bc.pml_alpha_polynomial integer general_pml.y_min_bc.pml_min_layers integer general_pml.y_min_bc.pml_max_layers integer general_pml.y_max_bc.pml_profile\tstandard\tstring general_pml.y_max_bc.pml_layer integer general_pml.y_max_bc.pml_kappa float general_pml.y_max_bc.pml_sigma float general_pml.y_max_bc.pml_polynomial integer general_pml.y_max_bc.pml_alpha float general_pml.y_max_bc.pml_alpha_polynomial integer general_pml.y_max_bc.pml_min_layers integer general_pml.y_max_bc.pml_max_layers integer general_pml.z_min_bc.pml_profile\tstandard\tstring general_pml.z_min_bc.pml_layer integer general_pml.z_min_bc.pml_kappa float general_pml.z_min_bc.pml_sigma float general_pml.z_min_bc.pml_polynomial integer general_pml.z_min_bc.pml_alpha float general_pml.z_min_bc.pml_alpha_polynomial integer general_pml.z_min_bc.pml_min_layers integer general_pml.z_min_bc.pml_max_layers integer general_pml.z_max_bc.pml_profile\tstandard\tstring general_pml.z_max_bc.pml_layer integer general_pml.z_max_bc.pml_kappa float general_pml.z_max_bc.pml_sigma float general_pml.z_max_bc.pml_polynomial integer general_pml.z_max_bc.pml_alpha float general_pml.z_max_bc.pml_alpha_polynomial integer general_pml.z_max_bc.pml_min_layers integer general_pml.z_max_bc.pml_max_layers integer geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float boundary.x_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.x_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.y_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.y_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.z_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.z_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. "},{"title":"3.2 Mesh​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#32-mesh","content":"3.2.1 add_mesh​ Add sub mesh. add_mesh( self, *, name: str, property: PostProcessSubMesh, )  Parameters\tDescriptionname\tMesh name. property\tGeometry type. Example: st.add_mesh(name='sub_mesh', property={'general': {'dx': 0.002, 'dy': 0.002, 'dz': 0.002}, 'geometry': {'x': 0, 'x_span': 6, 'y': 0, 'y_span': 2, 'z': 0, 'z_span': 0.2}})  Parameters\tDefault\tType\tNotesgeneral.override_x_mesh bool general.override_y_mesh bool general.override_z_mesh bool general.dx float\tRestrained by condition: &gt;0. general.dy float\tRestrained by condition: &gt;0. general.dz float\tRestrained by condition: &gt;0. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t 3.2.2 add_emesh​ Add electric mesh. add_emesh( self, *, name: str, property: Dict[str, Any], )  Parameters\tDescriptionname\tElectric local mesh name. property\tElectric local mesh property. Example: st.add_emesh(name=&quot;EMesh_Local&quot;, property={ &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: oe_y_max, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;mesh_size&quot;: egrid_local})  Parameters\tDefault\tType\tNotesx float x_span float\tRestrained by condition: &gt;=0. x_min float x_max float y float y_span float\tRestrained by condition: &gt;=0. y_min float y_max float z float z_span float\tRestrained by condition: &gt;=0. z_min float z_max float mesh_size float\tmax size of electrical simulation mesh 3.2.3 add_emesh_along_line​ Add electric mesh along line. add_emesh_along_line( self, *, name: str, property: Dict[str, Any], )  Parameters\tDescriptionname\tElectric mesh along line name. property\tElectric mesh along line property. Example: st.add_emesh_along_line(name=&quot;EMesh_Ge_SiO2_Interface_Slope_Left&quot;, property={ &quot;start_x&quot;: oe_x_mean, &quot;start_y&quot;: -Ge_y_span_bottom/2, &quot;start_z&quot;: Si_z_span, &quot;end_x&quot;: oe_x_mean, &quot;end_y&quot;: -Ge_y_span_top/2, &quot;end_z&quot;: Si_z_span+Ge_z_span, &quot;mesh_size&quot;: egrid_interface})  Parameters\tDefault\tType\tNotesstart_x\t0\tfloat start_y\t0\tfloat\tRestrained by condition: &gt;=0. start_z\t0\tfloat end_x\t1\tfloat end_y\t1\tfloat end_z\t1\tfloat\tRestrained by condition: &gt;=0. mesh_size\t0.01\tfloat\t "},{"title":"4. Source/Port​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#4-sourceport","content":"The following code will demonstrate how to add light source and port in a simulation project. Currently, for the source module it supports the addition of modal sources and Gaussian sources. And we support to add ports in EME simulation and FDTD simulation. "},{"title":"4.1 Mode source​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#41-mode-source","content":"Add a mode source into the project using code type=&quot;mode_source&quot;. add( self, *, type: Literal[&quot;mode_source&quot;], name: str, axis: AxisSelection, property: PostProcessModeSource, )  Parameters\tDescriptionname\tMode source name. type\tSource type. axis\tMode source axis. property\tMode source property. Example: src.add(name='source', type='mode_source', axis='x_forward', property={'general': { # 'amplitude': 1, 'phase': 0, 'mode_index': 0, 'rotations': {'theta': 0, 'phi': 0, 'rotation_offset': 0} 'mode_selection': 'user_select', 'waveform': {'waveform_id_select': wv_struct} }, 'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}})  Parameters\tDefault\tType\tNotesgeneral.inject_axis\tx_axis\tstring\tSelections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. general.direction\tforward\tstring\tSelections are ['forward', 'backward']. general.amplitude\t1.0\tfloat general.phase\t0.0\tfloat general.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. general.mode_removal.threshold float general.mode_index\t0\tinteger general.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. general.n\t1.0\tfloat general.number_of_trial_modes\t20\tinteger general.waveform.waveform_id_select any general.rotations.theta\t0\tfloat general.rotations.phi\t0\tfloat general.rotations.rotation_offset\t0\tfloat geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t "},{"title":"4.2 Gaussian source​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#42-gaussian-source","content":"Add a Gaussian source into the project using code type=&quot;mode_source&quot;. add( self, *, type: Literal[&quot;gaussian_source&quot;], name: str, axis: AxisSelection, property: PostProcessGaussianSource, )  Parameters\tDescriptionname\tGaussian source name. type\tSource type. axis\tGaussian source axis. property\tGaussian source property Example: so.add(name='source', type='gaussian_source', axis='z_backward', property={'general': {'angle_theta': 12, 'angle_phi': 0, 'polarization_angle': 90, 'waveform': {'waveform_id_select': wv[waveform_name]}, 'beam_settings': {'calculation_method': 'use_scalar_approximation', # [use_scalar_approximation,use_vector_approximation] 'beam_parameters': 'waist_size_and_position', # [waist_size_and_position,beam_size_and_divergence] 'waist_radius': 5.2, 'distance_from_waist': 1.5, 'beam_radius': 5.2, 'divergence_angle': 5.41444}}, 'geometry': {'x': 4, 'x_span': 20, 'y': 0, 'y_span': 20, 'z': 1.5, 'z_span': 0}})  Parameters\tDefault\tType\tNotesgeneral.inject_axis\tx_axis\tstring\tSelections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. general.direction\tforward\tstring\tSelections are ['forward', 'backward']. general.amplitude\t1.0\tfloat general.phase\t0.0\tfloat general.waveform.waveform_id_select waveform general.angle_theta\t0\tfloat general.angle_phi\t0\tfloat general.rotation_offset\t0\tfloat general.polarization_angle\t0\tfloat general.beam_settings.calculation_method\tuse_scalar_approximation\tstring\tSelections are ['use_scalar_approximation', 'use_vector_approximation']. general.beam_settings.beam_parameters\twaist_size_and_position\tstring\tSelections are ['waist_size_and_position', 'beam_size_and_divergence']. general.beam_settings.waist_radius float general.beam_settings.distance_from_waist float general.beam_settings.beam_radius float general.beam_settings.divergence_angle float geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t "},{"title":"4.3 FDTD port​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#43-fdtd-port","content":"Add a port to current project. add( self, *, type: Literal[&quot;eme_port&quot;], name: str, property: PostProcessEmePort, )  Parameters\tDescriptionname\tFDTD port name. type\tPort type. property\tFDTD port axis. Example: pt = pj.Port(property={'waveform_id': wv_struct, 'source_port': 'port_left'}) pt.add(name='port_left', type='fdtd_port', property={'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'forward', 'mode_selection': 'fundamental', }}})  Parameters\tDefault\tType\tNotesgeometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float modal_properties.general.inject_axis\tx_axis\tstring\tSelections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. modal_properties.general.direction\tforward\tstring\tSelections are ['forward', 'backward']. modal_properties.general.amplitude\t1\tfloat modal_properties.general.phase\t0\tfloat modal_properties.general.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. modal_properties.general.mode_removal.threshold float modal_properties.general.mode_index\t1\tinteger modal_properties.general.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. modal_properties.general.n\t1.0\tfloat modal_properties.general.number_of_trial_modes\t20\tinteger modal_properties.bent_waveguide.bent_waveguide\tfalse\tbool modal_properties.bent_waveguide.radius\t1\tfloat modal_properties.bent_waveguide.orientation\t20\tfloat modal_properties.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. "},{"title":"4.4 EME port​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#44-eme-port","content":"Add a port to current project. add( self, *, type: Literal[&quot;eme_port&quot;], name: str, property: PostProcessEmePort, )  Parameters\tDescriptionname\tEME port name. type\tPort type. property\tEME port property. Example: pjp = pj.Port(property={&quot;source_port&quot;: &quot;input_te_tm&quot;}) pjp.add(name=&quot;input_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;use_full_simulation_span&quot;: True, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1}, &quot;advanced&quot;: {&quot;offset&quot;: 0.1, &quot;number_of_trial_modes&quot;: number_of_modes}}})  Parameters\tDefault\tType\tNotesgeometry.port_location string\tSelections are ['left', 'right']. geometry.use_full_simulation_span\ttrue\tbool geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float eme_port.general.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. eme_port.general.mode_index\t1\tinteger eme_port.general.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. eme_port.general.n\t1.0\tinteger eme_port.bent_waveguide.bent_waveguide\tfalse\tbool eme_port.bent_waveguide.radius\t1\tfloat eme_port.bent_waveguide.orientation\t20\tfloat eme_port.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. eme_port.advanced.offset\t0\tfloat eme_port.advanced.number_of_trial_modes\t20\tinteger eme_port.advanced.mode_removal.threshold float\t "},{"title":"5. Monitor​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#5-monitor","content":"This section will help you to add the monitor to one simulation project. We offer a range of monitors to assist you in obtaining simulation data more intuitively. The following will be presented in sequence to provide an introduction. "},{"title":"5.1 Profile monitor​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#51-profile-monitor","content":"Add a profile monitor to current project. add( self, *, type: Literal[&quot;profile_monitor&quot;], name: str, property: PostProcessProfileMonitor, )  Parameters\tDescriptionname\tProfile monitor name. type\tMonitor type. property\tProfile monitor property. Example: mn = pj.Monitor() mn.add(name=&quot;y_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_y_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}})  Parameters\tDefault\tType\tNotesgeometry.monitor_type string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. geometry.x_resolution\t100\tinteger geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t "},{"title":"5.2 Global monitor/Global option​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#52-global-monitorglobal-option","content":"Add a global monitor to current project. add( self, *, type: Literal[&quot;global_monitor&quot;, &quot;global_option&quot;], name: str, property: PostProcessGlobalMonitor, )  Parameters\tDescriptionname\tGlobal monitor name. type\tMonitor type. property\tGlobal monitor property. Example: mn = pj.Monitor() mn.add(name='Global Option', type='global_option', property={'frequency_power': { # 'sample_spacing': 'uniform', 'use_wavelength_spacing': True, # ['min_max','center_span'] 'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}})  Parameters\tDefault\tType\tNotesfrequency_power.sample_spacing\tuniform\tstring\tSelections are ['uniform']. frequency_power.use_wavelength_spacing\ttrue\tbool frequency_power.spacing_type\twavelength\tstring\tSelections are ['wavelength', 'frequency']. frequency_power.spacing_limit\tmin_max\tstring\tSelections are ['min_max', 'center_span']. frequency_power.wavelength_min float frequency_power.wavelength_max float frequency_power.wavelength_center float frequency_power.wavelength_span float frequency_power.frequency_min float frequency_power.frequency_max float frequency_power.frequency_center float frequency_power.frequency_span float frequency_power.frequency_points\t5\tinteger advanced.min_sampling_per_cycle\t2\tinteger\t "},{"title":"5.3 Time monitor​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#53-time-monitor","content":"Add a time monitor to current project. add( self, *, type: Literal[&quot;time_monitor&quot;], name: str, property: PostProcessTimeMonitor, )  Parameters\tDescriptionname\tTime monitor name. type\tMonitor type. property\tTime monitor property. Example: mn = pj.Monitor() mn.add(name='time_monitor1', type='time_monitor', property={'general': { 'stop_method': 'end_of_simulation', 'start_time': 0, 'stop_time': 100, 'number_of_snapshots': 0}, 'geometry': {'monitor_type': 'point', 'x': 0, 'x_span': 0, 'y': 0, 'y_span': 0, 'z': 0, 'z_span': 0}, 'advanced': {'sampling_rate': {'min_sampling_per_cycle': 10}}})  Parameters\tDefault\tType\tNotesgeneral.stop_method\tend_of_simulation\tstring\tSelections are ['end_of_simulation', 'choose_stop_time', 'choose_number_of_snapshots']. general.start_time\t0\tfloat general.stop_time\t1000\tfloat general.number_of_snapshots\t0\tinteger geometry.monitor_type string\tSelections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float advanced.sampling_rate.min_sampling_per_cycle\t10\tinteger\t "},{"title":"5.4 Power monitor/Mode expansion​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#54-power-monitormode-expansion","content":"Add a power monitor to current project. Meanwhile, We can use 'mode_expansion' to calculate the mode expansion for its relative power monitor. add( self, *, type: Literal[&quot;power_monitor&quot;], name: str, property: PostProcessPowerMonitor, )  Parameters\tDescriptionname\tMonitor name. type\tMonitor type. property\tMonitor property. Example: mn = pj.Monitor() mn.add(name='through', type='power_monitor', property={'general': {'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}, }, 'geometry': {'monitor_type': '2d_x_normal', 'x': ports['op_1']['position'][0], 'x_span': 0, 'y': ports['op_1']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'mode_expansion': {&quot;enable&quot;: True, 'direction': 'positive', 'mode_calculation': { 'mode_selection': 'user_select', 'mode_index': [0, 1, 2, 3], 'override_global_monitor_setting': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}}}})  Parameters\tDefault\tType\tNotesgeometry.monitor_type string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.rotate_settings.theta\t0\tfloat\tRestrained by condition: &gt;-90,&lt;90. geometry.rotate_settings.phi\t0\tfloat\tRestrained by condition: &gt;=0,&lt;=360. geometry.rotate_settings.rotation_offset\t0\tfloat\tRestrained by condition: &gt;=-1e30,&lt;=1e30. mode_expansion.[]monitors_for_expansion.name string mode_expansion.[]monitors_for_expansion.frequency_monitor string mode_expansion.direction\tpositive\tstring\tSelections are ['positive', 'negative']. mode_expansion.mode_calculation.mode_selection string\tSelections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'user_select']. mode_expansion.mode_calculation.mode_index list mode_expansion.mode_calculation.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. mode_expansion.mode_calculation.n\t1.0\tfloat mode_expansion.mode_calculation.number_of_trial_modes\t20\tinteger mode_expansion.mode_calculation.override_global_options\tfalse\tbool mode_expansion.mode_calculation.override_global_monitor_setting.sample_spacing\tuniform\tstring\tSelections are ['uniform']. mode_expansion.mode_calculation.override_global_monitor_setting.use_wavelength_spacing\ttrue\tbool mode_expansion.mode_calculation.override_global_monitor_setting.spacing_type\twavelength\tstring\tSelections are ['wavelength', 'frequency']. mode_expansion.mode_calculation.override_global_monitor_setting.spacing_limit\tmin_max\tstring\tSelections are ['min_max', 'center_span']. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_min float mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_max float mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_center float mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_span float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_min float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_max float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_center float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_span float mode_expansion.mode_calculation.override_global_monitor_setting.frequency_points integer mode_expansion.mode_calculation.bent_waveguide.bent_waveguide\tfalse\tbool mode_expansion.mode_calculation.bent_waveguide.radius\t1.0\tfloat mode_expansion.mode_calculation.bent_waveguide.orientation\t0.0\tfloat mode_expansion.mode_calculation.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. "},{"title":"5.6 Band monitor​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#56-band-monitor","content":"Add a band monitor to current project. add( self, *, type: Literal[&quot;band_monitor&quot;], name: str, property: PostProcessBandMonitor, )  Parameters\tDescriptionname\tBand monitor name. type\tMonitor type. property\tBand monitor property. Example: mn = pj.Monitor() mn.add(name=&quot;band_line&quot;, type=&quot;band_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_z&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;interpolate_accuracy&quot;: 9}}) # endregion  Parameters\tDefault\tType\tNotesgeneral.record_ec\ttrue\tbool general.record_ev\ttrue\tbool general.record_ei\ttrue\tbool general.record_efn\ttrue\tbool general.record_efp\ttrue\tbool general.record_evac\ttrue\tbool geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10. "},{"title":"5.7 Charge monitor​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#57-charge-monitor","content":"Add a charge monitor to current project. add( self, *, type: Literal[&quot;charge_monitor&quot;], name: str, property: PostProcessChargeMonitor, )  Parameters\tDescriptionname\tCharge monitor name. type\tMonitor type. property\tCharge monitor property. Example: mn = pj.Monitor() mn.add(name=&quot;np_line_080nm&quot;, type=&quot;charge_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_y&quot;, &quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: -0.4, &quot;y_max&quot;: 0.4, &quot;z&quot;: 0.08, &quot;z_span&quot;: 0, &quot;interpolate_accuracy&quot;: 9}})  Parameters\tDefault\tType\tNotesgeneral.record_electrons\ttrue\tbool general.record_holes\ttrue\tbool general.integrate_total_charge\ttrue\tbool\tAvailable when monitor_type is in ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10. "},{"title":"5.8 Electric monitor​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#58-electric-monitor","content":"Add a electric monitor to current project. add( self, *, type: Literal[&quot;electric_monitor&quot;], name: str, property: PostProcessElectricMonitor, )  Parameters\tDescriptionname\tEME port name. type\tEME port type. property\tEME port property. Example:  mn = pj.Monitor() mn.add(name=&quot;electric_2d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: -Ge_y_span_bottom*3/4, &quot;y_max&quot;: Ge_y_span_bottom*3/4, &quot;z_min&quot;: 0, &quot;z_max&quot;: Si_z_span+Ge_z_span, &quot;interpolate_accuracy&quot;: 6}})  Parameters\tDefault\tType\tNotesgeneral.record_electrics_field\ttrue\tbool general.record_electrostatic_potential\ttrue\tbool general.calculate_net_charge\ttrue\tbool\tAvailable when monitor_type is in ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10. "},{"title":"6. Simulation​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#6-simulation","content":"In the upcoming code section, we will present the examples of simulation module, along with its parameter list. This will assist you in achieving a more comprehensive model simulation. We will provide support for multiple simulation modules, including optical and electrical aspects, such as FDE, FDTD, OEDevice, and more. add( self, *, name: str, type: &quot;SimulationTypeSelection&quot;, property: Any, **kwargs, )  Parameters\tDescriptionname\tSimulation name. type\tSimulation type. location\tSimulation run mode, cloud or local.Simulation property. property\tSimulation property. kwargs\tOther simulation parameters. &quot;source_name&quot; is needed for &quot;mode_selection:user_select&quot; type simulation. "},{"title":"6.1 FDE​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#61-fde","content":"Add a FDE solver to current project with the code type='FDE'. add( self, *, name: str, type: Literal[&quot;FDE&quot;], property: FdePostProcess, )  Example: simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={ # 'general': {'solver_type': '2d_x_normal'}, # default is '2d_x_normal' ['2d_x_normal','2d_y_normal','2d_z_normal'] 'mesh_settings': { 'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'search': 'max_index', # ['near_n','max_index'] # 'n': 2, 'calculate_group_index': False, 'mode_removal': {'threshold': 0.02}, # 'bent_waveguide': {'bent_waveguide': False, 'radius': 1, 'orientation': 0, 'location': 'simulation_center'} }, &quot;frequency_analysis&quot;: { &quot;frequency_analysis&quot;: run_options.run_frequency_sweep, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 2.7, &quot;detailed_dispersion_calculation&quot;: False }}})  Parameters\tDefault\tType\tNotesgeneral.solver_type\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. mesh_settings.global_mesh_uniform_grid.dx\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dy\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dz\t0.02\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat thread_setting.thread\t4\tinteger fde_analysis.modal_analysis.mesh_structure\tfalse\tbool fde_analysis.modal_analysis.calculate_modes\tfalse\tbool fde_analysis.modal_analysis.[]far_field_settings.calculate\ttrue\tbool fde_analysis.modal_analysis.[]far_field_settings.mode_selection integer fde_analysis.modal_analysis.[]far_field_settings.projection_method\tplanar\tstring\tSelections are ['planar']. fde_analysis.modal_analysis.[]far_field_settings.farfield_filter\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.material_index\t1.4\tfloat fde_analysis.modal_analysis.[]far_field_settings.projection_distance\t4430.65\tfloat fde_analysis.modal_analysis.[]far_field_settings.points_in_x\t50\tfloat fde_analysis.modal_analysis.[]far_field_settings.points_in_y\t50\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_x\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_x_span\t26.1834\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_y\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_y_span\t18.1231\tfloat fde_analysis.modal_analysis.wavelength\t1.55\tfloat fde_analysis.modal_analysis.wavelength_offset\t0.002\tfloat fde_analysis.modal_analysis.number_of_trial_modes\t5\tinteger fde_analysis.modal_analysis.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. fde_analysis.modal_analysis.n\t1\tfloat fde_analysis.modal_analysis.calculate_group_index\tfalse\tbool fde_analysis.modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool fde_analysis.modal_analysis.bent_waveguide.radius\t0.0\tfloat fde_analysis.modal_analysis.bent_waveguide.orientation\t0.0\tfloat fde_analysis.modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. fde_analysis.modal_analysis.mode_removal.threshold float fde_analysis.frequency_analysis.frequency_analysis\tfalse\tbool fde_analysis.frequency_analysis.start_wavelength\t1.55\tfloat fde_analysis.frequency_analysis.stop_wavelength\t1.49896\tfloat fde_analysis.frequency_analysis.number_of_points\t10\tinteger fde_analysis.frequency_analysis.effective_index\t1.0\tfloat fde_analysis.frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\t 6.1.1 Mode selection​ Add a mode selection to current project . add( self, *, name: str, simulation_name: str, source_name: str = &quot;&quot;, cell_group_index: int = 0, type: Literal[&quot;mode_selection:user_select&quot;], property: ModeSelectionUserSelectPostProcess, )  Example: simu = pj.Simulation() simu.add(name=simu_name+'_cal_mode', simulation_name=simu_name, source_name='source', type='mode_selection:user_select', property={'modal_analysis': {'calculate_modes': True, 'mesh_structure': True, 'wavelength': wavelength, 'number_of_trial_modes': 20, 'search': 'max_index', 'calculate_group_index': True }}) src_res = simu[f'{simu_name}_cal_mode'].run() src_res.extract(data='calculate_modes', savepath=f'{plot_path}{kL[2]}_Preview_SourceMode', attribute='E', mode=0, real=True, imag=True, **export_options, show=False)  Parameters\tDefault\tType\tNotesmodal_analysis.mesh_structure\tfalse\tbool modal_analysis.calculate_modes\tfalse\tbool modal_analysis.wavelength\t1.55\tfloat modal_analysis.wavelength_offset\t0.002\tfloat modal_analysis.number_of_trial_modes\t20\tinteger modal_analysis.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. modal_analysis.n\t1\tfloat modal_analysis.calculate_group_index\tfalse\tbool modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool modal_analysis.bent_waveguide.radius\t1.0\tfloat modal_analysis.bent_waveguide.orientation\t0.0\tfloat modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. modal_analysis.mode_removal.threshold float frequency_analysis.frequency_analysis\tfalse\tbool frequency_analysis.start_wavelength\t1.55\tfloat frequency_analysis.stop_wavelength\t1.49896\tfloat frequency_analysis.number_of_points\t10\tinteger frequency_analysis.effective_index\t1.0\tfloat frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\t 6.1.2 Beam overlap​ To calculate the beam overlap in FDE module. Firstly, we need to get the results of FDE beam and extract it. run_fde_beam_and_extract(self, *, property, export_csv=False, show=False, savepath=&quot;&quot;)  Parameters\tDescriptionproperty\tBeam settings export_csv\tWhether to save csv, defaults to False show\tShow figure or not, defaults as False savepath\tSave path of heatmap and csv, defaults to &quot;&quot; Then we can run FDE overlap function and extract result. run_fde_overlap_and_extract(self, *, property, savepath=&quot;a&quot;, export_csv=False)  Parameters\tDescriptionproperty\tOverlap settings savepath\tSave path of csv, defaults to &quot;a&quot; export_csv\tWhether to export csv, defaults to False Example: beam_res = simu[simu_name].run_fde_beam_and_extract( property={ &quot;define_gaussian_beam_by&quot;: &quot;waist_size_and_position&quot;, # [waist_size_and_position,beam_size_and_divergence], &quot;waist_radius&quot;: 10, &quot;distance_from_waist&quot;: 0, &quot;refractive_index&quot;: 1, &quot;theta&quot;: 0, &quot;phi&quot;: 0, &quot;polarization_angle&quot;: 0, &quot;sample_span&quot;: 10, &quot;sample_resolution&quot;: 200}, savepath=plot_path + 'beam_heatmap') overlap_res = simu[simu_name].run_fde_overlap_and_extract( property={&quot;add_global_mode&quot;: {&quot;task_path&quot;: beam_res.task_path, &quot;mode&quot;: 0}, &quot;mode&quot;: 0, &quot;optimize_position&quot;: True}, export_csv=True, savepath=plot_path + 'overlap')  6.1.3 Bent Waveguide​ To calculate the bent waveguide mode in FDE module. simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={'general': {'solver_type': '2d_x_normal'}, 'mesh_settings': {'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}}, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'calculate_group_index': True, 'bent_waveguide': {'bent_waveguide': True, 'radius': 5.25, 'orientation': 0, 'location': 'simulation_center'}}}})  6.1.4 Far field​ simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={'general': {'solver_type': '2d_z_normal'}, 'mesh_settings': {'global_mesh_uniform_grid': {'dx': grid, 'dy': grid}}, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'far_field_settings': [{'calculate': run_options.run_far_field, 'mode_selection': 0, 'material_index': 3.7, 'farfield_filter': 0, 'projection_distance': 8000, 'points_in_x': 50, 'points_in_y': 50, 'farfield_x_span': 40, 'farfield_y_span': 40, 'farfield_x': 0, 'farfield_y': 0}]}}})  "},{"title":"6.2 EME​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#62-eme","content":"Add a EME solver to current project with the code type='EME'. add( self, *, name: str, type: Literal[&quot;EME&quot;], property: EmePostProcess, )  Example: simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 200, &quot;cell_number&quot;: 30, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 3, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_3&quot;, &quot;start&quot;: 50, &quot;stop&quot;: 250, &quot;number_of_points&quot;: 5}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}})  Parameters\tDefault\tType\tNotesgeneral.wavelength float general.wavelength_offset\t0.002\tfloat general.use_wavelength_sweep\tfalse\tbool eme_setup.cell_geometry.energy_conservation\tmake_passive\tstring\tSelections are ['none', 'make_passive']. eme_setup.cell_geometry.display_cells\tfalse\tbool eme_setup.cell_geometry.display_groups\tfalse\tbool eme_setup.cell_geometry.[]cell_group_definition.span float eme_setup.cell_geometry.[]cell_group_definition.cell_number integer eme_setup.cell_geometry.[]cell_group_definition.number_of_modes integer eme_setup.cell_geometry.[]cell_group_definition.sc\tnone\tstring\tSelections are ['none', 'sub_cell', 'sc']. eme_setup.cell_geometry.[]cell_group_definition.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. eme_setup.cell_geometry.[]cell_group_definition.n\t1.0\tfloat transverse_mesh_setting.global_mesh_uniform_grid.dx\t0.02\tfloat transverse_mesh_setting.global_mesh_uniform_grid.dy\t0.02\tfloat transverse_mesh_setting.global_mesh_uniform_grid.dz\t0.02\tfloat transverse_mesh_setting.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat advanced.eme_settings.max_stored_modes\t1000\tinteger thread_settings.thread\t4\tinteger eme_analysis.eme_propagate\tfalse\tbool eme_analysis.periodicity.periodicity\tfalse\tbool eme_analysis.periodicity.[]periodic_group_definition.start_cell_group integer eme_analysis.periodicity.[]periodic_group_definition.end_cell_group integer eme_analysis.periodicity.[]periodic_group_definition.periods integer eme_analysis.propagation_sweep.propagation_sweep\tfalse\tbool eme_analysis.propagation_sweep.parameter\tgroup_span_1\tstring eme_analysis.propagation_sweep.start\t0\tfloat eme_analysis.propagation_sweep.stop\t1\tfloat eme_analysis.propagation_sweep.number_of_points\t3\tinteger eme_analysis.wavelength_sweep.wavelength_sweep\tfalse\tbool eme_analysis.wavelength_sweep.start\t1.5\tfloat eme_analysis.wavelength_sweep.stop\t1.6\tfloat eme_analysis.wavelength_sweep.number_of_wavelength_points\t3\tinteger eme_analysis.select_source.phase\t0\tfloat eme_analysis.select_source.select_mode  6.2.1 EME CellGroup Custom Setting​ To set a customized EME cell group. simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: {&quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2.5, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: 30, &quot;sc&quot;: sc_method, &quot;search&quot;: &quot;max_index&quot;}, {&quot;span&quot;: 5.2, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: 50, &quot;sc&quot;: sc_method, &quot;search&quot;: &quot;max_index&quot;, &quot;n&quot;: 1.5}, {&quot;span&quot;: 2.5, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: 30, &quot;sc&quot;: sc_method, &quot;search&quot;: &quot;max_index&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_2&quot;, &quot;start&quot;: 41, &quot;stop&quot;: 61, &quot;number_of_points&quot;: 11}, &quot;wavelength_sweep&quot;: {&quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: wavelength - 0.05, &quot;stop&quot;: wavelength + 0.05, &quot;number_of_wavelength_points&quot;: 11}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}})  6.2.2 EME Periodic Structure​ To set an EME Periodic Structure. simu = pj.Simulation() simu.add(name=simu_name, type='EME', property={ 'general': {'wavelength': wavelength}, 'eme_setup': {'cell_geometry': { 'cell_group_definition': [ {'span': EME_marg, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}, {'span': wb, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}, {'span': ws, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}, {'span': EME_marg, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}]}}, 'transverse_mesh_setting': {'global_mesh_uniform_grid': {'dx':grid, 'dy': grid, 'dz': grid} }, 'eme_analysis': { 'eme_propagate': run_options.run, 'periodicity': {'periodicity': True, 'periodic_group_definition': [{'start_cell_group': 1, 'end_cell_group': 2, 'periods': grating_periods}]} }})  "},{"title":"6.3 FDTD​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#63-fdtd","content":"Add a FDTD solver to current project with the code type='FDTD'. add( self, *, name: str, type: Literal[&quot;FDTD&quot;], property: FdtdPostProcess, )  Example: simu = pj.Simulation() simu.add(name=simu_name, type='FDTD', property={'general': {'simulation_time': 10000, }, 'mesh_settings': {'mesh_type': 'auto_non_uniform', 'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}, 'minimum_mesh_step_settings': {'min_mesh_step': 1e-4}}, # 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-4, 'down_sample_time': 200}}, # 'thread_setting': {'thread': 4} })  Parameters\tDefault\tType\tNotesextra.fdtd_port_group.source_port string general.dimension\t3d\tstring\tSelections are ['3d']. general.using_optical_path_estimate_time\tfalse\tbool general.simulation_time\t1000\tinteger mesh_settings.mesh_type\tauto_non_uniform\tstring\tSelections are ['auto_non_uniform', 'uniform']. mesh_settings.mesh_accuracy.cells_per_wavelength\t15\tinteger mesh_settings.mesh_step_settings.dx\t0.1\tfloat mesh_settings.mesh_step_settings.dy\t0.1\tfloat mesh_settings.mesh_step_settings.dz\t0.1\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat advanced_options.auto_shutoff.use_early_shutoff\ttrue\tbool advanced_options.auto_shutoff.auto_shutoff_min\t1.0e-4\tfloat advanced_options.auto_shutoff.down_sample_time\t100\tfloat advanced_options.live_slice_filed_display_settings.show_field\tfalse\tbool advanced_options.live_slice_filed_display_settings.select_field_section\t2d_z_normal\tstring\tSelections are ['2d_y_normal', '2d_z_normal']. advanced_options.live_slice_filed_display_settings.select_component\tex\tstring\tSelections are ['ex', 'ey', 'ez']. advanced_options.live_slice_filed_display_settings.time_interval\t200\tfloat advanced_options.live_slice_filed_display_settings.position\t0\tfloat thread_setting.thread  6.3.1 Far field​ To calculate the far field in FDTD module. fdtd_res = simu[simu_name].run() ff_res = fdtd_res.calculate( monitor_name=&quot;through&quot;, property={&quot;wavelength&quot;: 1.31, &quot;far_field_settings&quot;: { &quot;general&quot;: {&quot;projection_direction&quot;: &quot;forward&quot;, &quot;material_index&quot;: 1, &quot;far_field_filter&quot;: 0, &quot;resolution&quot;: {&quot;horizontal_points&quot;: 100, &quot;vertical_points&quot;: 100}}}})  "},{"title":"6.4 Sweep:FDTD/FDE/EME​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#64-sweepfdtdfdeeme","content":"Add a sweep module to current project. add( self, *, name: str, type: Literal[&quot;FDTD:sweep&quot;, &quot;FDE:sweep&quot;, &quot;EME:sweep&quot;], property: AnyParameterSweepPostProcess, )  Example: simu = pj.Simulation() simu.add(type='FDTD:sweep', name='FDTDSweep', property={ 'simulation_name': simu_name, 'sweep_type': 'values', 'parameters': [{ 'variable': gap, 'values': [0.45, 0.55, 0.65], }], 'result': [ {'name': resultL[0], 'result': 'through', 'component': 'T'}, {'name': resultL[1], 'result': 'cross', 'component': 'T'}, {'name': resultL[2], 'result': 'through_me', 'component': 'T_forward'}, {'name': resultL[3], 'result': 'cross_me', 'component': 'T_forward'} ] })  An example of FDE sweep is illustrated in the following code. simu = pj.Simulation() simu.add(type=&quot;FDE:sweep&quot;, name=&quot;FDESweep&quot;, property={ &quot;simulation_name&quot;: simu_name, &quot;sweep_type&quot;: &quot;values&quot;, &quot;parameters&quot;: [{&quot;variable&quot;: width, &quot;values&quot;: [0.5, 0.7, 0.9]}], &quot;result&quot;: [{&quot;name&quot;: result[0], &quot;component&quot;: &quot;mode2:neff&quot;, &quot;result&quot;: &quot;FDE:Structure Sweep&quot;}, {&quot;name&quot;: result[1], &quot;component&quot;: &quot;mode1:neff&quot;, &quot;result&quot;: &quot;FDE:Structure Sweep&quot;}, {&quot;name&quot;: result[2], &quot;component&quot;: &quot;mode1:loss&quot;, &quot;result&quot;: &quot;FDE:Structure Sweep&quot;}, ] })  An example of EME sweep is illustrated in the following code. simu = pj.Simulation() simu.add( type='EME:sweep', name='EMESweep', property={ 'simulation_name': simu_name, 'parameters': [ {'variable': gap, 'number_of_points': 3, 'start': 0.45, 'stop': 0.65} ], # 'sweep_type': 'values', # 'parameters': [ { 'variable': gap, 'values': [0.45, 0.55, 0.65] } ], 'result': [ {'name': 'SMatrix', 'component': 'S', 'result': 'S-Matrix'} ] }, )  Parameters\tDefault\tType\tNotessimulation_name string sweep_type\tranges\tstring\tSelections are ['ranges', 'values']. []parameters.variable float []parameters.start float []parameters.stop float []parameters.number_of_points integer []parameters.values list []result.name string []result.result string []result.component string\t "},{"title":"6.5 AFDTD​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#65-afdtd","content":"Add an AFDTD solver to current project with the code type='AFDTD'. add( self, *, name: str, type: Literal[&quot;AFDTD&quot;], property: FdtdPostProcess, )  Example: simu = pj.Simulation() simu.add(name=&quot;preview_fdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}})  Parameters\tDefault\tType\tNotesextra.fdtd_port_group.source_port string general.dimension\t3d\tstring\tSelections are ['3d']. general.using_optical_path_estimate_time\tfalse\tbool general.simulation_time\t1000\tinteger mesh_settings.mesh_type\tauto_non_uniform\tstring\tSelections are ['auto_non_uniform', 'uniform']. mesh_settings.mesh_accuracy.cells_per_wavelength\t15\tinteger mesh_settings.mesh_step_settings.dx\t0.1\tfloat mesh_settings.mesh_step_settings.dy\t0.1\tfloat mesh_settings.mesh_step_settings.dz\t0.1\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat advanced_options.auto_shutoff.use_early_shutoff\ttrue\tbool advanced_options.auto_shutoff.auto_shutoff_min\t1.0e-4\tfloat advanced_options.auto_shutoff.down_sample_time\t100\tfloat advanced_options.live_slice_filed_display_settings.show_field\tfalse\tbool advanced_options.live_slice_filed_display_settings.select_field_section\t2d_z_normal\tstring\tSelections are ['2d_y_normal', '2d_z_normal']. advanced_options.live_slice_filed_display_settings.select_component\tex\tstring\tSelections are ['ex', 'ey', 'ez']. advanced_options.live_slice_filed_display_settings.time_interval\t200\tfloat advanced_options.live_slice_filed_display_settings.position\t0\tfloat thread_setting.thread\t4\tinteger\t "},{"title":"6.6 AFDE​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#66-afde","content":"Add an AFDE solver to current project with the code type='AFDE'. add( self, *, name: str, type: Literal[&quot;AFDE&quot;], property: AfdePostProcess, )  Example: simu = pj.Simulation() simu.add(name=&quot;preview_fde&quot;, type=&quot;AFDE&quot;, property={ &quot;mesh_settings&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: ogrid_global_y, &quot;dz&quot;: ogrid_global_z}}, &quot;fde_analysis&quot;: {&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: False, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength}, &quot;modulator_analysis&quot;: {&quot;modulator_analysis&quot;: True, &quot;wavelength&quot;: wavelength, &quot;np_path&quot;: &quot;&quot;}}, &quot;other&quot;: {**Si_index_vs_doping}})  Parameters\tDefault\tType\tNotesgeneral.solver_type\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. mesh_settings.global_mesh_uniform_grid.dx\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dy\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dz\t0.02\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat thread_setting.thread\t4\tinteger fde_analysis.modal_analysis.mesh_structure\tfalse\tbool fde_analysis.modal_analysis.calculate_modes\tfalse\tbool fde_analysis.modal_analysis.[]far_field_settings.calculate\ttrue\tbool fde_analysis.modal_analysis.[]far_field_settings.mode_selection integer fde_analysis.modal_analysis.[]far_field_settings.projection_method\tplanar\tstring\tSelections are ['planar']. fde_analysis.modal_analysis.[]far_field_settings.farfield_filter\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.material_index\t1.4\tfloat fde_analysis.modal_analysis.[]far_field_settings.projection_distance\t4430.65\tfloat fde_analysis.modal_analysis.[]far_field_settings.points_in_x\t50\tfloat fde_analysis.modal_analysis.[]far_field_settings.points_in_y\t50\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_x\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_x_span\t26.1834\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_y\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_y_span\t18.1231\tfloat fde_analysis.modal_analysis.wavelength\t1.55\tfloat fde_analysis.modal_analysis.wavelength_offset\t0.002\tfloat fde_analysis.modal_analysis.number_of_trial_modes\t5\tinteger fde_analysis.modal_analysis.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. fde_analysis.modal_analysis.n\t1\tfloat fde_analysis.modal_analysis.calculate_group_index\tfalse\tbool fde_analysis.modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool fde_analysis.modal_analysis.bent_waveguide.radius\t0.0\tfloat fde_analysis.modal_analysis.bent_waveguide.orientation\t0.0\tfloat fde_analysis.modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. fde_analysis.modal_analysis.mode_removal.threshold float fde_analysis.frequency_analysis.frequency_analysis\tfalse\tbool fde_analysis.frequency_analysis.start_wavelength\t1.55\tfloat fde_analysis.frequency_analysis.stop_wavelength\t1.49896\tfloat fde_analysis.frequency_analysis.number_of_points\t10\tinteger fde_analysis.frequency_analysis.effective_index\t1.0\tfloat fde_analysis.frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\t "},{"title":"6.7 OEDevice​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#67-oedevice","content":"Add an OEDevice solver to current project with the code type='AFDE'. add( self, *, name: str, type: Literal[&quot;OEDevice&quot;], property: OeDevicePostProcess, )  Example: simu = pj.Simulation() simu.add(name=&quot;preview_fdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}}) simu.add(name=&quot;preview_oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: &quot;&quot;, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  Parameters\tDefault\tType\tNotesgeneral.simulation_region\tDevice_Region\tstring\tSelections are ['Device_Region']. general.norm_length\t1\tfloat general.solver_mode\tsteady_state\tstring\tSelections are ['steady_state', 'transient', 'SSAC']. general.temperature_dependence\tIsothermal\tstring\tSelections are ['Isothermal']. general.simulation_temperature\t300\tfloat advanced.non_linear_solver\tNewton\tstring\tSelections are ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', ' LU', ' BCGS']. advanced.use_quasi_fermi\tdisabled\tstring\tSelections are ['disabled', ' enabled']. advanced.damping\tnone\tstring\tSelections are ['none', ' potential']. advanced.potential_update\t1\tinteger advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. advanced.thread_count\t4\tinteger advanced.max_iterations\t30\tinteger advanced.use_global_max_iterations\tfalse\tinteger\tSelections are ['false', 'true'] advanced.poisson_max_iterations\t30\tinteger advanced.ddm_max_iterations\t30\tinteger advanced.relative_tolerance\t1.0e-5\tfloat advanced.tolerance_relax\t1.0e+5\tfloat advanced.divergence_factor\t1.0e+25\tfloat genrate.genrate_path string genrate.source_fraction float genrate.coordinate_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float geometry.z_min float geometry.z_max float small_signal_ac.perturbation_amplitude\t0.001\tfloat small_signal_ac.frequency_spacing\tsingle\tstring\tSelections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat small_signal_ac.start_frequency\t1.0e+06\tfloat small_signal_ac.stop_frequency\t1.0e+09\tfloat small_signal_ac.frequency_interval\t9.9999e+10\tfloat small_signal_ac.num_frequency_points\t2\tinteger small_signal_ac.log_start_frequency\t1.0e+06\tfloat small_signal_ac.log_stop_frequency\t1.0e+10\tfloat small_signal_ac.log_num_frequency_points\t2\tinteger\t "},{"title":"7. Preview​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#7-preview","content":""},{"title":"7.1 Run index​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#71-run-index","content":"We can use the code below to preview the index of structure. run_index( self, *, property: RunIndex, name: str, export_csv: bool = False, show: bool = False, savepath: str = 'a', export_n: bool = True, export_c: bool = False, max_index: Optional[int] = None, max_sigma: Optional[int] = None, )  Parameters\tDescriptionproperty\tIndex monitor properties. name\tMonitor name. export_csv\tExport csv or not. Default as False. show\tShow figure or not. Default as False. savepath\tSave path for csv and picture. Default as 'a'. export_n\tWhether to export nx, ny, nz... . Default as True. export_c\tWhether to export σx, σy, σz... . Default as False. max_index\tMaximum index of heatmap colorbar. Default as None. max_sigma\tMaximum sigma of heatmap colorbar. Default as None. Example: simu[simu_name].run_index(name=f'{simu_name}_x_0', savepath=f'{plot_path}{k}IndexPreview_x=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 2}})  Parameters\tDefault\tType\tNotesgeometry.monitor_type string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t "},{"title":"7.2 Structure show and show 3D​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#72-structure-show-and-show-3d","content":"Show structure. If there are Pyramid or Arc-Waveguide 3D type geometry in current structure manager, this method is invalid. structure_show( self, *, mode=&quot;XY&quot;, show: bool, savepath: str, fig_type: Literal[&quot;png&quot;, &quot;svg&quot;] = &quot;png&quot;, simulation_name: Optional[str] = None, disabled_components: Tuple[ Literal[ &quot;materials&quot;, &quot;helpers&quot;, &quot;box&quot;, &quot;box.coordinate&quot;, &quot;box.cavity&quot;, &quot;ModeSource&quot;, &quot;PowerMonitor&quot;, &quot;ProfileMonitor&quot;, &quot;FDTDPortGroup&quot;, ], ... ] = tuple(), xyratio=(1, 1), celldisplay=False )  Parameters\tDescriptionmode\tShow mode. show\tWhether to show the picture. If set to False, the picture will be saved instead. savepath\tPicture save path. fig_type\tPicture suffix(type). simulation_name\tSimulation name. disabled_components\tDisable components from showing. xyratioZoom multiplier of x and y direction.\tZoom multiplier of x and y direction. celldisplay\tWhether to show eme cells. Show 3D structure in a pop up windows. show3d(self, show_with: Literal[&quot;webviewer&quot;, &quot;matplotlib&quot;] = &quot;webviewer&quot;)  Parameters\tDescriptionshow_with\t&quot;webviewer&quot; will start a server and toggle a browser windows. &quot;matplotlib&quot; will toggle a Axes3D windows. Default as &quot;webviewer&quot;. Example: st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}{kL[0]}{simu_name}', simulation_name=simu_name) simu[simu_name].show3d(show_with=&quot;local_gui&quot;)  "},{"title":"7.3 Run_doping​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#73-run_doping","content":"Run doping. run_doping( self, name: str, property: RunDopingPostProcess, norm: str, scale: str, superimpose: bool, show: bool, material_list: list, cmin: float, savepath: str )  Parameters\tDescriptionproperty\tDoping preview properties. name\tDoping preview name. show\tShow figure or not. Default as False. savepath\tSave path for picture. Required. norm\tColorbar normalization. Selections are ['linear', 'log']. Default as 'linear'. scale\tScale type. Selections are ['equal', 'auto']. Default as 'equal'. superimpose\tSuperimpose doping on structure or not. Default as True. material_list\tSpecified material type list. Default as []. region_list\tSpecified region name list. Default as []. Superior to material_list when not empty. cmax\tMaximum concentration of heatmap colorbar. Default as None. cmin\tMinimum concentration of heatmap colorbar. Default as None. Example: simu[&quot;preview_oedevice&quot;].run_doping(name=&quot;x_in&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}}, norm=&quot;log&quot;, scale=&quot;equal&quot;, superimpose=False, show=False, material_list=[&quot;Ge&quot;, &quot;Si&quot;], cmin=8e5, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;doping_x_in&quot;)  Parameters\tDefault\tType\tNotesgeometry.dimension string\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t "},{"title":"8. Extract result​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#8-extract-result","content":"In this section, we will explore how to use code to extract simulation result data, exporting data results in various formats, enabling more effective data processing. We support the atrributes to extract as below: Parameters\tDescriptionPowerAttributes\tLiteral['E', 'Ex', 'Ey', 'Ez', 'H', 'Hx', 'Hy', 'Hz', 'Px', 'Py', 'Pz', 'Energy density'] ModeAttributes\tLiteral[&quot;a&quot;, &quot;b&quot;, &quot;n&quot;, &quot;p&quot;, &quot;N&quot;, &quot;P&quot;, &quot;t_forward&quot;, &quot;t_backward&quot;, &quot;T_forward&quot;, &quot;T_backward&quot;] Literal[&quot;TEratio&quot;, &quot;neff_real&quot;, &quot;neff_imag&quot;, &quot;ng_real&quot;, &quot;ng_imag&quot;, &quot;wavelength_nm&quot;, &quot;loss_dBpcm&quot;]\t Parameters\tDescriptiondata\tWhich type/field data will be extracted. export_csv\tWhether to export a csv. Default as False. show\tWhether to show the picture. If set to False, the picture will be saved instead. Default as False. savepath\tPicture save path. Default as 'a'. target\tHow the data is organized/displayed. Default as None. attribute\tWhich attribute will extracted, in few cases this parameter is not needed. Default as None. real\tWhether to add real part of data. Default as True. imag\tWhether to add imag part of data. If both real and imag is activate, 'ABS' data will be extracted. Default as True. plot_x\tselection of x axis of heatmap or line plot. plot_y\tselection of y axis of heatmap. kwargs\tOther visualization parameters. 'monitor_name' and 'mode_expansion_name' for 'fdtd:mode_expansion' for example. "},{"title":"8.1 FDE​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#81-fde","content":"To extract the data of FDE module. 8.1.1 Calculate mode result​ Get the result of calculated mode. extract( self, *, # target - intensity data: Literal['calculate_modes'], attribute: PowerAttributes/ModeAttributes/OtherAttributes export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', mode: int, )  Example: result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_mode{m}', attribute='E', mode=m, real=True, imag=True, **export_options, show=False)  8.1.2 Far-field FDE result​ Get the result of calculated far-field FDE. extract( self, *, # target - table data: Literal['farfield_fde'], attribute: PowerAttributes, show=False, export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = 'a', mode: int, )  Example: fde_res.extract(data='farfield_fde', savepath=f'{plot_path}05_{simu_name}_far_field', attribute='E', mode=0, export_csv=True)  8.1.3 Mesh structure result​ To extract the result of meshing structure. extract( self, *, data: Literal['mesh_structure'], savepath:Any = 'a', target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, )  Example: simu.add(name=simu_name+&quot;_cal_mode&quot;, type=&quot;mode_selection:user_select&quot;, simulation_name=simu_name, source_name=&quot;source&quot;, property={&quot;modal_analysis&quot;: {&quot;mesh_structure&quot;: True, &quot;calculate_modes&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: 10, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True}})  8.1.4 Frequency analysis result​ To extract the result of frequency analysis. extract( self, *, target: Literal['line'] = 'line', data: Literal['frequency_analysis'], attribute: Literal['neff', 'group_index', 'loss', 'polarization'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None )  Example: result_fde.extract(data=&quot;frequency_analysis&quot;, savepath=f'{plot_path}{k}_freq_sweep_neff', attribute=&quot;neff&quot;, real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"8.2 EME​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#82-eme","content":"To extract the relevant data of EME module. 8.2.1 EME propagate:facet data​ Get the result of calculated facet data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:facet_data', ], export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = 'a', )  Example: eme_res.extract(data='eme_propagate:facet_data', savepath=plot_path, real=True, imag=True, export_csv=True)  8.2.2 EME propagate:monitor​ Get the result of monitor data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:monitor', ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract( data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_y_normal&quot;, monitor_name=&quot;y_normal&quot;, attribute=&quot;E&quot;, export_csv=True)  8.2.3 Propagation sweep:monitor​ Get the result of monitor data of Propagation sweep. extract( self, *, data: Literal[ 'propagation_sweep:monitor', ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True)  8.2.4 Wavelength sweep:monitor​ Get the result of monitor data of wavelength sweep. extract( self, *, data: Literal[ 'wavelength_sweep:monitor', ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True)  8.2.5 EME propagate:smatrix​ Get the result of smatrix data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:smatrix', ], target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True)  8.2.6 EME propagate:port mode infomation​ Get the result of port mode data of EME propagation. extract( self, *, # target - intensity data: Literal['eme_propagate:port_mode_info'], target: Literal['intensity'] = 'intensity', attribute: Literal['E', 'H'], port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, )  Example: eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True)  8.2.7 EME propagate:port mesh structure​ Get the result of port mesh structure data of EME propagation. extract( self, *, # target - intensity data: Literal['eme_propagate:port_mesh_structure'], port_name: str, target: Literal['line', 'intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data='eme_propagate:port_mesh_structure', savepath=f'{plot_path}{kL[3]}_eme_structure_{port_name}', port_name=port_name, target='intensity', # plot_x='y', plot_y='z', export_csv=False, show=False )  8.2.8 EME propagate:cell mesh structure​ Get the result of cell mesh structure data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:cell_mesh_structure', ], target: Literal[&quot;intensity&quot;, &quot;line&quot;], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data='eme_propagate:cell_mesh_structure', savepath=f'{plot_path}{kL[4]}_eme_c{cell_index}_index', cell_params='c' + str(cell_index), target='intensity', plot_x='y', plot_y='z', # export_csv=False, show=False )  "},{"title":"8.3 FDTD​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#83-fdtd","content":"To extract the relevant data of FDTD module. 8.3.1 FDTD:power monitor​ Get the result of power monitor data of FDTD. extract( self, *, data: Literal['fdtd:power_monitor'], target: Literal['intensity', 'line'], attribute: Union[PowerAttributes, Literal[&quot;T&quot;]], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, wavelength: Optional[Any] = None, )  Example: fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[6]}_TransVsLambda_power', monitor_name='through', target='line', plot_x='wavelength', attribute='T', real=True, imag=False, export_csv=True, export_mat=True, show=False)  8.3.2 FDTD:time monitor​ Get the result of FDTD time monitor data. extract( self, *, data: Literal['fdtd:time_monitor'], target: Literal['intensity', 'line'], attribute: Union[PowerAttributes, Literal[&quot;T&quot;]], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, wavelength: Optional[Any] = None, )  Example: fdtd_res.extract(data='fdtd:time_monitor', savepath=f'{plot_path}{kL[6]}_TransVstime', monitor_name='through', target='line', plot_x='time(fs)', attribute='E', real=True, imag=False, export_csv=True, export_mat=True, show=False)  8.3.3 FDTD:mode expansion​ Get the result of FDTD mode expansion data. extract( self, *, data: Literal['fdtd:mode_expansion'], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: ModeAttributes, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, mode: Optional[Any] = None, wavelength: Optional[Any] = None, monitor_name: str, mode_expansion_name: str, )  Example: fdtd_res.extract(data='fdtd:mode_expansion', savepath=f'{plot_path}{kL[5]}_TransVsLambda_mode=0', monitor_name='through', target='line', plot_x='wavelength', mode=0, attribute='T_forward', real=True, imag=True, export_csv=True, export_mat=True, show=False)  8.3.4 FDTD:port mode information​ Get the result of FDTD port mode information. extract( self, *, data: Literal['fdtd:port_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', port_name: str, mode: Any = None, plot_x: OptStr=None, plot_y: OptStr=None, )  Example: fdtd_res.extract(data='fdtd:port_mode_info', savepath=f'{plot_path}{kL[3]}_left_port_mode', port_name='left_port', target='intensity', attribute='E', mode=0, export_csv=True)  8.3.5 FDTD:mode source information​ Get the result of FDTD mode source information. extract( self, *, data: Literal['fdtd:mode_source_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', source_name: str, mode: Any = None, plot_x: OptStr=None, plot_y: OptStr=None, )  Example: fdtd_res.extract(data='fdtd:mode_source_mode_info', savepath=f'{plot_path}{kL[2]}_source_modeprofile', source_name='source', target='intensity', attribute='E', mode=0, real=True, imag=True, **export_options, show=False)  8.3.6 FDTD:mode expansion information​ Get the result of FDTD mode expansion information. extract( self, *, data: Literal['fdtd:mode_expansion_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', monitor_name: str, mode_expansion_name: str, plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, wavelength: Any = None, )  Example: fdtd_res.extract(data='fdtd:mode_expansion_mode_info', savepath=f'{plot_path}{kL[3]}_me_throughmode_info', monitor_name='through', target='intensity', attribute='E', mode=0, wavelength=f'{wavelength}', real=True, imag=True, **export_options, show=False)  "},{"title":"8.4 Sweep​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#84-sweep","content":"To extract the relevant data of sweep function. 8.4.1 sweep​ Get the result of sweep data. extract( self, *, data: Literal['sweep'], target: Literal['intensity', 'line'], attribute: str, monitor_name: Optional[str] = None, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, **kwargs, )  Example: swp_res.extract(data='sweep', target='line', attribute='S', plot_x='sweep_gap', savepath=f'{plot_path}/01 S', export_csv=True)  swp_res.extract(data='mode_expansion', target='line', attribute='T_forward', plot_x='sweep_gap', monitor_name='through', savepath=f'{plot_path}/03 {resultL[2]}', export_csv=True, )  8.4.2 smatrix sweep​ Get the result of smatrix sweep data. extract( self, *, data: Literal['smatrix_sweep'], target: Literal['intensity', 'line'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, )  Example: smatrix_res.extract(data='smatrix_sweep', savepath=f'{plot_path}{kL[8]}_smatrix_sweep', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"9. Other Fuction​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#9-other-fuction","content":"待整理  @abstractmethod def calculate( self, *, simulation_name: str, monitor_name: str, property: FdtdCalculateMethodPropertyProcess, cmp_f: Optional[Callable] = None, ): &quot;&quot;&quot; Calculate basing on the simulation result. :param monitor_name: monitor name :param property: properties for calculation :param simulation_name: simulation name :param cmp_f: compare function, defaults to None &quot;&quot;&quot;  def extract( self, *, data: Literal[ 'eme_propagate:port_effective_index', 'eme_propagate:port_ng', ], port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', )  def extract( self, *, data: Literal[ 'eme_propagate:port_overlap', ], target: Literal['line'] = 'line', port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  extract( self, *, target: Literal['intensity'] = 'intensity', data: Literal[ 'eme_propagate:cell_mode_info', ], attribute: Literal['E', 'H'], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, )  extract( self, *, data: Literal[ 'eme_propagate:prop_field', ], # target: intensity&quot;, attribute:PowerAttributes, cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  extract( self, *, data: Literal[ &quot;eme_propagate:internal_s&quot;, ], target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, ) -&gt; List[DataFrame]: ... @abstractmethod @overload def extract( self, *, data: Literal[ &quot;eme_propagate:cell_p_matrix&quot;, &quot;eme_propagate:cell_overlap&quot;, &quot;eme_propagate:cell_s&quot;, &quot;eme_propagate:prop_s&quot;, ], target: Literal['intensity'] = 'intensity', cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  "},{"title":"6.1.1 Mode selection​","type":1,"pageTitle":"Max-Optics SDK","url":"/my-website/docs/test/core/1#611-mode-selection-1","content":"Integrate a mode selection into the current project. add( self, *, name: str, simulation_name: str, source_name: str = &quot;&quot;, cell_group_index: int = 0, type: Literal[&quot;mode_selection:user_select&quot;], property: ModeSelectionUserSelectPostProcess, )  Example: simu = pj.Simulation() simu.add(name=simu_name+'_cal_mode', simulation_name=simu_name, source_name='source', type='mode_selection:user_select', property={'modal_analysis': {'calculate_modes': True, 'mesh_structure': True, 'wavelength': wavelength, 'number_of_trial_modes': 20, 'search': 'max_index', 'calculate_group_index': True }}) src_res = simu[f'{simu_name}_cal_mode'].run() src_res.extract(data='calculate_modes', savepath=f'{plot_path}{kL[2]}_Preview_SourceMode', attribute='E', mode=0, real=True, imag=True, **export_options, show=False)  Parameters\tDefault\tType\tNotesmodal_analysis.mesh_structure\tfalse\tbool modal_analysis.calculate_modes\tfalse\tbool modal_analysis.wavelength\t1.55\tfloat modal_analysis.wavelength_offset\t0.002\tfloat modal_analysis.number_of_trial_modes\t20\tinteger modal_analysis.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. modal_analysis.n\t1\tfloat modal_analysis.calculate_group_index\tfalse\tbool modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool modal_analysis.bent_waveguide.radius\t1.0\tfloat modal_analysis.bent_waveguide.orientation\t0.0\tfloat modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. modal_analysis.mode_removal.threshold float frequency_analysis.frequency_analysis\tfalse\tbool frequency_analysis.start_wavelength\t1.55\tfloat frequency_analysis.stop_wavelength\t1.49896\tfloat frequency_analysis.number_of_points\t10\tinteger frequency_analysis.effective_index\t1.0\tfloat frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\t "},{"title":"geometry_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/geometry_typing","content":"geometry_typing","keywords":""},{"title":"mesh_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/mesh_typing","content":"mesh_typing","keywords":""},{"title":"OBoundary_not_same_settings_post_process_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/OBoundary_not_same_settings_post_process_typing","content":"OBoundary_not_same_settings_post_process_typing","keywords":""},{"title":"OBoundary_same_settings_post_process_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/OBoundary_same_settings_post_process_typing","content":"OBoundary_same_settings_post_process_typing","keywords":""},{"title":"post_process_analytical_waveguide_property_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_analytical_waveguide_property_typing","content":"post_process_analytical_waveguide_property_typing","keywords":""},{"title":"post_process_arc_waveguide_3d_property_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_arc_waveguide_3d_property_typing","content":"post_process_arc_waveguide_3d_property_typing","keywords":""},{"title":"post_process_arc_waveguide_property_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_arc_waveguide_property_typing","content":"post_process_arc_waveguide_property_typing","keywords":""},{"title":"maxoptics_sdk.core.structure.interface module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/interface","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example","content":"None  "},{"title":"STRUCTURE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#structure_property","content":"\tDefault\tType\tNotes mesh_type\tcurve_mesh\tstring\tSelections are ['curve_mesh', 'staircase']. mesh_factor\t1.2\tfloat\tRestrained by condition:(1.05,1.6) background_material material\t "},{"title":"1. EBoundary and OBoundary​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#1-eboundary-and-oboundary","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax","content":"abstract EBoundary(*, property: StructureEBoundaryPropertyDict) Not Implemented abstract OBoundary(*, pml_same_settings: bool = True, property: OBoundarySameSettingsPostProcess | OBoundaryNotSameSettingsPostProcess) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage","content":"Add a set of default optical boundary’s property to current project. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#parameters-and-returns","content":"Parameters\tExplanation property\tDefault optical boundary property. pml_same_settings\tUse same pml settings on every directions or not.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example-1","content":"None  "},{"title":"OBOUNDARY_SAME_SETTINGS​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#oboundary_same_settings","content":"\tdefault\ttype\tnotes general_pml.pml_same_settings\ttrue\tbool general_pml.pml_profile\tstandard\tstring general_pml.pml_layer integer general_pml.pml_kappa float general_pml.pml_sigma float general_pml.pml_polynomial integer general_pml.pml_alpha float general_pml.pml_alpha_polynomial integer general_pml.pml_min_layers integer general_pml.pml_max_layers integer geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float boundary.x_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.x_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.y_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.y_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.z_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.z_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. "},{"title":"OBOUNDARY_NOT_SAME_SETTINGS​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#oboundary_not_same_settings","content":"\tdefault\ttype\tnotes general_pml.pml_same_settings\ttrue\tbool general_pml.x_min_bc.pml_profile\tstandard\tstring general_pml.x_min_bc.pml_layer integer general_pml.x_min_bc.pml_kappa float general_pml.x_min_bc.pml_sigma float general_pml.x_min_bc.pml_polynomial integer general_pml.x_min_bc.pml_alpha float general_pml.x_min_bc.pml_alpha_polynomial integer general_pml.x_min_bc.pml_min_layers integer general_pml.x_min_bc.pml_max_layers integer general_pml.x_max_bc.pml_profile\tstandard\tstring general_pml.x_max_bc.pml_layer integer general_pml.x_max_bc.pml_kappa float general_pml.x_max_bc.pml_sigma float general_pml.x_max_bc.pml_polynomial integer general_pml.x_max_bc.pml_alpha float general_pml.x_max_bc.pml_alpha_polynomial integer general_pml.x_max_bc.pml_min_layers integer general_pml.x_max_bc.pml_max_layers integer general_pml.y_min_bc.pml_profile\tstandard\tstring general_pml.y_min_bc.pml_layer integer general_pml.y_min_bc.pml_kappa float general_pml.y_min_bc.pml_sigma float general_pml.y_min_bc.pml_polynomial integer general_pml.y_min_bc.pml_alpha float general_pml.y_min_bc.pml_alpha_polynomial integer general_pml.y_min_bc.pml_min_layers integer general_pml.y_min_bc.pml_max_layers integer general_pml.y_max_bc.pml_profile\tstandard\tstring general_pml.y_max_bc.pml_layer integer general_pml.y_max_bc.pml_kappa float general_pml.y_max_bc.pml_sigma float general_pml.y_max_bc.pml_polynomial integer general_pml.y_max_bc.pml_alpha float general_pml.y_max_bc.pml_alpha_polynomial integer general_pml.y_max_bc.pml_min_layers integer general_pml.y_max_bc.pml_max_layers integer general_pml.z_min_bc.pml_profile\tstandard\tstring general_pml.z_min_bc.pml_layer integer general_pml.z_min_bc.pml_kappa float general_pml.z_min_bc.pml_sigma float general_pml.z_min_bc.pml_polynomial integer general_pml.z_min_bc.pml_alpha float general_pml.z_min_bc.pml_alpha_polynomial integer general_pml.z_min_bc.pml_min_layers integer general_pml.z_min_bc.pml_max_layers integer general_pml.z_max_bc.pml_profile\tstandard\tstring general_pml.z_max_bc.pml_layer integer general_pml.z_max_bc.pml_kappa float general_pml.z_max_bc.pml_sigma float general_pml.z_max_bc.pml_polynomial integer general_pml.z_max_bc.pml_alpha float general_pml.z_max_bc.pml_alpha_polynomial integer general_pml.z_max_bc.pml_min_layers integer general_pml.z_max_bc.pml_max_layers integer geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float boundary.x_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.x_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.y_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.y_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.z_max string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.z_min string\tSelections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. "},{"title":"2. add_doping​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#2-add_doping","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-1","content":"abstract add_doping(*, name: str, type: Literal['p', 'n', 'file'], property: StructureDopingPropertyDictUsingFile | StructureDopingPropertyDictUsingNP | StructureDopingPropertyDictUsingNPVolume) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage-1","content":"Add a set of default optical boundary’s property to current project. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#parameters-and-returns-1","content":"Parameters\tExplanation name\tDoping name type\tDoping type property\tDoping property  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example-2","content":"None  "},{"title":"FILE​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#file","content":"\tDefault\tType\tNotes general.format str\tSelections are ['DOP'] general.file_path str general.species str\tSelections are ['n', 'p'] volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' "},{"title":"N/P​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#np","content":"\tDefault\tType\tNotes geometry.x float geometry.x_span float geometry.y float geometry.y_span float geometry.z float geometry.z_span float geometry.rotate_x float geometry.rotate_y float geometry.rotate_z float geometry.x_min float geometry.x_max float geometry.y_min float geometry.y_max float geometry.z_min float geometry.z_max float general.distribution_function str\tSelections are ['constant', 'gaussian'] general.concentration float general.source_face str\tAvailable when distribution_function is 'gaussian' general.junction_width float\tAvailable when distribution_function is 'gaussian' general.ref_concentration float\tAvailable when distribution_function is 'gaussian' volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list list\tAvailable when volume_type is 'material' volume.region_list list\tAvailable when volume_type is 'region' "},{"title":"3. add_electrode​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#3-add_electrode","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-2","content":"abstract add_electrode(*, name: str, property: StructureElectrodeProperty) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage-2","content":"_summary_ "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#parameters-and-returns-2","content":"Parameters\tExplanation name\tElectric boundary condition name. property Electric boundary condition property.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example-3","content":"None  "},{"title":"STEADY_STATE​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#steady_state","content":"\tdefault\ttype\tnotes force_ohmic\ttrue\tbool bc_mode\tsteady_state\tstring\tSelections are ['steady_state']. apply_AC_small_signal\tnone\tstring\tSelections are ['none']. sweep_type\tsingle\tstring\tSelections are ['single', 'range', 'value']. v_step_max\t0.5\tfloat voltage\t0\tfloat\tAvailable when sweep_type is 'single'. range_start\t0\tfloat\tAvailable when sweep_type is 'range'. range_stop\t1\tfloat\tAvailable when sweep_type is 'range'. range_interval\t1\tfloat\tAvailable when sweep_type is 'range'. range_num_points\t2\tinteger\tAvailable when sweep_type is 'range'. []sweep_value_table.index integer\tAvailable when sweep_type is 'value'. []sweep_value_table.number float\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t "},{"title":"SSAC​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#ssac","content":"\tdefault\ttype\tnotes force_ohmic\ttrue\tbool bc_mode\tsteady_state\tstring\tSelections are ['steady_state']. apply_AC_small_signal\tnone\tstring\tSelections are ['none', 'All']. sweep_type\tsingle\tstring\tSelections are ['single', 'range', 'value']. v_step_max\t0.5\tfloat voltage\t0\tfloat\tAvailable when sweep_type is 'single'. range_start\t0\tfloat\tAvailable when sweep_type is 'range'. range_stop\t1\tfloat\tAvailable when sweep_type is 'range'. range_interval\t1\tfloat\tAvailable when sweep_type is 'range'. range_num_points\t2\tinteger\tAvailable when sweep_type is 'range'. []sweep_value_table.index integer\tAvailable when sweep_type is 'value'. []sweep_value_table.number float\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t "},{"title":"TRANSIENT​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#transient","content":"\tdefault\ttype\tnotes force_ohmic\ttrue\tbool bc_mode string\tSelections are ['transient']. voltage\t0\tfloat []time_table.time_start float []time_table.time_stop float []time_table.initial_step float []time_table.max_step float []time_table.optical.enabled\t0\tinteger\tSelections are [0, 1] []time_table.optical.envelop integer\tSelections are [0] []time_table.optical.source_fraction float surface_type\tsolid\tstring\tSelections are ['solid']. solid string\t "},{"title":"4. add_emesh​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#4-add_emesh","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-3","content":"abstract add_emesh(*, name: str, property: Dict[str, Any]) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage-3","content":"Add electric mesh. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#parameters-and-returns-3","content":"Parameters\tExplanation name\tElectric local mesh name. property\tElectric local mesh property.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example-4","content":"None  "},{"title":"SUB_EMESH​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#sub_emesh","content":"\tdefault\ttype\tnotes x float x_span float\tRestrained by condition: &gt;=0. x_min float x_max float y float y_span float\tRestrained by condition: &gt;=0. y_min float y_max float z float z_span float\tRestrained by condition: &gt;=0. z_min float z_max float mesh_size float\tmax size of electrical simulation mesh "},{"title":"5. add_emesh_along_line​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#5-add_emesh_along_line","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-4","content":"abstract add_emesh_along_line(*, name: str, property: Dict[str, Any]) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage-4","content":"Add electric mesh along line. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#parameters-and-returns-4","content":"Parameters\tExplanation name\tElectric local mesh name. property\tElectric local mesh property.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example-5","content":"None  "},{"title":"SUB_EMESH_ALONG_LINE​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#sub_emesh_along_line","content":"\tdefault\ttype\tnotes start_x\t0\tfloat start_y\t0\tfloat\tRestrained by condition: &gt;=0. start_z\t0\tfloat end_x\t1\tfloat end_y\t1\tfloat end_z float\tRestrained by condition: &gt;=0. mesh_size\t0.01\tfloat\t "},{"title":"6. add_geometry​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#6-add_geometry","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-5","content":"abstract add_geometry(*, name: str, type: str, property: StructureGeometryPropertyDict) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage-5","content":"Add a geometry(structure) to current project. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#parameters-and-returns-5","content":"Parameters\tExplanation name\tGeometry name. type\tGeometry type. property Geometry property.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example-6","content":"None  "},{"title":"GDS_FILE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#gds_file_property","content":"\tDefault\tType\tNotes geometry.x\t0\tfloat geometry.y\t0\tfloat geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. general.path string general.cell_name string general.layer_name list\t "},{"title":"GDS_FILE3D_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#gds_file3d_property","content":"\tDefault\tType\tNotes geometry.x\t0\tfloat geometry.y\t0\tfloat geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.tilt_angle\t90\tfloat geometry.tilt_location\ttop\tstring\tSelections are ['top', 'TOP', 'Top', 'bottom', 'BOTTOM', 'Bottom', 'middle', 'MIDDLE', 'Middle', 'user_defined']. geometry.user_defined\t1\tfloat geometry.mirror_normal_z\t0\tfloat geometry.mirror_plane_z0\t0\tfloat geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. general.path string general.cell_name string general.layer_name list general.construct_method string\tSelections are ['method1', 'method2'] "},{"title":"ARC_WAVEGUIDE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#arc_waveguide_property","content":"\tDefault\tType\tNotes geometry.inner_radius float\tRestrained by condition: &gt;0. geometry.outer_radius float\tRestrained by condition: &gt;0. geometry.angle float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"ARC_WAVEGUIDE_3D_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#arc_waveguide_3d_property","content":"\tDefault\tType\tNotes geometry.radius float\tRestrained by condition: &gt;0. geometry.angle float\tRestrained by condition: &gt;0,≤360. geometry.base_height float\tRestrained by condition: &gt;0. geometry.top_width float\tRestrained by condition: &gt;0. geometry.bottom_width float\tRestrained by condition: &gt;0. geometry.x float geometry.y float geometry.z float geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"BEZIER_CURVE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#bezier_curve_property","content":"\tDefault\tType\tNotes geometry.point_1_x float geometry.point_1_y float geometry.point_2_x float geometry.point_2_y float geometry.point_3_x float geometry.point_3_y float geometry.point_4_x float geometry.point_4_y float geometry.width float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"BEZIER_CURVE_3D_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#bezier_curve_3d_property","content":"\tDefault\tType\tNotes geometry.base_height float\tRestrained by condition: &gt;0. geometry.top_width float\tRestrained by condition: &gt;0. geometry.bottom_width float\tRestrained by condition: &gt;0. geometry.[control_points.x float geometry.[control_points.y float geometry.x float geometry.y float geometry.z float geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"CIRCLE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#circle_property","content":"\tDefault\tType\tNotes geometry.radius float\tRestrained by condition: &gt;0. geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"CUSTOM_POLYGON_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#custom_polygon_property","content":"\tDefault\tType\tNotes geometry.size float\tRestrained by condition: &gt;0. geometry.sides integer\tRestrained by condition: &gt;=3. geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"ELLIPSE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#ellipse_property","content":"\tDefault\tType\tNotes geometry.x_radius float\tRestrained by condition: &gt;0. geometry.y_radius float\tRestrained by condition: &gt;0. geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"LINEAR_TRAPEZOID_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#linear_trapezoid_property","content":"\tDefault\tType\tNotes geometry.point_1_x float geometry.point_1_y float geometry.point_2_x float geometry.point_2_y float geometry.point_3_x float geometry.point_3_y float geometry.point_4_x float geometry.point_4_y float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"PYRAMID_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#pyramid_property","content":"\tDefault\tType\tNotes geometry.x_span_bottom float\tRestrained by condition: &gt;=0. geometry.y_span_bottom float\tRestrained by condition: &gt;=0. geometry.x_span_top float\tRestrained by condition: &gt;=0. geometry.y_span_top float\tRestrained by condition: &gt;=0. geometry.theta_x\t0\tfloat geometry.theta_y\t0\tfloat geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"ANALYTICAL_WAVEGUIDE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#analytical_waveguide_property","content":"\tDefault\tType\tNotes geometry.x_span float\tRestrained by condition: &gt;0. geometry.x_min float geometry.x_max float geometry.y_span float\tRestrained by condition: &gt;0. geometry.y_min float geometry.y_max float geometry.equation1 string geometry.equation2\t1\tstring geometry.nonsymmetric\tfalse\tbool geometry.resolution\t10\tinteger geometry.tilt_angle\t90\tfloat geometry.tilt_location\ttop\tstring\tSelections are ['top', 'TOP', 'Top', 'bottom', 'BOTTOM', 'Bottom', 'middle', 'MIDDLE', 'Middle', 'user_defined']. geometry.user_defined\t1\tfloat geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"RECTANGLE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#rectangle_property","content":"\tDefault\tType\tNotes geometry.x_span float\tRestrained by condition: &gt;0. geometry.x_min float geometry.x_max float geometry.y_span float\tRestrained by condition: &gt;0. geometry.y_min float geometry.y_max float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"RING_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#ring_property","content":"\tDefault\tType\tNotes geometry.inner_radius float\tRestrained by condition: &gt;0. geometry.outer_radius float\tRestrained by condition: &gt;0. geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"SECTOR_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#sector_property","content":"\tDefault\tType\tNotes geometry.radius float\tRestrained by condition: &gt;0. geometry.angle float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"TRIANGLE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#triangle_property","content":"\tDefault\tType\tNotes geometry.point_1_x float geometry.point_1_y float geometry.point_2_x float geometry.point_2_y float geometry.point_3_x float geometry.point_3_y float geometry.x float geometry.y float geometry.z float geometry.z_span float\tRestrained by condition: &gt;0. geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0. "},{"title":"TERRACE_PROPERTY​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#terrace_property","content":"\tdefault\ttype\tnotes geometry.top_width float geometry.top_length float geometry.bottom_width float geometry.bottom_length float geometry.height float geometry.theta_x\t0\tfloat geometry.theta_y\t0\tfloat geometry.x float geometry.y float geometry.z float geometry.z_min float geometry.z_max float geometry.rotate_x\t0\tfloat geometry.rotate_y\t0\tfloat geometry.rotate_z\t0\tfloat material.material material material.mesh_order integer\tRestrained by condition: &gt;=0  "},{"title":"7. add_mesh​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#7-add_mesh","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-6","content":"abstract add_mesh(*, name: str, property: PostProcessSubMesh) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage-6","content":"Add sub mesh. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#parameters-and-returns-6","content":"Parameters\tExplanation name\tMesh name. property\tMesh property.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example-7","content":"None  "},{"title":"SUB_MESH​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#sub_mesh","content":"\tdefault\ttype\tnotes general.override_x_mesh bool general.override_y_mesh bool general.override_z_mesh bool general.dx float\tRestrained by condition: &gt;0. general.dy float\tRestrained by condition: &gt;0. general.dz float\tRestrained by condition: &gt;0. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float\t "},{"title":"8. add_surface_recombination​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#8-add_surface_recombination","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-7","content":"abstract add_surface_recombination(*, name: str, property: AddSurfaceRecombination) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage-7","content":"Add surface recombination. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#parameters-and-returns-7","content":"Parameters\tExplanation name\tSurface recombination name. property\tSurface recombination property.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example-8","content":"None  "},{"title":"SURFACE_RECOMBINATION​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#surface_recombination","content":"\tdefault\ttype\tnotes surface_type\tdomain_domain\tstring\tSelections are ['domain_domain', 'material_material']. interface_type\tnull\tstring\tSelections are ['null', 'InsulatorInterface', 'HomoJunction', 'HeteroJunction', 'MetalOhmicInterface', 'SolderPad']. infinite_recombination\ttrue\tbool\tAvailable when interface_type is 'MetalOhmicInterface'. velocity_hole\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface' or 'InsulatorInterface'. velocity_electron\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface' or 'InsulatorInterface'. domain_1 string\tAvailable when surface_type is 'domain_domain'. domain_2 string\tAvailable when surface_type is 'domain_domain'. material_1 material\tAvailable when surface_type is 'material_material'. material_2 material\tAvailable when surface_type is 'material_material'. "},{"title":"9. export_gds​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#9-export_gds","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-8","content":"abstract export_gds(filepath: str, top_cell: str, layers: List[GdsExportTableData]) "},{"title":"10. run_doping​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#10-run_doping","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-9","content":"abstract run_doping(*args, **kwargs) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage-8","content":"Not Implemented yet. "},{"title":"11. structure_show​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#11-structure_show","content":""},{"title":"Syntax​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#syntax-10","content":"abstract structure_show(*, mode='XY', show: bool, savepath: str, fig_type: Literal['png', 'svg'] = 'png', simulation_name: str | None = None, disabled_components: Tuple[Literal['materials', 'helpers', 'box', 'box.coordinate', 'box.cavity', 'ModeSource', 'PowerMonitor', 'ProfileMonitor', 'FDTDPortGroup'], ...] = (), xyratio=(1, 1), celldisplay=False) "},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#usage-9","content":"Show Structure. If there are Pyramid or ArcWaveguide3D type geometry in current Structure manager, this method is invalid. "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#parameters-and-returns-8","content":"Parameters\tExplanation mode\tShow mode. show\tWhether to show the picture. If set to False, the picture will be saved instead. savepath\tPicture save path. fig_type\tPicture suffix(type). simulation_name\tSimulation name. disabled_components\tDisable components from showing. xyratio\tZoom multiplier of x and y direction. celldisplay\tWhether to show eme cells.  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.interface module","url":"/my-website/docs/test/core/structure/interface#example-9","content":"None  "},{"title":"post_process_bezier_curve_3d_property_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_bezier_curve_3d_property_typing","content":"post_process_bezier_curve_3d_property_typing","keywords":""},{"title":"post_process_circle_property_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_circle_property_typing","content":"post_process_circle_property_typing","keywords":""},{"title":"post_process_bezier_curve_property_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_bezier_curve_property_typing","content":"post_process_bezier_curve_property_typing","keywords":""},{"title":"post_process_custom_polygon_property_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_custom_polygon_property_typing","content":"post_process_custom_polygon_property_typing","keywords":""},{"title":"maxoptics_sdk.core.structure.post_process_elipse_property_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_ellipse_property_typing module","content":"","keywords":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_elipse_property_typing module","url":"/my-website/docs/test/core/structure/post_process_ellipse_property_typing module#parameters-and-returns","content":"Parameter\tType\tDescription geometry\tPostProcessEllipsePropertyGeometry material\tPostProcessEllipsePropertyMaterial\t  Returns:\tNo return.  class maxoptics_sdk.core.structure.post_process_elipse_property_typing.PostProcessEllipsePropertyGeometry(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_elipse_property_typing module","url":"/my-website/docs/test/core/structure/post_process_ellipse_property_typing module#parameters-and-returns-1","content":"Parameter\tType\tDescription rotate_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled x_radius\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0 y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled y_radius\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0 z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z_max\tUnion[float, int, FloatParameter, FloatParameterExpression] z_min\tUnion[float, int, FloatParameter, FloatParameterExpression] z_span\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0  Returns:\tNo return.  class maxoptics_sdk.core.structure.post_process_elipse_property_typing.PostProcessEllipsePropertyMaterial(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_elipse_property_typing module","url":"/my-website/docs/test/core/structure/post_process_ellipse_property_typing module#parameters-and-returns-2","content":"Parameter\tType\tDescription material\tMaterial\tMUST be filled mesh_order\tint\tcheck: &gt;=0  Returns:\tNo return. "},{"title":"maxoptics_sdk.core.structure.post_process_gds_file_property_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_gds_file_property_typing module","content":"","keywords":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_gds_file_property_typing module","url":"/my-website/docs/test/core/structure/post_process_gds_file_property_typing module#parameters-and-returns","content":"Property\tType general\tPostProcessGdsFilePropertyGeneral geometry\tPostProcessGdsFilePropertyGeometry material\tPostProcessGdsFilePropertyMaterial  Returns:\tNo return. class maxoptics_sdk.core.structure.post_process_gds_file_property_typing.PostProcessGdsFilePropertyGeneral(*args, **kwargs)  Bases: Protocol Parameter\tType\tDescription cell_name\tstr\tMUST be filled layer_name\tUnion[Tuple[Any, ...], List[Any]]\tMUST be filled path\tstr\tMUST be filled  Returns:\tNo return.  class maxoptics_sdk.core.structure.post_process_gds_file_property_typing.PostProcessGdsFilePropertyGeometry(*args, **kwargs)  Bases: Protocol Parameter\tType\tDescription x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z_max\tUnion[float, int, FloatParameter, FloatParameterExpression] z_min\tUnion[float, int, FloatParameter, FloatParameterExpression] z_span\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0  Returns:\tNo return. "},{"title":"post_process_gds_file3d_property_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_gds_file3d_property_typing","content":"post_process_gds_file3d_property_typing","keywords":""},{"title":"maxoptics_sdk.core.structure.post_process_linear_trapezoid_property_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_linear_trapezoid_property_typing","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_linear_trapezoid_property_typing module","url":"/my-website/docs/test/core/structure/post_process_linear_trapezoid_property_typing#usage","content":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_linear_trapezoid_property_typing module","url":"/my-website/docs/test/core/structure/post_process_linear_trapezoid_property_typing#parameters-and-returns","content":"Property\tType geometry\tPostProcessLinearTrapezoidPropertyGeometry material\tPostProcessLinearTrapezoidPropertyMaterial  Returns:\tNo return.  class maxoptics_sdk.core.post_process_linear_trapezoid_property_typing.PostProcessLinearTrapezoidPropertyGeometry(*args, **kwargs)  Bases: Protocol Parameter\tType\tDescription point_1_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_1_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_2_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_2_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_3_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_3_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_4_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_4_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled rotate_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z_max\tUnion[float, int, FloatParameter, FloatParameterExpression] z_min\tUnion[float, int, FloatParameter, FloatParameterExpression] z_span\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0  Returns:\tNo return.  class maxoptics_sdk.core.post_process_linear_trapezoid_property_typing.PostProcessLinearTrapezoidPropertyMaterial(*args, **kwargs)  Bases: Protocol Parameter\tType\tDescription material\tMaterial\tMUST be filled mesh_order\tint\tcheck: &gt;=0  Returns:\tNo return. "},{"title":"maxoptics_sdk.core.structure.post_process_pyramid_property_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_pyramid_property_typing","content":"","keywords":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_pyramid_property_typing module","url":"/my-website/docs/test/core/structure/post_process_pyramid_property_typing#parameters-and-returns","content":"Property\tType geometry\tPostProcessPyramidPropertyGeometry material\tPostProcessPyramidPropertyMaterial  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_pyramid_property_typing module","url":"/my-website/docs/test/core/structure/post_process_pyramid_property_typing#example","content":"class maxoptics_sdk.core.structure.post_process_pyramid_property_typing.PostProcessPyramidPropertyGeometry(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_pyramid_property_typing module","url":"/my-website/docs/test/core/structure/post_process_pyramid_property_typing#parameters-and-returns-1","content":"Parameter\tType\tDescription rotate_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 theta_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 theta_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled x_span_bottom\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;=0 x_span_top\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;=0 y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled y_span_bottom\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;=0 y_span_top\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;=0 z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z_max\tUnion[float, int, FloatParameter, FloatParameterExpression] z_min\tUnion[float, int, FloatParameter, FloatParameterExpression] z_span\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0  Returns:\tNo return.  class maxoptics_sdk.core.structure.post_process_pyramid_property_typing.PostProcessPyramidPropertyMaterial(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_pyramid_property_typing module","url":"/my-website/docs/test/core/structure/post_process_pyramid_property_typing#parameters-and-returns-2","content":"Parameter\tType\tDescription material\tMaterial\tMUST be filled mesh_order\tint\tcheck: &gt;=0  Returns:\tNo return. "},{"title":"maxoptics_sdk.core.struture.post_process_rectangle_property_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_rectangle_property_typing","content":"","keywords":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.struture.post_process_rectangle_property_typing module","url":"/my-website/docs/test/core/structure/post_process_rectangle_property_typing#parameters-and-returns","content":"Property\tType geometry\tPostProcessRectanglePropertyGeometry material\tPostProcessRectanglePropertyMaterial  Returns:\tNo return.  class maxoptics_sdk.core.struture.post_process_rectangle_property_typing.PostProcessRectanglePropertyGeometry(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.struture.post_process_rectangle_property_typing module","url":"/my-website/docs/test/core/structure/post_process_rectangle_property_typing#parameters-and-returns-1","content":"Parameter\tType\tDescription rotate_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled x_max\tUnion[float, int, FloatParameter, FloatParameterExpression] x_min\tUnion[float, int, FloatParameter, FloatParameterExpression] x_span\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0 y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled y_max\tUnion[float, int, FloatParameter, FloatParameterExpression] y_min\tUnion[float, int, FloatParameter, FloatParameterExpression] y_span\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0 z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z_max\tUnion[float, int, FloatParameter, FloatParameterExpression] z_min\tUnion[float, int, FloatParameter, FloatParameterExpression] z_span\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0  Returns:\tNo return.  class maxoptics_sdk.core.struture.post_process_rectangle_property_typing.PostProcessRectanglePropertyMaterial(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.struture.post_process_rectangle_property_typing module","url":"/my-website/docs/test/core/structure/post_process_rectangle_property_typing#parameters-and-returns-2","content":"Parameter\tType\tDescription material\tMaterial\tMUST be filled mesh_order\tint\tcheck: &gt;=0  Returns:\tNo return. "},{"title":"maxoptics_sdk.core.structure.post_process_ring_property_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_ring_property_typing","content":"","keywords":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_ring_property_typing module","url":"/my-website/docs/test/core/structure/post_process_ring_property_typing#parameters-and-returns","content":"Property\tType geometry\tPostProcessRingPropertyGeometry material\tPostProcessRingPropertyMaterial  Returns:\tNo return.  class maxoptics_sdk.core.structure.post_process_ring_property_typing.PostProcessRingPropertyGeometry(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_ring_property_typing module","url":"/my-website/docs/test/core/structure/post_process_ring_property_typing#parameters-and-returns-1","content":"Parameter\tType\tDescription inner_radius\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0 outer_radius\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0 rotate_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z_max\tUnion[float, int, FloatParameter, FloatParameterExpression] z_min\tUnion[float, int, FloatParameter, FloatParameterExpression] z_span\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0  Returns:\tNo return.  class maxoptics_sdk.core.structure.post_process_ring_property_typing.PostProcessRingPropertyMaterial(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_ring_property_typing module","url":"/my-website/docs/test/core/structure/post_process_ring_property_typing#parameters-and-returns-2","content":"Parameter\tType\tDescription material\tMaterial\tMUST be filled mesh_order\tint\tcheck: &gt;=0 "},{"title":"post_process_sector_property_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_sector_property_typing","content":"post_process_sector_property_typing","keywords":""},{"title":"post_process_sub_electrode_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_sub_electrode_typing","content":"post_process_sub_electrode_typing","keywords":""},{"title":"maxoptics_sdk.core.structure.post_process_structure_property_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_structure_property_typing","content":"","keywords":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_structure_property_typing module","url":"/my-website/docs/test/core/structure/post_process_structure_property_typing#parameters-and-returns","content":"Parameter\tType\tDescription background_material\tMaterial\tMUST be filled mesh_factor\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 1.2, check: [1.05,1.6] mesh_type\tLiteral[&quot;curve_mesh&quot;, &quot;staircase&quot;]\tdefault: curve_mesh  Returns:\tNo return. "},{"title":"maxoptics_sdk.core.structure.post_process_terrace_property_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_terrace_property_typing","content":"","keywords":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_terrace_property_typing module","url":"/my-website/docs/test/core/structure/post_process_terrace_property_typing#parameters-and-returns","content":"Parameter\tType geometry\tPostProcessTerracePropertyGeometry material\tPostProcessTerracePropertyMaterial  Returns:\tNo return. class maxoptics_sdk.core.structure.post_process_terrace_property_typing.PostProcessTerracePropertyGeometry(*args, **kwargs)  Bases: Protocol Parameter\tType\tDescription bottom_length\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled bottom_width\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled height\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled rotate_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 theta_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 theta_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 top_length\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled top_width\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z_max\tUnion[float, int, FloatParameter, FloatParameterExpression] z_min\tUnion[float, int, FloatParameter, FloatParameterExpression]\t  Returns:\tNo return.  class maxoptics_sdk.core.structure.post_process_terrace_property_typing.PostProcessTerracePropertyMaterial(*args, **kwargs)  Bases: Protocol Parameter\tType geometry\tPostProcessTerracePropertyGeometry material\tPostProcessTerracePropertyMaterial  Returns:\tNo return. "},{"title":"maxoptics_sdk.core.structure.mesh_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_sub_mesh_typing","content":"","keywords":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.mesh_typing module","url":"/my-website/docs/test/core/structure/post_process_sub_mesh_typing#parameters-and-returns","content":"Parameter\tUnit dx\tum dy\tum dz\tum  Returns:\tNo return. "},{"title":"Example​","type":1,"pageTitle":"maxoptics_sdk.core.structure.mesh_typing module","url":"/my-website/docs/test/core/structure/post_process_sub_mesh_typing#example","content":"class maxoptics_sdk.core.structure.mesh_typing.StructureMeshPropertyDict(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.mesh_typing module","url":"/my-website/docs/test/core/structure/post_process_sub_mesh_typing#parameters-and-returns-1","content":"Parameter\tType general\t_MeshGeneral geometry\tGeometryDict  Returns:\tNo return. class maxoptics_sdk.core.structure.mesh_typing._MeshGeneralActive(*args, **kwargs)  Bases: Dict "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.mesh_typing module","url":"/my-website/docs/test/core/structure/post_process_sub_mesh_typing#parameters-and-returns-2","content":"Parameter\tType\tConstraint x\tUnion[float, int]\tMUST be filled x_span\tUnion[float, int]\tMUST be filled, check: &gt;=0 y\tUnion[float, int]\tMUST be filled y_span\tUnion[float, int]\tMUST be filled, check: &gt;=0 z\tUnion[float, int]\tMUST be filled z_span\tUnion[float, int]\tMUST be filled, check: &gt;=0 dz\tUnion[float, int]\t  Returns:\tNo return.  class maxoptics_sdk.core.structure.mesh_typing.StructureMeshPropertyDictActive(*args, **kwargs)  Bases: Dict "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.mesh_typing module","url":"/my-website/docs/test/core/structure/post_process_sub_mesh_typing#parameters-and-returns-3","content":"Parameter\tType geometry\t_MeshGeneralActive  Returns:\tNo return. "},{"title":"maxoptics_sdk.core.structure.post_process_triangle_property_typing module","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/post_process_triangle_property_typing","content":"","keywords":""},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_triangle_property_typing module","url":"/my-website/docs/test/core/structure/post_process_triangle_property_typing#parameters-and-returns","content":"Parameter\tType\tDescription material\tMaterial\tMUST be filled mesh_order\tint\tcheck: &gt;=0  Returns:\tNo return.  class maxoptics_sdk.core.structure.post_process_triangle_property_typing.PostProcessRectanglePropertyGeometry(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_triangle_property_typing module","url":"/my-website/docs/test/core/structure/post_process_triangle_property_typing#parameters-and-returns-1","content":"Parameter\tType\tDescription point_1_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_1_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_2_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_2_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_3_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled point_3_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled rotate_x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 rotate_z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tdefault: 0 x\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled y\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled z_max\tUnion[float, int, FloatParameter, FloatParameterExpression] z_min\tUnion[float, int, FloatParameter, FloatParameterExpression] z_span\tUnion[float, int, FloatParameter, FloatParameterExpression]\tMUST be filled, check: &gt;0  Returns:\tNo return.  class maxoptics_sdk.core.structure.post_process_triangle_property_typing.PostProcessRectangleProperty(*args, **kwargs)  Bases: Protocol "},{"title":"Parameters and Returns​","type":1,"pageTitle":"maxoptics_sdk.core.structure.post_process_triangle_property_typing module","url":"/my-website/docs/test/core/structure/post_process_triangle_property_typing#parameters-and-returns-2","content":"Property\tType geometry\tPostProcessTrianglePropertyGeometry material\tPostProcessTrianglePropertyMaterial  Returns:\tNo return. "},{"title":"run_index_typing","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/structure/run_index_typing","content":"","keywords":""},{"title":"RunIndex​","type":1,"pageTitle":"run_index_typing","url":"/my-website/docs/test/core/structure/run_index_typing#runindex","content":"class maxoptics_sdk.core.structure.run_index_typing.RunIndex(*args, **kwargs)  Bases: dict geometry: RunIndexGeometry "},{"title":"RunIndexGeometry​","type":1,"pageTitle":"run_index_typing","url":"/my-website/docs/test/core/structure/run_index_typing#runindexgeometry","content":"class maxoptics_sdk.core.structure.run_index_typing.RunIndexGeometry(*args, **kwargs)  Bases: dict Parameter\tType monitor_type\tLiteral['2d_x_normal', '2d_y_normal', '2d_z_normal'] x\tfloat | int x_span\tfloat | int y\tfloat | int y_span\tfloat | int z\tfloat | int z_span\tfloat | int "},{"title":"type_alias","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/type_alias","content":"type_alias","keywords":""},{"title":"interface","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/waveform/interface","content":"","keywords":""},{"title":"WaveformInterface​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/waveform/interface#waveforminterface","content":"class maxoptics_sdk.core.waveform.interface.WaveformInterface(*args, **kwargs)  Bases: Protocol "},{"title":"syntax​","type":1,"pageTitle":"interface","url":"/my-website/docs/test/core/waveform/interface#syntax","content":"add(*, name: str, wavelength_center: float, wavelength_span: float, unit: Literal['um', 'nm'] = 'um') add(*, name: str, wavelength_min: float, wavelength_max: float, unit: Literal['um', 'nm'] = 'um') add(*, name: str, frequency_center: float, frequency_span: float) add(*, name: str, frequency_min: float, frequency_max: float) Add a project waveform. Parameter\tDescription name\tWaveform name kwargs\tWaveform data  wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1)  "},{"title":"typed_dicts","type":0,"sectionRef":"#","url":"/my-website/docs/test/core/typed_dicts","content":"","keywords":""},{"title":"maxoptics_sdk.core.typed_dicts.BoundaryDict​","type":1,"pageTitle":"typed_dicts","url":"/my-website/docs/test/core/typed_dicts#maxoptics_sdkcoretyped_dictsboundarydict","content":"class maxoptics_sdk.core.typed_dicts.BoundaryDict(*args, **kwargs)  Bases: dict Parameter\tType\tDescription pml_kappa\tint\tThe kappa value for PML (Perfectly Matched Layer) pml_layer\tint\tThe number of layers in PML pml_polynomial\tint\tThe polynomial degree of PML pml_sigma\tint\tThe sigma value for PML x_max\tLiteral['metal', 'PEC', 'PML']\tThe maximum value for x boundary condition x_min\tLiteral['metal', 'PEC', 'PML']\tThe minimum value for x boundary condition y_max\tLiteral['metal', 'PEC', 'PML']\tThe maximum value for y boundary condition y_min\tLiteral['metal', 'PEC', 'PML']\tThe minimum value for y boundary condition z_max\tLiteral['metal', 'PEC', 'PML']\tThe maximum value for z boundary condition z_min\tLiteral['metal', 'PEC', 'PML']\tThe minimum value for z boundary condition "},{"title":"maxoptics_sdk.core.typed_dicts.FDEDict​","type":1,"pageTitle":"typed_dicts","url":"/my-website/docs/test/core/typed_dicts#maxoptics_sdkcoretyped_dictsfdedict","content":"class maxoptics_sdk.core.typed_dicts.FDEDict(*args, **kwargs)  Bases: dict Parameter\tType\tDescription calculate_group_index\tbool\tFlag indicating whether to calculate the group index detailed_dispersion_calculation\tbool\tFlag indicating whether to perform detailed dispersion calculation number_of_trial_modes\tint\tNumber of trial modes for dispersion calculation use_max_index\tbool\tFlag indicating whether to use the maximum index for dispersion calculation "},{"title":"maxoptics_sdk.core.typed_dicts.GeometryDict​","type":1,"pageTitle":"typed_dicts","url":"/my-website/docs/test/core/typed_dicts#maxoptics_sdkcoretyped_dictsgeometrydict","content":"class maxoptics_sdk.core.typed_dicts.GeometryDict(*args, **kwargs)  Bases: dict Parameter\tType\tDescription rotate_x\tfloat\tRotation angle around the x-axis rotate_y\tfloat\tRotation angle around the y-axis rotate_z\tfloat\tRotation angle around the z-axis x\tfloat\tThe value of x x_max\tfloat\tThe maximum value for x x_min\tfloat\tThe minimum value for x x_span\tfloat\tThe span of x y\tfloat\tThe value of y y_max\tfloat\tThe maximum value for y y_min\tfloat\tThe minimum value for y y_span\tfloat\tThe span of y z\tfloat\tThe value of z z_max\tfloat\tThe maximum value for z z_min\tfloat\tThe minimum value for z z_span\tfloat\tThe span of z "},{"title":"maxoptics_sdk.core.typed_dicts.MaterialDict​","type":1,"pageTitle":"typed_dicts","url":"/my-website/docs/test/core/typed_dicts#maxoptics_sdkcoretyped_dictsmaterialdict","content":"class maxoptics_sdk.core.typed_dicts.MaterialDict(*args, **kwargs)  Bases: dict Parameter\tType\tDescription material\tMaterial\tThe material used mesh_order\tint\tThe mesh order override_mesh_order\tbool\tFlag indicating whether to override the mesh order "},{"title":"Material","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/1Material","content":"","keywords":""},{"title":"1.1 Add anisotropy material​","type":1,"pageTitle":"Material","url":"/my-website/docs/test/v2_core/1Material#11-add-anisotropy-material","content":"Add anisotropy material to a project. add_anisotropy( self, *, name: str, data: List[ Tuple[ float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float], ], color: Optional[str] = None, alpha: Optional[float] = None, fitting: Literal[None, &quot;linear&quot;], order: int = 2, )  Parameters\tDescription name\tThe name of material in the project. data\tMaterial data. Format is [(wavelength, xx index real, xx index imag, yy index real, yy index imag, zz index real, zz index imag), …] or [(wavelength, xx index real, xx index imag, xy index real, xy index imag, …), …]. color\tThe color of materials in the visual model. If it is not set, the color will be automatically calculated based on the refractive index. fitting\tThe fitting mode of material data. order\tThe coverage order of materials when modeling a geometric structure. Example: mt = pj.Material() mt.add_anisotropy(name=&quot;LN&quot;, fitting=None, data=[(wavelength * 1e-6, 2.211, 0, 2.138, 0, 2.211, 0)], order=2 )  "},{"title":"1.2 Add dispersion material​","type":1,"pageTitle":"Material","url":"/my-website/docs/test/v2_core/1Material#12-add-dispersion-material","content":"Add dispersion material to a project. add_dispersion( self, *, name: str, data: List[ Tuple[float, float, float], ], color: Optional[str] = None, alpha: Optional[float] = None, fitting: Literal[None, &quot;linear&quot;], order: int = 2 )  Parameters\tDescription name\tThe name of material in the project. data\tMaterial data. Format is [(wavelength, index real, index imag), …]. color\tThe color of materials in the visual model. If it is not set, the color will be automatically calculated based on the refractive index. fitting\tThe fitting mode of material data. order\tThe coverage order of materials when modeling a geometric structure. Example: mt = pj.Material() mt.add_dispersion(name=&quot;SiO2&quot;, data=[(1.55e-06, 1.444, 0), (1.30e-06, 1.81, 0.227)], order=2 )  "},{"title":"1.3 Add material in Max-Optics material library​","type":1,"pageTitle":"Material","url":"/my-website/docs/test/v2_core/1Material#13-add-material-in-max-optics-material-library","content":"Add material in the Max-Optics material library to a project. add_lib( self, *, name: str, data: Any, override: Optional[dict]=None, color: Optional[str] = None, alpha: Optional[float] = None, order: int = 2 )  Parameters\tDescription name\tThe name of material in the project. data\tAn existing material in the library. override\tOverride. color\tThe color of materials in the visual model. If not set, the color will be automatically calculated based on the index parameters. order\tThe coverage order of materials when modeling a geometric structure. Example: mt = pj.Material() mt.add_lib(name=&quot;Air&quot;, data=mo.Material.Air, order=2)  "},{"title":"1.4 Add nondispersion material​","type":1,"pageTitle":"Material","url":"/my-website/docs/test/v2_core/1Material#14-add-nondispersion-material","content":"Add non-dispersion material to a project. add_nondispersion( self, *, name: str, data: List[Tuple[float, float]], color: Optional[str] = None, alpha: Optional[float] = None, order: int = 2 )  Parameters\tDescription name\tThe name of material in the project. data\tMaterial data. Format is [(index real, index imag)]. color\tThe color of materials in the visual model. If not set, the color will be automatically calculated based on the refractive index. order\tThe coverage order of materials when modeling a geometric structure. Example: mt = pj.Material() mt.add_nondispersion(name=&quot;SiO2&quot;, data=[(1.444, 0)], order=1)  "},{"title":"Boundary/Mesh","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/3Boundary","content":"","keywords":""},{"title":"3.1 Boundary​","type":1,"pageTitle":"Boundary/Mesh","url":"/my-website/docs/test/v2_core/3Boundary#31-boundary","content":"The following content comprises code explanations and specific examples of boundary conditions in optical simulation. OBoundary( self, *, pml_same_settings: bool = True, property: Union['OBoundarySameSettingsPostProcess', 'OBoundaryNotSameSettingsPostProcess'], )  Parameters\tDescriptionproperty\tThe default property of the optical boundary. pml_same_settings\tTo decide whether using the same pml settings on every directions or not. As demonstrated in the following examples, we also provide support for customizing boundary conditions in different directions. Example: st.OBoundary(property={&quot;geometry&quot;: {&quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_beam/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 6, &quot;z&quot;: 0.11, &quot;z_span&quot;: monitor_h}, &quot;boundary&quot;: {&quot;x_min&quot;: &quot;PML&quot;, &quot;x_max&quot;: &quot;PML&quot;, &quot;y_min&quot;: &quot;PML&quot;, &quot;y_max&quot;: &quot;PML&quot;, &quot;z_min&quot;: &quot;PML&quot;, &quot;z_max&quot;: &quot;PML&quot;}, &quot;general_pml&quot;: {&quot;pml_same_settings&quot;: True, &quot;pml_kappa&quot;: 2, &quot;pml_sigma&quot;: 0.8, &quot;pml_layer&quot;: 8, &quot;pml_polynomial&quot;: 3}})  Parameters\tDefault\tType\tNotesgeneral_pml.pml_same_settings\ttrue\tbool\tTo decide whether using the same pml settings on every directions or not. general_pml.pml_profile\tstandard\tstring\tTo provide the options of PML profile. general_pml.pml_layer\t-\tinteger\tSet the number of layers after discretizing the PML region. general_pml.pml_kappa\t-\tfloat\tSet the kappa parameter related to the absorption characteristics of the PML region. general_pml.pml_sigma\t-\tfloat\tSet the sigma parameter related to the absorption characteristics of the PML region. general_pml.pml_polynomial\t-\tinteger\tSet the order of the kappa and the sigma parameters. general_pml.pml_alpha\t-\tfloat\tSet the alpha parameter related to the absorption characteristics of the PML region. general_pml.pml_alpha_polynomial\t-\tinteger\tSet the order of the alpha parameter. general_pml.pml_min_layers\t-\tinteger\tSet the minimum number of layers within a reasonable range for the PML layers. general_pml.pml_max_layers\t-\tinteger\tSet themaximum number of layers within a reasonable range for the PML layers. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the boundary. geometry.x_span\t-\tfloat\tThe length in x direction of the boundary. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the boundary. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the boundary. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the boundary. geometry.y_span\t-\tfloat\tThe width in y direction of the boundary. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the boundary. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the boundary. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the boundary. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the boundary. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the boundary. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the boundary. boundary.x_max\t-\tstring\tSet the boundary type in the x+ direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.x_min\t-\tstring\tSet the boundary type in the x- direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.y_max\t-\tstring\tSet the boundary type in the y+ direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.y_min\t-\tstring\tSet the boundary type in the y- direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. boundary.z_max\t-\tstring\tSet the boundary type in the z+ direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'periodic']. boundary.z_min\t-\tstring\tSet the boundary type in the z- direction. Selections are ['PML', 'PEC', 'metal', 'PMC', 'symmetric', 'anti_symmetric', 'periodic']. If you need to customize the boundary conditions for simulation requirements, you can also refer to the table below for modifying boundary conditions in different directions.Taking the x coordinate axis as an example, the parameters invocation is the same for the y/z coordinates. Parameters\tDefault\tType\tNotesgeneral_pml.pml_same_settings\ttrue\tbool\tTo decide whether using the same pml settings on every directions or not. general_pml.x_min_bc.pml_profile\tstandard\tstring\tTo provide the options of PML profile in x- direction. general_pml.x_min_bc.pml_layer\t-\tinteger\tSet the number of layers after discretizing the PML region in x- direction. general_pml.x_min_bc.pml_kappa\t-\tfloat\tSet the kappa parameter related to the absorption characteristics of the PML region in x- direction. general_pml.x_min_bc.pml_sigma\t-\tfloat\tSet the sigma parameter related to the absorption characteristics of the PML region in x- direction. general_pml.x_min_bc.pml_polynomial\t-\tinteger\tSet the order of the kappa and the sigma parameters in x- direction. general_pml.x_min_bc.pml_alpha\t-\tfloat\tSet the alpha parameter related to the absorption characteristics of the PML region in x- direction. general_pml.x_min_bc.pml_alpha_polynomial\t-\tinteger\tSet the order of the alpha parameter in x- direction. general_pml.x_min_bc.pml_min_layers\t-\tinteger\tSet the minimum number of layers within a reasonable range for the PML layers in x- direction. general_pml.x_min_bc.pml_max_layers\t-\tinteger\tSet the maximum number of layers within a reasonable range for the PML layers in x- direction. general_pml.x_max_bc.pml_profile\tstandard\tstring\tTo provide the options of PML profile in x+ direction. general_pml.x_max_bc.pml_layer\t-\tinteger\tSet the number of layers after discretizing the PML region in x+ direction. general_pml.x_max_bc.pml_kappa\t-\tfloat\tSet the kappa parameter related to the absorption characteristics of the PML region in x+ direction. general_pml.x_max_bc.pml_sigma\t-\tfloat\tSet the sigma parameter related to the absorption characteristics of the PML region in x+ direction. general_pml.x_max_bc.pml_polynomial\t-\tinteger\tSet the order of the kappa and the sigma parameters in x+ direction. general_pml.x_max_bc.pml_alpha\t-\tfloat\tSet the alpha parameter related to the absorption characteristics of the PML region in x+ direction. general_pml.x_max_bc.pml_alpha_polynomial\t-\tinteger\tSet the order of the alpha parameter in x+ direction. general_pml.x_max_bc.pml_min_layers\t-\tinteger\tSet the minimum number of layers within a reasonable range for the PML layers in x+ direction. general_pml.x_max_bc.pml_max_layers\t-\tinteger\tSet the maximum number of layers within a reasonable range for the PML layers in x+ direction. "},{"title":"3.2 Mesh​","type":1,"pageTitle":"Boundary/Mesh","url":"/my-website/docs/test/v2_core/3Boundary#32-mesh","content":"In this section, we will discuss how to add meshing to the simulation. This step is crucial to ensure the precision and dependability of the simulation outcomes. "},{"title":"3.2.1 Add mesh​","type":1,"pageTitle":"Boundary/Mesh","url":"/my-website/docs/test/v2_core/3Boundary#321-add-mesh","content":"Add sub mesh to the simulation project with the code below (for optical simulation). add_mesh( self, *, name: str, property: PostProcessSubMesh, )  Parameters\tDescriptionname\tThe name of optical mesh in the simulation project. property\tThe property of optical mesh in the simulation project. Example: st.add_mesh(name='sub_mesh', property={'general': {'dx': 0.002, 'dy': 0.002, 'dz': 0.002}, 'geometry': {'x': 0, 'x_span': 6, 'y': 0, 'y_span': 2, 'z': 0, 'z_span': 0.2}})  Parameters\tDefault\tType\tNotesgeneral.override_x_mesh\t-\tbool\tTo set whether to override the mesh in the x direction. general.override_y_mesh\t-\tbool\tTo set whether to override the mesh in the y direction. general.override_z_mesh\t-\tbool\tTo set whether to override the mesh in the z direction. general.dx\t-\tfloat\tThe maximum mesh step in the x direction. Restrained by condition: &gt;0. general.dy\t-\tfloat\tThe maximum mesh step in the y direction. Restrained by condition: &gt;0. general.dz\t-\tfloat\tThe maximum mesh step in the z direction. Restrained by condition: &gt;0. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the mesh. geometry.x_span\t-\tfloat\tThe length in x direction of the mesh. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the mesh. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the mesh. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the mesh. geometry.y_span\t-\tfloat\tThe width in y direction of the mesh. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the mesh. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the mesh. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the mesh. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the mesh. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the mesh. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the mesh. "},{"title":"3.2.2 Add emesh​","type":1,"pageTitle":"Boundary/Mesh","url":"/my-website/docs/test/v2_core/3Boundary#322-add-emesh","content":"In the context of electrical simulation, we present guidelines on how to incorporate meshing to ensure the precision and dependability of the simulation outcomes. The code explanations and a practical example provided below. add_emesh( self, *, name: str, property: Dict[str, Any], )  Parameters\tDescriptionname\tElectric local mesh name. property\tElectric local mesh property. Example: st.add_emesh(name=&quot;EMesh_Local&quot;, property={ &quot;y_min&quot;: oe_y_min, &quot;y_max&quot;: oe_y_max, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;mesh_size&quot;: egrid_local})  Parameters\tDefault\tType\tNotesgeometry.x\t-\tfloat\tThe x-coordinate of the center point position of the electrical mesh. geometry.x_span\t-\tfloat\tThe length in x direction of the electrical mesh. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the electrical mesh. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the electrical mesh. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the electrical mesh. geometry.y_span\t-\tfloat\tThe width in y direction of the electrical mesh. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the electrical mesh. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the electrical mesh. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the electrical mesh. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the electrical mesh. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the electrical mesh. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the electrical mesh. mesh_size\t-\tfloat\tThe max size of electrical simulation mesh. "},{"title":"3.2.3 Add emesh along line​","type":1,"pageTitle":"Boundary/Mesh","url":"/my-website/docs/test/v2_core/3Boundary#323-add-emesh-along-line","content":"By implementing an electric mesh along line, you can accurately capture intricate electrical phenomena and variations, enhancing the comprehensiveness of your simulation results. add_emesh_along_line( self, *, name: str, property: Dict[str, Any], )  Parameters\tDescriptionname\tThe name of electric mesh along line. property\tThe property of electric mesh along line. Example: st.add_emesh_along_line(name=&quot;EMesh_Ge_SiO2_Interface_Slope_Left&quot;, property={ &quot;start_x&quot;: oe_x_mean, &quot;start_y&quot;: -Ge_y_span_bottom/2, &quot;start_z&quot;: Si_z_span, &quot;end_x&quot;: oe_x_mean, &quot;end_y&quot;: -Ge_y_span_top/2, &quot;end_z&quot;: Si_z_span+Ge_z_span, &quot;mesh_size&quot;: egrid_interface})  Parameters\tDefault\tType\tNotesstart_x\t0\tfloat start_y\t0\tfloat\tRestrained by condition: &gt;=0. start_z\t0\tfloat end_x\t1\tfloat end_y\t1\tfloat end_z\t1\tfloat\tRestrained by condition: &gt;=0. mesh_size\t0.01\tfloat\t "},{"title":"Source/Port","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/4Source","content":"","keywords":""},{"title":"4.1 Waveform​","type":1,"pageTitle":"Source/Port","url":"/my-website/docs/test/v2_core/4Source#41-waveform","content":"Before adding a light source, firstly we define the relevant parameters of the waveform in this section of the project. wv = pj.Waveform() wv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=0.1) wv_struct = wv[waveform_name]  Parameters\tDescriptionname\tThe waveform name in the simulation. wavelength_center\tDetermine the center wavelength of the waveform. wavelength_span\tDetermine the wavelength span of the waveform. wavelength_min\tDetermine the minimun wavelength of the waveform. wavelength_max\tDetermine the maximum wavelength of the waveform. frequency_center\tDetermine the center frequency of the waveform. frequency_span\tDetermine the frequency span of the waveform. frequency_min\tDetermine the minimun frequency of the waveform. frequency_max\tDetermine the maximum frequency of the waveform. "},{"title":"4.2 Mode source​","type":1,"pageTitle":"Source/Port","url":"/my-website/docs/test/v2_core/4Source#42-mode-source","content":"Incorporate a model source into the project by utilizing the provided code with the attribute type=&quot;mode_source&quot;. add( self, *, type: Literal[&quot;mode_source&quot;], name: str, axis: AxisSelection, property: PostProcessModeSource, )  Parameters\tDescriptionname\tThe name of mode source defined in the project. type\tTo decide the type of source. axis\tDetermining the propagation direction of the mode source. Literal[&quot;x_forward&quot;,&quot;y_forward&quot;,&quot;z_forward&quot;,&quot;x_backward&quot;,&quot;y_backward&quot;,&quot;z_backward&quot;]. property\tThe property of mode source. Example: src.add(name='source', type='mode_source', axis='x_forward', property={'general': { # 'amplitude': 1, 'phase': 0, 'mode_index': 0, 'rotations': {'theta': 0, 'phi': 0, 'rotation_offset': 0} 'mode_selection': 'user_select', 'waveform': {'waveform_id_select': wv_struct} }, 'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}})  Parameters\tDefault\tType\tNotesgeneral.inject_axis\tx_axis\tstring\tTo set the inject axis of mode source. Selections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. general.direction\tforward\tstring\tTo set the propagation direction of mode source. Selections are ['forward', 'backward']. general.amplitude\t1.0\tfloat\tTo set the amplitude of mode source. general.phase\t0.0\tfloat\tTo set the initial phase value for the mode source. general.mode_selection\t-\tstring\tTo decide the mode which propagates in the waveguide. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. general.mode_removal.threshold\t-\tfloat\tScreen the mode source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission mode. general.mode_index\t0\tinteger\tUnder the 'user_select' condition, use this parameter to decide the related number of source mode. general.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. general.n\t1.0\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the source mode. general.number_of_trial_modes\t20\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. general.waveform.waveform_id_select\t-\tany\tCall the previously defined wavelength form MO waveform list. general.rotations.theta\t0\tfloat\tSet the theta rotation angle of the mode source. general.rotations.phi\t0\tfloat\tSet the phi rotation angle of the mode source. general.rotations.rotation_offset\t0\tfloat\tSet the rotation offset of the mode source. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the mode source. geometry.x_span\t-\tfloat\tThe length in x direction of the mode source. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the mode source. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the mode source. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the mode source. geometry.y_span\t-\tfloat\tThe width in y direction of the mode source. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the mode source. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the mode source. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the mode source. geometry.z_span\t-\tfloat\tThe height in z direction of the mode source. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the mode source. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the mode source. "},{"title":"4.3 Gaussian source​","type":1,"pageTitle":"Source/Port","url":"/my-website/docs/test/v2_core/4Source#43-gaussian-source","content":"Integrate a Gaussian source into the project by applying the code type=&quot;Gaussian_source&quot;. add( self, *, type: Literal[&quot;gaussian_source&quot;], name: str, axis: AxisSelection, property: PostProcessGaussianSource, )  Parameters\tDescriptionname\tThe name of Gaussian source defined in the project. type\tTo decide the type of source. axis\tDetermining the propagation direction of the Gaussian source. Literal[&quot;x_forward&quot;,&quot;y_forward&quot;,&quot;z_forward&quot;,&quot;x_backward&quot;,&quot;y_backward&quot;,&quot;z_backward&quot;]. property\tThe property of Gaussian source. Example: so.add(name='source', type='gaussian_source', axis='z_backward', property={'general': {'angle_theta': 12, 'angle_phi': 0, 'polarization_angle': 90, 'waveform': {'waveform_id_select': wv[waveform_name]}, 'beam_settings': {'calculation_method': 'use_scalar_approximation', # [use_scalar_approximation,use_vector_approximation] 'beam_parameters': 'waist_size_and_position', # [waist_size_and_position,beam_size_and_divergence] 'waist_radius': 5.2, 'distance_from_waist': 1.5, 'beam_radius': 5.2, 'divergence_angle': 5.41444}}, 'geometry': {'x': 4, 'x_span': 20, 'y': 0, 'y_span': 20, 'z': 1.5, 'z_span': 0}})  Parameters\tDefault\tType\tNotesgeneral.inject_axis\tx_axis\tstring\tTo set the inject axis of Gaussian source. Selections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. general.direction\tforward\tstring\tTo set the propagation direction of Gaussian source. Selections are ['forward', 'backward']. general.amplitude\t1.0\tfloat\tTo set the amplitude of Gaussian source. general.phase\t0.0\tfloat\tTo set the initial phase value for the Gaussian source. general.waveform.waveform_id_select\t-\tany\tCall the previously defined wavelength form MO waveform list. general.rotations.theta\t0\tfloat\tSet the theta rotation angle of the Gaussian source. general.rotations.phi\t0\tfloat\tSet the phi rotation angle of the Gaussian source. general.rotations.rotation_offset\t0\tfloat\tSet the rotation offset of the Gaussian source. general.polarization_angle\t0\tfloat\tSet the polarization angle of Gaussian source. general.beam_settings.calculation_method\tuse_scalar_approximation\tstring\tChoose a method for calculating Gaussian source. Selections are ['use_scalar_approximation', 'use_vector_approximation']. general.beam_settings.beam_parameters\twaist_size_and_position\tstring\tChoose a method for determining the relevant parameters of Gaussian source. Selections are ['waist_size_and_position', 'beam_size_and_divergence']. general.beam_settings.waist_radius\t-\tfloat\tThe beam waist radius of the Gaussian source. The corresponding position when the field attenuates to 1/e. general.beam_settings.distance_from_waist\t-\tfloat\tThe distance from the center of the Gaussian source to the beam waist radius. general.beam_settings.beam_radius\t-\tfloat\tThe beam radius of the Gaussian source. general.beam_settings.divergence_angle\t-\tfloat\tThe divergence angle of Gaussian beam. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the Gaussian source. geometry.x_span\t-\tfloat\tThe length in x direction of the Gaussian source. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the Gaussian source. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the Gaussian source. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the Gaussian source. geometry.y_span\t-\tfloat\tThe width in y direction of the Gaussian source. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the Gaussian source. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the Gaussian source. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the Gaussian source. geometry.z_span\t-\tfloat\tThe height in z direction of the Gaussian source. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the Gaussian source. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the Gaussian source. "},{"title":"4.3 FDTD port​","type":1,"pageTitle":"Source/Port","url":"/my-website/docs/test/v2_core/4Source#43-fdtd-port","content":"Incorporate a port into the current FDTD simulation project. add( self, *, type: Literal[&quot;fdtd_port&quot;], name: str, property: PostProcessFdtdPort, )  Parameters\tDescriptionname\tThe name of FDTD port source defined in the project. type\tTo decide the type of source. property\tThe property of the FDTD port source. Example: pt = pj.Port(property={'waveform_id': wv_struct, 'source_port': 'port_left'}) pt.add(name='port_left', type='fdtd_port', property={'geometry': {'x': ports['op_0']['position'][0], 'x_span': 0, 'y': ports['op_0']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'forward', 'mode_selection': 'fundamental', }}})  Parameters\tDefault\tType\tNotesgeometry.x\t-\tfloat\tThe x-coordinate of the center point position of the FDTD port source. geometry.x_span\t-\tfloat\tThe length in x direction of the FDTD port source. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the FDTD port source. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the FDTD port source. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the FDTD port source. geometry.y_span\t-\tfloat\tThe width in y direction of the FDTD port source. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the FDTD port source. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the FDTD port source. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the FDTD port source. geometry.z_span\t-\tfloat\tThe height in z direction of the FDTD port source. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the FDTD port source. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the FDTD port source. modal_properties.general.inject_axis\tx_axis\tstring\tTo set the inject axis of FDTD port source. Selections are ['x_axis', 'y_axis', 'z_axis', 'x', 'y', 'z']. modal_properties.general.direction\tforward\tstring\tTo set the propagation direction of FDTD port source. Selections are ['forward', 'backward']. modal_properties.general.amplitude\t1.0\tfloat\tTo set the amplitude of FDTD port source. modal_properties.general.phase\t0.0\tfloat\tTo set the initial phase value for the FDTD port source. modal_properties.general.mode_selection\t-\tstring\tTo decide the FDTD port mode which propagates in the waveguide. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. modal_properties.general.mode_removal.threshold\t-\tfloat\tScreen the FDTD port source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission FDTD port mode. modal_properties.general.mode_index\t0\tinteger\tUnder the 'user_select' condition, use this parameter to decide the FDTD port source mode. modal_properties.general.search\tmax_index\tstring\tCalculate the FDTD port mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. modal_properties.general.n\t1.0\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the FDTD port source mode. modal_properties.general.number_of_trial_modes\t20\tinteger\tWhen calculating FDTD port mode, determine the calculated number of FDTD port mode around the refractive index. modal_properties.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in bent waveguides. modal_properties.bent_waveguide.radius\t1\tfloat\tSet the waveguide radius for bent waveguides. modal_properties.bent_waveguide.orientation\t20\tfloat\tThe bent direction of the waveguide. modal_properties.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. "},{"title":"4.4 EME port​","type":1,"pageTitle":"Source/Port","url":"/my-website/docs/test/v2_core/4Source#44-eme-port","content":"Incorporate a port into the current EME simulation project. add( self, *, type: Literal[&quot;eme_port&quot;], name: str, property: PostProcessEmePort, )  Parameters\tDescriptionname\tThe name of EME port source defined in the project. type\tTo decide the type of the EME port source. property\tThe property of the EME port source. Example: pjp = pj.Port(property={&quot;source_port&quot;: &quot;input_te_tm&quot;}) pjp.add(name=&quot;input_te_tm&quot;, type=&quot;eme_port&quot;, property={&quot;geometry&quot;: {&quot;port_location&quot;: &quot;left&quot;, &quot;use_full_simulation_span&quot;: True, &quot;y&quot;: 1.256, &quot;y_span&quot;: 8, &quot;z&quot;: 0, &quot;z_span&quot;: 6}, &quot;eme_port&quot;: {&quot;general&quot;: {&quot;mode_selection&quot;: &quot;fundamental_TE_and_TM&quot;, &quot;mode_index&quot;: 1}, &quot;advanced&quot;: {&quot;offset&quot;: 0.1, &quot;number_of_trial_modes&quot;: number_of_modes}}})  Parameters\tDefault\tType\tNotesgeometry.port_location\t-\tstring\tSet the location type of EME port. Selections are ['left', 'right']. geometry.use_full_simulation_span\ttrue\tbool\tConfirm whether to use full simulation span. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the EME port source. geometry.y_span\t-\tfloat\tThe width in y direction of the EME port source. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the EME port source. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the EME port source. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the EME port source. geometry.z_span\t-\tfloat\tThe height in z direction of the EME port source. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the EME port source. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the EME port source. eme_port.general.mode_selection\t-\tstring\tTo decide the mode which propagates in the waveguide. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'fundamental_TE_and_TM', 'user_select', 'user_import']. eme_port.general.mode_index\t1\tinteger\tUnder the 'user_select' condition, use this parameter to decide the source mode. eme_port.general.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. Selections are ['near_n', 'max_index']. eme_port.general.n\t1.0\tinteger\tUnder the 'near_n' condition, use this value of refractive index to search the source mode. eme_port.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in bent waveguides. eme_port.bent_waveguide.radius\t1\tfloat\tSet the waveguide radius for curved waveguides. eme_port.bent_waveguide.orientation\t20\tfloat\tBent direction of the waveguide. eme_port.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. eme_port.advanced.offset\t0\tfloat\tSet the offset of EME port position. eme_port.advanced.number_of_trial_modes\t20\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. eme_port.advanced.mode_removal.threshold\t-\tfloat\tScreen the mode source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission mode. "},{"title":"Structure","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/2Structure","content":"","keywords":""},{"title":"2.1 Add geometry​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#21-add-geometry","content":"Add a geometry structure to current project. add_geometry( self, *, name: str, type: str, property: &quot;StructureGeometryPropertyDict&quot; )  Parameters\tDescriptionname\tThe name of a specific geometric structure. type\tThe type of a specific geometric structure. property\tThe property of a specific geometric structure, including the materials, geometric dimensions, and so on. "},{"title":"2.1.1 GDS file/GDS file3D​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#211-gds-filegds-file3d","content":"The following codes can import the structure in Max-Optics SDK from GDS layout files. Example: st.add_geometry(name=&quot;gds_file&quot;, type=&quot;gds_file&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: { &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}, &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;EXTEND_1&quot;, &quot;layer_name&quot;: (3, 0)}})  Parameters\tDefault\tType\tNotesgeometry.x\t0\tfloat\tThe x-coordinate of the center point position of structures in the imported GDS file. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of structures in the imported GDS file. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of structures in the imported GDS file. geometry.z_span\t-\tfloat\tSetting the height of structures in the imported GDS file. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of structures in the imported GDS file. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of structures in the imported GDS file. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. general.path\t-\tstring\tThe path of the imported GDS file. general.cell_name\t-\tstring\tThe cell name of imported GDS file. general.layer_name\t-\tlist\tThe layer name of imported GDS file. Meanwhile, we also offer support for basic operations to GDS layout modeling using type=&quot;gds_file3D&quot;. The code for this function is provided below: st.add_geometry(name=&quot;gds_file_3D&quot;, type=&quot;gds_file3D&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;general&quot;: {&quot;path&quot;: gds_file, &quot;cell_name&quot;: &quot;EXTEND_1&quot;, &quot;layer_name&quot;: (3, 0)}, &quot;geometry&quot;: {&quot;tilt_angle&quot;: 60,&quot;tilt_location&quot;: &quot;bottom&quot;, &quot;x&quot;: 4*space, &quot;y&quot;: 2*space, &quot;z&quot;: 0.05, &quot;z_span&quot;: 0.1, &quot;mirror_normal_z&quot;: 0,&quot;mirror_plane_z0&quot;: 0,&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.tilt_angle\t90\tfloat\tTilt angle of waveguide sidewall. geometry.tilt_location\ttop\tstring\tTo ensure that the models within the GDS layout are placed at the specified sizes on the different ratio of sidewalls when importing GDS layout. Selections are ['top', 'TOP', 'Top', 'bottom', 'BOTTOM', 'Bottom', 'middle', 'MIDDLE', 'Middle', 'user_defined']. geometry.user_defined\t1\tfloat\tTo decide the ratio of sidewalls when importing GDS layout. geometry.mirror_normal_z\t0\tfloat\tThe posiotion of z-normal plane for mirror symmetry. geometry.mirror_plane_z0\t0\tfloat\tThe center point position of z normal palne. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. general.construct_method\t-\tstring\tThe method around constructing the GDS after choosing to import the GDS file. Selections are ['method1', 'method2'] "},{"title":"2.1.2 Arc waveguide/Arc waveguide 3D​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#212-arc-waveguidearc-waveguide-3d","content":"To establish an arc waveguide within the project, utilize the code type=&quot;ArcWaveguide&quot;. Example: st.add_geometry(name=&quot;arc&quot;, type=&quot;ArcWaveguide&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;inner_radius&quot;: size-wg_width/2, &quot;outer_radius&quot;: size+wg_width/2, &quot;angle&quot;: 90, &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.inner_radius\t-\tfloat\tThe inner radius of arc waveguide. Restrained by condition: &gt;0. geometry.outer_radius\t-\tfloat\tThe outer radius of arc waveguide. Restrained by condition: &gt;0. geometry.angle\t-\tfloat\tThe angle corresponding to the arc length of an arc waveguide. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of arc waveguide. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of arc waveguide. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of arc waveguide. geometry.z_span\t-\tfloat\tSetting the height of arc waveguide. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of arc waveguide. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of arc waveguide. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. Similarly, we offer support for using code type=&quot;ArcWaveguide3D&quot; to adjust the arc waveguide structure in the height direction. st.add_geometry(name=&quot;arc_3d&quot;, type=&quot;ArcWaveguide3D&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: size, &quot;angle&quot;: 180, &quot;base_height&quot;: wg_height, &quot;top_width&quot;: wg_width_top, &quot;bottom_width&quot;: wg_width, &quot;x&quot;: space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.radius\t-\tfloat\tThe radius of the central width of the arc. Restrained by condition: &gt;0. geometry.angle\t-\tfloat\tThe angle corresponding to the arc length of an arc waveguide. Restrained by condition: &gt;0,&lt;=360. geometry.base_height\t-\tfloat\tThe height of the arc waveguide. Restrained by condition: &gt;0. geometry.top_width\t-\tfloat\tThe top width of the arc waveguide. Restrained by condition: &gt;0. geometry.bottom_width\t-\tfloat\tThe bottom width of the arc waveguide. Restrained by condition: &gt;0. "},{"title":"2.1.3 Bezier curve/ Bezier curve 3D​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#213-bezier-curve-bezier-curve-3d","content":"Within the project, we can incorporate a Bezier curve structure by employing the code type=&quot;BezierCurve&quot;. Example: st.add_geometry(name=&quot;bezier&quot;, type=&quot;BezierCurve&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 2*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;width&quot;: wg_width, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size/2, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size/2, &quot;point_4_x&quot;: size, &quot;point_4_y&quot;: size}})  Parameters\tDefault\tType\tNotesgeometry.point_1_x\t-\tfloat\tThe x-coordinate of the first point for generating a Bezier curve. geometry.point_1_y\t-\tfloat\tThe y-coordinate of the first point for generating a Bezier curve. geometry.point_2_x\t-\tfloat\tThe x-coordinate of the second point for generating a Bezier curve. geometry.point_2_y\t-\tfloat\tThe y-coordinate of the second point for generating a Bezier curve. geometry.point_3_x\t-\tfloat\tThe x-coordinate of the third point for generating a Béezier curve. geometry.point_3_y\t-\tfloat\tThe y-coordinate of the third point for generating a Béezier curve. geometry.point_4_x\t-\tfloat\tThe x-coordinate of the forth point for generating a Bezier curve. geometry.point_4_y\t-\tfloat\tThe y-coordinate of the forth point for generating a Bezier curve. geometry.width\t-\tfloat\tThe width of the Bezier curve. geometry.x\t-\tfloat\tThe center point x-coordinate the Bezier curve. geometry.y\t-\tfloat\tThe center point y-coordinate the Bezier curve. geometry.z\t-\tfloat\tThe center point z-coordinate the Bezier curve. geometry.z_span\t-\tfloat\tThe thinckness of the Bezier curve. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe bottom position of the height of the Bezier curve in the z-coordinate. geometry.z_max\t-\tfloat\tThe top position of the height of the Bezier curve in the z-coordinate. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. Similarly, we offer support for using code type=&quot;BezierCurve3D&quot; to adjust the Bézier curve structure in the height direction. st.add_geometry(name=&quot;bezier_3d&quot;, type=&quot;BezierCurve3D&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 3*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;base_height&quot;: wg_height, &quot;top_width&quot;: wg_width_top, &quot;bottom_width&quot;: wg_width, &quot;control_points&quot;: [{&quot;x&quot;: 0, &quot;y&quot;: 0}, {&quot;x&quot;: 0, &quot;y&quot;: size/2}, {&quot;x&quot;: size, &quot;y&quot;: size/2}, {&quot;x&quot;: size, &quot;y&quot;: size}]}})  Parameters\tDefault\tType\tNotesgeometry.base_height\t-\tfloat\tThe height of the Bezier curve. Restrained by condition: &gt;0. geometry.top_width\t-\tfloat\tThe top width of the Bezier curve. Restrained by condition: &gt;0. geometry.bottom_width\t-\tfloat\tThe bottom width of the Bezier curve. Restrained by condition: &gt;0. geometry.[]control_points.x\t-\tfloat\tThe x-coordinate of the points for generating a Bezier curve. geometry.[]control_points.y\t-\tfloat\tThe y-coordinate of the points for generating a Bezier curve. "},{"title":"2.1.4 Circle​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#214-circle","content":"Integrate a circular structure into the simulation project by employing the code type=&quot;Circle&quot;. Example: st.add_geometry(name=&quot;circle&quot;, type=&quot;Circle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;radius&quot;: size, &quot;x&quot;: 4*space, &quot;y&quot;: 0, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}})  Parameters\tDefault\tType\tNotesgeometry.radius\t-\tfloat\tThe radius of the circle. Restrained by condition: &gt;0. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of circle. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of circle. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of circle. geometry.z_span\t-\tfloat\tThe thinckness of the circle. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe bottom position of the height of the circle in z-coordinate. geometry.z_max\t-\tfloat\tThe top position of the height of the circle in z-coordinate. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. "},{"title":"2.1.5 Custom polygon​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#215-custom-polygon","content":"By utilizing the code type=&quot;CustomPolygon&quot;, it becomes possible to incorporate a custiomized polygon into the project. Example: st.add_geometry(name=&quot;custom_polygon&quot;, type=&quot;CustomPolygon&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;size&quot;: size, &quot;sides&quot;: 6, &quot;x&quot;: 4*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.size\t-\tfloat\tThe side length of the polygon. Restrained by condition: &gt;0. geometry.sides\t-\tinteger\tTo set the number of custom polygon sides. Restrained by condition: &gt;=3. geometry.x\t-\tfloat\tThe center point x-coordinate the custom polygon. geometry.y\t-\tfloat\tThe center point y-coordinate the custom polygon. geometry.z\t-\tfloat\tThe center point z-coordinate the custom polygon. geometry.z_span\t-\tfloat\tThe thinckness of the custom polygon. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the custom polygon. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the custom polygon. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial around the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. "},{"title":"2.1.6 Ellipse​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#216-ellipse","content":"Incorporate an ellipse into the project by implementing the code type=&quot;Ellipse&quot;. Example: st.add_geometry(name=&quot;ellipse&quot;, type=&quot;Ellipse&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x_radius&quot;: size, &quot;y_radius&quot;: 1.5*size, &quot;x&quot;: 3*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.x_radius\t-\tfloat\tThe length in the x direction of the ellipse. Restrained by condition: &gt;0. geometry.y_radius\t-\tfloat\tThe width in the y direction of the ellipse.Restrained by condition: &gt;0. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the ellipse. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the ellipse. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the ellipse. geometry.z_span\t-\tfloat\tThe thinckness of the ellipse. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the ellipse. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the ellipse. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. "},{"title":"2.1.7 Linear trapezoid​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#217-linear-trapezoid","content":"Integrate a linear trapezoid shape into the project using the code type=&quot;LinearTrapezoid&quot;. Example: st.add_geometry(name=&quot;linear_trapezoid&quot;, type=&quot;LinearTrapezoid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size/2, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size, &quot;point_4_x&quot;: size, &quot;point_4_y&quot;: 0, &quot;x&quot;: 2*space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.point_1_x\t-\tfloat\tThe x-coordinate of one point when constructing a linear trapezoid structure. geometry.point_1_y\t-\tfloat\tThe y-coordinate of one point when constructing a linear trapezoid structure. geometry.point_2_x\t-\tfloat\tThe x-coordinate of one point when constructing a linear trapezoid structure. geometry.point_2_y\t-\tfloat\tThe y-coordinate of one point when constructing a linear trapezoid structure. geometry.point_3_x\t-\tfloat\tThe x-coordinate of one point when constructing a linear trapezoid structure. geometry.point_3_y\t-\tfloat\tThe y-coordinate of one point when constructing a linear trapezoid structure. geometry.point_4_x\t-\tfloat\tThe x-coordinate of one point when constructing a linear trapezoid structure. geometry.point_4_y\t-\tfloat\tThe y-coordinate of one point when constructing a linear trapezoid structure. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the linear trapezoid. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the linear trapezoid. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the linear trapezoid. geometry.z_span\t-\tfloat\tThe thinckness of the linear trapezoid. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the linear trapezoid. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the linear trapezoid. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. "},{"title":"2.1.8 Pyramid​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#218-pyramid","content":"Incorporate a pyramid structure into the project by employing the code type=&quot;Pyramid&quot;. Example: st.add_geometry(name=&quot;pyramid&quot;, type=&quot;Pyramid&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;x&quot;: space, &quot;y&quot;: space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;theta_x&quot;: 0, &quot;theta_y&quot;: 0, &quot;x_span_bottom&quot;: 2*size, &quot;x_span_top&quot;: size, &quot;y_span_bottom&quot;: 2*size, &quot;y_span_top&quot;: size}})  Parameters\tDefault\tType\tNotesgeometry.x_span_bottom\t-\tfloat\tThe length in the x-direction at the bottom of the pyramid. Restrained by condition: &gt;=0. geometry.y_span_bottom\t-\tfloat\tThe width in the y-direction at the bottom of the pyramid. Restrained by condition: &gt;=0. geometry.x_span_top\t-\tfloat\tThe length in the x-direction at the top of the pyramid. Restrained by condition: &gt;=0. geometry.y_span_top\t-\tfloat\tThe width in the y-direction at the top of the pyramid. Restrained by condition: &gt;=0. geometry.theta_x\t0\tfloat\tThe tilt angle of the top pyramid structure along the x+ axis. geometry.theta_y\t0\tfloat\tThe tilt angle of the top pyramid structure along the y+ axis. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the pyramid. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the pyramid. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the pyramid. geometry.z_span\t-\tfloat\tThe thinckness of the pyramid. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the pyramid. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the pyramid. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. "},{"title":"2.1.9 Analytical waveguide​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#219-analytical-waveguide","content":"Integrate an analytical waveguide structure into the project by implementing the code type='AnalyticalWaveguide'. Example: st.add_geometry(name='taper_symmetric_test', type='AnalyticalWaveguide', property={'geometry': {'x': 0, 'x_span': L, 'y': 0, 'y_span': taper_width, 'z': 0, 'z_span': 0.22, 'equation1': f'{str(A)}*({str(L/2)}-x)^{str(m)}+1.5', 'nonsymmetric': False, 'tilt_location': 'user_defined', 'tilt_angle': 80, 'user_defined': 0.5, 'resolution': 1000}, 'material': {'material': mt['Si'], 'mesh_order': 2}})  Parameters\tDefault\tType\tNotesgeometry.x_span\t-\tfloat\tThe length of the waveguide in the x-direction. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe x-coordinate value of the endpoint for the waveguide length. geometry.x_max\t-\tfloat\tThe x-coordinate value of the endpoint for the waveguide length. geometry.y_span\t-\tfloat\tThe width of the waveguide in the y-direction. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe y-coordinate value of the endpoint for the waveguide width. geometry.y_max\t-\tfloat\tThe y-coordinate value of the endpoint for the waveguide width. geometry.equation1\t-\tstring\tThe customed function 1 used in modeling the analytical waveguide. geometry.equation2\t-\tstring\tWhen the geometry is asymmetric('nonsymmetric': True), the customed function 2 used in modeling the analytical waveguide. geometry.nonsymmetric\tfalse\tbool\tTo Control whether the waveguide is symmetric. geometry.resolution\t10\tinteger\tThe resolution in modeling the analytical waveguide when working with functions. geometry.tilt_angle\t90\tfloat\tTilt angle of the structure sidewall. geometry.tilt_location\ttop\tstring\tDifferent ways of tilting the sidewalls of the waveguide. Selections are ['top', 'TOP', 'Top', 'bottom', 'BOTTOM', 'Bottom', 'middle', 'MIDDLE', 'Middle', 'user_defined']. geometry.user_defined\t1\tfloat\tTo decide the ratio of sidewalls. geometry.x\t0\tfloat\tThe x-coordinate of the center point position of the analytical waveguide. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of the analytical waveguide. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the analytical waveguide. geometry.z_span\t-\tfloat\tSetting the height of the analytical waveguide. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the analytical waveguide. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the analytical waveguide. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. "},{"title":"2.1.10 Rectangle​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#2110-rectangle","content":"Incorporate a rectangle structure into the project by utilizing the code type=&quot;Rectangle&quot;. Example: st.add_geometry(name=&quot;rectangle&quot;, type=&quot;Rectangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;x&quot;: 0, &quot;x_span&quot;: size, &quot;y&quot;: space, &quot;y_span&quot;: wg_width, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, }})  Parameters\tDefault\tType\tNotesgeometry.x_span float\tThe length of the rectangle in the x-direction. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe x-coordinate value of the endpoint for the rectangle length. geometry.x_max\t-\tfloat\tThe x-coordinate value of the endpoint for the rectangle length. geometry.y_span\t-\tfloat\tThe width of the rectangle in the y-direction. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe y-coordinate value of the endpoint for the rectangle width. geometry.y_max\t-\tfloat\tThe y-coordinate value of the endpoint for the rectangle width. geometry.x\t0\tfloat\tThe x-coordinate of the center point position of the rectangle. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of the rectangle. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the rectangle. geometry.z_span\t-\tfloat\tSetting the height of the rectangle. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the rectangle. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the rectangle. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. "},{"title":"2.1.11 Ring​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#2111-ring","content":"Integrate a ring structure into the project by implementing the code type=&quot;Ring&quot; . Example: st.add_geometry(name=&quot;ring&quot;, type=&quot;Ring&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 2*space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;inner_radius&quot;: size-wg_width/2, &quot;outer_radius&quot;: size+wg_width/2,}})  Parameters\tDefault\tType\tNotesgeometry.inner_radius\t-\tfloat\tThe inner radius of the ring. Restrained by condition: &gt;0. geometry.outer_radius\t-\tfloat\tThe outer radius of the ring. Restrained by condition: &gt;0. geometry.x\t0\tfloat\tThe x-coordinate of the center point position of the ring. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of the ring. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the ring. geometry.z_span\t-\tfloat\tSetting the height of the ring. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the ring. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the ring. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. "},{"title":"2.1.12 Sector​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#2112-sector","content":"Incorporate a sector structure into the project by employing the code type=&quot;Sector&quot;. Example: st.add_geometry(name=&quot;sector&quot;, type=&quot;Sector&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;radius&quot;: size, &quot;angle&quot;: 75, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0, &quot;x&quot;: space, &quot;y&quot;: 2*space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height}})  Parameters\tDefault\tType\tNotesgeometry.radius\t-\tfloat\tThe radius of the sector. Restrained by condition: &gt;0. geometry.angle\t-\tfloat\tThe angle of the sector. geometry.x\t0\tfloat\tThe x-coordinate of the center point position of the sector. geometry.y\t0\tfloat\tThe y-coordinate of the center point position of the sector. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the sector. geometry.z_span\t-\tfloat\tSetting the height of the sector. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the sector. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the sector. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure.Restrained by condition: &gt;=0. "},{"title":"2.1.13 Triangle​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#2113-triangle","content":"Integrate a triangle structure into the project by implementing the code type=&quot;Triangle&quot;. Example: st.add_geometry(name=&quot;triangle&quot;, type=&quot;Triangle&quot;, property={ &quot;material&quot;: {&quot;material&quot;: mt[&quot;Si&quot;], &quot;mesh_order&quot;: 2}, &quot;geometry&quot;: {&quot;point_1_x&quot;: 0, &quot;point_1_y&quot;: 0, &quot;point_2_x&quot;: 0, &quot;point_2_y&quot;: size, &quot;point_3_x&quot;: size, &quot;point_3_y&quot;: size, &quot;x&quot;: 2*space, &quot;y&quot;: 2*space, &quot;z&quot;: 0, &quot;z_span&quot;: wg_height, &quot;rotate_x&quot;: 0, &quot;rotate_y&quot;: 0, &quot;rotate_z&quot;: 0}})  Parameters\tDefault\tType\tNotesgeometry.point_1_x\t-\tfloat\tThe x-coordinate of endpoint when constructing a triangle. geometry.point_1_y\t-\tfloat\tThe y-coordinate of endpoint when constructing a triangle. geometry.point_2_x\t-\tfloat\tThe x-coordinate of endpoint when constructing a triangle. geometry.point_2_y\t-\tfloat\tThe y-coordinate of endpoint when constructing a triangle. geometry.point_3_x\t-\tfloat\tThe x-coordinate of endpoint when constructing a triangle. geometry.point_3_y\t-\tfloat\tThe y-coordinate of endpoint when constructing a triangle. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the triangle. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the triangle. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the triangle. geometry.z_span\t-\tfloat\tThe thinckness of the triangle. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the triangle. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the triangle. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. material.material\t-\tmaterial\tMaterial of the geometric structure. material.mesh_order\t-\tinteger\tThe order of material coverage when creating a geometric structure. Restrained by condition: &gt;=0. "},{"title":"2.2 Add doping​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#22-add-doping","content":"When participating in optoelectronic simulation, you have the option to utilize the provided code for introducing doping into the simulation structure. Our platform offers assistance in importing doping data from files and also allows for the customization of doping regions according to your requirements. add_doping( self, *, name: str, type: &quot;StructureDopingTypeSelection&quot;, property: &quot;StructureDopingPropertyDict&quot; )  Parameters\tDescriptionname\tTo set the name of doping in simulation type\tThe method type of setting up doping. Selections are ['type', 'n', 'p']. property\tThe property of doping. For instance, the code for importing doping from a file is demonstrated as follows. Example: st.add_doping(name=&quot;import_n&quot;, type=&quot;file&quot;, property={ &quot;general&quot;: {&quot;format&quot;: &quot;DOP&quot;, &quot;file_path&quot;: n_dop_file, &quot;species&quot;: &quot;n&quot;}})  You can configure parameters related to importing doping files by adjusting settings under the property.general sections. Parameters\tDefault Type Notesgeneral.format\t-\tstr\tSelections are ['DOP'] general.file_path\t-\tstr\tThe file path of doping. general.species\t-\tstr\tTo set the doing species. Selections are ['n', 'p']. volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region']. volume.material_list\t-\tlist\tAvailable when volume_type is 'material' volume.region_list\t-\tlist\tAvailable when volume_type is 'region' The code for utilizing custom region doping is provided below. Example: st.add_doping(name=&quot;Uniform&quot;, type=&quot;p&quot;, property={ &quot;geometry&quot;: {&quot;x&quot;: p_uniform_x_center, &quot;x_span&quot;: p_uniform_x_span, &quot;y&quot;: p_uniform_y_center, &quot;y_span&quot;: p_uniform_y_span, &quot;z&quot;: p_uniform_z_center, &quot;z_span&quot;: p_uniform_z_span}, &quot;general&quot;: {&quot;distribution_function&quot;: &quot;constant&quot;, &quot;concentration&quot;: p_uniform_con}, &quot;volume&quot;: {&quot;volume_type&quot;: &quot;material&quot;, &quot;material_list&quot;: [mt[&quot;mat_si&quot;]]}})  Parameters\tDefault\tType\tNotesgeometry.x\t-\tfloat\tThe x-coordinate of the center point position of the doping. geometry.x_span\t-\tfloat\tThe length in x direction of the doping. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the doping. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the doping. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the doping. geometry.y_span\t-\tfloat\tThe width in y direction of the doping. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the doping. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the doping. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the doping. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the doping. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the doping. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the doping. geometry.rotate_x\t0\tfloat\tThe angle around the x-axis in the rotation operation. geometry.rotate_y\t0\tfloat\tThe angle around the y-axis in the rotation operation. geometry.rotate_z\t0\tfloat\tThe angle around the z-axis in the rotation operation. general.distribution_function\t-\tstr\tTo set the type of distribution function for doping region. Selections are ['constant', 'gaussian'] general.concentration\t-\tfloat general.source_face\t-\tstr\tTo set the doping source surface. Available when distribution_function is 'gaussian' general.junction_width\t-\tfloat\tTo set the junction width. Available when distribution_function is 'gaussian' general.ref_concentration\t-\tfloat\tAvailable when distribution_function is 'gaussian' volume.volume_type\t'all'\tstr\tSelections are ['all', 'material', 'region'] volume.material_list\t-\tlist\tAvailable when volume_type is 'material' volume.region_list\t-\tlist\tAvailable when volume_type is 'region' "},{"title":"2.3 Add electrode​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#23-add-electrode","content":"In this section, we will demonstrate how to integrate electrode structures into optoelectronic simulations using the provided code. Currently, the platform allows configuring both steady-state and transient voltages for the electrodes. Detailed code descriptions and specific examples are provided below for reference. add_electrode( self, *, name: str, property: StructureElectrodeProperty, )  Parameters Description name\tTo set the name of eelectrode in simulation. property\tTo set the property of electrode in simulation. "},{"title":"2.3.1 Steady state​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#231-steady-state","content":"st = pj.Structure() st.add_electrode(name=&quot;anode&quot;, property={ &quot;solid&quot;: &quot;Anode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;none&quot;}) st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;single&quot;, &quot;voltage&quot;: 0, &quot;apply_AC_small_signal&quot;: &quot;none&quot;})  Parameters\tDefault\tType\tNotesforce_ohmic\ttrue\tbool bc_mode\tsteady_state\tstring\tTo set the type of electircal boundary condition. Selections are ['steady_state',transient]. apply_AC_small_signal\tnone\tstring\tDetermining whether to apply the small-signal alternating current. Selections are ['none', 'All']. sweep_type\tsingle\tstring\tTo set the voltage type of the electrode. Selections are ['single', 'range', 'value']. v_step_max\t0.5\tfloat\tThe maxium step of voltage value. voltage\t0\tfloat\tThe value of voltage. Available when sweep_type is 'single' range_start\t0\tfloat\tThe start value of a voltage range. Available when sweep_type is 'range' range_stop\t1\tfloat\tThe stop value of a voltage range. Available when sweep_type is 'range' range_interval\t1\tfloat\tThe interval value of a voltage range. Available when sweep_type is 'range' range_num_points\t2\tinteger\tThe The number of points within the voltage range. Available when sweep_type is 'range' []sweep_value_table.index\t-\tinteger\tAvailable when sweep_type is 'value'. []sweep_value_table.number\t-\tfloat\tAvailable when sweep_type is 'value'. surface_type\tsolid\tstring\tSelections are ['solid']. solid\t-\tstring\t "},{"title":"2.3.2 SSAC (Small signal alternating current)​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#232-ssac-small-signal-alternating-current","content":"st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;steady_state&quot;, &quot;sweep_type&quot;: &quot;range&quot;, &quot;range_start&quot;: tcad_vmin, &quot;range_stop&quot;: tcad_vmax, &quot;range_interval&quot;: tcad_vstep, &quot;apply_AC_small_signal&quot;: &quot;All&quot;})  "},{"title":"2.3.3 Transient​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#233-transient","content":"st = pj.Structure() st.add_electrode(name=&quot;cathode&quot;, property={ &quot;solid&quot;: &quot;Cathode&quot;, &quot;bc_mode&quot;: &quot;transient&quot;, &quot;voltage&quot;: tcad_vbias, &quot;v_step_max&quot;: 0.5, &quot;time_table&quot;: [{&quot;time_start&quot;: 0, &quot;time_stop&quot;: 2e-12, &quot;initial_step&quot;: 1e-12, &quot;max_step&quot;: 5e-12}, {&quot;time_start&quot;: 2e-12, &quot;time_stop&quot;: 2.001e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 30e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.001e-12, &quot;time_stop&quot;: 2.01e-12, &quot;initial_step&quot;: 30e-18, &quot;max_step&quot;: 60e-18, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.01e-12, &quot;time_stop&quot;: 2.03e-12, &quot;initial_step&quot;: 60e-18, &quot;max_step&quot;: 2e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 2.03e-12, &quot;time_stop&quot;: 10e-12, &quot;initial_step&quot;: 2e-15, &quot;max_step&quot;: 50e-15, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}, {&quot;time_start&quot;: 10e-12, &quot;time_stop&quot;: 500e-12, &quot;initial_step&quot;: 50e-15, &quot;max_step&quot;: 10e-12, &quot;optical&quot;: {&quot;enabled&quot;: 1, &quot;envelop&quot;: 0, &quot;source_fraction&quot;: source_fraction}}]})  Parameters\tDefault\ttype Notes force_ohmic\ttrue\tbool bc_mode\t-\tstring\tSelections are ['transient']. voltage\t0\tfloat []time_table.time_start\t-\tfloat []time_table.time_stop\t-\tfloat []time_table.initial_step\t-\tfloat []time_table.max_step\t-\tfloat []time_table.optical.enabled\t0\tinteger\tSelections are [0, 1] []time_table.optical.envelop\t-\tinteger\tSelections are [0] []time_table.optical.source_fraction\t-\tfloat surface_type\tsolid\tstring\tSelections are ['solid']. solid\t-\tstring\t "},{"title":"2.4 Add surface recombination​","type":1,"pageTitle":"Structure","url":"/my-website/docs/test/v2_core/2Structure#24-add-surface-recombination","content":"While conducting optoelectronic simulations, you can incorporate surface recombination into the simulation structure using the following code. add_surface_recombination( self, *, name: str, property: AddSurfaceRecombination, )  Parameters\tDescriptionname\tTo set the name of surface recombination in simulation. property\tTo set the property of surface recombination in simulation. Example: st.add_surface_recombination(name=&quot;Cathode_Si&quot;, property={ &quot;surface_type&quot;: &quot;domain_domain&quot;, &quot;interface_type&quot;: &quot;MetalOhmicInterface&quot;, &quot;domain_1&quot;: &quot;Cathode&quot;, &quot;domain_2&quot;: &quot;Si_base&quot;, &quot;infinite_recombination&quot;: False, &quot;velocity_electron&quot;: 1e7, &quot;velocity_hole&quot;: 1e7})  Parameters\tDefault\tType\tNotessurface_type\tdomain_domain\tstring\tTo set the type for calculating surface recombination. Selections are ['domain_domain', 'material_material']. interface_type\tnull\tstring\tTo set the interface type of surface recombination. Selections are ['null', 'InsulatorInterface', 'HomoJunction', 'HeteroJunction', 'MetalOhmicInterface', 'SolderPad']. infinite_recombination\ttrue\tbool\tAvailable when interface_type is 'MetalOhmicInterface' velocity_hole\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' velocity_electron\t0\tfloat\tAvailable when interface_type is 'MetalOhmicInterface'/'InsulatorInterface' domain_1\t-\tstring\tThe region 1 for surface recombination. Available when surface_type is 'domain_domain' domain_2\t-\tstring\tThe region 2 for surface recombination. Available when surface_type is 'domain_domain' material_1\t-\tmaterial\tThe material 1 for surface recombination. Available when surface_type is 'material_material' material_2\t-\tmaterial\tThe material 2 for surface recombination. Available when surface_type is 'material_material' "},{"title":"Monitor","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/5Mornitor","content":"","keywords":""},{"title":"5.1 Profile monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/test/v2_core/5Mornitor#51-profile-monitor","content":"Incorporate a profile monitor into the current project. The profile monitor is solely used for the EME simulation. add( self, *, type: Literal[&quot;profile_monitor&quot;], name: str, property: PostProcessProfileMonitor, )  Parameters\tDescriptionname\tThe name of profile monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of profile monitor. Example: mn = pj.Monitor() mn.add(name=&quot;y_normal&quot;, type=&quot;profile_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_y_normal&quot;, &quot;x_resolution&quot;: 100, &quot;x&quot;: 0, &quot;x_span&quot;: 206, &quot;y&quot;: 0, &quot;y_span&quot;: 0, &quot;z&quot;: 0.5, &quot;z_span&quot;: 7}})  Parameters\tDefault\tType\tNotesgeometry.monitor_type\t-\tstring\tSelect the profile monitor type and the orientation.Selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. geometry.x_resolution\t100\tinteger\tThe resolution of output simulation results in profile monitor. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the profile monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the profile monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the profile monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the profile monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the profile monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the profile monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the profile monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the profile monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the profile monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the profile monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the height of the profile monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the height of the profile monitor. "},{"title":"5.2 Global monitor/Global option​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/test/v2_core/5Mornitor#52-global-monitorglobal-option","content":"Integrate a global monitor into the current project. add( self, *, type: Literal[&quot;global_monitor&quot;, &quot;global_option&quot;], name: str, property: PostProcessGlobalMonitor, )  Parameters\tDescriptionname\tThe name of global monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of global monitor. Example: mn = pj.Monitor() mn.add(name='Global Option', type='global_option', property={'frequency_power': { # 'sample_spacing': 'uniform', 'use_wavelength_spacing': True, # ['min_max','center_span'] 'spacing_type': 'wavelength', 'spacing_limit': 'center_span', 'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}})  Parameters\tDefault\tType\tNotesfrequency_power.sample_spacing\tuniform\tstring\tSet the type of frequency interval for the frequency monitor. Selections are ['uniform']. frequency_power.use_wavelength_spacing\ttrue\tbool\tSelect whether to use wavelength as a variable for result output. frequency_power.spacing_type\twavelength\tstring\tThe different spacing type for result output. Selections are ['wavelength', 'frequency']. frequency_power.spacing_limit\tmin_max\tstring\tSelect the way to set wavelength interval or frequency interval.Selections are ['min_max', 'center_span']. frequency_power.wavelength_min\t-\tfloat\tSet the minimum value of the wavelength range. frequency_power.wavelength_max\t-\tfloat\tSet the maximum value of the wavelength range. frequency_power.wavelength_center\t-\tfloat\tSet the center wavelength. frequency_power.wavelength_span\t-\tfloat\tSet the wavelength span. frequency_power.frequency_min\t-\tfloat\tSet the minimum value of the frequency range. frequency_power.frequency_max\t-\tfloat\tSet the maximum value of the frequency range. frequency_power.frequency_center\t-\tfloat\tSet the center value of the frequency range. frequency_power.frequency_span\t-\tfloat\tSet the frequency span. frequency_power.frequency_points\t5\tinteger\tSet the number of points in the frequency range or wavelength range. advanced.min_sampling_per_cycle\t2\tinteger\tSet the minimum sampling number of points within the optical cycle. "},{"title":"5.3 Time monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/test/v2_core/5Mornitor#53-time-monitor","content":"Incorporate a time monitor into the current project. add( self, *, type: Literal[&quot;time_monitor&quot;], name: str, property: PostProcessTimeMonitor, )  Parameters\tDescriptionname\tThe name of time monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of time monitor. Example: mn = pj.Monitor() mn.add(name='time_monitor1', type='time_monitor', property={'general': { 'stop_method': 'end_of_simulation', 'start_time': 0, 'stop_time': 100, 'number_of_snapshots': 0}, 'geometry': {'monitor_type': 'point', 'x': 0, 'x_span': 0, 'y': 0, 'y_span': 0, 'z': 0, 'z_span': 0}, 'advanced': {'sampling_rate': {'min_sampling_per_cycle': 10}}})  Parameters\tDefault\tType\tNotesgeneral.stop_method\tend_of_simulation\tstring\tSet the method to stop data collection for the time monitor. Selections are ['end_of_simulation', 'choose_stop_time', 'choose_number_of_snapshots']. general.start_time\t0\tfloat\tThe start time for data collection by the time monitor. general.stop_time\t1000\tfloat\tThe stop time for data collection by the time monitor. general.number_of_snapshots\t0\tinteger\tThe number of time snapshots for data collection. geometry.monitor_type string\tThe type and orientation of the time monitor. Selections are ['point', 'linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal', '3d']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the time monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the time monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the time monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the time monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the time monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the time monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the time monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the time monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the time monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the time monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe bottom position of the height of the time monitor in z direction. geometry.z_max\t-\tfloat\tThe top position of the height of the time monitor in z direction. advanced.sampling_rate.min_sampling_per_cycle\t10\tinteger\tSet the minimum sampling number of points within the optical cycle. "},{"title":"5.4 Power monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/test/v2_core/5Mornitor#54-power-monitor","content":"Incorporate a power monitor into the current project. Additionally, you can utilize the 'mode_expansion' to compute the mode expansion associated with its corresponding relative power monitor. add( self, *, type: Literal[&quot;power_monitor&quot;], name: str, property: PostProcessPowerMonitor, )  Parameters\tDescriptionname\tThe name of power monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of power monitor. "},{"title":"5.4.1 Power monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/test/v2_core/5Mornitor#541-power-monitor","content":"As demonstrated in the following code, add a power monitor to the current project. mn = pj.Monitor() mn.add(name=&quot;z_normal&quot;, type=&quot;power_monitor&quot;, property={&quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_z_normal&quot;,&quot;x&quot;: 0, &quot;x_span&quot;: 2*(l_input+l_bend+l_beam/2-0.5), &quot;y&quot;: 0, &quot;y_span&quot;: 5, &quot;z&quot;: 0.11, &quot;z_span&quot;: 0}})  "},{"title":"5.4.2 Mode expansion​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/test/v2_core/5Mornitor#542-mode-expansion","content":"As demonstrated code below, add a mode expansion for the related power monitor. mn.add(name='through', type='power_monitor', property={'general': {'frequency_profile': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}, }, 'geometry': {'monitor_type': '2d_x_normal', 'x': ports['op_1']['position'][0], 'x_span': 0, 'y': ports['op_1']['position'][1], 'y_span': monitor_w, 'z': 0, 'z_span': monitor_h}, 'mode_expansion': {&quot;enable&quot;: True, 'direction': 'positive', 'mode_calculation': { 'mode_selection': 'user_select', 'mode_index': [0, 1, 2, 3], 'override_global_monitor_setting': {'wavelength_center': wavelength, 'wavelength_span': 0.1, 'frequency_points': 11}}}})  Parameters\tDefault\tType\tNotesgeometry.monitor_type\t-\tstring\tThe type and orientation of the power monitor. Selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the power monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the power monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the power monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the power monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the power monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the power monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the power monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the power monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the power monitor. geometry.z_span\t-\tfloat\tThe height in z direction of the power monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe bottom position of the height of the power monitor in z direction. geometry.z_max\t-\tfloat\tThe top position of the height of the power monitor in z direction. geometry.rotate_settings.theta\t0\tfloat\tThe rotation angle theta of the power monitor. Restrained by condition: &gt;-90,&lt;90. geometry.rotate_settings.phi\t0\tfloat\tThe rotation angle phi of the power monitor. Restrained by condition: &gt;=0,&lt;=360. geometry.rotate_settings.rotation_offset\t0\tfloat\tThe rotation offset of the power monitor.Restrained by condition: &gt;=-1e30,&lt;=1e30. Parameters\tDefault\tType\tNotesmode_expansion.[]monitors_for_expansion.name\t-\tstring\tThe name of the power monitor required for individual mode expansion when called separately. mode_expansion.[]monitors_for_expansion.frequency_monitor\t-\tstring\tThe name of the frequency monitor required for individual mode expansion when called separately. mode_expansion.direction\tpositive\tstring\tSet the direction of the mode expansion. Selections are ['positive', 'negative']. mode_expansion.mode_calculation.mode_selection\t-\tstring\tDecide the mode for mode expansion calculation. Selections are ['fundamental', 'fundamental_TE', 'fundamental_TM', 'user_select']. mode_expansion.mode_calculation.mode_index\t-\tlist\tUnder the 'user_select' condition, use this parameter to decide the related number of source mode. mode_expansion.mode_calculation.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. mode_expansion.mode_calculation.n\t1.0\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the mode. mode_expansion.mode_calculation.number_of_trial_modes\t20\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. mode_expansion.mode_calculation.override_global_options\tfalse\tbool\tDecide whether to override the global monitor settings. mode_expansion.mode_calculation.override_global_monitor_setting.sample_spacing\tuniform\tstring\tSet the type of frequency interval. Selections are ['uniform']. mode_expansion.mode_calculation.override_global_monitor_setting.use_wavelength_spacing\ttrue\tbool\tSelect whether to use wavelength as a variable for result output. mode_expansion.mode_calculation.override_global_monitor_setting.spacing_type\twavelength\tstring\tThe different spacing type for result output. Selections are ['wavelength', 'frequency']. mode_expansion.mode_calculation.override_global_monitor_setting.spacing_limit\tmin_max\tstring\tSelect the way to set wavelength interval or frequency interval.Selections are ['min_max', 'center_span']. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_min\t-\tfloat\tSet the minimum value of the wavelength range. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_max\t-\tfloat\tSet the maximum value of the wavelength range. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_center\t-\tfloat\tSet the center wavelength. mode_expansion.mode_calculation.override_global_monitor_setting.wavelength_span\t-\tfloat\tSet the wavelength span. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_min\t-\tfloat\tSet the minimum value of the frequency range. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_max\t-\tfloat\tSet the maximum value of the frequency range. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_center\t-\tfloat\tSet the center value of the frequency range. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_span\t-\tfloat\tSet the frequency span. mode_expansion.mode_calculation.override_global_monitor_setting.frequency_points\t-\tinteger\tSet the number of points in the frequency range or wavelength range. mode_expansion.mode_calculation.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in curved waveguides. mode_expansion.mode_calculation.bent_waveguide.radius\t1\tfloat\tSet the waveguide radius for curved waveguides. mode_expansion.mode_calculation.bent_waveguide.orientation\t20\tfloat\tBent direction of the waveguide. mode_expansion.mode_calculation.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. "},{"title":"5.6 Band monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/test/v2_core/5Mornitor#56-band-monitor","content":"Integrate a band monitor into the current project. add( self, *, type: Literal[&quot;band_monitor&quot;], name: str, property: PostProcessBandMonitor, )  Parameters\tDescriptionname\tThe name of band monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of band monitor. Example: mn = pj.Monitor() mn.add(name=&quot;band_line&quot;, type=&quot;band_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_z&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: 0, &quot;y_max&quot;: 0, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max, &quot;interpolate_accuracy&quot;: 9}}) # endregion  Parameters\tDefault\tType\tNotesgeneral.record_ec\ttrue\tbool general.record_ev\ttrue\tbool general.record_ei\ttrue\tbool general.record_efn\ttrue\tbool general.record_efp\ttrue\tbool general.record_evac\ttrue\tbool geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10. "},{"title":"5.7 Charge monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/test/v2_core/5Mornitor#57-charge-monitor","content":"Incorporate a charge monitor into the current project. add( self, *, type: Literal[&quot;charge_monitor&quot;], name: str, property: PostProcessChargeMonitor, )  Parameters\tDescriptionname\tThe name of charge monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of charge monitor. Example: mn = pj.Monitor() mn.add(name=&quot;np_line_080nm&quot;, type=&quot;charge_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;linear_y&quot;, &quot;x&quot;: st_x_mean, &quot;x_span&quot;: st_x_span, &quot;y_min&quot;: -0.4, &quot;y_max&quot;: 0.4, &quot;z&quot;: 0.08, &quot;z_span&quot;: 0, &quot;interpolate_accuracy&quot;: 9}})  Parameters\tDefault\tType\tNotesgeneral.record_electrons\ttrue\tbool general.record_holes\ttrue\tbool general.integrate_total_charge\ttrue\tbool\tAvailable when monitor_type is in ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10. "},{"title":"5.8 Electric monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/test/v2_core/5Mornitor#58-electric-monitor","content":"Integrate an electric monitor into the current project. add( self, *, type: Literal[&quot;electric_monitor&quot;], name: str, property: PostProcessElectricMonitor, )  Parameters\tDescriptionname\tThe name of electric monitor defined in the project. type\tTo decide the type of monitor. property\tThe property of electric monitor. Example:  mn = pj.Monitor() mn.add(name=&quot;electric_2d&quot;, type=&quot;electric_monitor&quot;, property={ &quot;geometry&quot;: {&quot;monitor_type&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y_min&quot;: -Ge_y_span_bottom*3/4, &quot;y_max&quot;: Ge_y_span_bottom*3/4, &quot;z_min&quot;: 0, &quot;z_max&quot;: Si_z_span+Ge_z_span, &quot;interpolate_accuracy&quot;: 6}})  Parameters\tDefault\tType\tNotesgeneral.record_electrics_field\ttrue\tbool general.record_electrostatic_potential\ttrue\tbool general.calculate_net_charge\ttrue\tbool\tAvailable when monitor_type is in ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.monitor_type string\tSelections are ['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float\tRestrained by condition: &gt;=0. geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float\tRestrained by condition: &gt;=0. geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float\tRestrained by condition: &gt;=0. geometry.z_min float geometry.z_max float geometry.interpolate_accuracy\t1\tinteger\tRestrained by condition: &gt;=1 &amp;&amp; &lt;= 10. "},{"title":"Preview","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/7Preview","content":"","keywords":""},{"title":"7.1 Run index​","type":1,"pageTitle":"Preview","url":"/my-website/docs/test/v2_core/7Preview#71-run-index","content":"The code contained in this module enables a preview of the refractive index images with various structures. run_index( self, *, property: RunIndex, name: str, export_csv: bool = False, show: bool = False, savepath: str = 'a', export_n: bool = True, export_c: bool = False, max_index: Optional[int] = None, max_sigma: Optional[int] = None, )  Parameters\tDescriptionproperty\tTo set the properties of index monitor. name\tThe name of index monitor in the simulation. export_csv\tDecide whether to export the data as csv format or not. The default is False. show\tDecide whether to show index preview figure or not. The default is False. savepath\tDefine the save path for the csv data and the picture. The default is 'a'. export_n\tDecide whether to export the real part of index ,such as nx, ny, nz... . The default is True. export_c\tDecide whether to export the imaginary part of index, such as σx, σy, σz... . The default is False. max_index\tThe maximum index of heatmap colorbar. The default is None. max_sigma\tThe maximum sigma of heatmap colorbar.The default is None. Example: simu[simu_name].run_index(name=f'{simu_name}_x_0', savepath=f'{plot_path}{k}IndexPreview_x=0', # export_csv=False, show=False, property={'geometry': {'x': 0, 'x_span': 0, 'y': 0, 'y_span': 3, 'z': 0, 'z_span': 2}})  Parameters\tDefault\tType\tNotesgeometry.monitor_type\t-\tstring\tSet the orientation of the index monitor. The selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the index monitor. geometry.x_span\t-\tfloat\tThe length in x direction of the index monitor. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the index monitor. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the index monitor. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the index monitor. geometry.y_span\t-\tfloat\tThe width in y direction of the index monitor. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the index monitor. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the index monitor. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the index monitor. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the index monitor. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the index monitor. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the index monitor. "},{"title":"7.2 Structure show and show 3D​","type":1,"pageTitle":"Preview","url":"/my-website/docs/test/v2_core/7Preview#72-structure-show-and-show-3d","content":"This portion of the code is primarily intended for show structure. Please note that this method becomes invalid if the current structure manager contains Pyramid or Arc-Waveguide 3D type geometries. structure_show( self, *, mode=&quot;XY&quot;, show: bool, savepath: str, fig_type: Literal[&quot;png&quot;, &quot;svg&quot;] = &quot;png&quot;, simulation_name: Optional[str] = None, disabled_components: Tuple[ Literal[ &quot;materials&quot;, &quot;helpers&quot;, &quot;box&quot;, &quot;box.coordinate&quot;, &quot;box.cavity&quot;, &quot;ModeSource&quot;, &quot;PowerMonitor&quot;, &quot;ProfileMonitor&quot;, &quot;FDTDPortGroup&quot;, ], ... ] = tuple(), xyratio=(1, 1), celldisplay=False )  Parameters\tDescriptionmode\tSpecify the orientation of the structure preview function. show\tDecide whether to show directly the preview of structure directly in the related software.If set to False, the picture will be saved instead. savepath\tDecide the save path of the preivew picture. fig_type\tDecide the suffix(type) of the preivew picture. simulation_name\tThe simulation name. disabled_components\tDisable the components from showing. xyratioZoom multiplier of x and y direction.\tZoom multiplier of x and y direction. celldisplay\tWhether to show eme cells. Show 3D structure in a pop up windows. show3d(self, show_with: Literal[&quot;webviewer&quot;, &quot;matplotlib&quot;，&quot;local_gui&quot;] = &quot;webviewer&quot;)  Parameters\tDescriptionshow_with\tChoose the type of display. The selection are &quot;webviewer&quot;, &quot;matplotlib&quot;，&quot;local_gui&quot;. The &quot;webviewer&quot; will start a server and toggle a browser windows. &quot;matplotlib&quot; will toggle a Axes3D windows. Default as &quot;webviewer&quot;. Example: st.structure_show(fig_type='png', show=False, savepath=f'{plot_path}{kL[0]}{simu_name}', simulation_name=simu_name) simu[simu_name].show3d(show_with=&quot;local_gui&quot;)  "},{"title":"7.3 Run doping​","type":1,"pageTitle":"Preview","url":"/my-website/docs/test/v2_core/7Preview#73-run-doping","content":"The code within this module enables the preview of doping results for the respective structures. run_doping( self, name: str, property: RunDopingPostProcess, norm: str, scale: str, superimpose: bool, show: bool, material_list: list, cmin: float, savepath: str )  Parameters\tDescriptionproperty\tThe properties of doping preview. name\tThe name of doping preview. show\tDecide whether to show directly the preview of structure directly in the related software.If set to False, the picture will be saved instead. savepath\tThe save path for picture. norm\tThe normalization of colorbar. Selections are ['linear', 'log']. Default as 'linear'. scale\tThe type of pcture scale. Selections are ['equal', 'auto']. Default as 'equal'. superimpose\tSuperimpose doping on structure or not. Default as True. material_list\tSpecified material type list. Default as []. region_list\tSpecified region name list. Default as []. Superior to material_list when not empty. cmax\tMaximum concentration of heatmap colorbar. Default as None. cmin\tMinimum concentration of heatmap colorbar. Default as None. Example: simu[&quot;preview_oedevice&quot;].run_doping(name=&quot;x_in&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}}, norm=&quot;log&quot;, scale=&quot;equal&quot;, superimpose=False, show=False, material_list=[&quot;Ge&quot;, &quot;Si&quot;], cmin=8e5, savepath=plot_path + simu_name + &quot;_&quot; + time_str + &quot;doping_x_in&quot;)  Parameters\tDefault\tType\tNotesgeometry.dimension string\tSet the orientation of the doping region. The selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x\t-\tfloat\tThe x-coordinate of the center point position of the doping region. geometry.x_span\t-\tfloat\tThe length in x direction of the doping region. Restrained by condition: &gt;0. geometry.x_min\t-\tfloat\tThe minimum x-coordinate endpoint data of the doping region. geometry.x_max\t-\tfloat\tThe maximum x-coordinate endpoint data of the doping region. geometry.y\t-\tfloat\tThe y-coordinate of the center point position of the doping region. geometry.y_span\t-\tfloat\tThe width in y direction of the doping region. Restrained by condition: &gt;0. geometry.y_min\t-\tfloat\tThe minimum y-coordinate endpoint data of the doping region. geometry.y_max\t-\tfloat\tThe maximum y-coordinate endpoint data of the doping region. geometry.z\t-\tfloat\tThe z-coordinate of the center point position of the doping region. geometry.z_span\t-\tfloat\tThe thinckness in z direction of the doping region. Restrained by condition: &gt;0. geometry.z_min\t-\tfloat\tThe z-coordinate of the bottom position of the thickness of the doping region. geometry.z_max\t-\tfloat\tThe z-coordinate of the top position of the thickness of the doping region. "},{"title":"Extract result","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/8Extract","content":"","keywords":""},{"title":"8.1 FDE​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#81-fde","content":"In this section, we will provide examples for extracting simulation result data from FDE simulation, along with a description table of parameters. "},{"title":"8.1.1 Calculate mode result​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#811-calculate-mode-result","content":"Get the result of calculated mode. extract( self, *, # target - intensity data: Literal['calculate_modes'], attribute: PowerAttributes/ModeAttributes/OtherAttributes export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', mode: int, )  Example: result_fde.extract(data='calculate_modes', savepath=f'{plot_path}{k}_mode{m}', attribute='E', mode=m, real=True, imag=True, **export_options, show=False)  "},{"title":"8.1.2 Far-field FDE result​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#812-far-field-fde-result","content":"Get the result of calculated far-field FDE. extract( self, *, # target - table data: Literal['farfield_fde'], attribute: PowerAttributes, show=False, export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = 'a', mode: int, )  Example: fde_res.extract(data='farfield_fde', savepath=f'{plot_path}05_{simu_name}_far_field', attribute='E', mode=0, export_csv=True)  "},{"title":"8.1.3 Mesh structure result​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#813-mesh-structure-result","content":"To extract the result of meshing structure. extract( self, *, data: Literal['mesh_structure'], savepath:Any = 'a', target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, )  Example: simu.add(name=simu_name+&quot;_cal_mode&quot;, type=&quot;mode_selection:user_select&quot;, simulation_name=simu_name, source_name=&quot;source&quot;, property={&quot;modal_analysis&quot;: {&quot;mesh_structure&quot;: True, &quot;calculate_modes&quot;: True, &quot;wavelength&quot;: wavelength, &quot;number_of_trial_modes&quot;: 10, &quot;search&quot;: &quot;max_index&quot;, &quot;calculate_group_index&quot;: True}})  "},{"title":"8.1.4 Frequency analysis result​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#814-frequency-analysis-result","content":"To extract the result of frequency analysis. extract( self, *, target: Literal['line'] = 'line', data: Literal['frequency_analysis'], attribute: Literal['neff', 'group_index', 'loss', 'polarization'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None )  Example: result_fde.extract(data=&quot;frequency_analysis&quot;, savepath=f'{plot_path}{k}_freq_sweep_neff', attribute=&quot;neff&quot;, real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"8.2 EME​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#82-eme","content":"To extract the relevant data of EME module. "},{"title":"8.2.1 EME propagate:facet data​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#821-eme-propagatefacet-data","content":"Get the result of calculated facet data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:facet_data', ], export_csv=False, export_mat=False, export_zbf=False, real=True, imag=True, savepath: Any = 'a', )  Example: eme_res.extract(data='eme_propagate:facet_data', savepath=plot_path, real=True, imag=True, export_csv=True)  "},{"title":"8.2.2 EME propagate:monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#822-eme-propagatemonitor","content":"Get the result of monitor data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:monitor', ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract( data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_y_normal&quot;, monitor_name=&quot;y_normal&quot;, attribute=&quot;E&quot;, export_csv=True)  "},{"title":"8.2.3 Propagation sweep:monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#823-propagation-sweepmonitor","content":"Get the result of monitor data of propagation sweep. extract( self, *, data: Literal[ 'propagation_sweep:monitor', ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data=&quot;eme_propagate:monitor&quot;, savepath=plot_path + &quot;013_eme_z_normal&quot;, monitor_name=&quot;z_normal&quot;, attribute=&quot;E&quot;, export_csv=True)  "},{"title":"8.2.4 Wavelength sweep:monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#824-wavelength-sweepmonitor","content":"Get the result of monitor data of wavelength sweep. extract( self, *, data: Literal[ 'wavelength_sweep:monitor', ], attribute: PowerAttributes, monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data=&quot;wavelength_sweep:sweep&quot;, savepath=plot_path + &quot;20_wavelength_sweep&quot;, plot_x=&quot;wavelength&quot;, export_csv=True)  "},{"title":"8.2.5 EME propagate:smatrix​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#825-eme-propagatesmatrix","content":"Get the result of smatrix data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:smatrix', ], target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True)  "},{"title":"8.2.6 EME propagate:port mode infomation​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#826-eme-propagateport-mode-infomation","content":"Get the result of port mode data of EME propagation. extract( self, *, # target - intensity data: Literal['eme_propagate:port_mode_info'], target: Literal['intensity'] = 'intensity', attribute: Literal['E', 'H'], port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, )  Example: eme_res.extract(data=&quot;eme_propagate:smatrix&quot;, savepath=plot_path + &quot;011_eme_smatrix_intensity&quot;, target=&quot;intensity&quot;, export_csv=True)  "},{"title":"8.2.7 EME propagate:port mesh structure​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#827-eme-propagateport-mesh-structure","content":"Get the result of port mesh structure data of EME propagation. extract( self, *, # target - intensity data: Literal['eme_propagate:port_mesh_structure'], port_name: str, target: Literal['line', 'intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data='eme_propagate:port_mesh_structure', savepath=f'{plot_path}{kL[3]}_eme_structure_{port_name}', port_name=port_name, target='intensity', # plot_x='y', plot_y='z', export_csv=False, show=False )  "},{"title":"8.2.8 EME propagate:cell mesh structure​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#828-eme-propagatecell-mesh-structure","content":"Get the result of cell mesh structure data of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:cell_mesh_structure', ], target: Literal[&quot;intensity&quot;, &quot;line&quot;], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  Example: eme_res.extract(data='eme_propagate:cell_mesh_structure', savepath=f'{plot_path}{kL[4]}_eme_c{cell_index}_index', cell_params='c' + str(cell_index), target='intensity', plot_x='y', plot_y='z', # export_csv=False, show=False )  "},{"title":"8.2.9 EME propagate:port overlap​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#829-eme-propagateport-overlap","content":"Get the result of port overlap data of EME propagation. def extract( self, *, data: Literal[ 'eme_propagate:port_overlap', ], target: Literal['line'] = 'line', port_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  "},{"title":"8.2.10 EME propagate:cell mode information​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#8210-eme-propagatecell-mode-information","content":"Get the result of cell mode information of EME propagation. extract( self, *, target: Literal['intensity'] = 'intensity', data: Literal[ 'eme_propagate:cell_mode_info', ], attribute: Literal['E', 'H'], cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, )  "},{"title":"8.2.11 EME propagate:propagation field​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#8211-eme-propagatepropagation-field","content":"Get the result of propagation field of EME propagation. extract( self, *, data: Literal[ 'eme_propagate:prop_field', ], # target: intensity&quot;, attribute:PowerAttributes, cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  "},{"title":"8.2.12 EME propagate:internal S​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#8212-eme-propagateinternal-s","content":"Get the result of internal S data of EME propagation. extract( self, *, data: Literal[ &quot;eme_propagate:internal_s&quot;, ], target: Literal['intensity'] = 'intensity', export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  "},{"title":"8.2.13 EME propagate:cell p matrix/cell overlap/cell S/propagation S​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#8213-eme-propagatecell-p-matrixcell-overlapcell-spropagation-s","content":"Get the result of cell p matrix/cell overlap/cell S/propagation S data of EME propagation.  def extract( self, *, data: Literal[ &quot;eme_propagate:cell_p_matrix&quot;, &quot;eme_propagate:cell_overlap&quot;, &quot;eme_propagate:cell_s&quot;, &quot;eme_propagate:prop_s&quot;, ], target: Literal['intensity'] = 'intensity', cell_params: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, )  "},{"title":"8.3 FDTD​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#83-fdtd","content":"To extract the relevant data of FDTD module. "},{"title":"8.3.1 FDTD:power monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#831-fdtdpower-monitor","content":"Get the result of power monitor data of FDTD. extract( self, *, data: Literal['fdtd:power_monitor'], target: Literal['intensity', 'line'], attribute: Union[PowerAttributes, Literal[&quot;T&quot;]], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, wavelength: Optional[Any] = None, )  Example: fdtd_res.extract(data='fdtd:power_monitor', savepath=f'{plot_path}{kL[6]}_TransVsLambda_power', monitor_name='through', target='line', plot_x='wavelength', attribute='T', real=True, imag=False, export_csv=True, export_mat=True, show=False)  "},{"title":"8.3.2 FDTD:time monitor​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#832-fdtdtime-monitor","content":"Get the result of FDTD time monitor data. extract( self, *, data: Literal['fdtd:time_monitor'], target: Literal['intensity', 'line'], attribute: Union[PowerAttributes, Literal[&quot;T&quot;]], monitor_name: str, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, wavelength: Optional[Any] = None, )  Example: fdtd_res.extract(data='fdtd:time_monitor', savepath=f'{plot_path}{kL[6]}_TransVstime', monitor_name='through', target='line', plot_x='time(fs)', attribute='E', real=True, imag=False, export_csv=True, export_mat=True, show=False)  "},{"title":"8.3.3 FDTD:mode expansion​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#833-fdtdmode-expansion","content":"Get the result of FDTD mode expansion data. extract( self, *, data: Literal['fdtd:mode_expansion'], target: Literal[&quot;intensity&quot;, &quot;line&quot;], attribute: ModeAttributes, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, plot_y: OptStr=None, mode: Optional[Any] = None, wavelength: Optional[Any] = None, monitor_name: str, mode_expansion_name: str, )  Example: fdtd_res.extract(data='fdtd:mode_expansion', savepath=f'{plot_path}{kL[5]}_TransVsLambda_mode=0', monitor_name='through', target='line', plot_x='wavelength', mode=0, attribute='T_forward', real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"8.3.4 FDTD:port mode information​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#834-fdtdport-mode-information","content":"Get the result of FDTD port mode information. extract( self, *, data: Literal['fdtd:port_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', port_name: str, mode: Any = None, plot_x: OptStr=None, plot_y: OptStr=None, )  Example: fdtd_res.extract(data='fdtd:port_mode_info', savepath=f'{plot_path}{kL[3]}_left_port_mode', port_name='left_port', target='intensity', attribute='E', mode=0, export_csv=True)  "},{"title":"8.3.5 FDTD:mode source information​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#835-fdtdmode-source-information","content":"Get the result of FDTD mode source information. extract( self, *, data: Literal['fdtd:mode_source_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', source_name: str, mode: Any = None, plot_x: OptStr=None, plot_y: OptStr=None, )  Example: fdtd_res.extract(data='fdtd:mode_source_mode_info', savepath=f'{plot_path}{kL[2]}_source_modeprofile', source_name='source', target='intensity', attribute='E', mode=0, real=True, imag=True, **export_options, show=False)  "},{"title":"8.3.6 FDTD:mode expansion information​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#836-fdtdmode-expansion-information","content":"Get the result of FDTD mode expansion information. extract( self, *, data: Literal['fdtd:mode_expansion_mode_info'], target: Literal['intensity', 'line'], attribute: Literal['E', 'H', 'Loss', 'Neff', 'TE Polarization Fraction'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', monitor_name: str, mode_expansion_name: str, plot_x: OptStr=None, plot_y: OptStr=None, mode: Any = None, wavelength: Any = None, )  Example: fdtd_res.extract(data='fdtd:mode_expansion_mode_info', savepath=f'{plot_path}{kL[3]}_me_throughmode_info', monitor_name='through', target='intensity', attribute='E', mode=0, wavelength=f'{wavelength}', real=True, imag=True, **export_options, show=False)  "},{"title":"8.4 Sweep​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#84-sweep","content":"To extract the relevant data of sweep function. "},{"title":"8.4.1 parameter sweep​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#841-parameter-sweep","content":"Get the result of sweep data. extract( self, *, data: Literal['sweep'], target: Literal['intensity', 'line'], attribute: str, monitor_name: Optional[str] = None, export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, **kwargs, )  Example: swp_res.extract(data='sweep', target='line', attribute='S', plot_x='sweep_gap', savepath=f'{plot_path}/01 S', export_csv=True)  swp_res.extract(data='mode_expansion', target='line', attribute='T_forward', plot_x='sweep_gap', monitor_name='through', savepath=f'{plot_path}/03 {resultL[2]}', export_csv=True, )  "},{"title":"8.4.2 smatrix sweep​","type":1,"pageTitle":"Extract result","url":"/my-website/docs/test/v2_core/8Extract#842-smatrix-sweep","content":"Get the result of smatrix sweep data. extract( self, *, data: Literal['smatrix_sweep'], target: Literal['intensity', 'line'], export_csv=False, export_mat=False, export_zbf=False, show=False, real=True, imag=True, savepath:Any = 'a', plot_x: OptStr=None, )  Example: smatrix_res.extract(data='smatrix_sweep', savepath=f'{plot_path}{kL[8]}_smatrix_sweep', target='line', plot_x='wavelength', real=True, imag=True, export_csv=True, export_mat=True, show=False)  "},{"title":"Material","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/1Material","content":"","keywords":""},{"title":"1 Standard Material Database​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#1-standard-material-database","content":"The standard material database includes two parts, one is material list, and another is material property plot. The material list includes a number of common materials, when creating a new simulation, the standard database will be loaded. And the materials in the standard material database can be imported into “User” and “Project” material database. The default materials cannot be edited directly.  "},{"title":"1.1 Material List​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#11-material-list","content":" ID : IDName : Material NameMesh Oder: Decides how overlapping objects are meshed in the simulation.Color : Material ColorType : Types of material, three types are included, there are Lossy material, Lossless material and List data as follows. Lossy Material : Lossy MaterialLossless Material : Lossless Material (insulating material)List Data : Materials whose dielectric permittivity changes with wavelength settings, displayed in tabular form. Last Modified :Last modified timeImport: Import materials to user or project database.Export: Export materials according to user needs. "},{"title":"1.2 Materials in the Standard Material Database​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#12-materials-in-the-standard-material-database","content":"The following materials are included in the standard material database. ID\tName\tMesh Order\tType1\tAir\t2\tLossless Material 2\tAl (Aluminium) - Palik\t2\tList Data 3\tAl (Aluminium) - CRC\t2\tList Data 4\tAu (Gold) - CRC\t2\tList Data 5\tAu (Gold) - Johnson and Christy\t2\tList Data 6\tAu (Gold) - Palik\t2\tList Data 7\tGe (Germanium) - CRC\t2\tList Data 8\tGe (Germanium) - Palik\t2\tList Data 9\tSi (Silicon) - Palik\t2\tList Data 10\tSiO2 (Glass) - Palik\t2\tList Data 11\tSi3N4 (Silicon Nitride) - Kischkat\t2\tList Data 12\tSi3N4 (Silicon Nitride) - Phillip\t2\tList Data 13\tAg (Silver) - CRC\t2\tList Data 14\tPt (Platinum) - Palik\t2\tList Data 15\tTa (Tantalum) - CRC\t2\tList Data 16\tTiN - Palik\t2\tList Data 17\tCu (Copper) - Palik\t2\tList Data 18\tFe (Iron) - CRC\t2\tList Data 19\tW (Tungsten) - CRC\t2\tList Data 20\tTi (Titanium) - Palik\t2\tList Data 21\tTi (Titanium) - CRC\t2\tList Data 22\tSn (Tin) - Palik\t2\tList Data 23\tH2O (Water) - Palik\t2\tList Data 24\tCr (Chromium) - CRC\t2\tList Data 25\tPd (Palladium) - Palik\t2\tList Data 26\tInAs - Palik\t2\tList Data 27\tAg (Silver) - Palik (1-10um)\t2\tList Data 28\tAg (Silver) - Johnson and Christy\t2\tList Data 29\tW (Tungsten) - Palik\t2\tList Data 30\tFe (Iron) - Palik\t2\tList Data 31\tCr (Chromium) - Palik\t2\tList Data 32\tAl2O3 - Palik\t2\tList Data 33\tIn (Indium) - Palik\t2\tList Data 34\tCu (Copper) - CRC\t2\tList Data 35\tNi (Nickel) - CRC\t2\tList Data 36\tV (Vanadium) - CRC\t2\tList Data 37\tInP - Palik\t2\tList Data 38\tGaAs - Palik\t2\tList Data 39\tNi (Nickel) - Palik\t2\tList Data 40\tRh (Rhodium) - Palik\t2\tList Data 41\tAg (Silver) - Palik (0-2um)\t2\tList Data "},{"title":"1.3 Material Properties:​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#13-material-properties","content":" Plot : User can view each material property in this plot area via clicking a certain material in material list, also can view properties they are interested in via two options in the bottom of plot. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index)&amp;Im(refractive index), “εr′,εr″”-Re(relative permittivity)&amp;Im(relative permittivity), ε’,σ-Re(relative permittivity)&amp;Im(relative permittivity). 1.1.3.1 Material Data &amp; Model Fitting​ Material Data tab: User can view each material property in this list via double clicking a certain material in material list. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index)&amp;Im(refractive index), and “εr′,εr″”-Re(relative permittivity)&amp;Im(relative permittivity). 1. Material Data  2. Model Fitting: (Currently, the model fitting feature is not available and is still in the development process.) "},{"title":"2 User Material Database​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#2-user-material-database","content":"The User material database, a database that stores materials used by user. The user material database includes two parts, one is material list, and another is material property plot. User can copy or delete a selected material, The materials in the “User” material database can be imported to the “Project” material database. And users also can export materials according to their needs.  "},{"title":"2.1 Material List​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#21-material-list","content":"ID : IDName : Material NameMesh Oder: Decides how overlapping objects are meshed in the simulation.Color : Material ColorType : Types of material, three types are included, there are Lossy material, Lossless material and List data as follows. Lossy Material : Lossy MaterialLossless Material : Lossless Material (insulating material)List Data : Materials whose dielectric permittivity changes with wavelength settings, displayed in tabular form. Last Modified :Last modified timeImport: Import materials to user or project database.Export: Export materials according to user needs. "},{"title":"2.2 Material Properties​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#22-material-properties","content":" Plot : User can view each material property in this plot area via clicking a certain material in material list, also can view properties they are interested in via two options in the bottom of plot. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index)&amp;Im(refractive index), “εr′,εr″”-Re(relative permittivity)&amp;Im(relative permittivity), ε’,σ-Re(relative permittivity)&amp;Im(relative permittivity). 2.2.1 Material Data &amp; Model Fitting​ Material Data Tab: User can view each material property in this list via double clicking a certain material in material list. Material properties include “Color”, “Name”, “Mesh Order”, “Wavelength”, “Frequency”, “n,k”-Re(refractive index)&amp;Im(refractive index), and “εr′,εr″”-Re(relative permittivity)&amp;Im(relative permittivity). Anisotropy : Two options in this drop-down menu, “None” and “Diagonal”, when diagonal option is checked, user can create FDTD, FDE, or EME anisotropic optical material in the “User Material Database” window. Solver physics :Anisotropic materials react to electric field with directional dependent electric displacement. Permittivity can be represented by a 9 element tensor εij\\varepsilon_{ij}εij​. Di=εijEjD_i = \\varepsilon_{ij}E_jDi​=εij​Ej​ In general, this tensor can be diagnonalized by a proper choice of coordinate system, e.g. in principle dielectric axes. So it is simplified to ε=[εx000εy000εz]\\varepsilon =\\begin{bmatrix} \\varepsilon_x &amp; 0 &amp; 0\\\\ 0 &amp; \\varepsilon_y &amp; 0\\\\ 0 &amp; 0 &amp; \\varepsilon_z \\end{bmatrix}ε=​εx​00​0εy​0​00εz​​​ Diagonal anisotropic materials:To define an anisotropic material, set the Anisotropy field in the material database to Diagonal and assign the parameters for each diagonal component.  "},{"title":"3 Project Material Database​","type":1,"pageTitle":"Material","url":"/my-website/docs/tutorial/1Material#3-project-material-database","content":"The project material database stores project materials. The database would inherit materials from the project automatically, which may contain standard materials and user materials in the project. And the materials in the standard and user material database can be imported to project material database. Users also can add, delete and export materials according to their needs. "},{"title":"Waveform","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/2Waveform","content":"Waveform Features Description: Global waveforms settings include two parts, one is standard waveform list, and another is project waveform list. There are three default materials in the standard waveform list, includes Waveform_1550, Waveform_1310 and Visible_Light. The default waveforms in the standard waveform list cannot be edited directly, user can add, or copy one of waveforms from the standard waveform list. User only can delete newly added or copied waveforms in the standard waveform list. The waveforms in the project waveform list inherit form projects built by user, user can add new waveform or delete selected waveforms in the project waveform list. Select one Waveform (e.g., Waveform1) in Waveform list, then edit the selected waveform in the left-down Waveforms window, at the same time, signal vs time image will display in the right-down window. Signal Vs Time: The range of time can be zoom in via dragging the two ends of bottom bar. You can add, delete, or copy a certain waveform in the list.You can set Frequency/wavelength or Time domain in the drop-down menu, at the same time, signal and time image will be changed as well.If the “set frequency/wavelength” option was chosen, “set time domain” option will be disabled, this section makes it possible to either set the frequency or the wavelength and choose to either set the center and span or the minimum and maximum frequencies of the source.For single frequency simulations, simply sets both the min and max wavelengths to the same value.If the “set time domain ” option was chosen, “set frequency/wavelength” option will be disabled.Broadband: The broadband source, which contains a much wider spectrum, consists of a chirped optical carrier with a Gaussian envelope. Frequency: The center frequency of the optical carrier. The value currently is default.Pulse Length: The half-width at -109 dB power temporal duration of the pulse. Offset: The time dealy form the start of simulation to the peak of the waveform. The value currently is default.Bandwidth：source band width setting.Optimize for short pulse: Enabled, this is the default setting for FDTD, meaning a very short pulse will be used in most simulations.","keywords":""},{"title":"Simulation","type":0,"sectionRef":"#","url":"/my-website/docs/test/v2_core/6Simulation","content":"","keywords":""},{"title":"6.1 FDE​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#61-fde","content":"Incorporate a FDE solver into the current project using the code type='FDE'. add( self, *, name: str, type: Literal[&quot;FDE&quot;], property: FdePostProcess, )  Example: simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={ # 'general': {'solver_type': '2d_x_normal'}, # default is '2d_x_normal' ['2d_x_normal','2d_y_normal','2d_z_normal'] 'mesh_settings': { 'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}, # 'minimum_mesh_step_settings': {'min_mesh_step': 1.0e-4} }, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'search': 'max_index', # ['near_n','max_index'] # 'n': 2, 'calculate_group_index': False, 'mode_removal': {'threshold': 0.02}, # 'bent_waveguide': {'bent_waveguide': False, 'radius': 1, 'orientation': 0, 'location': 'simulation_center'} }, &quot;frequency_analysis&quot;: { &quot;frequency_analysis&quot;: run_options.run_frequency_sweep, &quot;start_wavelength&quot;: 1.50, &quot;stop_wavelength&quot;: 1.60, &quot;number_of_points&quot;: 3, &quot;effective_index&quot;: 2.7, &quot;detailed_dispersion_calculation&quot;: False }}})  Parameters\tDefault\tType\tNotesgeneral.solver_type\t2d_x_normal\tstring\tTo decide the type of simulation. Selections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. mesh_settings.global_mesh_uniform_grid.dx\t0.02\tfloat\tThe global mesh step in the x direction. mesh_settings.global_mesh_uniform_grid.dy\t0.02\tfloat\tThe global mesh step in the y direction. mesh_settings.global_mesh_uniform_grid.dz\t0.02\tfloat\tThe global mesh step in the z direction. mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat\tThe minimum mesh step in the simulation ragion. thread_setting.thread\t4\tinteger\tDetermine the number of cores required to run the simulation on the local computer. fde_analysis.modal_analysis.mesh_structure\tfalse\tbool\tConfirm whether to generate a refractive index diagram for the structure. fde_analysis.modal_analysis.calculate_modes\tfalse\tbool\tDetermine whether to calculate the modes. fde_analysis.modal_analysis.wavelength\t1.55\tfloat\tThe mode wavelength for FDE calculation. fde_analysis.modal_analysis.wavelength_offset\t0.002\tfloat\tThe mode wavelength offset for FDE calculation. fde_analysis.modal_analysis.number_of_trial_modes\t5\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. fde_analysis.modal_analysis.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. fde_analysis.modal_analysis.n\t1\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the source mode. fde_analysis.modal_analysis.calculate_group_index\tfalse\tbool\tDetermine whether to calculate the group refractive index. fde_analysis.modal_analysis.mode_removal.threshold\t-\tfloat\tScreen the FDTD port source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission FDTD port mode. fde_analysis.frequency_analysis.frequency_analysis\tfalse\tbool\tDetermine whether to invoke frequency analysis. fde_analysis.frequency_analysis.start_wavelength\t-\tfloat\tSet the start frequency of the frequency analysis. fde_analysis.frequency_analysis.stop_wavelength\t-\tfloat\tSet the stop frequency of the frequency analysis. fde_analysis.frequency_analysis.number_of_points\t10\tinteger\tSet the number of points in the frequency analysis fde_analysis.frequency_analysis.effective_index\t1.0\tfloat\tTo search the mode near this refractive index. fde_analysis.frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\tDetermine whether to calculate the dispersion of structure. "},{"title":"6.1.1 Mode selection​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#611-mode-selection","content":"For quick previewing structure index or getting convinent mode calculation, we integrate a FDE mode selection into the FDTD simulation project. add( self, *, name: str, simulation_name: str, source_name: str = &quot;&quot;, cell_group_index: int = 0, type: Literal[&quot;mode_selection:user_select&quot;], property: ModeSelectionUserSelectPostProcess, )  Example: simu = pj.Simulation() simu.add(name=simu_name+'_cal_mode', simulation_name=simu_name, source_name='source', type='mode_selection:user_select', property={'modal_analysis': {'calculate_modes': True, 'mesh_structure': True, 'wavelength': wavelength, 'number_of_trial_modes': 20, 'search': 'max_index', 'calculate_group_index': True }}) src_res = simu[f'{simu_name}_cal_mode'].run() src_res.extract(data='calculate_modes', savepath=f'{plot_path}{kL[2]}_Preview_SourceMode', attribute='E', mode=0, real=True, imag=True, **export_options, show=False)  Parameters\tDefault\tType\tNotesmodal_analysis.mesh_structure\tfalse\tbool\tConfirm whether to generate a refractive index diagram for the structure. modal_analysis.calculate_modes\tfalse\tbool\tConfirm whether to calculate the mode for the structure. modal_analysis.wavelength\t1.55\tfloat\tThe mode wavelength for FDE calculation. modal_analysis.wavelength_offset\t0.002\tfloat\tThe mode wavelength offset for FDE calculation. modal_analysis.number_of_trial_modes\t20\tinteger\tWhen calculating modes, determine the calculated number of modes around the refractive index. modal_analysis.search\tmax_index\tstring\tCalculate the mode based on the maximum refractive index or user defined refractive index in the structure. Selections are ['near_n', 'max_index']. modal_analysis.n\t1\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the source mode. modal_analysis.calculate_group_index\tfalse\tbool\tDetermine whether to calculate the group refractive index. modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in bent waveguides. modal_analysis.bent_waveguide.radius\t1.0\tfloat\tSet the waveguide radius for bent waveguides. modal_analysis.bent_waveguide.orientation\t0.0\tfloat\tThe bent direction of the waveguide. modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. modal_analysis.mode_removal.threshold\t-\tfloat\tScreen the FDTD port source according to the energy arriving at the boundary to ensure the accuracy of the calculated transmission FDTD port mode. frequency_analysis.frequency_analysis\tfalse\tbool\tDetermine whether to invoke frequency analysis. frequency_analysis.start_wavelength\t1.55\tfloat\tSet the start frequency of the frequency analysis. frequency_analysis.stop_wavelength\t1.49896\tfloat\tSet the stop frequency of the frequency analysis. frequency_analysis.number_of_points\t10\tinteger\tSet the number of points in the frequency analysis frequency_analysis.effective_index\t1.0\tfloat\tTo search the mode near this refractive index. frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\tDetermine whether to calculate the dispersion of structure. "},{"title":"6.1.2 Beam overlap​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#612-beam-overlap","content":"Calculating beam overlap involves a two-step process within the FDE module. Firstly, it's necessary to acquire the FDE beam results and extract the relevant data. run_fde_beam_and_extract(self, *, property, export_csv=False, show=False, savepath=&quot;&quot;)  Parameters\tDescriptionproperty\tSet the property of beam to calculate overlap. export_csv\tWhether to save a file as csv format, defaults to False. show\tWhether to show figure or not, defaults as False savepath\tThe save path of heatmap and csv. Subsequently, we can execute the FDE overlap function and extract the result. run_fde_overlap_and_extract(self, *, property, savepath=&quot;a&quot;, export_csv=False)  Parameters\tDescriptionproperty\tSet the property of overlap calculation. savepath\tSave path of csv, defaults to &quot;a&quot;. export_csv\tWhether to export csv, defaults to False. Example: beam_res = simu[simu_name].run_fde_beam_and_extract( property={ &quot;define_gaussian_beam_by&quot;: &quot;waist_size_and_position&quot;, # [waist_size_and_position,beam_size_and_divergence], &quot;waist_radius&quot;: 10, &quot;distance_from_waist&quot;: 0, &quot;refractive_index&quot;: 1, &quot;theta&quot;: 0, &quot;phi&quot;: 0, &quot;polarization_angle&quot;: 0, &quot;sample_span&quot;: 10, &quot;sample_resolution&quot;: 200}, savepath=plot_path + 'beam_heatmap') overlap_res = simu[simu_name].run_fde_overlap_and_extract( property={&quot;add_global_mode&quot;: {&quot;task_path&quot;: beam_res.task_path, &quot;mode&quot;: 0}, &quot;mode&quot;: 0, &quot;optimize_position&quot;: True}, export_csv=True, savepath=plot_path + 'overlap')  "},{"title":"6.1.3 Bent Waveguide FDE simulation​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#613-bent-waveguide-fde-simulation","content":"Calculating the mode of a bent waveguide within the FDE module. simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={'general': {'solver_type': '2d_x_normal'}, 'mesh_settings': {'global_mesh_uniform_grid': {'dy': grid, 'dz': grid}}, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'calculate_group_index': True, 'bent_waveguide': {'bent_waveguide': True, 'radius': 5.25, 'orientation': 0, 'location': 'simulation_center'}}}})  Parameters\tDefault\tType\tNotesfde_analysis.modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool\tSelect whether to calculate modes in bent waveguides. fde_analysis.modal_analysis.bent_waveguide.radius\t0.0\tfloat\tSet the waveguide radius for bent waveguides. fde_analysis.modal_analysis.bent_waveguide.orientation\t0.0\tfloat\tThe bent direction of the waveguide. fde_analysis.modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSet the bent center position of bent waveguides. Selections are ['simulation_center']. "},{"title":"6.1.4 Far field​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#614-far-field","content":"To compute the far-field pattern within the FDE module. simu = pj.Simulation() simu.add(name=simu_name, type='FDE', property={'general': {'solver_type': '2d_z_normal'}, 'mesh_settings': {'global_mesh_uniform_grid': {'dx': grid, 'dy': grid}}, 'fde_analysis': { 'modal_analysis': { 'calculate_modes': run_options.run, 'mesh_structure': True, 'wavelength': wavelength, 'wavelength_offset': 0.0001, 'number_of_trial_modes': number_of_trial_modes, 'far_field_settings': [{'calculate': run_options.run_far_field, 'mode_selection': 0, 'material_index': 3.7, 'farfield_filter': 0, 'projection_distance': 8000, 'points_in_x': 50, 'points_in_y': 50, 'farfield_x_span': 40, 'farfield_y_span': 40, 'farfield_x': 0, 'farfield_y': 0}]}}})  Parameters\tDefault\tType\tNotesfde_analysis.modal_analysis.[]far_field_settings.calculate\ttrue\tbool\tDetermine whether to calculate the far field. fde_analysis.modal_analysis.[]far_field_settings.mode_selection\t-\tinteger\tSelect the mode for which far-field calculation is needed. fde_analysis.modal_analysis.[]far_field_settings.projection_method\tplanar\tstring\tSpecify the projection type for calculating the far-field.Selections are ['planar']. fde_analysis.modal_analysis.[]far_field_settings.farfield_filter\t0\tfloat\tConfigure this parameter to filter near field data for eliminating high frequency ripples in the results. Its value ranging from 0 to 1. fde_analysis.modal_analysis.[]far_field_settings.material_index\t1.4\tfloat\tSet the material refractive index for projection. fde_analysis.modal_analysis.[]far_field_settings.projection_distance\t4430.65\tfloat\tThe distance for far-field projection calculation. fde_analysis.modal_analysis.[]far_field_settings.points_in_x\t50\tfloat\tIn x direction, the number of points in the far field. fde_analysis.modal_analysis.[]far_field_settings.points_in_y\t50\tfloat\tIn y direction, the number of points in the far field. fde_analysis.modal_analysis.[]far_field_settings.farfield_x\t0\tfloat\tIn x direction, the position of far field center point. fde_analysis.modal_analysis.[]far_field_settings.farfield_x_span\t26.1834\tfloat\tIn x direction, the span of far field range. fde_analysis.modal_analysis.[]far_field_settings.farfield_y\t0\tfloat\tIn y direction, the position of far field center point. fde_analysis.modal_analysis.[]far_field_settings.farfield_y_span\t18.1231\tfloat\tIn y direction, the span of far field range. "},{"title":"6.2 EME​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#62-eme","content":"Incorporate an EME solver into the current project using the code type='EME'. add( self, *, name: str, type: Literal[&quot;EME&quot;], property: EmePostProcess, )  Example: simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 200, &quot;cell_number&quot;: 30, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 3, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_3&quot;, &quot;start&quot;: 50, &quot;stop&quot;: 250, &quot;number_of_points&quot;: 5}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}})  Parameters\tDefault\tType\tNotesgeneral.wavelength\t-\tfloat\tSpecify the wavelength for EME simulation. general.wavelength_offset\t0.002\tfloat\tSet the offset of wavelength in EME simulation. general.use_wavelength_sweep\tfalse\tbool\tConfirm whether to invoke wavelength sweep. eme_setup.cell_geometry.energy_conservation\tmake_passive\tstring\tSet the type of energy conservation when calculating the S matrix. Selections are ['none', 'make_passive']. eme_setup.cell_geometry.display_cells\tfalse\tbool\tConfirm whether to generate a preview of the EME cell when generating a structure preview. eme_setup.cell_geometry.display_groups\tfalse\tbool\tConfirm whether to generate a preview of the EME cell groups when generating a structure preview. eme_setup.cell_geometry.[]cell_group_definition.span\t-\tfloat\tSet the span of the cell group in EME simulation. eme_setup.cell_geometry.[]cell_group_definition.cell_number\t-\tinteger\tSet the number of the cell in EME simulation. eme_setup.cell_geometry.[]cell_group_definition.number_of_modes\t-\tinteger\tSet the number of the modes calculated in EME simulation. eme_setup.cell_geometry.[]cell_group_definition.sc\tnone\tstring\tSet the subcell method in EME simulation. Selections are ['none', 'sub_cell', 'sc']. eme_setup.cell_geometry.[]cell_group_definition.search\tmax_index\tstring\tCalculate the modes based on the maximum refractive index or user defined refractive index in the EME simulation. Selections are ['near_n', 'max_index']. eme_setup.cell_geometry.[]cell_group_definition.n\t1.0\tfloat\tUnder the 'near_n' condition, use this value of refractive index to search the modes in EME simulation. transverse_mesh_setting.global_mesh_uniform_grid.dx\t0.02\tfloat\tSet the global mesh grid of EME simulation region in x coordinate. transverse_mesh_setting.global_mesh_uniform_grid.dy\t0.02\tfloat\tSet the global mesh grid of EME simulation region in y coordinate. transverse_mesh_setting.global_mesh_uniform_grid.dz\t0.02\tfloat\tSet the global mesh grid of EME simulation region in z coordinate. transverse_mesh_setting.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat\tSet the minimum mesh step in EME simulation. advanced.eme_settings.max_stored_modes\t1000\tinteger\tThe maximum number of modes for EME simulation in each cell. thread_settings.thread\t4\tinteger\tDetermine the number of cores required to run the simulation on the local computer. eme_analysis.eme_propagate\tfalse\tbool\tDetermine whether to calculate the propogation fields and the s matrix. eme_analysis.periodicity.periodicity\tfalse\tbool\tSpecify whether to use periodicity to simplify structure in the EME simulation. eme_analysis.periodicity.[]periodic_group_definition.start_cell_group\t-\tinteger\tSet the start cell number for periodic structure. eme_analysis.periodicity.[]periodic_group_definition.end_cell_group\t-\tinteger\tSet the end cell number for periodic structure. eme_analysis.periodicity.[]periodic_group_definition.periods\t-\tinteger\tSet the repetition number of cells in the periodic structure. "},{"title":"6.2.1 EME CellGroup Custom Setting​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#621-eme-cellgroup-custom-setting","content":"This section provides guidance on configuring a customized EME cell group according to your specifications. Example: simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: {&quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2.5, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: 30, &quot;sc&quot;: sc_method, &quot;search&quot;: &quot;max_index&quot;}, {&quot;span&quot;: 5.2, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: 50, &quot;sc&quot;: sc_method, &quot;search&quot;: &quot;max_index&quot;, &quot;n&quot;: 1.5}, {&quot;span&quot;: 2.5, &quot;cell_number&quot;: cell_number, &quot;number_of_modes&quot;: 30, &quot;sc&quot;: sc_method, &quot;search&quot;: &quot;max_index&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_2&quot;, &quot;start&quot;: 41, &quot;stop&quot;: 61, &quot;number_of_points&quot;: 11}, &quot;wavelength_sweep&quot;: {&quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: wavelength - 0.05, &quot;stop&quot;: wavelength + 0.05, &quot;number_of_wavelength_points&quot;: 11}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}})  "},{"title":"6.2.2 EME Periodic Structure​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#622-eme-periodic-structure","content":"This section can guide you in configuring an EME periodic structure. Example: simu = pj.Simulation() simu.add(name=simu_name, type='EME', property={ 'general': {'wavelength': wavelength}, 'eme_setup': {'cell_geometry': { 'cell_group_definition': [ {'span': EME_marg, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}, {'span': wb, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}, {'span': ws, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}, {'span': EME_marg, 'cell_number': 1, 'number_of_modes': 10, 'sc': 'none'}]}}, 'transverse_mesh_setting': {'global_mesh_uniform_grid': {'dx':grid, 'dy': grid, 'dz': grid} }, 'eme_analysis': { 'eme_propagate': run_options.run, 'periodicity': {'periodicity': True, 'periodic_group_definition': [{'start_cell_group': 1, 'end_cell_group': 2, 'periods': grating_periods}]} }})  "},{"title":"6.2.3 EME propagation Sweep​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#623-eme-propagation-sweep","content":"Example: simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: 2, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 1, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}, {&quot;span&quot;: 200, &quot;cell_number&quot;: 30, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, {&quot;span&quot;: 3, &quot;cell_number&quot;: 1, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;none&quot;}]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: grid, &quot;dz&quot;: grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;propagation_sweep&quot;: {&quot;propagation_sweep&quot;: run_options.run_length_sweep, &quot;parameter&quot;: &quot;group_span_3&quot;, &quot;start&quot;: 50, &quot;stop&quot;: 250, &quot;number_of_points&quot;: 5}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}})  Parameters\tDefault\tType\tNoteseme_analysis.propagation_sweep.propagation_sweep\tfalse\tbool\tDetermine whether to sweep the length of structure for propagating in EME simulation. eme_analysis.propagation_sweep.parameter\tgroup_span_1\tstring\tSelect the cell group corresponding to the structure for which propagation sweep is needed. eme_analysis.propagation_sweep.start\t0\tfloat\tSet the starting length of the structure for propagation sweep. eme_analysis.propagation_sweep.stop\t1\tfloat\tSet the stopping length of the structure for propagation sweep. eme_analysis.propagation_sweep.number_of_points\t3\tinteger\tSet the number of points for propagation sweep. "},{"title":"6.2.4 EME wavelength Sweep​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#624-eme-wavelength-sweep","content":"Example: simu = pj.Simulation() simu.add(name=simu_name, type=&quot;EME&quot;, property={&quot;general&quot;: {&quot;wavelength&quot;: wavelength, &quot;use_wavelength_sweep&quot;: True}, &quot;eme_setup&quot;: { &quot;cell_geometry&quot;: { &quot;energy_conservation&quot;: &quot;make_passive&quot;, # [&quot;none&quot;,&quot;make_passive&quot;] &quot;cell_group_definition&quot;: [ {&quot;span&quot;: L-1, &quot;cell_number&quot;: 10, &quot;number_of_modes&quot;: number_of_modes, &quot;sc&quot;: &quot;sub_cell&quot;}, ]}}, &quot;transverse_mesh_setting&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: global_mesh_grid, &quot;dz&quot;: global_mesh_grid}}, &quot;eme_analysis&quot;: { &quot;eme_propagate&quot;: run_options.run, &quot;wavelength_sweep&quot;: { &quot;wavelength_sweep&quot;: run_options.run_wavelength_sweep, &quot;start&quot;: wavelength_start, &quot;stop&quot;: wavelength_stop, &quot;number_of_wavelength_points&quot;: wavelength_points}, &quot;select_source&quot;: {&quot;phase&quot;: 0, &quot;select_mode&quot;: &quot;TE&quot;}}})  Parameters\tDefault\tType\tNoteseme_analysis.wavelength_sweep.wavelength_sweep\tfalse\tbool\tDecide whether to sweep the wavelength in EME simulaiton. eme_analysis.wavelength_sweep.start\t1.5\tfloat\tSet the starting wavelength in EME simulaiton. eme_analysis.wavelength_sweep.stop\t1.6\tfloat\tSet the stopping wavelength in EME simulaiton. eme_analysis.wavelength_sweep.number_of_wavelength_points\t3\tinteger\tSet the number of points in wavelength range. eme_analysis.select_source.phase\t0\tfloat\tSet the phase of selected source in EME simulation. eme_analysis.select_source.select_mode\t-\tstring\tSet the type of mode propagating in the EME simulation. "},{"title":"6.3 FDTD​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#63-fdtd","content":"Incorporate an FDTD solver into the current project using the code type='FDTD'. add( self, *, name: str, type: Literal[&quot;FDTD&quot;], property: FdtdPostProcess, )  Example: simu = pj.Simulation() simu.add(name=simu_name, type='FDTD', property={'general': {'simulation_time': 10000, }, 'mesh_settings': {'mesh_type': 'auto_non_uniform', 'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}, 'minimum_mesh_step_settings': {'min_mesh_step': 1e-4}}, # 'advanced_options': {'auto_shutoff': {'auto_shutoff_min': 1.00e-4, 'down_sample_time': 200}}, # 'thread_setting': {'thread': 4} })  Parameters\tDefault\tType\tNotesgeneral.dimension\t3d\tstring\tDetermine the dimension type of the FDTD simulation. Selections are ['3d']. general.using_optical_path_estimate_time\tfalse\tbool\tChoose whether to use the time evaluated by system running the FDTD simulation. general.simulation_time\t1000\tinteger\tSet the simulation time in FDTD simulation. mesh_settings.mesh_type\tauto_non_uniform\tstring\tDecide the type of mesh in FDTD simulation. Selections are ['auto_non_uniform', 'uniform']. mesh_settings.mesh_accuracy.cells_per_wavelength\t15\tinteger\tUnder the 'auto_non_uniform' condition, this parameter helps to set the mesh accuarcy by using cell number in per wavelength. mesh_settings.mesh_step_settings.dx\t0.1\tfloat\tUnder the 'uniform' condition, this parameter helps to set the mesh accuarcy by using cell length in x coordinent. mesh_settings.mesh_step_settings.dy\t0.1\tfloat\tUnder the 'uniform' condition, this parameter helps to set the mesh accuarcy by using cell length in y coordinent. mesh_settings.mesh_step_settings.dz\t0.1\tfloat\tUnder the 'uniform' condition, this parameter helps to set the mesh accuarcy by using cell length in z coordinent. mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat\tUnder the 'auto_non_uniform' condition, this parameter helps to set the minimum mesh step. advanced_options.auto_shutoff.use_early_shutoff\ttrue\tbool\tDecide whether to use early shutoff. advanced_options.auto_shutoff.auto_shutoff_min\t1.0e-4\tfloat\tControl the simulation shutoff based on the ratio of energy to the maximum input energy. advanced_options.auto_shutoff.down_sample_time\t100\tfloat\tInspect the auto shutoff conditions every down sample time. advanced_options.live_slice_filed_display_settings.show_field\tfalse\tbool\tDecide whether to gennerate the electric intensity filed image for the results. advanced_options.live_slice_filed_display_settings.select_field_section\t2d_z_normal\tstring\tDecide the type of the field image. Selections are ['2d_y_normal', '2d_z_normal']. advanced_options.live_slice_filed_display_settings.select_component\tex\tstring\tDecide the field component to show in the image. Selections are ['ex', 'ey', 'ez']. advanced_options.live_slice_filed_display_settings.time_interval\t200\tfloat\tSet the time interval for displaying image. advanced_options.live_slice_filed_display_settings.position\t0\tfloat\tSet the center position of the field image. thread_setting.thread\t4\tinteger\tDetermine the number of cores required to run the simulation on the local computer. "},{"title":"6.3.1 Far field​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#631-far-field","content":"This section can assist you in computing the far-field pattern within the FDTD module. fdtd_res = simu[simu_name].run() ff_res = fdtd_res.calculate( monitor_name=&quot;through&quot;, property={&quot;wavelength&quot;: 1.31, &quot;far_field_settings&quot;: { &quot;general&quot;: {&quot;projection_direction&quot;: &quot;forward&quot;, &quot;material_index&quot;: 1, &quot;far_field_filter&quot;: 0, &quot;resolution&quot;: {&quot;horizontal_points&quot;: 100, &quot;vertical_points&quot;: 100}}}})  "},{"title":"6.3.2 FDTD smatrix sweep​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#632-fdtd-smatrix-sweep","content":"When we use the FDTD port as the input source, we can assist you in computing the smatrix sweep within the FDTD module. # region --- Port --- pt = pj.Port(property={'waveform_id': wv[waveform_name], 'source_port': 'left_port'}) pt.add(name='left_port', type='fdtd_port', property={'geometry': {'x': -wg_length / 2 + span, 'x_span': 0, 'y': 0, 'y_span': port_width, 'z': 0, 'z_span': port_height}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'forward', 'mode_selection': 'fundamental'}}}) if run_options.matrix_sweep: pt.add(name='right_port', type='fdtd_port', property={'geometry': {'x': wg_length / 2 - span, 'x_span': 0, 'y': 0, 'y_span': port_width, 'z': 0, 'z_span': port_height}, 'modal_properties': {'general': {'inject_axis': 'x_axis', 'direction': 'backward', 'mode_selection': 'fundamental'}}}) # endregion # region --- Simulation --- simu = pj.Simulation() simu.add(name='fdtd', type='FDTD', property={'general': {'simulation_time': 1000}, 'mesh_settings': {'mesh_accuracy': {'cells_per_wavelength': grids_per_lambda}}}) if run_options.matrix_sweep: smatrix_res = simu.add(name='matrix_sweep', type='FDTD:smatrix', property={'simulation_name': 'fdtd', 's_matrix_setup': [{'port': 'left_port', 'active': True}, {'port': 'right_port', 'active': True}]}) # endregion  "},{"title":"6.4 Sweep:FDTD/FDE/EME​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#64-sweepfdtdfdeeme","content":"Integrate a sweep module into the current project add( self, *, name: str, type: Literal[&quot;FDTD:sweep&quot;, &quot;FDE:sweep&quot;, &quot;EME:sweep&quot;], property: AnyParameterSweepPostProcess, )  An example of FDTD sweep is presented in the following code. Example: simu = pj.Simulation() simu.add(type='FDTD:sweep', name='FDTDSweep', property={ 'simulation_name': simu_name, 'sweep_type': 'values', 'parameters': [{ 'variable': gap, 'values': [0.45, 0.55, 0.65], }], 'result': [ {'name': resultL[0], 'result': 'through', 'component': 'T'}, {'name': resultL[1], 'result': 'cross', 'component': 'T'}, {'name': resultL[2], 'result': 'through_me', 'component': 'T_forward'}, {'name': resultL[3], 'result': 'cross_me', 'component': 'T_forward'} ] })  A FDE sweep is provided in the subsequent code example. simu = pj.Simulation() simu.add(type=&quot;FDE:sweep&quot;, name=&quot;FDESweep&quot;, property={ &quot;simulation_name&quot;: simu_name, &quot;sweep_type&quot;: &quot;values&quot;, &quot;parameters&quot;: [{&quot;variable&quot;: width, &quot;values&quot;: [0.5, 0.7, 0.9]}], &quot;result&quot;: [{&quot;name&quot;: result[0], &quot;component&quot;: &quot;mode2:neff&quot;, &quot;result&quot;: &quot;FDE:Structure Sweep&quot;}, {&quot;name&quot;: result[1], &quot;component&quot;: &quot;mode1:neff&quot;, &quot;result&quot;: &quot;FDE:Structure Sweep&quot;}, {&quot;name&quot;: result[2], &quot;component&quot;: &quot;mode1:loss&quot;, &quot;result&quot;: &quot;FDE:Structure Sweep&quot;}, ] })  An example of EME sweep is presented in the following code. simu = pj.Simulation() simu.add( type='EME:sweep', name='EMESweep', property={ 'simulation_name': simu_name, 'parameters': [ {'variable': gap, 'number_of_points': 3, 'start': 0.45, 'stop': 0.65} ], # 'sweep_type': 'values', # 'parameters': [ { 'variable': gap, 'values': [0.45, 0.55, 0.65] } ], 'result': [ {'name': 'SMatrix', 'component': 'S', 'result': 'S-Matrix'} ] }, )  Parameters\tDefault\tType\tNotessimulation_name\t-\tstring\tSet the sweep name in the simulation. sweep_type\tranges\tstring\tSet the type of valuse to sweep parameters in the simulation. Selections are ['ranges', 'values']. []parameters.variable float\tInvoke the specific variable for sweep. []parameters.start float\tUnder the 'ranges' circumstances, we can decide the initial value of the variable. []parameters.stop float\tUnder the 'ranges' circumstances, we can decide the stopping value of the variable. []parameters.number_of_points integer\tDecide the number of points in the range of variable. []parameters.values list\tUnder the 'values' circumstances, we can give the value of the variable. []result.name string\tSet the name in the sweep function. []result.result string\tGet the related results. []result.component string\tInvoke the related componet in results. "},{"title":"6.5 OEDevice​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#65-oedevice","content":"Incorporate an OEDevice(Optic Eletrical Devices) solver into the current project using the code type='OEDevice'. add( self, *, name: str, type: Literal[&quot;OEDevice&quot;], property: OeDevicePostProcess, )  Example: simu = pj.Simulation() simu.add(name=&quot;preview_fdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}}) simu.add(name=&quot;preview_oedevice&quot;, type=&quot;OEDevice&quot;, property={ &quot;geometry&quot;: {&quot;dimension&quot;: &quot;2d_x_normal&quot;, &quot;x&quot;: oe_x_mean, &quot;x_span&quot;: 0, &quot;y&quot;: oe_y_mean, &quot;y_span&quot;: oe_y_span, &quot;z_min&quot;: oe_z_min, &quot;z_max&quot;: oe_z_max}, &quot;genrate&quot;: {&quot;genrate_path&quot;: &quot;&quot;, &quot;coordinate_unit&quot;: &quot;m&quot;, &quot;field_length_unit&quot;: &quot;m&quot;, &quot;source_fraction&quot;: source_fraction}, &quot;general&quot;: {&quot;norm_length&quot;: normal_length, &quot;solver_mode&quot;: &quot;steady_state&quot;, &quot;simulation_temperature&quot;: temperature}, &quot;advanced&quot;: {&quot;non_linear_solver&quot;: &quot;Newton&quot;, &quot;linear_solver&quot;: &quot;MUMPS&quot;, &quot;max_iterations&quot;: 50}})  Parameters\tDefault\tType\tNotesgeneral.simulation_region\tDevice_Region\tstring\tSelections are ['Device_Region']. general.norm_length\t1\tfloat general.solver_mode\tsteady_state\tstring\tSelections are ['steady_state', 'transient', 'SSAC']. general.temperature_dependence\tIsothermal\tstring\tSelections are ['Isothermal']. general.simulation_temperature\t300\tfloat advanced.non_linear_solver\tNewton\tstring\tSelections are ['Newton']. advanced.linear_solver\tMUMPS\tstring\tSelections are ['MUMPS', ' LU', ' BCGS']. advanced.use_quasi_fermi\tdisabled\tstring\tSelections are ['disabled', ' enabled']. advanced.damping\tnone\tstring\tSelections are ['none', ' potential']. advanced.potential_update\t1\tinteger advanced.multi_threads\tlet_solver_choose\tstring\tSelections are ['let_solver_choose', 'set_thread_count']. advanced.thread_count\t4\tinteger advanced.max_iterations\t30\tinteger advanced.use_global_max_iterations\tfalse\tinteger\tSelections are ['false', 'true'] advanced.poisson_max_iterations\t30\tinteger advanced.ddm_max_iterations\t30\tinteger advanced.relative_tolerance\t1.0e-5\tfloat advanced.tolerance_relax\t1.0e+5\tfloat advanced.divergence_factor\t1.0e+25\tfloat genrate.genrate_path string genrate.source_fraction float genrate.coordinate_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. genrate.field_length_unit\tm\tstring\tSelections are ['m', 'cm', 'um', 'nm']. geometry.dimension\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal']. geometry.x float geometry.x_span float geometry.x_min float geometry.x_max float geometry.y float geometry.y_span float geometry.y_min float geometry.y_max float geometry.z float geometry.z_span float geometry.z_min float geometry.z_max float small_signal_ac.perturbation_amplitude\t0.001\tfloat small_signal_ac.frequency_spacing\tsingle\tstring\tSelections are ['single', 'linear', 'log']. small_signal_ac.frequency\t1.0e+6\tfloat small_signal_ac.start_frequency\t1.0e+06\tfloat small_signal_ac.stop_frequency\t1.0e+09\tfloat small_signal_ac.frequency_interval\t9.9999e+10\tfloat small_signal_ac.num_frequency_points\t2\tinteger small_signal_ac.log_start_frequency\t1.0e+06\tfloat small_signal_ac.log_stop_frequency\t1.0e+10\tfloat small_signal_ac.log_num_frequency_points\t2\tinteger\t "},{"title":"6.6 AFDTD​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#66-afdtd","content":"Incorporate an AFDTD(Active Finite-Difference Time-Domain) solver into the current project using the code type='AFDTD'. add( self, *, name: str, type: Literal[&quot;AFDTD&quot;], property: FdtdPostProcess, )  Example: simu = pj.Simulation() simu.add(name=&quot;preview_fdtd&quot;, type=&quot;AFDTD&quot;, property={ &quot;mesh_settings&quot;: {&quot;mesh_accuracy&quot;: {&quot;cells_per_wavelength&quot;: cells_per_wavelength}}})  Parameters\tDefault\tType\tNotesextra.fdtd_port_group.source_port string general.dimension\t3d\tstring\tSelections are ['3d']. general.using_optical_path_estimate_time\tfalse\tbool general.simulation_time\t1000\tinteger mesh_settings.mesh_type\tauto_non_uniform\tstring\tSelections are ['auto_non_uniform', 'uniform']. mesh_settings.mesh_accuracy.cells_per_wavelength\t15\tinteger mesh_settings.mesh_step_settings.dx\t0.1\tfloat mesh_settings.mesh_step_settings.dy\t0.1\tfloat mesh_settings.mesh_step_settings.dz\t0.1\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat advanced_options.auto_shutoff.use_early_shutoff\ttrue\tbool advanced_options.auto_shutoff.auto_shutoff_min\t1.0e-4\tfloat advanced_options.auto_shutoff.down_sample_time\t100\tfloat advanced_options.live_slice_filed_display_settings.show_field\tfalse\tbool advanced_options.live_slice_filed_display_settings.select_field_section\t2d_z_normal\tstring\tSelections are ['2d_y_normal', '2d_z_normal']. advanced_options.live_slice_filed_display_settings.select_component\tex\tstring\tSelections are ['ex', 'ey', 'ez']. advanced_options.live_slice_filed_display_settings.time_interval\t200\tfloat advanced_options.live_slice_filed_display_settings.position\t0\tfloat thread_setting.thread\t4\tinteger\t （解释各个标题，以及将OED放在最前面，AFDE属于OED） "},{"title":"6.7 AFDE​","type":1,"pageTitle":"Simulation","url":"/my-website/docs/test/v2_core/6Simulation#67-afde","content":"Integrate an AFDE(Active Finite Difference Eigenmode) solver into the current project using the code type='AFDE'. add( self, *, name: str, type: Literal[&quot;AFDE&quot;], property: AfdePostProcess, )  Example: simu = pj.Simulation() simu.add(name=&quot;preview_fde&quot;, type=&quot;AFDE&quot;, property={ &quot;mesh_settings&quot;: {&quot;global_mesh_uniform_grid&quot;: {&quot;dy&quot;: ogrid_global_y, &quot;dz&quot;: ogrid_global_z}}, &quot;fde_analysis&quot;: {&quot;modal_analysis&quot;: {&quot;calculate_modes&quot;: False, &quot;mesh_structure&quot;: False, &quot;wavelength&quot;: wavelength}, &quot;modulator_analysis&quot;: {&quot;modulator_analysis&quot;: True, &quot;wavelength&quot;: wavelength, &quot;np_path&quot;: &quot;&quot;}}, &quot;other&quot;: {**Si_index_vs_doping}})  Parameters\tDefault\tType\tNotesgeneral.solver_type\t2d_x_normal\tstring\tSelections are ['2d_x_normal', '2d_y_normal', '2d_z_normal', 'x', 'y', 'z']. mesh_settings.global_mesh_uniform_grid.dx\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dy\t0.02\tfloat mesh_settings.global_mesh_uniform_grid.dz\t0.02\tfloat mesh_settings.minimum_mesh_step_settings.min_mesh_step\t0.0001\tfloat thread_setting.thread\t4\tinteger fde_analysis.modal_analysis.mesh_structure\tfalse\tbool fde_analysis.modal_analysis.calculate_modes\tfalse\tbool fde_analysis.modal_analysis.[]far_field_settings.calculate\ttrue\tbool fde_analysis.modal_analysis.[]far_field_settings.mode_selection integer fde_analysis.modal_analysis.[]far_field_settings.projection_method\tplanar\tstring\tSelections are ['planar']. fde_analysis.modal_analysis.[]far_field_settings.farfield_filter\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.material_index\t1.4\tfloat fde_analysis.modal_analysis.[]far_field_settings.projection_distance\t4430.65\tfloat fde_analysis.modal_analysis.[]far_field_settings.points_in_x\t50\tfloat fde_analysis.modal_analysis.[]far_field_settings.points_in_y\t50\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_x\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_x_span\t26.1834\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_y\t0\tfloat fde_analysis.modal_analysis.[]far_field_settings.farfield_y_span\t18.1231\tfloat fde_analysis.modal_analysis.wavelength\t1.55\tfloat fde_analysis.modal_analysis.wavelength_offset\t0.002\tfloat fde_analysis.modal_analysis.number_of_trial_modes\t5\tinteger fde_analysis.modal_analysis.search\tmax_index\tstring\tSelections are ['near_n', 'max_index']. fde_analysis.modal_analysis.n\t1\tfloat fde_analysis.modal_analysis.calculate_group_index\tfalse\tbool fde_analysis.modal_analysis.bent_waveguide.bent_waveguide\tfalse\tbool fde_analysis.modal_analysis.bent_waveguide.radius\t0.0\tfloat fde_analysis.modal_analysis.bent_waveguide.orientation\t0.0\tfloat fde_analysis.modal_analysis.bent_waveguide.location\tsimulation_center\tstring\tSelections are ['simulation_center']. fde_analysis.modal_analysis.mode_removal.threshold float fde_analysis.frequency_analysis.frequency_analysis\tfalse\tbool fde_analysis.frequency_analysis.start_wavelength\t1.55\tfloat fde_analysis.frequency_analysis.stop_wavelength\t1.49896\tfloat fde_analysis.frequency_analysis.number_of_points\t10\tinteger fde_analysis.frequency_analysis.effective_index\t1.0\tfloat fde_analysis.frequency_analysis.detailed_dispersion_calculation\tfalse\tbool\t "},{"title":"Structure","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/3Structure","content":"","keywords":""},{"title":"1 Structures​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#1-structures","content":"  There are Triangle, Rectangle, Circle, Ring, Polygon, Sector, Ellipse, ArcWaveguide, ArcWaveguide3D, Linear Trapezoid, Pyramid and Bezier ArcWaveguide 3D. All structures support 3d modeling, and meet X, Y, Z direction rotation. "},{"title":"1.1 Triangle​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#11-triangle","content":" "},{"title":"1.2 Rectangle​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#12-rectangle","content":" "},{"title":"1.3 Circle​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#13-circle","content":" "},{"title":"1.4 Ring​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#14-ring","content":" "},{"title":"1.5 Polygon​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#15-polygon","content":" "},{"title":"1.6 Sector​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#16-sector","content":" "},{"title":"1.7 Ellipse​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#17-ellipse","content":" "},{"title":"1.8 Arc Waveguide​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#18-arc-waveguide","content":" "},{"title":"1.9 Arc Waveguide 3D​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#19-arc-waveguide-3d","content":" "},{"title":"1.10 Linear Trapezoid​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#110-linear-trapezoid","content":" "},{"title":"1.11 Pyramid​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#111-pyramid","content":" "},{"title":"1.12 Bezier 3D Waveguide​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#112-bezier-3d-waveguide","content":" Notes: Material Data Tab: User can view each material property via double clicking a certain material in material drop-down menu. Material properties include wavelength, frequency and Re (Index/permittivity), Im (Index/permittivity).  "},{"title":"2 Work Flows:​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#2-work-flows","content":""},{"title":"2.1 Add method:​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#21-add-method","content":"Click “Structures” button and select one structure from drop-down menu   "},{"title":"2.2 Edit Structure pop-up window methods:​","type":1,"pageTitle":"Structure","url":"/my-website/docs/tutorial/3Structure#22-edit-structure-pop-up-window-methods","content":"Edit pop-up window directly after each time structure adding; Left single click object in the “Object Tree”; Right single click object in the “Object Tree”, and select “Edit” in the drop-down menu;    __Transform**: Allow user to operate the object via the four features, include translate, scale, rotate and mirror.   Select “Edit Properties” tool in the shortcut bar.   "},{"title":"FDTD Solver","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/4Simulation/2FDTD","content":"","keywords":""},{"title":"1 Tool bar​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#1-tool-bar","content":""},{"title":"1.1 General tab​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#11-general-tab","content":" 1)Dimension: Number of dimensions of the simulation region. (Default: 3D) 2)Using Optical Path Estimate Time: It is the switch button that the estimation of simulation time based on optical path. 3)Estimate Time: Estimated simulation time. (when “Using Optical Path Estimate Time” is enabled, it is displayed and non-editable. 4)Simulation Time: Simulation time indicates the maximum duration of the simulation to be implemented. In reality the simulation may end earlier when some of the auto-shutoff conditions are satisfied before running till this maximum simulation time. (Default: 1000 fs) 5)Background Material: The combo box allows user to set the background material from drop down menu. “Project”, “Object Defined Dielectric”, and “Go to Material Library” can be operated. 6)Project: The “Background Material” can be selected from the “Project” sublist in the “Material Database” based upon the needs. 7)Object Defined Dielectric: The object-defined dielectric material, a default setting if user forgets to set background material, is defined for the current object background material setting, and once the user chooses this option, he does not need to set any material from the standard, user, or project material database. And the object-defined dielectric will not be loaded into any material database. Go to Material Library: If selected, user can go to standard material database to set background material according to needs. And the selected material relative property from standard material database will be displayed in the material data list. 8)Index: The refractive index of the surrounding, background medium in the simulation region.（Default: 1) "},{"title":"1.2 Geometry tab:​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#12-geometry-tab","content":" 1)X, Y, Z: The center position of the simulation region. 2)X Min, X Max: X min, X max position. 3)Y Min, Y Max: Y min, Y max position. 4)Z Min, Z Max: Z min, Z max position. 5)X Span, Y Span, Z Span: X, Y, Z span of the simulation region. "},{"title":"1.3 Mesh Settings tab:​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#13-mesh-settings-tab","content":" 1) Mesh Type:Two types of mesh generation algorithms are available, as described below; ① Auto non-uniform (Default) A non-uniform mesh is automatically generated based on the mesh accuracy slider bar. ② Uniform A uniform mesh is applied to the entire simulation volume, regardless of any material properties. If a mesh override region is used in conjunction with this option, the override region will force the mesh size everywhere, not just within the override region (the mesh is uniform). 2) Mesh Accuracy: Sets cells per wavelength. The default set is 15. 3) Minimum Mesh Step Settings: Set the absolute minimum mesh size for the entire solver region. 4) Mesh Refinement: Mesh refinement can give sub-cell accuracy for a simulation. ① Staircase: The material at each position of the Yee cell is evaluated to determine which material it is in, and the E field at that location uses only that single material property. The resulting discretized structure is unable to account for structure variations that occur within any single Yee cell, resulting in a &quot;staircase&quot; permittivity mesh that coincides with the Cartesian mesh furthermore, any layers are effectively moved to the nearest E field position on the Yee cell, meaning that layer thickness cannot be resolved to better than dx. ② Curve Mesh: Effective permittivities are derived using a contour path approach that accounts for the boundary conditions of the electromagnetic field at dielectric interfaces. 5) Grading: Grading factor, determines the maximum ratio of the neighboring spatial steps. "},{"title":"1.4 Boundary Conditions tab:​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#14-boundary-conditions-tab","content":" 1) PML: Perfectly matched layer (PML) boundaries absorb electromagnetic waves incident upon them. They essentially model open (or reflectionless) boundaries. 2) PEC: PEC boundary conditions are used to specify boundaries that behave as a Perfect Electric Conductor (PEC). Metal boundaries are perfectly reflecting, allowing no energy to escape the simulation volume along that boundary. 3) PML settings: When the state of the Same Settings on All Boundary Conditions is on, all PML boundaries share the same profile based on the properties listed in the table, including “Layers”, “Kappa”, “Sigma”, “Polynomial”, “Alpha”, “Alpha Polynomial”, “Min Layers”, and “Max Layers”; otherwise, each PML boundary can be set individually. 4) X/Y/Z min/ max PML: These fields describe the boundary conditions to be applied along the perimeter of the simulation region. "},{"title":"1.5 Advanced Options tab:​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#15-advanced-options-tab","content":" 1) Auto Shutoff : Stops the simulation when the energy in the simulation goes below the “Auto Shutoff Min” when the “Use Early Shutoff ” state is on , you can set min auto shutoff (Default: 1e-4) and down sample time (Default: 200) 2)Down sample time: The time step down sampling. (It is default: 200, and 10 &lt;= it &lt;= 1000) 3)Live Slice Field Display Settings ① Show Field: Real-time filed slice display switch. (Default: on) ② Select Field Section: Combo box allows you to choose from a list of 2D planes normal to the axes for field display. ( 2D Z Normal by default） ③ Select Component：Combo box allows you to choose from a list of the existing field components ( Ex by default) ④ Time Interval: The time step down sampling (200 fs by default) ⑤ Position: The position of slice (0 μm by default) "},{"title":"1.6 Thread Settings tab:​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#16-thread-settings-tab","content":" 1) Thread：Through thread setting can improve running effects, which makes simulation significantly faster than prior. (Default: 4) "},{"title":"2 Simulation Cases:​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#2-simulation-cases","content":"Objectives:In this example, we show how to use Max-Optics to run FDTD and view the simulation result. Works Flow:   "},{"title":"2.1 Modeling​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#21-modeling","content":"2.1.1 Material database settings​ Press on &quot;Material&quot; button, the material database window will bring out, and import new materials from standard material database or user material database into project material database according to user needs.( when import success a prompt information will pop out informs that Import Success. Success: 1/1, Fail: 0/1 (duplicated)). Material work flows:   2.1.2 Add a rectangle​ Press arrow on the “Structures” button, and select a Rectangle from the drop-down menu. Set the properties of the substrate rectangle according to the following table. Menu bar-&gt;Structures-&gt;Rectangle-&gt;Geometry-&gt;Material   2.1.3 Waveforms setting​ Press arrow on the “Waveforms” button in the menu bar, then add the waveform with name: ”Waveform0” under the project waveform and set the properties in Waveforms dialog box.       "},{"title":"2.2 Add FDTD​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#22-add-fdtd","content":"Press arrow on the “Simulation” button in the menu bar, and select “FDTD” from the drop-down menu, and set the properties according to the following table.   "},{"title":"2.3 Add Mode Source​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#23-add-mode-source","content":"Press arrow on the “Mode Source” button in the menu bar, and select “Mode Source” from the drop-down menu. Set the properties of mode source according to the following table     "},{"title":"2.4 Add Power Monitor​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#24-add-power-monitor","content":"Press arrow on the “Monitor” button in the menu bar, and select “Frequency-Domain Field and Power” from the drop-down menu. Set the properties of power monitor according to the following table.   Notes: Before simulation, please press “File” button, and select “Save” from drop-down manual, manually. (File -&gt; Save) "},{"title":"2.5 Run​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#25-run","content":"Press arrow on the “Run” button in the menu bar and select “Run FDTD” from drop-down menu.   "},{"title":"2.6 Result View​","type":1,"pageTitle":"FDTD Solver","url":"/my-website/docs/tutorial/4Simulation/2FDTD#26-result-view","content":"You can check the simulation result via clicking items in the “Result View”. 2.6.1 FDTD Monitor-&gt;Power Monitor-&gt;Image tab​   2.6.2 FDTD Monitor-&gt; Power Monitor-&gt;Line tab​ In these windows, you can view different plot types, and they are interested in via settings in relative sections.   "},{"title":"FDE Solver","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/4Simulation/1FDE","content":"","keywords":""},{"title":"1 Tool bar​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#1-tool-bar","content":"In this example, we show how to use Max-Optics local passive to run FDE and view the simulation result. "},{"title":"1.1 General tab​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#11-general-tab","content":" 1)Solver Type: Chooses either a 2D X/Y/Z normal. (Default: 2D X normal) 2)Background Material: The combo box allow user to set the background material from drop down menu. Project, object defined dielectric, and go to material library can be operated. Project: The background material inherits from the project’s material setting. Object Defined Dielectric: The object-defined dielectric material, a default setting if user forgets to set background material, is defined for the current object background material setting, and once the user chooses this option, he does not need to set any material from the standard, user, or project material database. And the object-defined dielectric will not be loaded into any material database. Go to Material Library: If selected, user can go to standard material database to set background material according to needs. And the selected material relative property from standard material database will be displayed in the material data list. Index: specify background index manually in stead of choosing form library. (Default :1). "},{"title":"1.2 Geometry tab​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#12-geometry-tab","content":" 1)X, Y, Z: The center of the simulation region. 2)X Min, X Max: minimal and maximal.in x direction 3)Y Min, Y Max: minimal and maximal.in y direction. 4)Z Min, Z Max: minimal and maximal.in z direction 5)X Span, Y Span, Z Span: X, Y, Z span of the simulation region. (Notes: The availability is based on the solver type.) "},{"title":"1.3 Mesh setting tab​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#13-mesh-setting-tab","content":" 1)Mesh Definition: There is one option: global uniform mesh step, which means all the mesh steps are uniform in the simulation region. 2)Define X Mesh/ Define Y Mesh/ Define Z Mesh: Maximum mesh step. 3)Mesh Refinement: Mesh refinement can give sub-cell accuracy for a simulation. ①Staircase: The material at each position of the Yee cell is defined as the material occupies majority space of the cell. Resulting a “staircase” like permitivity mesh. ②Curve Mesh:Effective permittivities can be derived via a contour path recipe, which effectively takes the dielectric interface shapes, as well as material weight inside a cell into account. 4)DX/DY/DZ: Maximum mesh step settings. The default setting is 0.02 μm. 5)Mesh Grading: In the case of a non-uniform mesh, Mesh Grading specifies the maximum ratio at which a neighboring grid can be enlarged or reduced. For instance, if dx(k+1) = c*dx(k), then 1/(GRADING FACTOR) &lt;= c &lt;= GRADING FACTOR. It is recommended that 1 &lt;= GRADING FACTOR &lt;= sqrt(2). (Default: 1.2) Minimum Mesh Step Settings: This indicates the minimum mesh step for the whole region managed by the solver (including also the mesh override regions). (Default: 0.0001μm) "},{"title":"1.4 Boundary conditions tab​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#14-boundary-conditions-tab","content":" 1)PML: The electromagnetic waves indicent upon a perfectly matched layer (PML) boundary will all be absorbed without any reflection at all frequencies and omni direction, i.e., a PML mimics in essence an ideally open (or reflectionless) boundary. In contrast to conventional boundary conditions, a PML boundary occupies a finite volume surrounding the simulation region and hence possesses only a finite thickness, and the process of light absorption takes place inside this thickness span. ①LAYERS: specify the number of layers PML regions are to be divided. ②KAPPA, SIGMA, ALPHA : Kappa and sigma are used for controlling the absorption performance of PML boundaries according to the simulation needs. As can be found in the reference, kappa is unitless by definition, while sigma requires normalization before being entered into the PML settings table as a unitless value. Specifically, kappa and sigma are both evaluated through polynomial variations with respect to their geometric positions inside the PML regions. ③PML Polynomial: This determines the degree of the polynomial utilized to grade kappa and sigma. 2)PEC: Metal boundary conditions are used to specify boundaries that behave as a Perfect Electric Conductor (PEC), Metal boundaries are perfectly reflecting, allowing no energy to escape the simulation volume along that boundary. 3)PMC: Perfect Magnetic Conductor (PMC) boundary conditions are introduced to be the magnetic correspondence of the metal (PEC) boundaries. 4)Symmetry/Anti-symmetry: When investigating a system that exhibits one or more axes/planes of symmetry, the symmetric/anti-symmetric boundary conditions are frequently employed, for both the structure and the source. For the electric field, symmetric boundaries serve as mirrors and anti-symmetric boundaries serve as anti-mirrors---whereas for the magnetic field, the story is exactly the opposite. For a desired vector symmetry of the solution, the choice between the symmetric or anti-symmetric boundary conditions is often of pivotal importance. Note that the sources and the boundary conditions must use the same type of symmetry for the results to be meaningful. 5)Periodic: Periodic BCs allow you to analyze the whole system by studying only one unit cell if the interested system is somewhat spatially periodic, and they are easily enabled by setting the simulation span identical to the length of one unit cell, plus choosing then &quot;Periodic BCs&quot; for that boundary. Upon doing so, the EM fields at one side of the unit cell (which is subjected to Periodic BCs) are always duplicated accordingly at the other side during the entire simulation. Notes: It is crucial to keep in mind that when employing Periodic Boundary Conditions (PBCs), both the physical structure and the electromagnetic (EM) fields in the system must be periodic. Neglecting this key aspect often leads to errors, such as utilizing PBCs in systems with a periodic structure but non-periodic EM fields. "},{"title":"1.5 Advanced tab​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#15-advanced-tab","content":" 1)Dispersion Settings: Sets dispersion. Fractional Offset for Group Delay: Numerically, the group delay of the device is computed by means of a finite-difference approximation of diffentiating the phase with respect to frequency. The “fractional offset for group delay” refers to the fractional amount of the frequency used in the step size of finite difference. If this setting is too small, the phase change may be severely affected by noise, whereas a too large setting could result in an unrealistic group delay since the phase may change by more than 2π. For rather long devices (10000+ wavelengths) in which the phase varies quickly with frequency, the user is encouraged to reduce this setting from the default value. Otherwise the default setting is generally recommended. (Default:0.0001 μm) ng=neff−λΔneffλoffsetn_{g}=n_{eff} -\\lambda \\frac{\\Delta n_{eff}}{\\lambda_{offset} } ng​=neff​−λλoffset​Δneff​​ "},{"title":"1.6 Thread Settings tab​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#16-thread-settings-tab","content":" 1)Thread：Through thread setting can improve running effects, which makes simulation significantly faster than prior. (Default: 4) "},{"title":"2 Simulation Cases:​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#2-simulation-cases","content":"In this example, we show how to use Max-Optics local passive to run FDE and view the simulation result. Work Flow   "},{"title":"2.1 Modeling​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#21-modeling","content":"Material database settings: Press on &quot;Material&quot; button, the material database window will bring out, and import new materials from standard material database or user material database into project material database according to user needs.( when import success a prompt information will pop out informs that “Import Success. Success: 1/1, Fail: 0/1 (duplicated).”) Material work flows:  Add a rectangle: Press arrow on the “Structures” button, and select a Rectangle from the drop-down menu. Set the properties of the rectangle according to the following table. Menu bar-&gt;Structures-&gt;Rectangle-&gt;Geometry-&gt;Material  "},{"title":"2.2 Add FDE​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#22-add-fde","content":"Press arrow on the “Simulation” button, and select the FDE from the drop-down menu, and set the properties according to the following table.  Notes: For other settings like “boundary conditions”, “advanced” and “thread setting “are adopted by default, additionally, before simulation, please press “File” button, and select “Save” from drop-down menu, manually. (File -&gt; Save) "},{"title":"2.3 Run​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#23-run","content":"Press arrow on the “Run” button in the menu bar and select “Run FDE” from drop-down menu.After pressing “Run FDE” button, a FDE Analysis window will pop out, and You can choose modal analysis or frequency analysis to calculate.  After pressing the “Calculate Modes” button, the simulation process will display on the right side Task Tree bar.   "},{"title":"2.4 Result view​","type":1,"pageTitle":"FDE Solver","url":"/my-website/docs/tutorial/4Simulation/1FDE#24-result-view","content":"Press “OK” button after simulation finishing, and view the result in the Result View.   Notes: If you want to change a certain parameter (e.g., the wavelength value) and simulation again you can change wavelength value in the modal analysis window and press “Calculate modes” directly without modeling again After setting the wavelength value to 1.56um, press the “Calculate Modes” button. You can view the simulation result in the Result View, when wavelength value equals to 1.56um.  You also can view other plot image via Mode plot options. If You want to get frequency analysis result, you can switch to “Frequency Analysis” tab, and set the relative parameters in the“Frequency Analysis” window. Then press the “Frequency Analysis” button.  Press “OK” button after simulation finishing, and view the result in the Result View.   After running, the result will be saved in Task Tree automatically   You also can view the result in Result View via clicking the FDE result item.  "},{"title":"EME Solver","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/4Simulation/3EME","content":"","keywords":""},{"title":"1 Tool bar​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#1-tool-bar","content":""},{"title":"1.1 General tab​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#11-general-tab","content":"  1)Algorithm: The type of mesh algorithm used (Currently，it is not available ). 2)Solver Type: “3D X Property” is currently the option, two-dimensional solver is not available present. 3)Background Material : The combo box allow user to set the background material from drop down menu. Project, object defined dielectric, and go to material library can be operated. ①Project: The background material inherits from the project’s material setting. ②Object Defined Dielectric: The object-defined dielectric material, a default setting if user forgets to set background material, is defined for the current object background material setting, and once the user chooses this option, he does not need to set any material from the standard, user, or project material database. And the object-defined dielectric will not be loaded into any material database. ③Go to Material Library: If selected, user can go to standard material database to set background material according to needs. And the selected material relative property from standard material database will be displayed in the material data list. ④Index: This refers to the refractive index of the ambient background medium inside the simulation window (Default: 1) 4)Set frequency/wavelength: Sets the frequency (Default: 193.414 THz) or wavelength (Default:1.55 μm) to calculate. 5)Use Wavelength Sweep off/on: If checked, the wavelength sweep function is on, which used for wavelength sweep in EME analysis window. "},{"title":"1.2 EME Setup tab​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#12-eme-setup-tab","content":"  1)Y, Z: The center position of the simulation region. 2)Y Min, Y Max: Y min, Y max position. 3)Z Min, Z Max: Z min, Z max position. 4)Y Span, Z Span: Y, Z span of the simulation region. 5)Cell geometry： ①X Min: Minimum x position of solver region. The first cell group starts from this position. ②Energy Conversation: This admits you to choose the energy conservation type for the Page S-matrix. The Page S-matrix is calculated at every Page of the neighboring cells accounting for the modes at the left- and right- hand sides of the Page. Two options “None” and “Make Passive” are available. -&gt;None: Energy conservation is not applied. -&gt;Make passive: Nothing is done when the norm of the Page S-matrix is less than or equal to 1; otherwise the norm is mandatorily altered to be identical to 1. ③Unified Mode Settings: When the switch is on, the user can modify only the first line of &quot;Number of Modes&quot;, the values in other lines of &quot;Number of Modes&quot; are forced to be identical to the first line in the Cell Group Definition. If the switch is off, everything in &quot;Number of Modes&quot; can be modified as freely as the user wishes. ④Cell Group Definition: This enables you to specify the span of every cell group, the number of cells in every cell group, which sub-cell method to employ (None or Sub Cell), and the number of modes to be solved for each cell. Besides, it displays the cell range of the group, as well as the begin and end positions of the cell group. -&gt;Number of Modes:This value cannot be beyond the maximum amount of stord modes. Otherwise, it will be mandatorily altered to be identical to the latter. -&gt;Delete button: Clears the custom settings for the selected cell group. -&gt;Add button: Allow you to make custom settings for the selected cell group. ⑤Display Groups: Displays cell boundaries in the CAD. ⑥Periodicity tab：   ①Periodicity Group Definition: This defines cell regions with periodic features and specifies the number of periods in each of them. The &quot;start cell group&quot; and the &quot;end cell group&quot; refer to the sequential numbers from &quot;cell group definition&quot;. "},{"title":"1.3 Transverse mesh settings tab​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#13-transverse-mesh-settings-tab","content":"Since the propagation in the EME solver is along the x-direction, the mesh settings are applicable merely along the y and/or z axes, depending on the solver type (3DX2D).   1)Mesh definition: Currently there is only the option of global uniform mesh step, meaning that the mesh steps are uniform throughout the entire simulation volume. 2)Define Y Mesh/ Define Z Mesh: Maximum mesh step. 3)Mesh Refinement: Select an approach to calculate refined mesh properties ①Staircase: Any point inside a Yee cell might be evaluated to determine of which material it is consisted, and the properties for that single material are used for depicting the E field at that point. As a consequence, the discretized structure hardly accounts for structure variations that arises inside a single Yee cell, therefore leading to a ``Staircase'' permittivity grid which agrees exactly with the Cartesian grid. Besides, all layers are effectively shifted to the closest E field position inside the Yee cell, implying that there is no way for the thickness to be resolved as finer than dx. ②Curve Mesh: Effective permittivities can be derived via a contour path recipe, which effectively takes the dielectric interface shapes, as well as material weight inside a cell into account. 4)Mesh Grading: In the case of a non-uniform mesh, Mesh Grading specifies the maximum ratio at which a neighboring grid can be enlarged or reduced. For instance, if dx(k+1) = c*dx(k), then 1/(GRADING FACTOR) &lt;= c &lt;= GRADING FACTOR. It is recommended that 1 &lt;= GRADING FACTOR &lt;= sqrt(2). (Default: 1.2) 5)DY/DZ: Maximum mesh step settings . The default setting is 0.02 μm. 6)Minimum mesh step settings: This indicates the minimum mesh step for the whole region managed by the solver (including also the mesh override regions). (Default: 0.0001μm). "},{"title":"2 Simulation Cases:​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#2-simulation-cases","content":"Objectives: In this example, we show how to use Max-Optics to run EME and view the simulation result. Works Flow:  "},{"title":"2.1 Modeling​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#21-modeling","content":"2.1.1 Material database settings​ Press on &quot;Material&quot; button, the material database window will bring out, and import new materials from standard material database or user material database into project material database according to user needs.( when import success a prompt information will pop out informs that Import Success. Success: 1/1, Fail: 0/1 (duplicated). Material work flows:  2.1.2 Add a rectangle​ Press arrow on the “Structures” button, and select a Rectangle from the drop-down menu. Set the properties of the substrate rectangle according to the following table. Menu bar-&gt;Structures-&gt;Rectangle-&gt;Geometry-&gt;Material  "},{"title":"2.2 Add EME​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#22-add-eme","content":"Press arrow on the “Simulation” button, and select the “EME” from the drop-down menu, and set the properties according to the following table.  General Tab  EME Setup Tab  Transverse Mesh Setting Tab  "},{"title":"2.3 Add EME Port​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#23-add-eme-port","content":" Geometry Tab of EME Port 1(Left)  Geometry Tab of EME Port 2(Right)  "},{"title":"2.4 Add Monitor (EME Profile monitor)​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#24-add-monitor-eme-profile-monitor","content":"Press arrow on the “Monitor” button and select “EME Profile Monitor” from drop-down manual. And set the properties according to the following table  Geometry Tab of Profile Monitor  Notes: Before simulation, please press “File” button, and select “Save” from drop-down manual, manually. (File -&gt; Save) "},{"title":"2.5 Run & Result View​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#25-run--result-view","content":"Press arrow on the “Run” button and select “Run EME” from drop-down menu.  After running, the “EME Analysis” window will pop out, in this window, you can run “EME Propagate”, “Propagation Sweep” and “Wavelength Sweep” via press buttons respectively.   ① EME propagate Press arrow on the “EME propagate” button, and you can view the EME propagate result via clicking EME result in Result View.  You can view different plot types via “Scalar Operation” options, and in attributes list, you can choose parameter which is interested in to view  ② Run Propagation sweep Press arrow on the “Propagation Sweep” button, and after running, “EME Propagation Sweep” window will pop out, you can view the result about Propagation Sweep. User can view different view via clicking options in S11, S12, S21 or S22 port box.  ③ Run Wavelength Sweep Press arrow on the “Wavelength Sweep” button, and after running, “EME Wavelength Sweep” window will pop out, you can view the result about Wavelength Sweep.  You can view different results via the options in S11/S12/S21/S22 Port box.  ④ Matrix Index Mapping Show the information about the mode corresponding to the port. ⑤ zbf Export The EME port and EME cell results support exporting mode information in a zbf format file. Works flows: Result View-&gt;EME port/EME Cell-&gt;Mode Fields-&gt;Export -&gt;OK  "},{"title":"3 Notes​","type":1,"pageTitle":"EME Solver","url":"/my-website/docs/tutorial/4Simulation/3EME#3-notes","content":"The simulation cases involved in the manual are only limited to guiding user how to use Max-Optics Studio silicon-based passive product running simulation, not for other purposes; The screenshot pictures are gained, under Hardware environment: Name: LAPTOP-MHBJS336 (MateB ook 14), Windows11, and software environment: Google browser, version:108.0.5359.125. "},{"title":"Mesh","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/4Simulation/4Mesh","content":"","keywords":""},{"title":"1 General tab​","type":1,"pageTitle":"Mesh","url":"/my-website/docs/tutorial/4Simulation/4Mesh#1-general-tab","content":" 1)Override X/Y/Z mesh: When “Override X/Y/Z mesh” button state is on, you can set dx/dy/dz mesh override region. The smaller the value of dx/dy/dz, the better accuracy you will get. "},{"title":"2 Geometry tab​","type":1,"pageTitle":"Mesh","url":"/my-website/docs/tutorial/4Simulation/4Mesh#2-geometry-tab","content":" 1)X, Y, Z: The center position of the simulation region. 2)X Min, X Max: X min, X max position. 3)Y Min, Y Max: Y min, Y max position. 4)Z Min, Z Max: Z min, Z max position. 5)X Span, Y Span, Z Span: X, Y, Z span of the simulation region. "},{"title":"Source","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/5Source","content":"","keywords":""},{"title":"1 Mode Source​","type":1,"pageTitle":"Source","url":"/my-website/docs/tutorial/5Source#1-mode-source","content":"Feature Description:The mode source is used to inject a guided mode into the simulation region in FDTD. You could add and set mode source here. "},{"title":"1.1 General tab​","type":1,"pageTitle":"Source","url":"/my-website/docs/tutorial/5Source#11-general-tab","content":" 1 ) Injection Axis: This field specifies the axis for the mode source propagation. Three options are available: “X-Axis”, “Y-Axis”, and “Z-Axis”. 2 ) Direction: This field indicates the direction of mode source propagation. Two options are available: “Forward” means the propagation is along a positive direction, while “Backward” means the propagation is along a negative direction. 3 ) Amplitude: This field specifies the amplitude of the mode source. See the section ``Units and normalization section''. (Default value: 1) 4 ) Phase: This field refers to the phase value (in units of degrees) of the mode source. It makes sense only when there exist relative phase differences among multiple sources of radiation. 5 ) Rotations: -&gt; Theta: This refers to the angle of propagation measured by degrees, with respect to the incident axis of the source in a 3D simulation. In a 2D simulation, it is the angle of propagation measured by degrees revolved around the global Z-axis in compliance with the right-hand rule, that is, the angle of propagation in the XY plane. -&gt; Phi: This refers to the angle of propagation measured by degrees revolved around the incident axis of the source in compliance with the right-hand rule in a 3D simulation. In a 2D simulation, this value does not take effect. -&gt; Rotation Offset: A rotation offset can be endowed to the plane upon which the mode is computed. This guarantees that mode sources at an angle do not interfere with structures not belonging to the waveguide/fiber. 6 ) Mode selection: Defines whether to inject fundamental mode or other user-selected modes chosen via the &quot;Select Mode&quot; button. Currently, mode selection options are “Fundamental Mode”, “Fundamental TE Mode”, “Fundamental TM Mode”, “User Select” and “User Import”. Works flow: User Select -&gt; “Select Mode” window:  1.1.2 Modal analysis tab​ In this section you can set “Frequency”, “Wavelength”, “Number of Trial Modes”, “Search”, and also can set bent waveguide via selecting “Calculate Group Index” and “Bent Wave guide”.  1) Number of Trial Modes: This specifies the number of modes to search for a fundamental mode. The modes eventually found by the solver may depend on that. If one uses a too small number, the expected modes could be missing. Usually, setting this number to 100 suffices to guarantee no physical modes would have been missed. However, users who are interested in higher order modes should set an even larger value, since in such cases more than 100 modes may be present. 2) Search: The user can specify an index to search around or a range of indices to sweep for finding modes of interest. The specified value indicates the magnitude of the index (which is complex) rather than just its real part. -&gt; Max index: By checking this option, the FDTD calculation automatically admits the maximum index mode (Default: 1). -&gt; Near N: If unchecked, the user can set the value of N in the following box according to the need. If the selected value is not within the range of the mode index value, the nearest value from the user’s setting will be adopted instead for selecting the FDTD mode. 3) Mesh Structure: User can view structure and material information about mesh. When click the button, result view will be shown, and attribute drop-down list includes: Index X, Index Y, Index Z.  4) Plot area: The plot area where the simulation data is plotted. 5) Mode list: Mode list where the “ID”, “Effective Index”, “Group Index”, “Wavelength”, “Loss”, and “TE Polarization Fraction” are shown. How many modes will be shown, will according to the “Number of Trail Modes” setting. 6) Mode Plot options: The mode plot options are used to specify which data to plot in the plot window, also can be used to modify the current mode plot options. 7) Export: The export button supports users exporting the data file they are interested in. Notes: For detailed information please refer to Chapter 2.7.6.1.2.Mode Plot Window 1.1.3 Boundary conditions tab​  In this section, you can set mode source simulation region’s boundary conditions and six types can be chosen: PEC, PML, PMC, Symmetric, Periodic and Anti-Symmetric. (Default: PEC) "},{"title":"1.2 Geometry tab​","type":1,"pageTitle":"Source","url":"/my-website/docs/tutorial/5Source#12-geometry-tab","content":" 1) X，X Span/ Y, Y Span, Z/ Z span: The geometry tab contains options to change the size and location of the sources. "},{"title":"2 Gaussian source：​","type":1,"pageTitle":"Source","url":"/my-website/docs/tutorial/5Source#2-gaussian-source","content":"Feature Description: The gaussian source is used to inject a gaussian source into the simulation region in FDTD. You could add and set gaussian source here. "},{"title":"2.1 General tab​","type":1,"pageTitle":"Source","url":"/my-website/docs/tutorial/5Source#21-general-tab","content":"  1) Injection Axis: This field specifies the axis for the gaussian source propagation. Three options are available: “X-Axis”, “Y-Axis”, and “Z-Axis”. 2) Direction: This field indicates the direction of gaussian source propagation. Two options are available: “Forward” means the propagation is along a positive direction, while “Backward” means the propagation is along a negative direction. 3) Angle Theta: This refers to the angle of propagation measured by degrees, with respect to the incident axis of the source in a 3D simulation. In a 2D simulation, it is the angle of propagation in degrees revolved around the global Z-axis in compliance with the right-hand rule, that is, the angle of propagation in the XY plane. 4) Angle Phi: For 3D simulations, Phi corresponds to the angle of propagation (measured by degrees) revolved around the axis of source injection in compliance with the right-hand rule. This value has no meaning for 2D simulations. 5) Amplitude: This field specifies the source amplitude. (Default value: 1) 6) Phase: This field refers to the phase value (in units of degrees) of the point source. It makes sense only when there exist relative phase differences among multiple sources of radiation. 7) Polarization Angle: For an injective electric field, the polarization angle is meant to be its orientation, measured with respect to the plane formed by the vector of propagating direction and the normal of the injection plane. Radiation with a vanishing polarization angle is P-polarized regardless of the direction of propagation, while radiation with a polarization angle of 90 degrees is S-polarized. "},{"title":"2.2 Waveform Tab​","type":1,"pageTitle":"Source","url":"/my-website/docs/tutorial/5Source#22-waveform-tab","content":"1) Waveform ID select: Allows you to choose the waveform id from a list of the existing waveforms. Three types options of for waveforms provided by default, which include Waveform_1550, Waveform_1310, and Visible_Light. Waveform List:The waveform information of “ID”, “Name”, “Center”, “Span”, “Start” and “Stop” are included in waveform list. "},{"title":"2.3 Beam Settings Tab​","type":1,"pageTitle":"Source","url":"/my-website/docs/tutorial/5Source#23-beam-settings-tab","content":"1) Calculation Method: You can select “Use Scalar Approximation” or “Use Vector Approximation” for calculation. (Default: Use Scalar Approximation) 2) Beam Parameters: The user can choose either “Waist Size and Position” or “Beam Size and Divergence” to define a scalar beam. (Default: Waist Size and Position) 3) Waist Radius W0: The user can input the value of waist radius (measured by μm; Default: 1.01818) within the range [1e-30,1e30]. The setting Beam Parameters=”Waist Size and Position” enables the user to modify the value. 4) Distance From Waist: This distance is positive if the beam is divergent, or negative provided the beam is convergent. The setting Beam Parameters=”Waist Size and Position” enables the user to modify the value. 5) Beam Radius Wz: The user can input the value (measured by μm; Default: calculated value) within the range [1e-30,1e30]. The setting Beam Parameters=”Beam Size and Divergence” enables the user to modify the value. 6) Divergence Angle: This refers to the angle of radiation spreading into the far field as measured. Positive/Negative angles correspond to diverging/converging beams, respectively. The user can input the value within the range of (-90,90). The value can be editted if Beam Parameters=”Beam Size and Divergence”. "},{"title":"2.4 Geometry tab​","type":1,"pageTitle":"Source","url":"/my-website/docs/tutorial/5Source#24-geometry-tab","content":" 1) X，X Span/ Y, Y Span, Z/ Z span: The geometry tab contains options to change the size and location of the sources. "},{"title":"Port","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/6Port","content":"","keywords":""},{"title":"1 FDTD Port​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#1-fdtd-port","content":"Feature description:Ports are usually viewed as a combination of mode source, field monitor and mode expansion monitor. Ports can be used either separately or together with the S-parameter sweep tool to compute the S-parameters for a device by means of the mode expansion method. Notes:Press the &quot;Port&quot; button in the menu bar, and select &quot;FDTD Port&quot; from the drop-down menu to add a port. Note that the prerequisite is that an FDTD simulation region must be already there. Upon adding a port, a port group named “Ports” is automatically generated as the child of the “Object Tree” , and all port objects are enclosed in this group. In particular, the port hierarchy is arranged in such a manner that ports cannot be moved outside the “Ports group”, and other objects are not allowed to be moved into the group. "},{"title":"1.1 FDTD Port Group tab​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#11-fdtd-port-group-tab","content":"1) Source Port:This option enables you to choose one from a list of the existing ports as the source port. 2) Source Mode:The mode of each port can be selected through “Mode Selection” in its “Modal Properties” tab, after which the mode number is recorded in “Source Mode” automatically 3) Waveform Name:Waveform name is identified by “Waveform ID”.  "},{"title":"1.2 The Geometry tab of FDTD Port​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#12-the-geometry-tab-of-fdtd-port","content":" 1) X,Y,Z:The center position of the simulation region. 1) X Min, X Max:X min, X max position. 1) Y Min, Y Max:Y min, Y max position. 1) Z Min, Z Max:Z min, Z max position. 5)X Span, Y SP, Z Span:X, Y, Z span of the simulation region. "},{"title":"1.3 The Modal properties tab of FDTD port tab​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#13-the-modal-properties-tab-of-fdtd-port-tab","content":" 1)Injection Axis:This indicates the axis of propagation. The geometry parameters that will work under the &quot;Geometry&quot; tab may depend on this setting (For instance, if the incident wave is along the x-axis, the port object possesses accordingly a 2D x-normal geometry). 2)Direction:This field indicates the direction of source propagation. Forward means the propagation is along a positive direction, while Backward means the propagation is along a negative direction. 3)Amplitude:&quot;Amplitude&quot; specifies the peak magnitude of electric field measured by V/m in the beam sources. (Default :1) 4)Phase:This refers to the phase of the source measured by degrees. 5)Mode Selection:This enables the user to select the modes used in the mode expansion computations. The eigenmode solver, with which the user may compute and visualize the supported modes (See “Mode Analysis”), is launched by checking the &quot;User Select&quot; option---this option can also be used to select the desired mode among multiple ones. Besides, the eigenmode solver offers a toolkit of frequency analysis. (See &quot;Frequency Analysis&quot;) 6)Bent Waveguide:Selecting this option enables the bent waveguide solver to work with the following settings:. -&gt;Bend Radius:This specifies the bend radius in units of um counted from the center of the port region. (Default value: 1.000e+6 um) -&gt;Bend Orientation: This specifies the orientation of the cylindrical coordinates employed for the computation of modes.Orientation of the cylindrical coordinate system used for calculating modes. -&gt;Bend Location: This option specifies the location of bend. (Note that only the simulation center is supported at present) "},{"title":"1.4 Mode Analysis window​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#14-mode-analysis-window","content":" "},{"title":"1.5 Frequency Analysis window​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#15-frequency-analysis-window","content":" 1)Track Selected Mode: By checking this box, the selected mode from the list will be tracked. -&gt;Start / Stop Frequency (THz): The beginning and final frequencies at which the modes will be solved for. The start frequency value defaults to the one for initial computations of modes inside the Modal Analysis tab, whenever a particular mode is being tracked. -&gt;Start / Stop Wavelength (μm): The beginning and final wavelengths at which the modes will be solved for. The start wavelength value defaults to the one for initial computations of modes inside the Modal Analysis tab, whenever a particular mode is being tracked. -&gt;Number of Points: The number of sampling frequencies/wavelengths to be included in the sweep. -&gt;Number of Trial Modes: This number specifies the maximum amount of modes to be swept. To track a single mode, this number is recommended to be about 3 in order to reduce the computation time to its minimum (this number will need to be raised a little bit in case there are discontinuities in the sweep data). When “Track Selected Mode” is not selected, this number determines the maximum amount of modes to be swept over the domain of frequency/wavelength within our attention scope. -&gt;Effective index: This parameter indicates the effective index value around which the modes will be solved for. It takes effect only when the selected modes are not being tracked. (Default: 1)) -&gt;Detailed Dispersion Calculation: Mode properties at extra frequencies are computed for collecting more accurate dispersion data over the domain of frequency/ wavelength within our attention scope. This produces more precise results with extra cost of time. 2)Bent Waveguide: Check this option to enable sweeping a waveguide with a bend inside. -&gt;Bend Radius: The curvature radius of the waveguide bend. -&gt;Bend Orientation: The orientation of the waveguide bend -&gt;Bend Location: The location of the waveguide bend. 3)Plot area: The plot area where the simulation data is plotted in line or image. Mode list: Mode list where the “ID”, “Effective Index”, “Group Index”, “Wavelength”, “Loss”, and “TE Polarization Fraction” are shown. How many modes will be shown, will according to the “Number of Trial Modes” setting. 4)Frequency Plot : The frequency plot options are used to specify which data to plot in the plot window, and also can be used to modify the current frequency plot options.  "},{"title":"2 EME Port​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#2-eme-port","content":"Feature Description: The EME solver region contains 2 ports by default. The ports button found in the menu bar adds additional ports to the solver. "},{"title":"2.1 Geometry tab​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#21-geometry-tab","content":" 1)Port Location: The port can be selected to locate at the left or right end of the EME solver region. 2)Use Full Simulation Span: By checking this option, the whole simulation span inheritted from the EME simulation region is employed. (Default: on) You need to uncheck this option if you wish to specify your own spans for the port. Therefore the following parameters settings are invalid when &quot;Use Full Simulation Span&quot; is enabled. 3)X, Y, Z: The center position of the simulation region. 4)X MIN, X MAX: X min, X max position. 5)Y MIN, Y MAX: Y min, Y max position. 6)Z MIN, Z MAX: Z min, Z max position. 7)X SPAN, Y SPAN, Z SPAN: X, Y, Z span of the simulation region. "},{"title":"2.2 EME Port tab​","type":1,"pageTitle":"Port","url":"/my-website/docs/tutorial/6Port#22-eme-port-tab","content":" 1)Offset: An offset can be endowed to the plane upon which the modes are computed. This guarantees that monitors placed at an angle do not interfere with unexpected structures. 2)Number of Trial Modes: This specifies the number of modes to search for finding a fundamental mode. The modes eventually found by the solver may depend on that. If one uses a too small number, the expected modes could be missing. Usually, setting this number to 100 suffices to guarantee no physical modes would have been missed. However, users who are interested in higher order modes should set a even larger value, since in such cases more than 100 modes may be present. (Default value: 20) 3)Mode Selection: ①　Allow you to select the modes to use for the mode expansion calculation. The &quot;user select&quot; option launches the eigenmode solver where the user can calculate and visualize the supported modes; use this option to select multiple modes. The &quot;Mode calculation&quot; section Allow you to select a mode they are interested in. The user S-matrix result returns the S-matrix for these selected modes. A selected mode can also be used as an input source in the EME propagation stage of the analysis, Fundamental Mode, Fundamental TE Mode, Fundamental TM Mode, Fundamental TE and TM Mode, Use Select and User Import are included. (Default: fundamental mode) ②　Checking the &quot;user select&quot; option enables you to specify mode parameters in the ``Select Mode'' window. The number of trial modes will be displayed in the mode list after they are solved by computation. The plot options of the user's interest can be specified in the mode plot options section. Select Mode tab:  ③　User import: Import arbitrary source fields into EME ports. It is possible to use a custom field profile from a .mat file, .datx file or .zbf file as the source in an EME simulation. The field profile data can be from another simulation. To set this as a port mode, open the Edit EME port tab, select “User import” under mode selection and click on “Import Field”.  Click the “Click to upload” button, select a generated custom field profile, if you has imported several profiles in the right section, you can specify one of them from right section, then the custom field profile has been imported successfully. Finally, click the “OK” button to save the custom profile.  "},{"title":"Monitor","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/7Monitor","content":"","keywords":""},{"title":"1 Reflective index monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#1-reflective-index-monitor","content":"Feature Description: Index monitors store the values of n and k as functions of frequency/wavelength in a simulation. In future, the index monitor will also be able to record the temporal profiles of physical properties for nonlinear media. "},{"title":"1.1 Geometry tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#11-geometry-tab","content":" 1)Monitor type: The monitor type and orientation, this option will control the availability of spatial settings below. 2)X, Y, Z: The center position of the simulation region. 3)X Min, X Max: X min, X max position. 4)Y Min, Y Max: Y min, Y max position. 5)Z Min, Z Max: Z min, Z max position. 6)X Span, Y Span, Z Span: X, Y, Z span of the simulation region. "},{"title":"1.2 Mesh Settings tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#12-mesh-settings-tab","content":" 1)Mesh Definition: Number of mesh cells or Maximum mesh step, the two options allow user to set the number or step of defined mesh . 2)Define X Mesh/ Define Y Mesh/ Define Z Mesh: Number of mesh cells and Maximum mesh. 3)Maximum Mesh Step Settings dx/ dy/ dz: Maximum mesh step settings. The default setting is 0.02 μm. 4)Minimum mesh step settings: Sets the minimum mesh step for the entire solver region including the mesh override regions. The default setting is 0.0001μm. 5)Number of Mesh Cells without Override Regions: This value specifies the number of mesh cells without override regions. Mesh Cells X/Y/Z: Sets the number of mesh cells.(Default: 50) 6)Mesh Refinement: Mesh refinement can give sub-cell accuracy for a simulation. Staircase: Any point inside a Yee cell might be evaluated to determine of which material it is consisted, and the properties for that single material are used for depicting the E field at that point. As a consequence, the discretized structure hardly accounts for structure variations that arises inside a single Yee cell, therefore leading to a ``Staircase'' permittivity grid which agrees exactly with the Cartesian grid. Besides, all layers are effectively shifted to the closest E field position inside the Yee cell, implying that there is no way for the thickness to be resolved as finer than dx. Curve Mesh: Effective permittivities can be derived via a contour path recipe, which effectively takes the dielectric interface shapes, as well as material weight inside a cell into account. Mesh Grading: In the case of a non-uniform mesh, Mesh Grading specifies the maximum ratio at which a neighboring grid can be enlarged or reduced. For instance, if dx(k+1) = c*dx(k), then 1/(GRADING FACTOR) &lt;= c &lt;= GRADING FACTOR. It is recommended that 1 &lt;= GRADING FACTOR &lt;= sqrt(2). (Default: 1.2) "},{"title":"2 Frequency-domain field and power monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#2-frequency-domain-field-and-power-monitor","content":"Feature Description:Frequency domain field monitors work in the frequency domain and extract the field profiles across some spatial regions of the FDTD simulation. Notes:Before adding the Frequency-domain field and power monitor, Mode Source must be added. "},{"title":"2.1 General tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#21-general-tab","content":" 1 ) Override Global Options: This is a toggle for overriding the global monitor settings. Checking this option enables the user to specify the frequency spans and number of points at which frequency-domain data will be collected. Otherwise the following options should be specified from the global monitor settings. 2 ) Sample Spacing: The sampling frequency or wavelength is determined somehow based on this choice parameter. Only the &quot;uniform&quot; option is available at present. 3 ) Use Source Limits: If the “Use Source Limits” state is turned on, the settings for “Spacing Type”, “Spacing Limit”, “Wavelength Min/Max” are disabled. Otherwise, the user can change the above settings in this section. 4 ) Frequency Points: Sets to choose the number of frequency points at which to record data. (Default: 5) "},{"title":"2.2 Geometry Tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#22-geometry-tab","content":" 1 ) Monitor Type: The monitor type and orientation, this option will control the available of spatial setting below, Point, Linear X/Y/Z, 2D X-Normal/2D Y-Normal/2D Z-Normal, 3D are included. ( Default: 2D X-normal) 2 ) X/X Span; Y/Y Span; Z/Z Span: X, Y, Z: The center position of the simulation region. X Min, X Max: X min, X max position. Y Min, Y Max: Y min, Y max position. Z Min, Z Max: Z min, Z max position. X SPAN, Y SPAN, Z SPAN: X, Y, Z span of the simulation region. "},{"title":"2.3 Data to Record tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#23-data-to-record-tab","content":" 1 ) Fields &amp; Poynting vector and power: Output quantities EX, EY, EZ, HX, HY, HZ, PX, PY, PZ: The user can select from the field components (EX, EY, EZ, HX, HY, HZ) or the Poynting vector (PX, PY, PZ) those ones he/she wishes to measure. For 3D simulations, only part of the components are non-vanishing (i.e., for TE simulations only EX, EY, and HZ will make sense). However to facilitate fast switches between TE and TM simulations, all the field quantities will remain active.(2D simulation is inavailable at present). 2 ) Output Power: The user can check this option to compute the power as an integral over the monitor surface, and it is for surface minitors (3D simultion) and line monitors (2D simulation) only. Once the simulation comes to end, this uses much less memory and is therefore rather appropriate for large parallel computations where only the integrated power over a surface is requested by the user. (2D FDTD is inavailable at present). "},{"title":"2.4 Advanced tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#24-advanced-tab","content":" 1 ) Sampling Frequency -&gt;Min Sampling Per Cycle: This parameter suggests the realistic minimum amount of samplings for each optical cycle. Default value is 2 (the Nyqusit limit) for sake of the optimum efficiency. -&gt;Desired Sampling: This converts the minimum sampling points in each optical cycle into an actual rate of sampling measured by Hz. -&gt;Nyquist Limit: The Nyquist limit of sampling is determined in accordance with the maximum frequencies that may arise in the simulation region. -&gt;Actual Sampling: The actual rate of sampling is identical to the rate that is actually employed for the discrete Fourier transform (DFT), by appropriately taking the desired sampling rate, the Nyquist limit, and the time step dt into account -&gt;Down Sample Time: This specifies the time for step down sampling. "},{"title":"2.5 Mode Expansion tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#25-mode-expansion-tab","content":" Feature Description: The user can use the Mode expansion monitor simulation objects to extract the fractional amount of power transmitted into any mode(s) of a non-absorbing waveguide or fiber. The Mode Expansion tab contains two main sections. The &quot;Mode calculation&quot; section allows you to select a mode (or a set of modes) to expand the input profile. The &quot;Monitors for Expansion&quot; section allows you to choose a field profile from an arbitrary monitor in the simulation to expand. 1 ) Enable: If the status of the button is on, allows user to set the “Mode calculation” and “Monitors for Expansion”. (Default: off ) 2 ) Direction: Direction of the Mode expansion monitor. Two options Negative and Positive are available. (Default value: Positive) 3 ) Mode Calculation: ①Mode Selection: Allow you to select the modes for the mode expansion calculation, and user select, “Fundamental Mode”, “Fundamental TE Mode” and “Fundamental TM Mode” are included. (Default: User Select) ②.Override Global Monitor Settings: -&gt;Sample spacing: The sampling frequency or wavelength is determined somehow based on this combo-choice parameter. -&gt;Use wavelength spacing: As a default setting, data is recorded at certain spatially discretized points depending on the involved wavelengths -&gt;Use source limits: When checked, the source limits are used by the monitors. Otherwise one uses the pull down menus and their underlying boxes to specify the frequencies/wavelengths at which to collect data. ③Frequency Points: Sets to choose the number of frequency points at which to record data. (Default: 5) 1 ) Monitors for Expansion: After the modes have been selected, the next step is to choose the monitor with the input field profile. The &quot;Add &quot; and &quot; Remove &quot; buttons on the side can be used to add/remove monitors, and You can choose the desired monitor from the monitor drop down list. 4 ) Bent Waveguide: Upon checking this option, the user can define a bent waveguide.. -&gt;Radius: Radius of the bent waveguide. (Default value: 1.000e+6 μm) -&gt;Orientation: Orientation of the bent waveguide -&gt;Location: Loaction of the bent waveguide. (at Simulation Center by default) 5 ) Rotations: -&gt;Theta: This refers to the angle of propagation measured by degrees, with respect to the incident axis of the source in a 3D simulation. In a 2D simulation, it is the angle of propagation measured by degrees revolved around the global Z-axis in compliance with the right-hand rule, that is, the angle of propagation in the XY plane. -&gt;Phi: This refers to the angle of propagation measured by degrees revolved around the incident axis of the source in compliance with the right-hand rule in a 3D simulation. In a 2D simulation, this value does not take effect. -&gt;Rotation Offset: A rotation offset can be endowed to the plane upon which the mode is computed. This guarantees that mode sources at an angle do not interfere with structures not belonging to the waveguide/fiber. "},{"title":"2.6 FDTD Far Field​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#26-fdtd-far-field","content":"Feature Description: The FDTD far field function is used for calculating the EM fields in the far field region of the selected “Frequency-Domain Field and Power Monitor” through adopting a systematic near-to-far-field (NTFF) transformation without the necessity of extending the simulation region to the actual far field area. After a single FDTD simulation, the frequency-domain field data of the selected monitor can be accurately and efficiently projected to the far field region defined by a hemisphere with a radius of 1 meter which is positioned 1 meter away from the center of the monitor. Work flow: Result view-&gt; Power monitor-&gt;Calculate-&gt; Far Filed Settings-&gt; OK 2.6.1 Select Frequency​  1 ) Frequency: allows user to select the frequency based on the power monitor calculation results to project. 2 ) Wavelength: allows user to select the wavelength based on the power monitor calculation results to project. Click the “Far Failed Setting” button from the bottom left corner of the Select Frequency window an additional window will pop out.  2.6.2 General Tab​ 1 ) Projection Direction: Forward and backward projection direction can be set. Forward will project towards the positive axis direction and backward will project to negative axis direction. 2 ) Material index: The refractive index of the medium to use for projection. 3 ) Far Field Filter: Sets the far filter alpha parameter. 4 ) Resolution: Sets the number of points in the far field to project to for 2D simulations. After clicking the “OK ” button, the visualizer window will show up, user can check two types of far-field plot results via the “Draw” option box, one is a standard plot another is the polar plot. 2.6.3 Standard plot visualizer​  Drawing: Drawing the far fields (Default:Standard Plot) Equal Scale: If checked, the result image will be shown in equal scale. Mesh Grid: Mesh grid display settings  Attribute: Allow users to choose the attribute their interested in to plot, includes E, H, Energy density, Ex, Ey, Ez, Hx, and Hy. (Default: E) Scalar Operation: A combo box allow user to choose the operation their interested in to plot, includes amplitude, phase, real, and imaginary. (Default: Amplitude) Custom Range: If checked, allow user to custom range to plot via the following options settings, includes horizontal (min/max), vertical (min/max), slice (x), mode (default: 1), color bar (min/max) and scale (Linear/ log). Data List: The result data of far field projection will be loaded here after running the far field projection.  -&gt;Name: The FDTD far field name. -&gt;Line Color: User can customize the line’s color interested in. -&gt;View Data: Allows user to view the data of far field , after pressing the button a FDTD Far Field data table will pop out.  Add: Add the far field result to plot. Copy: Copy a far field result data in the list to plot. Remove: Remove the selected result data. Export: Export the selected far field result data. The export button supports users exporting the data file they are interested in. Two types of files with two formats can be exported, one is the “export graph data” (.csv/.mat), and another is “export monitor data (CSV/mat/zbf). 2.6.4 Polar Plot Visualizer​  "},{"title":"3 Field time monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#3-field-time-monitor","content":"Feature Description: These monitors collect time-domain data for field components over the entire simulation course. Point, line or area monitors can be set and used for collecting such information over various spatial scales inside the simulation regions. "},{"title":"3.1 General Tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#31-general-tab","content":"The general tab for the time domain monitor includes options to edit the amount of data, and time period over which data is collected.  1)Stop Method: “End of Simulation”, “Choose Stop Time” and “Choose Number of Snapshots”. 2)Start Time: The time to switch on recording. 3)Stop Time: The time to end recording. 4)Number of Snapshots: The number of timesteps to be recorded. "},{"title":"3.2 Geometry tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#32-geometry-tab","content":" 1)Monitor Type: The monitor type and orientation, this option will control the available of spatial setting below , “Point”, “Linear X”, “Linear Y”, “Linear Z”, “2D X-Normal”, “2D Y-Normal”, “2D Z-Normal”,3D are included. (Default: Point) 2)X,Y,Z: The center position of the simulation region. 3)X Min/X Max: X min, X max position. 4)Y Min/ Y Max: Y min, Y max position. 5)Z Min/ Z Max: Z min, Z max position. 6)X Span/ Y Span / Z Span: X, Y, Z span of the simulation region. "},{"title":"3.3 Data to Record tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#33-data-to-record-tab","content":" 1 ) Fields &amp; Poynting vector and power: Output quantities EX, EY, EZ, HX, HY, HZ, PX, PY, PZ: The user can select from the field components (EX, EY, EZ, HX, HY, HZ) or the Poynting vector (PX, PY, PZ) those ones he/she wishes to measure. For 3D simulations, only part of the components are non-vanishing (i.e., for TE simulations only EX, EY, and HZ will make sense). However to facilitate fast switches between TE and TM simulations, all the field quantities will remain active.(2D simulation is not available) "},{"title":"3.4 Advanced tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#34--advanced-tab","content":" Sampling rate: 1 ) Min Sampling Per Cycle: This parameter indicates the realistic minimum amount of samplings in each optical cycle. Default value is 10. 2 ) Sampling Rate: The actual rate of sampling measured by THz. 3 ) Down Sample Time: This specifies the time for step down sampling. "},{"title":"4 EME Profile Monitor​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#4-eme-profile-monitor","content":"Feature description: EME profile monitors work in the frequency domain to extract field profiles from the simulation results produced by an EME solver over some spatial regions. "},{"title":"4.1 Geometry tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#41-geometry-tab","content":" 1 ) Monitor Type: This option specifies the monitor type and orientation, and will affect the availability of the spatial settings below. 2 ) X, Y, Z: The center position of the simulation region. 3 ) X Min, X Max: X min, X max position. 4 ) Y Min, Y Max: Y min, Y max position. 5 ) Z Min, Z Max: Z min, Z max position. 6 ) X Span, Y Span, Z Span: X, Y, Z span of the simulation region. 7 ) X Resolution: The number of mesh steps along propagation direction. "},{"title":"5 Global Option (FDTD)​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#5-global-option-fdtd","content":"Feature description: The global monitor settings, the parameter in this window will be adopted in other monitors if your override global options is unchecked. Notes: Monitors with override global option tab include profile and power monitor, reflective monitor and mode expansion. "},{"title":"5.1 Frequency power tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#51-frequency-power-tab","content":" 1 ) Sample Spacing: The parameter determines how the sample frequency/wavelength will be selected, currently the option is “uniform”. 2 ) Use Wavelength Spacing: Data is recorded at certain spaced points with respect to frequency. Selecting this option spaces data at certain spaced points with respect to wavelength. 3 ) Use Source Limits: When checked these monitors use the source limits. When unchecked, the frequencies/wavelengths at which to record data can be set using the pull down menus and boxes below them. 4 ) Spacing Type: Set spacing type, the options are wavelength and frequency. 5 ) Spacing Limit: Set spacing limits, you can set min/max of wavelength and center/span of wavelength. When the use source limits option is checked, this option will be disabled. 6 ) Frequency Points: Set to choose the number of frequency points at which to record data (Default 5). "},{"title":"5.2 Advanced tab​","type":1,"pageTitle":"Monitor","url":"/my-website/docs/tutorial/7Monitor#52-advanced-tab","content":" 1 ) Min Sampling Per Cycle: This parameter suggests the realistic minimum amount of samplings for each optical cycle. Default value is 2 (the Nyqusit limit) for sake of the optimum efficiency. 2 ) Desired Sampling: This converts the minimum sampling points in each optical cycle into an actual rate of sampling measured by Hz. 3 ) Nyquist Limit: The Nyquist limit of sampling is determined in accordance with the maximum frequencies that may arise in the simulation region. 4 ) Actual Sampling: The actual rate of sampling is identical to the rate that is actually employed for the discrete Fourier transform (DFT), by appropriately taking the desired sampling rate, the Nyquist limit, and the time step dt into account. 5 ) Down Sample Time: This specifies the time for step down sampling. "},{"title":"Check Memory","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/8Checkmemory","content":"Check Memory Feature description:Before running, user can press “ Check Memory Requirements” to check the needed memory.","keywords":""},{"title":"Run","type":0,"sectionRef":"#","url":"/my-website/docs/tutorial/9Run","content":"Run Feature description:Run simulation Notes: Please save all the settings, before running simulation. If user chooses FDE simulation, the work flow is Run-&gt;Run FDE -&gt; FDE Analysis -&gt; Calculate modes. If user chooses EME simulation, the work flow is Run-&gt;Run EME -&gt; EME Analysis-&gt;EME propagation / EME sweep / Wavelength sweep. If user chooses FDTD simulation, the work flow is Run-&gt;Run FDTD. Supports simulation memory requirements check.","keywords":""}]