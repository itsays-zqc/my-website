"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7780],{79167:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>_,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),r=n(87617);const o={},l="Modulator",s={unversionedId:"examples/SDK Examples/Active_Device/MOD/MOD",id:"examples/SDK Examples/Active_Device/MOD/MOD",title:"Modulator",description:"Introduction",source:"@site/docs/examples/SDK Examples/Active_Device/MOD/MOD.md",sourceDirName:"examples/SDK Examples/Active_Device/MOD",slug:"/examples/SDK Examples/Active_Device/MOD/",permalink:"/my-website/docs/examples/SDK Examples/Active_Device/MOD/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/examples/SDK Examples/Active_Device/MOD/MOD.md",tags:[],version:"current",frontMatter:{},sidebar:"examplesSidebar",previous:{title:"Active Devices",permalink:"/my-website/docs/category/active-devices-1"},next:{title:"Photodetector",permalink:"/my-website/docs/examples/SDK Examples/Active_Device/Photodetector"}},p={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Simulation Structure",id:"simulation-structure",level:2},{value:"1. Basic Operations",id:"1-basic-operations",level:3},{value:"2. Code description",id:"2-code-description",level:3},{value:"2.1 Import Modules",id:"21-import-modules",level:4},{value:"2.2 Define Parameters",id:"22-define-parameters",level:4},{value:"2.2.1 General Parameters",id:"221-general-parameters",level:5},{value:"2.2.2 Structure Geometry",id:"222-structure-geometry",level:5},{value:"2.2.3 Electrical Simulation Boundary",id:"223-electrical-simulation-boundary",level:5},{value:"2.2.4 Optical simulation Boundary",id:"224-optical-simulation-boundary",level:5},{value:"2.3 Define Engineering Function",id:"23-define-engineering-function",level:4},{value:"2.3.1 Create Project",id:"231-create-project",level:5},{value:"2.3.2 Set Material",id:"232-set-material",level:5},{value:"2.3.3 Define structure",id:"233-define-structure",level:5},{value:"2.3.4 Add Doping",id:"234-add-doping",level:5},{value:"2.3.5 Set Monitor",id:"235-set-monitor",level:5},{value:"2.3.6 Add Mesh",id:"236-add-mesh",level:5},{value:"2.3.6 Set preview Doping",id:"236-set-preview-doping",level:5},{value:"2.3.6 Set Preview Index",id:"236-set-preview-index",level:5},{value:"3. Output Result",id:"3-output-result",level:3},{value:"Analytic Character",id:"analytic-character",level:2},{value:"1.Modulation efficiency",id:"1modulation-efficiency",level:3},{value:"1.1 Basic Operations",id:"11-basic-operations",level:4},{value:"1.2 Code Description",id:"12-code-description",level:4},{value:"1.2.1 Import Modules",id:"121-import-modules",level:5},{value:"1.2.2 Define Parameters",id:"122-define-parameters",level:5},{value:"1.2.3 Set Path",id:"123-set-path",level:5},{value:"1.2.4 Create Structure",id:"124-create-structure",level:5},{value:"1.2.5 Set Simulation",id:"125-set-simulation",level:5},{value:"1.2.6 Run",id:"126-run",level:5},{value:"1.2.7 Extract Parameters",id:"127-extract-parameters",level:5},{value:"1.2.8 Calculate",id:"128-calculate",level:5},{value:"1.3 Output Result",id:"13-output-result",level:4},{value:"1.3.1 Loss",id:"131-loss",level:5},{value:"1.3.2 Effective Index",id:"132-effective-index",level:5},{value:"1.3.3 Modulation efficiency",id:"133-modulation-efficiency",level:5},{value:"2. Capacitance And Resistance",id:"2-capacitance-and-resistance",level:3},{value:"2.1 Basic Operations",id:"21-basic-operations",level:4},{value:"2.2 Code Description",id:"22-code-description",level:4},{value:"2.2.1 Import Modules",id:"221-import-modules",level:5},{value:"2.2.2 Define Parameters",id:"222-define-parameters",level:5},{value:"2.2.3 Set Path",id:"223-set-path",level:5},{value:"2.2.4 Set Simulation",id:"224-set-simulation",level:5},{value:"2.2.5 Create Component",id:"225-create-component",level:5},{value:"2.2.6 Run",id:"226-run",level:5},{value:"2.2.7 Extract Parameters",id:"227-extract-parameters",level:5},{value:"2.3 Output Result",id:"23-output-result",level:4},{value:"2.3.1 Small Signal AC Current",id:"231-small-signal-ac-current",level:5},{value:"2.3.2 Capacitance",id:"232-capacitance",level:5},{value:"2.3.3 Resistance",id:"233-resistance",level:5}],m={toc:d},c="wrapper";function _(e){let{components:t,...o}=e;return(0,i.kt)(c,(0,a.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"modulator"},"Modulator"),(0,i.kt)("font",{face:"Calibri"},(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"\u200bWe have developed an electro-optic modulator based on carrier-depletion mechanism in silicon to simulate carrier and index distribution in a global structure. The drift and diffusion of carriers result in depletion at the PN junction. Applying a reverse bias voltage at the cathode broadens the depletion region, altering the carrier concentration and modulating the material's refractive index. Gaussian doping was employed in this model. Modulation efficiency, capacitance, and resistance were calculated to analyze the electro-optic characteristics of the modulator."),(0,i.kt)("p",null,"\u200bThe figure below illustrates the device structure we constructed, wherein the aluminum electrode is applied to the silicon modulator, and the entire device is encapsulated with silicon dioxide material."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(16319).Z,width:"2469",height:"909"})),(0,i.kt)("h2",{id:"simulation-structure"},"Simulation Structure"),(0,i.kt)("p",null,"\u200bThe present structural file provides a comprehensive guide for constructing a simulation structure and establishing a Gaussian doping distribution. Initially, one must construct the geometric structure of the device, incorporate materials and physical models, specify the doping distribution, and simulation boundary conditions, and set the light source and simulation solver. Eventually, the simulation result data should be extracted and output. "),(0,i.kt)("p",null,"\u200bOur simulation is designed with a light source entering along the X-axis, and the primary optoelectronic characteristic analysis takes place within the three-dimensional structure on the YZ plane. The FDE solver is utilized to preview the distribution of effective refractive index, and the DDM solver is used to preview the doping distribution of the device. Finally, we generate ad output the  distribution map of doping and index in modulator structure."),(0,i.kt)("p",null,"Application Library path: ",(0,i.kt)("inlineCode",{parentName:"p"},":\\mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD00_structure.py")),(0,i.kt)("h3",{id:"1-basic-operations"},"1. Basic Operations"),(0,i.kt)("p",null,"It is essential to incorporate materials for structure. Although module of ",(0,i.kt)("inlineCode",{parentName:"p"},"maxoptics_sdk.all")," provides default values for standard semiconductors, these values can be customized in ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD_material.py")," . "),(0,i.kt)("p",null,"Application Library path: ",(0,i.kt)("inlineCode",{parentName:"p"},":\\mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD_material.py")),(0,i.kt)("p",null,"The module of ",(0,i.kt)("inlineCode",{parentName:"p"},"fundamental")," specifies the base parameters of the material electrical structure .  The ",(0,i.kt)("inlineCode",{parentName:"p"},"recombination")," includes recombination of  Auger, SRH, and Radiative. It is crucial to define the model type and parameter values, if another model is used instead of the default. The default mobility model of Silicon is ",(0,i.kt)("inlineCode",{parentName:"p"},"Analytic")," , but we use the mobility model of ",(0,i.kt)("inlineCode",{parentName:"p"},"Masetti")," in  ",(0,i.kt)("inlineCode",{parentName:"p"},"Mobility")," of this modulator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'elec_Si_properties = {\n    "permittivity": {\n        "permittivity": 11.7\n    },\n    "work_function":4.2,\n    "fundamental": {\n        "electron": "density_of_states",\n        "hole": "density_of_states",  \n        "nc": {\n            # "constant": 3.21657e19,\n            "enable_model": True,\n            "nc300": 3.21657e19\n        },\n        "nv": {\n            # "constant": 1.82868e19,\n            "enable_model": True,\n            "nv300": 1.82868e19\n        },\n        "eg": {\n            # "constant": 1.12416,\n            "enable_model": True,\n            "alpha": 0.000473,\n            "beta": 636,\n            "eg0": 1.16\n        },\n        "narrowing": {\n            "model": "slotboom",\n            "slotboom": {\n                "e0": 0.0045,\n                "n0": 1.0e17\n            }\n        },\n    },\n    "recombination":{\n        "trap_assisted": {\n            "enabled": True,\n            "taun": {\n                "enable_model": False,\n                # "constant": 1e-5,\n                # "alpha": 0,\n                "dopant": {\n                    "model": "scharfetter",  \n                    "scharfetter": {\n                        "nref": 7.1e15,\n                        "taumax": 3.3e-6,\n                        "taumin":0\n                    }\n                },\n                "field": {\n                    "model": "none",  \n                    # "schenk": {\n                    #     "hbar_omega": 0.068,\n                    #     "mt": 0.258,\n                    #     "s": 3.5\n                    # }\n                }\n            },\n            "taup": {\n                "enable_model": False,\n                # "constant": 3e-6,\n                # "alpha": 0,\n                "dopant": {\n                    "model": "scharfetter",  \n                    "scharfetter": {\n                        "nref": 7.1e15,\n                        "taumax": 4e-6,\n                        "taumin": 0\n                    }\n                },\n                "field": {\n                    "model": "none",\n                    # "schenk": {\n                    #     "hbar_omega": 0.068,\n                    #     "mt": 0.24,\n                    #     "s": 3.5\n                    # }\n                }\n            },\n            "ei_offset": 0.0\n        },\n        "radiative": {\n            "enabled": True,\n            "copt": 1.6e-14\n        },\n        "auger": {\n            "enabled": True,\n            "caun": {\n                "constant": 2.8e-31,\n                "enable_model": False,\n                # "a": 6.7e-32,\n                # "b": 2.45e-31,\n                # "c": -2.2e-32,\n                # "h": 3.46667,\n                # "n0": 1e18 \n            },\n            "caup": {\n                "constant": 9.9e-32,\n                "enable_model": False,\n                # "a": 7.2e-32,\n                # "b": 4.5e-33,\n                # "c": 2.63e-32,\n                # "h": 8.25688,\n                # "n0": 1e18\n            }\n        },\n        "band_to_band_tunneling": {\n            "enabled": False,\n            # "model": "hurkx",  # or "schenk"\n            # "hurkx": {\n            #     "agen": 3.5e21,\n            #     "arec": 3.5e21,\n            #     "bgen": 2.25e7,\n            #     "brec": 2.25e7,\n            #     "pgen": 2.0,\n            #     "prec": 2.0,\n            #     "alpha": 0\n            # },\n            # "schenk": {\n            #     "a": 8.977e20,\n            #     "b": 2.1466e7,\n            #     "hbar_omega": 0.0186\n            # }\n        }\n\n    },\n    "mobility":{\n        "mun": {\n            "lattice": {\n                # "constant": 1417,\n                "enable_model": True,\n                "eta": -2.5,\n                "mumax": 1471\n            },\n            "impurity": {\n                "model": "masetti", \n                "masetti": {\n                    "alpha": 0.68,\n                    "beta": 2,\n                    "cr": 9.68e16,\n                    "cs": 3.43e20,\n                    "mu1": 43.4,\n                    "mumin1": 52.2,\n                    "mumin2": 52.2,\n                    "pc": 0\n                }\n            },\n            "high_field": {\n                "model": "none",  \n                # "canali": {\n                #     "alpha": 0,\n                #     "beta0": 1.109,\n                #     "eta": 0.66\n                # },\n                # "driving_field": {\n                #     "model": "e_dot_j",  # or "grad_phi",\n                #     "grad_phi": {\n                #         "nref": 1e5\n                #     }\n                # },\n                # "vsat": {\n                #     "constant": 1.07e7,\n                #     "enable_model": False,\n                #     "gamma": 0.87,\n                #     "vsat0": 1.07e7\n                # }\n            }\n        },\n        "mup": {\n            "lattice": {\n                # "constant": 470.5,\n                "enable_model": True,\n                "eta": -2.2,\n                "mumax": 470.5\n            },\n            "impurity": {\n                "model": "masetti",  # or "none"\n                "masetti": {\n                    "alpha": 0.719,\n                    "beta": 2,\n                    "cr": 2.23e17,\n                    "cs": 6.1e20,\n                    "mu1": 29,\n                    "mumin1": 44.9,\n                    "mumin2": 44.9,\n                    "pc": 0\n                }\n            },\n            "high_field": {\n                "model": "none",  \n                # "canali": {\n                #     "alpha": 0,\n                #     "beta0": 1.213,\n                #     "eta": 0.17\n                # },\n                # "driving_field": {\n                #     "model": "e_dot_j",  # or "grad_phi",\n                #     "grad_phi": {\n                #         "nref": 1e5\n                #     }\n                # },\n                # "vsat": {\n                #     "constant": 8.37e6,\n                #     "enable_model": True,\n                #     "gamma": 0.52,\n                #     "vsat0": 8.37e6\n                # },\n            },\n        },\n    },\n}\n\n')),(0,i.kt)("p",null,"The parameter values of ",(0,i.kt)("inlineCode",{parentName:"p"},"opto_Si_properties_1550")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"opto_Si_properties_1310"),' are used to describe the perturbation variation of carrier distribution on refractive index. Should choose the "index_perturbation" model and enable the "np_density" model to define these parameters.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'opto_Si_properties_1550 = {\n    "index_perturbation":\n    {\n        "enabled": True,\n        "np_density": \n        {\n            "enable_model": True,\n            "np_density_model": "soref_and_bennett", \n            "coefficients": "user_input",   \n            "isotropic_data": [\n            {\n                "dalpha_an": 8.5e-18,\n                "dalpha_ap": 6e-18,\n                "dalpha_en": 1,\n                "dalpha_ep": 1,\n                "dn_an": -8.8e-22,\n                "dn_ap": -8.5e-18,\n                "dn_en": 1,\n                "dn_ep": 0.8,\n            }\n            ]\n        }\n    }\n}\n\nopto_Si_properties_1310 = {\n    "index_perturbation":\n    {\n        "enabled": True,\n        "np_density": \n        {\n            "enable_model": True,\n            "np_density_model": "soref_and_bennett", \n            "coefficients": "user_input",   \n            "isotropic_data": [\n            {\n                "dalpha_an": 6e-18,\n                "dalpha_ap": 4e-18,\n                "dalpha_en": 1,\n                "dalpha_ep": 1,\n                "dn_an": -6.2e-22,\n                "dn_ap": -6e-18,\n                "dn_en": 1,\n                "dn_ep": 0.8,\n            }\n            ]\n        }\n    }\n}\n')),(0,i.kt)("h3",{id:"2-code-description"},"2. Code description"),(0,i.kt)("h4",{id:"21-import-modules"},"2.1 Import Modules"),(0,i.kt)("p",null,"To begin, we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," command to call the relevant functional modules and  parameter values of material from previously defined file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import sys\n\n# encoding: utf-8\n\nfrom moapi.v3.aggregate import AggregatedUIService as Project\nimport maxoptics_sdk.all as mo\nfrom maxoptics_sdk.helper import timed, with_path\nimport os\nimport time\nfrom typing import NamedTuple\nimport sys\ncurrent_dir = os.path.dirname(__file__)\nsys.path.extend([current_dir])\nfrom MOD_material import elec_Si_properties, opto_Si_properties_1550, opto_Si_properties_1310\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"typing")," module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"os")," module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," module provides various functions to work with time-related operations and to measure time intervals. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"maxoptics_sdk")," package provides all in one optical simulation with Python."),(0,i.kt)("h4",{id:"22-define-parameters"},"2.2 Define Parameters"),(0,i.kt)("h5",{id:"221-general-parameters"},"2.2.1 General Parameters"),(0,i.kt)("p",null,"We define these parameters for entire simulation process."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'wavelength = 1.55    # um\ntemperature = 300    # K\nnormal_length = 1e4  # um\negrid_global = 0.01  # um\nogrid_global_y = 0.02   # um\nogrid_global_z = 0.02   # um\nogrid_local_y = 0.002    # um\nogrid_local_z = 0.002    # um\nrun_mode = "local"\nsimu_name = "MOD00"\n\n')),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Units"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"wavelength"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the optical wavelength of the source beam (in the vacuum) for mono-spectral simulations.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"temperature"),(0,i.kt)("td",{parentName:"tr",align:null},"K"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the temperature in Kelvin.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"normal_length"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the extent of a mesh section in the X direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"egrid_loacal"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the appropriate size of mesh in the Y and Z direction for overall region of DDM simulation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ogrid_global_y"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the mesh spacing in the Y direction for region of optical simulation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ogrid_global_z"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the mesh spacing in the Z direction for region of optical simulation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ogrid_local"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the mesh spacing in the Y and Z direction for local region of optical simulation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"run_mode"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the simulate model.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"simu_name"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies this file name to define name of output result folder.")))),(0,i.kt)("p",null,"Since we explore two communication wavelength, you should define the wavelength, and use next code to choose  relavent parameters values, which we defines in ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD_material.py")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"if wavelength > 1.4:\n    Si_index_vs_doping = opto_Si_properties_1550\nelse:\n    Si_index_vs_doping = opto_Si_properties_1310\n")),(0,i.kt)("h5",{id:"222-structure-geometry"},"2.2.2 Structure Geometry"),(0,i.kt)("p",null,"You should define the location of material in X, Y and Z direction about the modulator structure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"st_x_min = -0.3\nst_x_max = 0.3\nst_x_mean = 0.5*(st_x_min+st_x_max)\nst_x_span = st_x_max-st_x_min\n\nst_y_min = -5\nst_y_max = 5\nst_y_mean = 0.5*(st_y_min+st_y_max)\nst_y_span = st_y_max-st_y_min\n\nst_z_min = -0.3\nst_z_max = 0.8\n\nslab_height = 0.09\nrg_height = 0.22\nrg_width = 0.5\nelec_height = 0.5\nelec_width = 1.2\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Units"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"x_min, x_max, y_min, y_max, z_min, z_max"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the minimum or maximum value in X/Y boundary of modulator structure.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"x_mean, x_span, y_mean, y_span, z_mean, z_span"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the center or spacing value in X/Y boundary of modulator structure.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"slab_height"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the height of slab layer in Z direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"rg_height"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the height of RG layer in Z direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"elec_height, elec_width"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the Z-direction height and Y-direction width of electron.")))),(0,i.kt)("h5",{id:"223-electrical-simulation-boundary"},"2.2.3 Electrical Simulation Boundary"),(0,i.kt)("p",null,"Specifies the  boundary of electrical simulation for ",(0,i.kt)("inlineCode",{parentName:"p"},"DDM")," solver in 3D direction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"oe_x_min = 0\noe_x_max = 0\noe_x_mean = 0.5*(oe_x_min+oe_x_max)\noe_x_span = oe_x_max-oe_x_min\n\noe_y_min = st_y_min\noe_y_max = st_y_max\noe_y_mean = 0.5*(oe_y_min+oe_y_max)\noe_y_span = oe_y_max-oe_y_min\n\noe_z_min = st_z_min\noe_z_max = st_z_max\noe_z_mean = 0.5*(oe_z_min+oe_z_max)\noe_z_span = oe_z_max-oe_z_min\n")),(0,i.kt)("p",null,"Specifies the  concentration of uniform doping by ",(0,i.kt)("inlineCode",{parentName:"p"},"constant_con")," and its boundary throuth ",(0,i.kt)("inlineCode",{parentName:"p"},"center")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"span")," in Y-Z plane."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"constant_y_center = 0\nconstant_y_span = 10\nconstant_z_center = 0.1\nconstant_z_span = 0.3\nconstant_con = 1e15\n")),(0,i.kt)("p",null,"Specifies the  junction width and peak concentration of gaussian doping by",(0,i.kt)("inlineCode",{parentName:"p"},"_jw")," and  ",(0,i.kt)("inlineCode",{parentName:"p"},"_con")," , its boundary throuth ",(0,i.kt)("inlineCode",{parentName:"p"},"center")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"span")," in Y-Z plane of slab."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"p_slab_y_center = -2.575\np_slab_y_span = 4.85\np_slab_z_center = -0.105\np_slab_z_span = 0.39\np_slab_jw = 0.1\np_slab_con = 7e17\n\nn_slab_y_center = 2.575\nn_slab_y_span = 4.85\nn_slab_z_center = -0.105\nn_slab_z_span = 0.39\nn_slab_jw = 0.1\nn_slab_con = 5e17\n")),(0,i.kt)("p",null,"Specifies the doping region of high concentration in slab layer, including boundary\u3001junction width and peak concentration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"p_plus_y_center = -3.5\np_plus_y_span = 3\np_plus_z_center = -0.04\np_plus_z_span = 0.52\np_plus_jw = 0.1\np_plus_con = 1e19\n\nn_plus_y_center = 3.5\nn_plus_y_span = 3\nn_plus_z_center = -0.04\nn_plus_z_span = 0.52\nn_plus_jw = 0.1\nn_plus_con = 1e19\n")),(0,i.kt)("p",null,"Specifies the doping region of high concentration in waveguide structure, including boundary\u3001junction width and peak concentration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"p_wg_y_center = -0.12\np_wg_y_span = 0.36\np_wg_z_center = 0.1275\np_wg_z_span = 0.255\np_wg_jw = 0.12\np_wg_con = 5e17\n\nn_wg_y_center = 0.105\nn_wg_y_span = 0.29\nn_wg_z_center = 0.12\nn_wg_z_span = 0.235\nn_wg_jw = 0.11\nn_wg_con = 7e17\n")),(0,i.kt)("h5",{id:"224-optical-simulation-boundary"},"2.2.4 Optical simulation Boundary"),(0,i.kt)("p",null,"Specifies the boundary of optical simulation  for ",(0,i.kt)("inlineCode",{parentName:"p"},"FDE")," solver in 3D direction. We only consider optical characteristic of Y-Z plane, since the light travels along X-axis."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x_min = 0\nx_max = 0\nx_mean = 0.5*(x_min+x_max)\nx_span = x_max-x_min\n\ny_min = -2.3\ny_max = 2.3\ny_mean = 0.5*(y_min+y_max)\ny_span = y_max-y_min\n\nz_min = -1.5\nz_max = 1.5\nz_mean = 0.5*(z_min+z_max)\nz_span = z_max-z_min\n")),(0,i.kt)("h4",{id:"23-define-engineering-function"},"2.3 Define Engineering Function"),(0,i.kt)("p",null,"To facilitate the calling of other simulation scripts, it is recommended to define a function that can set materials, model, dope, and add boundary conditions."),(0,i.kt)("h5",{id:"231-create-project"},"2.3.1 Create Project"),(0,i.kt)("p",null,"Create a new simulation project."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class RunOptions(NamedTuple):\n    index_preview: bool = False\n    doping_preview: bool = False\n    calculate_modes: bool = False\n    run: bool = False\n    extract: bool = False\ndef create_project(project_name, run_options: RunOptions) -> Project:\n    # region --- 1. Project ---\n    pj = mo.Project(name=project_name)\n    # endregion\n    return pj\n\n")),(0,i.kt)("h5",{id:"232-set-material"},"2.3.2 Set Material"),(0,i.kt)("p",null,"The electrical and optical parameters of SiO2\u3001Al and Si materials in the material library can be accessed. If the parameters defined in the Si section of ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD_material.py"),"  are different from the default parameters in the material library, the former will be prioritized. In the overlapping area of the materials, the material with a higher order value will take precedence over the one with a lower value. If the values are the same, the material defined later will override the one defined earlier. It is worth noting that the material Aluminium will call the PEC material library."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 2. Material ---\n    mt = pj.Material()\n\n    mt.add_lib(name="mat_sio2", data=mo.OE_Material.SiO2, order=1)\n    mt.add_lib(name="mat_al", data=mo.OE_Material.Al, order=2, override={"work_function": 4.1})\n    mt.add_lib(name="mat_si", data=mo.OE_Material.Si, order=2, override=elec_Si_properties)\n    mt["mat_sio2"].set_optical_material(data=mo.Material.SiO2_Palik)\n    mt["mat_al"].set_optical_material(data=mo.Material.PEC)\n    mt["mat_si"].set_optical_material(data=mo.Material.Si_Palik, override=Si_index_vs_doping)\n    # endregion\n')),(0,i.kt)("h5",{id:"233-define-structure"},"2.3.3 Define structure"),(0,i.kt)("p",null,"To begin with, it is advisable to define the geometric region of the device structure in ",(0,i.kt)("inlineCode",{parentName:"p"},"geometry")," and add materials to this region by ",(0,i.kt)("inlineCode",{parentName:"p"},"material"),". The background material, which is usually Air or SiO2, should be added first."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 3. Structure ---\n    st = pj.Structure()\n\n    st.add_geometry(name="Slab", type="Rectangle", property={\n        "material": {"material": mt["mat_si"]},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": st_y_mean, "y_span": st_y_span, "z_min": 0, "z_max": slab_height}})\n\n    st.add_geometry(name="Rg", type="Rectangle", property={\n        "material": {"material": mt["mat_si"]},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": 0, "y_span": rg_width, "z_min": slab_height, "z_max": rg_height}})\n\n    # endregion\n')),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Units"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"name"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Restricts the applicability of the statement to regions with the specified name.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"type"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the  geometry of specified region.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"material"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Restricts the applicability of the statement to regions of the specified material.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"geometry"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the boundary of specified region in 3D direction")))),(0,i.kt)("p",null,"We offer several alternative electrode region for establishing the electrical simulation area."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    st.add_geometry(name="Anode", type="Rectangle", property={\n        "material": {"material": mt["mat_al"]},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y_min": st_y_min, "y_max": st_y_min + elec_width,\n                        "z_min": slab_height, "z_max": slab_height + elec_height}})\n\n    st.add_geometry(name="Cathode", type="Rectangle", property={\n        "material": {"material": mt["mat_al"]},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y_min": st_y_max - elec_width, "y_max": st_y_max,\n                        "z_min": slab_height, "z_max": slab_height + elec_height}})\n')),(0,i.kt)("h5",{id:"234-add-doping"},"2.3.4 Add Doping"),(0,i.kt)("p",null,"You should define the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," for doping region,and basic parameters of doping module in ",(0,i.kt)("inlineCode",{parentName:"p"},"property"),", such as  ",(0,i.kt)("inlineCode",{parentName:"p"},"dopant")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"geometry"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"applicable regions")," can choose the all region\u3001material or solid to reduce the doping region.Then define source face\u3001junction width\u3001peak concentration and  reference concentration in gaussian doping, or only concentration in uniform doping.  ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," specifies the n-type or donor dopant in ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," , and  p-type or acceptor dopant in ",(0,i.kt)("inlineCode",{parentName:"p"},"p")," , which may be used with gaussian and uniform profile types.  ",(0,i.kt)("inlineCode",{parentName:"p"},"ref_concentration")," specifies the diffusion boundary of Gaussian doping."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def add_ddm_settings(pj: Project, run_options: RunOptions):\n    # region --- 4. DDM:Doping ---\n    mt = pj.Material()\n    st = pj.Structure()\n    dp = pj.Doping()\n    dp.add(name="background_doping", type="constant_doping", property={\n        "dopant": {"dopant_type": "p", "concentration": constant_con},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span,\n                     "y": constant_y_center, "y_span": constant_y_span,\n                     "z": constant_z_center, "z_span": constant_z_span,\n                     "applicable_regions": "all_regions"\n                     }})\n    dp.add(name="p_slab", type="diffusion_doping", property={\n        "dopant": {"dopant_type": "p", "concentration": p_slab_con, "ref_concentration": 1e6,\n                   "source_face": "upper_z", "diffusion_function": "gaussian", "junction_width": p_slab_jw},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, \n                     "y": p_slab_y_center, "y_span": p_slab_y_span, \n                     "z": p_slab_z_center, "z_span": p_slab_z_span,\n                     "applicable_regions": "all_regions"\n                     }})\n    dp.add(name="n_slab", type="diffusion_doping", property={\n        "dopant": {"dopant_type": "n", "concentration": n_slab_con, "ref_concentration": 1e6,\n                   "source_face": "upper_z", "diffusion_function": "gaussian", "junction_width": n_slab_jw},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, \n                     "y": n_slab_y_center, "y_span": n_slab_y_span, \n                     "z": n_slab_z_center, "z_span": n_slab_z_span,\n                     "applicable_regions": "all_regions"\n                     }})\n    dp.add(name="p_plus", type="diffusion_doping", property={\n        "dopant": {"dopant_type": "p", "concentration": p_plus_con, "ref_concentration": 1e6,\n                   "source_face": "upper_z", "diffusion_function": "gaussian", "junction_width": p_plus_jw},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, \n                     "y": p_plus_y_center, "y_span": p_plus_y_span, \n                     "z": p_plus_z_center, "z_span": p_plus_z_span,\n                     "applicable_regions": "all_regions"\n                     }})\n    dp.add(name="n_plus", type="diffusion_doping", property={\n        "dopant": {"dopant_type": "n", "concentration": n_plus_con, "ref_concentration": 1e6,\n                   "source_face": "upper_z", "diffusion_function": "gaussian", "junction_width": n_plus_jw},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, \n                     "y": n_plus_y_center, "y_span": n_plus_y_span, \n                     "z": n_plus_z_center, "z_span": n_plus_z_span,\n                     "applicable_regions": "all_regions"\n                     }})\n    dp.add(name="p_wg", type="diffusion_doping", property={\n        "dopant": {"dopant_type": "p", "concentration": p_wg_con, "ref_concentration": 1e6,\n                   "source_face": "lower_y", "diffusion_function": "gaussian", "junction_width": p_wg_jw},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, \n                     "y": p_wg_y_center, "y_span": p_wg_y_span, \n                     "z": p_wg_z_center, "z_span": p_wg_z_span,\n                     "applicable_regions": "all_regions"\n                     }})    \n    dp.add(name="n_wg", type="diffusion_doping", property={\n        "dopant": {"dopant_type": "n", "concentration": n_wg_con, "ref_concentration": 1e6,\n                   "source_face": "upper_y", "diffusion_function": "gaussian", "junction_width": n_wg_jw},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, \n                     "y": n_wg_y_center, "y_span": n_wg_y_span, \n                     "z": n_wg_z_center, "z_span": n_wg_z_span,\n                     "applicable_regions": "all_regions"\n                     }})    \n    # endregion\n\n')),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Units"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"x_min, x_max, y_min, y_max, z_min, z_max"),(0,i.kt)("td",{parentName:"tr",align:"center"},"um"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Specifies the minimum or maximum value in X/Y boundary of modulator structure.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"x_mean, x_span, y_mean, y_span, z_mean, z_span"),(0,i.kt)("td",{parentName:"tr",align:"center"},"um"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Specifies the center or spacing value in X/Y boundary of modulator structure.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"applicable_regions"),(0,i.kt)("td",{parentName:"tr",align:"center"}),(0,i.kt)("td",{parentName:"tr",align:"center"},"Selections are ","['all_regions','solid','material']")))),(0,i.kt)("h5",{id:"235-set-monitor"},"2.3.5 Set Monitor"),(0,i.kt)("p",null,"Charge Monitor and Electrical Monitor support both 2D and 1D geometry, whereas Band Monitor can only be used for 1D geometry and Doping Monitor only supports 2D geometry. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 5. DDM:Monitor ---\n\n    mn = pj.Monitor()\n    mn.add(name="charge_monitor", type="charge_monitor", property={\n        "general": {"interpolate_accuracy": 1},\n        "geometry": {"monitor_type": "2d_x_normal", "x": st_x_mean, "x_span": 0,\n                     "y": st_y_mean, "y_span": st_y_span, "z": st_z_mean, "z_span": st_z_span}\n    })\n\n    mn.add(name="elec_monitor", type="electrical_monitor", property={\n        "general": {"interpolate_accuracy": 1},\n        "geometry": {"monitor_type": "2d_x_normal", "x": st_x_mean, "x_span": 0,\n                     "y": st_y_mean, "y_span": st_y_span, "z": st_z_mean, "z_span": st_z_span}\n    })\n    mn.add(name="band_monitor", type="band_monitor", property={\n        "general": {"interpolate_accuracy": 1},\n        "geometry": {"monitor_type": "y_linear", "x": st_x_mean, "x_span": 0,\n                     "y": st_y_mean, "y_span": st_y_span, "z": 0.08, "z_span": 0}\n    })\n    mn.add(name="doping_monitor", type="doping_monitor", property={\n        "general": {"interpolate_accuracy": 4},\n        "geometry": {"monitor_type": "2d_x_normal", "x": st_x_mean, "x_span": 0,\n                     "y": 0, "y_span": 0.8, "z_min": -0.1, "z_max": 0.3}\n    })\n\n    # endregion\n')),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"th"},"Parameters")),(0,i.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"name"),(0,i.kt)("td",{parentName:"tr",align:"center"},"The name of band monitor defined in the project.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"type"),(0,i.kt)("td",{parentName:"tr",align:"center"},"To decide the type of monitor.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"property"),(0,i.kt)("td",{parentName:"tr",align:"center"},"The property of band monitor.")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"th"},"Parameters")),(0,i.kt)("th",{parentName:"tr",align:"center"},"Default"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Type"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"general.interpolate_accuracy"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1"),(0,i.kt)("td",{parentName:"tr",align:"center"},"integer"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Set the accuracy of the rectangular grid for extracting the monitor result. Restrained by condition: >=1 && <= 10. Here 1 means the grid size is 10nm, and 10 means the grid size is 1nm, and the grid size varies uniformly with the variation in 'interpolate_accuracy'.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"monitor_type"),(0,i.kt)("td",{parentName:"tr",align:"center"}),(0,i.kt)("td",{parentName:"tr",align:"center"},"string"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Selections are ","['linear_x', 'linear_y', 'linear_z', '2d_x_normal', '2d_y_normal', '2d_z_normal']",".")))),(0,i.kt)("h5",{id:"236-add-mesh"},"2.3.6 Add Mesh"),(0,i.kt)("p",null,"When specifying meshes, a balance should be struck between accuracy and numerical efficiency. The accuracy, convergence, and program memory of the subsequent computation are all affected by the quality and size of the elements in the mesh, making mesh partitioning crucial in this module. Achieving accuracy requires a fine mesh that can resolve all significant features of the solution, while numerical efficiency requires a coarse mesh that minimizes the total number of grid points.  "),(0,i.kt)("p",null,"Due to the relatively simple structure of this modulator, a rough initial mesh can be established for electrical and optical simulation of the entire device. In order to obtain more accurate calculation results and better convergence, the ",(0,i.kt)("inlineCode",{parentName:"p"},"LocalMesh"),"  module is employed to refine the mesh of the regions with significant optical characteristics."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def add_fde_settings(pj: Project, run_options: RunOptions):\n    # region --- 6.FDE:Mesh ---\n    lm = pj.LocalMesh()\n\n    lm.add(name="Mesh", type="Mesh", property={\n        "general": {"dy": ogrid_local_y, "dz": ogrid_local_z},\n        "geometry": {"x": x_mean, "x_span": x_span, \n                     "y": 0, "y_span": 2*rg_width, \n                     "z_min": -0.5*rg_height, "z_max": 1.5*rg_height\n                     }})\n    # endregion\n')),(0,i.kt)("h5",{id:"236-set-preview-doping"},"2.3.6 Set preview Doping"),(0,i.kt)("p",null,"\u200bTo analyze the doping distribution of the device, the ",(0,i.kt)("inlineCode",{parentName:"p"},"DDM"),'  module can be invoked. First, define the file name for the resulting image and save it to the "plot" folder. Then, configure the DDM solver and define the region from which to extract the refractive index distribution, which is the coordinate in the two-dimensional Y-Z plane where the X-axis equals 0. Additionally, save the simulation process to the "log" folder in the "project" directory.'),(0,i.kt)("p",null,"Through invoking the ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," module and adding it to the file name, the output file of each simulation can be unique, which facilitates accurate file retrieval after multiple simulations. The ",(0,i.kt)("inlineCode",{parentName:"p"},"plot_path")," will be used as the path for saving extracted results and is set here to the plots folder in the same directory as the script. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'@timed\n@with_path\ndef preview_doping(**kwargs):\n    # region --- 6. Preview Doping ---\n    run_options = RunOptions(index_preview=False, doping_preview=True, calculate_modes=False, run=False, extract=False)\n\n    vsource = "Cathode" # electrode solid\n    gnd = "Anode"       # electrode solid  \n    path = kwargs["path"]\n    time_str = time.strftime("%Y%m%d_%H%M%S", time.localtime())\n    simu_name = "MOD00_structure_doping"\n    project_name = f"{simu_name}_{time_str}"\n    plot_path = f"{path}/plots/{project_name}/"\n    current_file_path = os.path.abspath(__file__)\n')),(0,i.kt)("p",null,"Adding electrical silmulation solver, is the prerequisite for output structure file. You can specify solver name and type in ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," module, and then define its other property. "),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"ddm")," module can be invoked to enable the charge carrier transport solver for analyzing the optoelectronic properties of a device. For this study, we set the solver to solve the steady state of the device at room temperature.\n, and should set the ",(0,i.kt)("inlineCode",{parentName:"p"},"electrode")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"BoundaryCondition"),". Additionally, we define the length of the three-dimensional X direction and the solution mode and temperature during the composite process. "),(0,i.kt)("p",null,"Since the simulation analysis is conducted in the two-dimensional Y-Z plane that is perpendicular to the X-axis, ",(0,i.kt)("inlineCode",{parentName:"p"},"2d_x_normal"),"  is adopted to define the simulation calculation geometry. And set the mesh size for entire region of DDM."),(0,i.kt)("p",null,"We utilize the ",(0,i.kt)("inlineCode",{parentName:"p"},"newton")," iteration method for calculation, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"mumps"),"  direct solver is employed as the linear solver. The ",(0,i.kt)("inlineCode",{parentName:"p"},"max_iterations")," parameter defines the maximum number of nonlinear iterations. When the number of iterations exceeds this value, the solver reduces the voltage step and starts a new iterative computations. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    pj: Project = create_project(project_name, run_options)\n\n    create_structures(pj, run_options)\n\n    mt = pj.Material()\n    st = pj.Structure()\n\n    simu = pj.Simulation()\n    simu.add(name=simu_name, type="DDM", property={\n        "background_material": mt["mat_sio2"], \n        "general": {"solver_mode": "steady_state",\n                    "norm_length": normal_length,\n                    "temperature_dependence": "isothermal",\n                    "temperature": temperature,\n                    },\n        "geometry": {"dimension": "2d_x_normal", "x": oe_x_mean, "x_span": 0, "y_min": oe_y_min, "y_max": oe_y_max, "z_min": oe_z_min, "z_max": oe_z_max},\n        "mesh_settings": {"mesh_size": egrid_global},\n        "advanced": {"non_linear_solver": "newton",\n                     "linear_solver": "mumps",\n                     "fermi_statistics": "disabled", # or "enabled"\n                     "damping": "none", # or "potential"\n                     "potential_update": 1.0,\n                     "max_iterations": 15,\n                     "relative_tolerance": 1e-5,\n                     "tolerance_relax": 1e5,\n                     "divergence_factor": 1e25\n                     }\n    })\n\n    add_ddm_settings(pj, run_options)\n\n    bd = pj.BoundaryCondition()\n\n    bd.add(name=vsource,type="electrode", property={\n        "geometry": {"surface_type": "solid", "solid": st[vsource]},\n        "general": {"electrode_mode": "steady_state",  \n                    "contact_type": "ohmic_contact",\n                    "sweep_type": "single", "voltage": 0,\n                    "apply_ac_small_signal": "none", \n                    # "envelop": "uniform",\n                    }\n    })\n    bd.add(name=gnd,type="electrode", property={\n        "geometry": {"surface_type": "solid", "solid": st[gnd]},\n        "general": {"electrode_mode": "steady_state",  \n                    "contact_type": "ohmic_contact",\n                    "sweep_type": "single", "voltage": 0,\n                    "apply_ac_small_signal": "none",\n                    # "envelop": "uniform",\n                    }\n    })\n\n    simu[simu_name].preview_doping(monitor_name="doping_monitor", savepath=f"{plot_path}doping", export_csv=True, real=True, imag=False)\n    # endregion\n')),(0,i.kt)("h5",{id:"236-set-preview-index"},"2.3.6 Set Preview Index"),(0,i.kt)("p",null,"You can invoke the ",(0,i.kt)("inlineCode",{parentName:"p"},"FDE"),'  module to analyze the refractive index distribution of the device. First, define the file name of the result image and save it to the "plot" folder, add structure and material about index region. To define the region of the refractive index distribution to be extracted in ',(0,i.kt)("inlineCode",{parentName:"p"},"geometry")," , which is the coordinate in the two-dimensional Y-Z plane at X-axis equal to 0. Then run analysis module of FDE and store the extracted result in file path."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'@timed\n@with_path\ndef preview_index(**kwargs):\n    # region --- 7. Preview Index ---\n    run_options = RunOptions(index_preview=True, doping_preview=False, calculate_modes=False, run=False, extract=False)\n\n    path = kwargs["path"]\n    simu_name = "MOD00_structure_index"\n    time_str = time.strftime("%Y%m%d_%H%M%S", time.localtime())\n    project_name = f"{simu_name}_{time_str}"\n    plot_path = f"{path}/plots/{project_name}/"\n    current_file_path = os.path.abspath(__file__)\n\n    pj: Project = create_project(project_name, run_options)\n    \n    create_structures(pj, run_options)\n\n    mt = pj.Material()\n    st = pj.Structure()\n\n    simu = pj.Simulation()\n    simu.add(name=simu_name, type="FDE",\n             property={"background_material": mt["mat_sio2"],\n                       "geometry": {"x": x_mean, "x_span": x_span, "y": y_mean, "y_span": y_span, "z": z_mean, "z_span": z_span, },\n                       "boundary_conditions": {"y_min_bc": "PEC", "y_max_bc": "PEC", "z_min_bc": "PEC", "z_max_bc": "PEC",},\n                       # \'mode_removal\': {\'threshold\': 0.02},\n                       # default is \'2d_x_normal\' [\'2d_x_normal\',\'2d_y_normal\',\'2d_z_normal\']\n                       \'general\': {\'solver_type\': \'2d_x_normal\'},\n                       "mesh_settings": {"mesh_refinement": {"mesh_refinement": "curve_mesh"}, "mesh_factor": 1.2,\n                                         "global_mesh_uniform_grid": {"dy": ogrid_global_y, "dz": ogrid_global_z, },\n                                         #    \'minimum_mesh_step_settings\': {\'min_mesh_step\': 1.0e-4}\n                                         }})\n\n    add_fde_settings(pj, run_options)\n\n    simu_res = simu[simu_name].run()\n\n    analysis = pj.Analysis()\n    analysis.add(name="fde_analysis", type="FDEAnalysis",\n                    property={"workflow_id": simu_res.workflow_id, "simulation_name": "FDE",\n                        "modal_analysis": {"calculate_modes": run_options.run, "mesh_structure": run_options.index_preview,\n                                        "wavelength": wavelength, "wavelength_offset": 0.0001, "number_of_trial_modes": 5,\n                                        "search": "max_index",  # [\'near_n\',\'max_index\']\n                                        # "n": 1,\n                                        "calculate_group_index": False,\n                                        "bent_waveguide": {"bent_waveguide": False, "radius": 1, "orientation": 0, "location": "simulation_center"}\n                                        }})\n    result_fde = analysis["fde_analysis"].run()\n\n    result_fde.extract(data="mesh_structure", savepath=f"{plot_path}01_index", export_csv=True)\nif __name__ == "__main__":\n    preview_doping()\n    preview_index()\n')),(0,i.kt)("h3",{id:"3-output-result"},"3. Output Result"),(0,i.kt)("p",null,"\u200bHere, we present the device geometry as defined in the structure file, along with the P-type and N-type dopant distributions, and the overall doping distribution."),(0,i.kt)("p",null,"\u200bApplication Library path:\n",(0,i.kt)("inlineCode",{parentName:"p"},":mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD00_structure_doping_time")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Na Doping"),(0,i.kt)("th",{parentName:"tr",align:"center"},"N Doping"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Nd Doping"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(85889).Z,width:"640",height:"480"})),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(84533).Z,width:"640",height:"480"})),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(31383).Z,width:"640",height:"480"}))))),(0,i.kt)("p",null,"\u200b\tWe can see the distribution of the refractive index in these three directions of device."),(0,i.kt)("p",null,"\u200b\tApplication Library path:\n",(0,i.kt)("inlineCode",{parentName:"p"},":mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD00_structure_index_time")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"X-axis"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Y-axis"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Z-axis"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(41664).Z,width:"640",height:"480"})),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(41454).Z,width:"640",height:"480"})),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(39297).Z,width:"640",height:"480"}))))),(0,i.kt)("h2",{id:"analytic-character"},"Analytic Character"),(0,i.kt)("h3",{id:"1modulation-efficiency"},"1.Modulation efficiency"),(0,i.kt)("p",null,"\u200bThe half-wave voltage refers to the applied voltage required by the modulator's optical signal to generate a phase difference of pi radians, directly reflecting the modulation efficiency of the modulator. Usually, the modulation efficiency of a device is represented by multiplying the half-wave voltage with a parameter that represents the length of the modulator required for phase variation. A smaller value of this parameter indicates higher modulation efficiency, resulting in a smaller required device size. "),(0,i.kt)("p",null,"According to the modulator's operating principle, the extra carriers created by the doped device under external bias form an internal electric field and depletion layer in the device via drift diffusion, resulting in changes in refractive index and loss. You may determine np density using DDM's steady-state solution by ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD02_np.py")," and then input the data into FDE to calculate changes in optical loss and refractive index by ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD0A_vpi.py"),". "),(0,i.kt)("p",null,"\u200bApplication Library path:\n",(0,i.kt)("inlineCode",{parentName:"p"},":mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD02_np.py"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},":mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD0A_vpi.py")),(0,i.kt)("h4",{id:"11-basic-operations"},"1.1 Basic Operations"),(0,i.kt)("p",null,"\u200bBefore analyzing the characteristic parameters of the device, you need to set up the simulation environment in advance and invoke the modules into the file by  ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," . Please refer to the PD documentation for detailed instructions on specific Python commands."),(0,i.kt)("h4",{id:"12-code-description"},"1.2 Code Description"),(0,i.kt)("h5",{id:"121-import-modules"},"1.2.1 Import Modules"),(0,i.kt)("p",null,"\u200bTo begin, we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," command to call the relevant functional modules."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import sys\n\n# encoding: utf-8\n\nfrom maxoptics_sdk.helper import timed, with_path\nimport os\nimport time\nimport sys\nimport numpy as np\ncurrent_dir = os.path.dirname(__file__)\nsys.path.extend([current_dir])\nfrom MOD00_structure import *\n\n")),(0,i.kt)("p",null,"\u200bFor specific instructions, see the description document of PD device."),(0,i.kt)("p",null,"\u200bBy adding the runtime function module to the file name, you can ensure the orderly storage of simulation results without data overlay or overwriting during multiple simulation runs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'@timed\n@with_path\ndef simulation(*, run_options: "RunOptions", **kwargs, ):\n')),(0,i.kt)("h5",{id:"122-define-parameters"},"1.2.2 Define Parameters"),(0,i.kt)("p",null,"\u200bThe operational mechanism of the device we simulated in this study primarily revolves around the application of a reverse voltage to modify the width of the depletion region, thereby effectively modifying the carrier concentration and subsequently modulating the refractive index. Hence, it is necessary to specify the voltage of initial\u3001termination and step, with both parameters expressed in volts. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'vsource = "Cathode" # electrode solid\n    gnd = "Anode"       # electrode solid  \n\n    sweep_vstart = -0.5\n    sweep_vstop = 4\n    sweep_vstep = 0.5  \n')),(0,i.kt)("h5",{id:"123-set-path"},"1.2.3 Set Path"),(0,i.kt)("p",null,"\u200bYou could define the project name of path, and then define the parameters for path."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'\n    path = kwargs["path"]\n    simu_name = "MOD02_np"\n    time_str = time.strftime("%Y%m%d_%H%M%S", time.localtime())\n    project_name = f"{simu_name}_local_{time_str}"\n    plot_path = f"{path}/plots/{project_name}/"\n    current_file_path = os.path.abspath(__file__)\n\n    # endregion\n\n    # region --- 1. Project ---\n\n    pj: Project = create_project(project_name, run_options)\n\n    # endregion\n')),(0,i.kt)("h5",{id:"124-create-structure"},"1.2.4 Create Structure"),(0,i.kt)("p",null,"Could directly reference the device structure and materials set in the previous file ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD00_structure.py")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD_material.py"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# region --- 1. Project ---\n\n    pj: Project = create_project(project_name, run_options)\n\n    # endregion\n\n    # region --- 2. Structure ---\n\n    create_structures(pj, run_options)\n\n    mt = pj.Material()\n    st = pj.Structure()\n\n    # endregion\n")),(0,i.kt)("h5",{id:"125-set-simulation"},"1.2.5 Set Simulation"),(0,i.kt)("p",null,"\u200bYou can add a electrical model solver here, include ",(0,i.kt)("inlineCode",{parentName:"p"},"DDM")," solver and boundary conditons. \u200bYou can specify the physical attributes of an electrode. You can set the BC model and scanning method here. The bias voltage range is set for steady-state solutions. Detailed information about the Electrode attribute can be found in the appendix of the PD documentation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    # region --- 3. Simulation ---\n    simu = pj.Simulation()\n    simu.add(name=simu_name, type="DDM", property={\n        "background_material": mt["mat_sio2"], \n        "general": {"solver_mode": "steady_state",\n                    "norm_length": normal_length,\n                    "temperature_dependence": "isothermal",\n                    "temperature": temperature,\n                    },\n        "geometry": {"dimension": "2d_x_normal", "x": oe_x_mean, "x_span": 0, "y_min": oe_y_min, "y_max": oe_y_max, "z_min": oe_z_min, "z_max": oe_z_max},\n        "mesh_settings": {"mesh_size": egrid_global},\n        "advanced": {"non_linear_solver": "newton",\n                     "linear_solver": "mumps",\n                     "fermi_statistics": "disabled", # or "enabled"\n                     "damping": "potential", # or "none"\n                     "potential_update": 1.0,\n                     "max_iterations": 15,\n                     "relative_tolerance": 1e-5,\n                     "tolerance_relax": 1e5,\n                     "divergence_factor": 1e25\n                     }\n    })\n\n    # endregion\n\n    # region --- 4. Simulation settings ---\n\n    add_ddm_settings(pj, run_options)\n\n    bd = pj.BoundaryCondition()\n\n    bd.add(name=vsource,type="electrode", property={\n        "geometry": {"surface_type": "solid", "solid": st[vsource]},\n        "general": {"electrode_mode": "steady_state",  \n                    "contact_type": "ohmic_contact",\n                    "sweep_type": "range", "range_start": sweep_vstart, "range_stop": sweep_vstop, "range_step": sweep_vstep,\n                    "apply_ac_small_signal": "none", \n                    # "envelop": "uniform",\n                    }\n    })\n    bd.add(name=gnd,type="electrode", property={\n        "geometry": {"surface_type": "solid", "solid": st[gnd]},\n        "general": {"electrode_mode": "steady_state",  \n                    "contact_type": "ohmic_contact",\n                    "sweep_type": "single", "voltage": 0,\n                    "apply_ac_small_signal": "none",\n                    # "envelop": "uniform",\n                    }\n    })\n    # endregion\n')),(0,i.kt)("h5",{id:"126-run"},"1.2.6 Run"),(0,i.kt)("p",null,"\u200bIt is recommended to include a module that runs the solver and initiates the simulation. The ",(0,i.kt)("inlineCode",{parentName:"p"},"result_device")," variable stores simulation results for subsequent extraction. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    # region --- 5. Run ---\n    if run_options.run:\n        result_ddm = simu[simu_name].run(resources={"threads": 4})\n    # endregion\n')),(0,i.kt)("h5",{id:"127-extract-parameters"},"1.2.7 Extract Parameters"),(0,i.kt)("p",null,"\u200bYou can extract and export simulation results to the plot folder."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 6. Extract ---\n    if run_options.run and run_options.extract:\n        export_options = {"export_csv": True,\n                          "export_mat": True, "export_zbf": False}\n\n        # --- Voltage list ---\n        result_ddm.extract(data="ddm:electrode", electrode_name=vsource, savepath=f"{plot_path}I_{vsource}",\n                           target="line", attribute="I", plot_x=f"V_{vsource}", real=True, imag=False, show=False, export_csv=True)\n        \n        result_ddm.save_as(data="ddm:charge_monitor", monitor_name="charge_monitor", savepath=f"{plot_path}/charge")        \n        \n        voltage_list = np.genfromtxt(f"{plot_path}I_{vsource}.csv", delimiter=",", skip_header=1)[:,0]\n\n        # --- Monitor Result ---\n        for voltage in voltage_list:\n            slice_options = {f"v_{vsource.lower()}": voltage, f"v_{gnd.lower()}": 0.0}\n\n            # --- Charge Monitor ---\n            attribute = "n"  # "n", "p"\n            result_ddm.extract(data="ddm:charge_monitor", monitor_name="charge_monitor", savepath=f"{plot_path}{attribute}/{voltage}V",\n                               target="intensity", attribute=attribute, real=True, imag=False, log=False, show=False, **slice_options, **export_options)\n            \n            # --- Electrical Monitor ---\n            attribute = "E"  # "E", "Ex", "Ey", "Ez"\n            result_ddm.extract(data="ddm:electrical_monitor", monitor_name="elec_monitor", savepath=f"{plot_path}{attribute}/{voltage}V",\n                               target="intensity", attribute=attribute, real=True, imag=False, log=False, show=False, **slice_options, **export_options)\n\n            # --- Band Monitor ---\n            attribute = "Ec" # "Ec", "Ev", "Efn", "Efp"                   \n            result_ddm.extract(data="ddm:band_monitor", monitor_name="band_monitor", savepath=f"{plot_path}{attribute}/{voltage}V",\n                               target="line", attribute=attribute, plot_x="y", real=True, imag=False, log=False, show=False, **slice_options, export_csv=True)\n\n    # endregion\n\n    return result_ddm if run_options.run else None\n\nif __name__ == "__main__":\n    simulation(run_options=RunOptions(index_preview=False, doping_preview=False, calculate_modes=False, run=True, extract=True))\n\n')),(0,i.kt)("h5",{id:"128-calculate"},"1.2.8 Calculate"),(0,i.kt)("p",null,"Import the ",(0,i.kt)("inlineCode",{parentName:"p"},"np density")," file, which contains the carrier distribution derived from the ",(0,i.kt)("inlineCode",{parentName:"p"},"DDM")," method, into the ",(0,i.kt)("inlineCode",{parentName:"p"},"FDE")," model. This integration facilitates the analysis of refractive index and loss variations as a function of bias voltage at specific wavelengths."),(0,i.kt)("p",null,"\u200bAccording to the phase change formula, we can determine that the refractive index ",(0,i.kt)("em",{parentName:"p"},"n")," is a function of bias voltage, which means that we can change the refractive index of the material by adjusting the bias voltage. "),(0,i.kt)(r.BlockMath,{math:"\\Delta\\varphi=\\frac{2\\pi}{\\lambda}\\Delta n(V)L\\\\=\\frac{2\\pi}{\\lambda}\\frac{dn}{dV}\\Delta VL",mdxType:"BlockMath"}),(0,i.kt)("p",null,"\u200bWith the following formula, when the phase difference is pi:"),(0,i.kt)(r.BlockMath,{math:"\\Delta V_\\pi L=\\frac{\\Delta V}{\\Delta n}\\frac{\\lambda}{2}",mdxType:"BlockMath"}),(0,i.kt)("p",null,"\u200bApplication Library path:\n",(0,i.kt)("inlineCode",{parentName:"p"},":mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD0A_vpi.py")),(0,i.kt)("p",null,"The fundamental simulation process entails loading Python modules, retrieving the device's structural and material properties from ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD00_structure"),", and obtaining the DDM simulation  setting from ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD02_np"),", while also specifying the file paths."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import sys\n\n# encoding: utf-8\nfrom maxoptics_sdk.helper import timed, with_path\nimport os\nimport time\nimport sys\nimport numpy as np\ncurrent_dir = os.path.dirname(__file__)\nsys.path.extend([current_dir])\n\nfrom MOD00_structure import *\nfrom MOD02_np import simulation as ddm_simulation\n\nrun_with_ddm = True # True: run ddm first, then import the np result to fde solver automatically\n                    # False: run fde only, the np file path need to be specified manually\n\n@timed\n@with_path\ndef simulation(*, run_options: "RunOptions", **kwargs, ):\n    # region --- 0. General Parameter ---\n\n    vsource = "Cathode" # electrode solid\n    gnd = "Anode"       # electrode solid\n\n    path = kwargs["path"]\n    np_file = kwargs["np_file"]\n    simu_name = "MOD0A_FDE"\n    time_str = time.strftime("%Y%m%d_%H%M%S", time.localtime())\n    project_name = f"{simu_name}_{time_str}"\n    plot_path = f"{path}/plots/{project_name}/"\n    current_file_path = os.path.abspath(__file__)\n\n    # endregion\n    # region --- 1. Project ---\n    pj: Project = create_project(project_name, run_options)\n    # endregion\n    \n    create_structures(pj, run_options)\n\n    mt = pj.Material()\n    st = pj.Structure()\n')),(0,i.kt)("p",null,"The optical solver ",(0,i.kt)("inlineCode",{parentName:"p"},"FDE")," can be configured in this location, allowing for the inclusion of ",(0,i.kt)("inlineCode",{parentName:"p"},"np density")," file within ",(0,i.kt)("inlineCode",{parentName:"p"},"data space"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    # region --- 2. Simulation ---\n    simu = pj.Simulation()\n    simu.add(name=simu_name, type="FDE",\n             property={"background_material": mt["mat_sio2"],\n                       "geometry": {"x": x_mean, "x_span": x_span, "y": y_mean, "y_span": y_span, "z": z_mean, "z_span": z_span, },\n                       "boundary_conditions": {"y_min_bc": "PEC", "y_max_bc": "PEC", "z_min_bc": "PEC", "z_max_bc": "PEC",},\n                       # \'mode_removal\': {\'threshold\': 0.02},\n                       # default is \'2d_x_normal\' [\'2d_x_normal\',\'2d_y_normal\',\'2d_z_normal\']\n                       \'general\': {\'solver_type\': \'2d_x_normal\'},\n                       "mesh_settings": {"mesh_refinement": {"mesh_refinement": "curve_mesh"}, "mesh_factor": 1.2,\n                                         "global_mesh_uniform_grid": {"dy": ogrid_global_y, "dz": ogrid_global_z, },\n                                         #    \'minimum_mesh_step_settings\': {\'min_mesh_step\': 1.0e-4}\n                                         }})\n    # endregion\n\n    # region --- 3. Simulation settings ---\n    add_fde_settings(pj, run_options)\n\n    ds = pj.DataSpace()\n    ds.import_data(name="np", type="np_density", property={"path": np_file})\n\n    attr = pj.Attribute()\n    attr.add(name="np", type="np_density", property={\n        "data": ds["np"], "index": {f"V_{vsource}": kwargs[f"V_{vsource}_index"], f"V_{gnd}": 0}\n    })\n\n    # endregion\n\n')),(0,i.kt)("p",null,"Run FDE solver and add the analysis to calculate the change of effective refractive index and optical loss under specific wavelength."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 4. Run ---\n    simu_res = simu[simu_name].run()\n\n    # --- Analysis ---\n    analysis = pj.Analysis()\n    analysis.add(name="fde_analysis", type="FDEAnalysis",\n                    property={"workflow_id": simu_res.workflow_id, "simulation_name": "FDE",\n                        "modal_analysis": {"calculate_modes": run_options.run, "mesh_structure": run_options.index_preview,\n                                        "wavelength": wavelength, "wavelength_offset": 0.0001, "number_of_trial_modes": 5,\n                                        "search": "max_index",  # [\'near_n\',\'max_index\']\n                                        # "n": 1,\n                                        "calculate_group_index": False,\n                                        "bent_waveguide": {"bent_waveguide": False, "radius": 1, "orientation": 0, "location": "simulation_center"}\n                                        }})\n    result_fde = analysis["fde_analysis"].run()\n    # endregion\n')),(0,i.kt)("p",null,"\u200bThis section of the program is dedicated to calculating the parameters ",(0,i.kt)("em",{parentName:"p"},"VpiL")," and ",(0,i.kt)("em",{parentName:"p"},"VpiLoss"),"."),(0,i.kt)("p",null,"\u200bYou should first extract the parameters for transmission loss and the real part of effective refractive index."),(0,i.kt)("p",null,"\u200bThe filename ",(0,i.kt)("inlineCode",{parentName:"p"},"01_neff.csv")," is automatically generated for the n-V data file. The initial ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"  indicates the electrode number, which changes when extracting current from different electrodes. Therefore, iterate from 0 to 9 to locate the saved n-V data files."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    # region --- 5. Extract ---\n    \n    export_options = {"export_csv": True,\n                      "export_mat": True, "export_zbf": True}\n\n    if run_options.extract:\n        if run_options.index_preview:\n            result_fde.extract(\n                data="mesh_structure", savepath=f"{plot_path}01_index", export_csv=True)\n            \n        if run_options.run:\n            res = result_fde.extract(\n                data="calculate_modes", savepath=f"{plot_path}02_neff_table", export_csv=True)\n            # print(res.to_string(index=True))\n            # for m in range(len(res)):\n            #     result_fde.extract(data="calculate_modes", savepath=f"{plot_path}03_mode{m}",\n            #                         attribute="E", mode=m, real=True, imag=True, **export_options, show=False)\n            return res\n    # endregion\n\n    return None\n\nif __name__ == "__main__":\n    simu_name="MOD0A_vpi"\n    time_str = time.strftime("%Y%m%d_%H%M%S", time.localtime())\n    plot_folder = os.path.join(current_dir, "plots", f"{simu_name}_{time_str}")\n\n    if not os.path.exists(plot_folder):\n        os.makedirs(plot_folder)\n\n    if run_with_ddm:\n        result_ddm = ddm_simulation(run_options=RunOptions(run=True))\n        result_ddm.save_as(data="ddm:charge_monitor", monitor_name="charge_monitor", savepath=f"{plot_folder}/charge")\n        np_density_file = f"{plot_folder}/charge.cdat"\n    else:\n        np_density_file = os.path.join(os.path.dirname(__file__), "MOD02_np.cdat")\n\n    voltage_list = np.linspace(-0.5, 4, 10)\n    neff = []\n    loss = []\n    for index in range(len(voltage_list)):\n        res = simulation(run_options=RunOptions(run=True, extract=True), V_Cathode_index=index, np_file=np_density_file)\n        neff.append(res["neff_real"][0])\n        loss.append(res["loss_dBpcm"][0])\n')),(0,i.kt)("p",null,"\u200bGenerate the relationship curve and data file for the product of half-wave voltage and effective modulation length (",(0,i.kt)("em",{parentName:"p"},"VpiL"),"), the product of half-wave voltage and loss (",(0,i.kt)("em",{parentName:"p"},"VpiLoss"),"), as well as VBias, and save them in the respective newly created files."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    vpil = []\n    volt_out = []\n    vpiloss = []\n\n    for i in range(1, len(voltage_list)-1):\n        volt_out.append(voltage_list[i])\n        vpil.append((voltage_list[i+1]-voltage_list[i-1])/(neff[i+1]-neff[i-1])*wavelength/2*1e-4)\n        vpiloss.append(vpil[-1]*loss[i])\n\n    neff_file = os.path.join(plot_folder, "01_neff.csv")\n    loss_file = os.path.join(plot_folder, "02_loss.csv")\n    vpil_file = os.path.join(plot_folder, "03_vpil.csv")\n    vpiloss_file = os.path.join(plot_folder, "04_vpiloss.csv")\n\n')),(0,i.kt)("p",null,"\u200bYou can use the following program to set up the title and style of the picture."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"    np.savetxt(neff_file, np.array((voltage_list, neff)).T, fmt='%f,%.15f', header='voltage,neff')\n    np.savetxt(loss_file, np.array((voltage_list, loss)).T, fmt='%f,%.15f', header='voltage,loss')\n    np.savetxt(vpil_file, np.array((volt_out, vpil)).T, fmt='%f,%.15f', header='voltage,VpiL')\n    np.savetxt(vpiloss_file, np.array((volt_out, vpiloss)).T, fmt='%f,%.15f', header='voltage,VpiLoss')\n")),(0,i.kt)("h4",{id:"13-output-result"},"1.3 Output Result"),(0,i.kt)("p",null,"\u200bApplication Library path: ",(0,i.kt)("inlineCode",{parentName:"p"},":mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD0A_vpi_local_time")),(0,i.kt)("h5",{id:"131-loss"},"1.3.1 Loss"),(0,i.kt)("p",null,"\u200bThis section displays the variation of losses with bias voltage."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(16273).Z,width:"1200",height:"800"})),(0,i.kt)("h5",{id:"132-effective-index"},"1.3.2 Effective Index"),(0,i.kt)("p",null,"\u200bThese graphs depict the real and imaginary components of the refractive index as a function of bias voltage."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Reffective index real"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Reffective index imaginary"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(49766).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(52198).Z,width:"1200",height:"800"}))))),(0,i.kt)("h5",{id:"133-modulation-efficiency"},"1.3.3 Modulation efficiency"),(0,i.kt)("p",null,"\u200bThese graphs illustrate the relationship between two parameters that represent modulation efficiency as a function of bias voltage."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("em",{parentName:"th"},"VpiL")),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("em",{parentName:"th"},"VpiLoss")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(84613).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:n(92626).Z,width:"1200",height:"800"}))))),(0,i.kt)("h3",{id:"2-capacitance-and-resistance"},"2. Capacitance And Resistance"),(0,i.kt)("p",null,"\u200bCapacitance and resistance play crucial roles in determining the performance of devices. Optimal capacitance values enable the modulator to selectively allow or block signals within specific frequency ranges, facilitating signal coupling. Suitable resistance values enable adjustment of signal amplitude and modulation current determination."),(0,i.kt)("p",null,"\u200bApplication Library path: ",(0,i.kt)("inlineCode",{parentName:"p"},":mo_sdk_solution_v3.2.3.0\\examples\\active_demo\\doping_function\\MOD\\MOD0B_RC.py")),(0,i.kt)("h4",{id:"21-basic-operations"},"2.1 Basic Operations"),(0,i.kt)("p",null,"\u200bThe simulation program for calculating capacitance and voltage exhibits numerous similarities to the program used for investigating modulation efficiency. Prior to conducting the simulation, it is necessary to import the module in order to invoke the structures and physical models defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD00_structure.py")," ."),(0,i.kt)("h4",{id:"22-code-description"},"2.2 Code Description"),(0,i.kt)("h5",{id:"221-import-modules"},"2.2.1 Import Modules"),(0,i.kt)("p",null,"\u200bThe necessary Python modules for the program are invoked within the process."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import sys\n\n# encoding: utf-8\n\nfrom maxoptics_sdk.helper import timed, with_path\nimport os\nimport time\nimport sys\nimport numpy as np\ncurrent_dir = os.path.dirname(__file__)\nsys.path.extend([current_dir])\nfrom MOD00_structure import *\n")),(0,i.kt)("h5",{id:"222-define-parameters"},"2.2.2 Define Parameters"),(0,i.kt)("p",null,"\u200bThe voltages to be applied to the electrodes of the device are specified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'@timed\n@with_path\ndef simulation(*, run_options: "RunOptions", **kwargs, ):\n    \n    # region --- 0. General Parameter ---\n\n    vsource = "Cathode" # electrode solid\n    gnd = "Anode"       # electrode solid  \n\n    sweep_vstart = -0.5\n    sweep_vstop = 4\n    sweep_vstep = 0.5\n\n    ssac_amplitude = 0.001\n')),(0,i.kt)("h5",{id:"223-set-path"},"2.2.3 Set Path"),(0,i.kt)("p",null,"\u200bYou can use the time module for file naming conventions and then store the files in the ",(0,i.kt)("inlineCode",{parentName:"p"},"plot_path")," folder."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'  path = kwargs["path"]\n    simu_name = "MOD01_RC"\n    time_str = time.strftime("%Y%m%d_%H%M%S", time.localtime())\n    project_name = f"{simu_name}_local_{time_str}"\n    plot_path = f"{path}/plots/{project_name}/"\n    current_file_path = os.path.abspath(__file__)\n')),(0,i.kt)("h5",{id:"224-set-simulation"},"2.2.4 Set Simulation"),(0,i.kt)("p",null,"\u200bYou can add a solver for the simulation and define its properties. Furthermore, the properties of the AC small-signal module are defined in this section. The frequency interval is logarithmically defined, specifying the initial frequency, final frequency, and the number of frequencies. The variable ",(0,i.kt)("inlineCode",{parentName:"p"},'ssac_amplitude"')," represents the amplitude of the small signal. In this instance, three frequency values (1, 100, and 10000 MHz) are selected from the range of 1e6 to 1e10."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 1. Project ---\n\n    pj: Project = create_project(project_name, run_options)\n\n    # endregion\n\n    # region --- 2. Structure ---\n\n    create_structures(pj, run_options)\n\n    mt = pj.Material()\n    st = pj.Structure()\n\n    # endregion\n\n    # region --- 3. Simulation ---\n    simu = pj.Simulation()\n    simu.add(name=simu_name, type="DDM", property={\n        "background_material": mt["mat_sio2"], \n        "general": {"solver_mode": "ssac",\n                    "norm_length": normal_length,\n                    "temperature_dependence": "isothermal",\n                    "temperature": temperature,\n                    "perturbation_amplitude": ssac_amplitude, "frequency_spacing": "log", \n                    "log_start_frequency": 1e6, "log_stop_frequency": 1e10, "number_of_points": 3\n                    },\n        "geometry": {"dimension": "2d_x_normal", "x": oe_x_mean, "x_span": 0, "y_min": oe_y_min, "y_max": oe_y_max, "z_min": oe_z_min, "z_max": oe_z_max},\n        "mesh_settings": {"mesh_size": egrid_global},\n        "advanced": {"non_linear_solver": "newton",\n                     "linear_solver": "mumps",\n                     "fermi_statistics": "disabled", # or "enabled"\n                     "damping": "potential", # or "none"\n                     "potential_update": 1.0,\n                     "max_iterations": 15,\n                     "relative_tolerance": 1e-5,\n                     "tolerance_relax": 1e5,\n                     "divergence_factor": 1e25\n                     }\n    })\n\n    # endregion\n')),(0,i.kt)("h5",{id:"225-create-component"},"2.2.5 Create Component"),(0,i.kt)("p",null,"\u200bYou can directly invoke the engineering function and device structure created in the ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD00_structure.py"),"  file, and then add the electrodes and their attributes. In this case, a bias voltage ranging from -0.5 V to 4 V with a scan step of 0.5 V is applied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"cathode")," electrode during small-signal simulation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'\n    # region --- 4. Simulation settings ---\n\n    add_ddm_settings(pj, run_options)\n\n    bd = pj.BoundaryCondition()\n\n    bd.add(name=vsource,type="electrode", property={\n        "geometry": {"surface_type": "solid", "solid": st[vsource]},\n        "general": {"electrode_mode": "steady_state",  \n                    "contact_type": "ohmic_contact",\n                    "sweep_type": "range", "range_start": sweep_vstart, "range_stop": sweep_vstop, "range_step": sweep_vstep,\n                    "apply_ac_small_signal": "all", \n                    # "envelop": "uniform",\n                    }\n    })\n    bd.add(name=gnd,type="electrode", property={\n        "geometry": {"surface_type": "solid", "solid": st[gnd]},\n        "general": {"electrode_mode": "steady_state",  \n                    "contact_type": "ohmic_contact",\n                    "sweep_type": "single", "voltage": 0,\n                    "apply_ac_small_signal": "none",\n                    # "envelop": "uniform",\n                    }\n    })\n    # endregion\n')),(0,i.kt)("h5",{id:"226-run"},"2.2.6 Run"),(0,i.kt)("p",null,"\u200bIt is recommended to include a module to execute the solver and commence the simulation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    # region --- 5. Run ---\n    if run_options.run:\n        result_ddm = simu[simu_name].run(resources={"threads": 4})\n    # endregion\n')),(0,i.kt)("h5",{id:"227-extract-parameters"},"2.2.7 Extract Parameters"),(0,i.kt)("p",null,"\u200bFirstly, the names of the folders used to store the extracted data for the real and imaginary components of the refractive index should be defined. \u200bSecondly, the following program can be used to define the output files for the real and imaginary parts of the refractive index, as well as the capacitance and resistance, while also specifying the data content within the files and ensuring proper attention to the frequency units."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    # region --- 6. Extract ---\n    if run_options.run and run_options.extract:\n        export_options = {"export_csv": True,\n                          "export_mat": True, "export_zbf": False}\n        \n        # --- Frequency list ---\n        result_ddm.extract(data="ddm:electrode_ac", electrode_name=vsource, savepath=f"{plot_path}Iac_f",\n                            target="line", attribute="Iac", plot_x=f"frequency", real=True, imag=False, show=False, export_csv=True)\n        ssac_frequency_span = np.genfromtxt(f"{plot_path}Iac_f.csv", skip_header=1, delimiter=\',\')[:,0]\n\n        # --- Iac ---\n        for i,val in enumerate(ssac_frequency_span):\n            plot_path_f = os.path.join(plot_path, f"{val/1e6:.2f}MHz")\n            result_ddm.extract(data="ddm:electrode_ac", electrode_name=vsource, savepath=f"{plot_path_f}/Iac_{vsource}_real",\n                            target="line", attribute="Iac", plot_x=f"V_{vsource}", real=True, imag=False, frequency=val, show=False, export_csv=True)\n            \n            result_ddm.extract(data="ddm:electrode_ac", electrode_name=vsource, savepath=f"{plot_path_f}/Iac_{vsource}_imag",\n                            target="line", attribute="Iac", plot_x=f"V_{vsource}", real=False, imag=True, frequency=val, show=False, export_csv=True)\n    # endregion\n')),(0,i.kt)("p",null,"2.2.8 Calculate"),(0,i.kt)("p",null,"\u200bFinally, the column names in the previously defined data files can be set, with the first column representing voltage and the second column representing capacitance or resistance. Additionally, the axis titles and styles should be set for the output images."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'    # region --- 7. Post Processing ---\n        fontsize = 20\n        linewidth = 1\n        plt.rcParams.update({"font.size": fontsize})\n        for i,val in enumerate(ssac_frequency_span):\n            plot_path_f = os.path.join(plot_path, f"{val/1e6:.2f}MHz")\n            Iac_real_data = np.genfromtxt(f"{plot_path_f}/Iac_Cathode_real.csv", skip_header=1, delimiter=",")\n            Iac_imag_data = np.genfromtxt(f"{plot_path_f}/Iac_Cathode_imag.csv", skip_header=1, delimiter=",")\n            Iac = Iac_real_data[:,1] + 1j * Iac_imag_data[:,1]\n            Vdc = Iac_real_data[:,0]\n            Z = ssac_amplitude/Iac\n            R = np.abs(np.real(Z))\n            C = np.abs(np.imag(1/Z)/(2*np.pi*ssac_frequency_span[i]))/1e4*1e15\n\n            np.savetxt(f"{plot_path_f}/resistance.csv", np.array((Vdc, R)).T, fmt=\'%f,%.15e\', header=\'voltage,resistance\')\n            np.savetxt(f"{plot_path_f}/capacitance.csv", np.array((Vdc, C)).T, fmt=\'%f,%.15e\', header=\'voltage,capacitance\')\n\n            fig, ax1 = plt.subplots()\n            fig.set_size_inches(12, 8)\n            ax1.plot(Vdc, R, c=\'b\', linewidth=linewidth, label=f"f:{val/1e6:.2f}MHz",marker=\'o\')\n            ax1.set_xlabel(\'VBias[V]\')\n            ax1.set_ylabel(\'Resistance[Ohm]\')\n            ax1.legend()\n            ax1.grid()\n            plt.savefig(f"{plot_path_f}/resistance.jpg")\n            plt.close()\n\n            fig, ax2 = plt.subplots()\n            fig.set_size_inches(12, 8)\n            ax2.plot(Vdc, C, c=\'b\', linewidth=linewidth, label=f"f:{val/1e6:.2f}MHz",marker=\'o\')\n            ax2.set_xlabel(\'VBias[V]\')\n            ax2.set_ylabel(\'Capacitance[fF/um]\')\n            ax2.legend()\n            ax2.grid()\n            plt.savefig(f"{plot_path_f}/capacitance.jpg")    \n            plt.close()\n    # endregion\nif __name__ == "__main__":\n    simulation(run_options=RunOptions(index_preview=False, doping_preview=False, calculate_modes=False, run=True, extract=True))\n')),(0,i.kt)("h4",{id:"23-output-result"},"2.3 Output Result"),(0,i.kt)("p",null,"\u200bApplication Library path: ",(0,i.kt)("inlineCode",{parentName:"p"},":\\examples\\active_demo\\doping_function\\MOD\\plots\\MOD0B_RC_local_time")),(0,i.kt)("h5",{id:"231-small-signal-ac-current"},"2.3.1 Small Signal AC Current"),(0,i.kt)("p",null,"\u200bThis section displays the variations of the real and imaginary components of the AC current with respect to bias voltage at different frequencies."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null},"1 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"100 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"10000 MHZ"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Real"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(12050).Z,width:"640",height:"480"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(70044).Z,width:"640",height:"480"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(22957).Z,width:"640",height:"480"}))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Image"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(79751).Z,width:"640",height:"480"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(23080).Z,width:"640",height:"480"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(12982).Z,width:"640",height:"480"}))))),(0,i.kt)("h5",{id:"232-capacitance"},"2.3.2 Capacitance"),(0,i.kt)("p",null,"\u200bThis section displays the variations of capacitance with respect to bias voltage at different frequencies."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"1 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"100 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"10000 MHZ"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(26603).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(35906).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(24616).Z,width:"1200",height:"800"}))))),(0,i.kt)("h5",{id:"233-resistance"},"2.3.3 Resistance"),(0,i.kt)("p",null,"\u200bThis section displays the variations of resistance with respect to bias voltage at different frequencies."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"1 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"100 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"10000 MHZ"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(81259).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(66717).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:n(2076).Z,width:"1200",height:"800"}))))))))}_.isMDXComponent=!0},41664:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/01_index (index X)-2944bcd83f301a6b0a551fe82dc71e84.png"},41454:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/01_index (index Y)-c33f5593471fa2460095ced8f30276a0.png"},39297:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/01_index (index Z)-6275fe12b48eaa0af5ee397659a302a3.png"},84533:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/doping_N-e47c2b74a6d401fd636a4f4ad9c7794f.png"},85889:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/doping_Na-fb08dfaa8d7d7c1cdeae3b6868e65ac1.png"},31383:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/doping_Nd-57b4e26d737c5f25985e7fc5226ee64c.png"},79751:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Iac_Cathode_imag-9796cbef5d7df2d2bec7b67c8fc94ad2.png"},12050:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Iac_Cathode_real-8035f64abc17b3086f6537e425db660a.png"},26603:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/capacitance-da73faa57aef0d8e04cd7fa8d4b120e4.jpg"},81259:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/resistance-138b8a36e68edd26e6eeedc46325f407.jpg"},23080:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Iac_Cathode_imag-815f86c3b4e3d3c2d8ed1e67852e4a13.png"},70044:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Iac_Cathode_real-8c60f0ae083c16ae73fe2efd64956e12.png"},35906:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/capacitance-b498a009bc7acc7983b866cc95594b0d.jpg"},66717:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/resistance-e470cca236bdb59b1e6aa0f6ffb26d49.jpg"},12982:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Iac_Cathode_imag-ab9f1f2137482bb8e81b264ab9c0f596.png"},22957:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Iac_Cathode_real-6c2b54d3f35e96557d8624cccd12cc1d.png"},24616:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/capacitance-2f5c17a18a9196b0ac22864d577e56cb.jpg"},2076:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/resistance-cb14aff4116b35e9f478f95f71b64a3a.jpg"},16273:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/0_loss_Real-f57256029a34a21de342d447129dda39.png"},52198:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/0_effective index_Imaginary-68e2dfd95fc6193bf7858075886b3d60.png"},49766:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/0_effective index_Real-d2348313d128ef9fde35166b3b3067d6.png"},84613:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/0_VpiL_Real-4e05ebdce4c4c39bcb14b393878395a1.png"},92626:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/0_VpiLoss_Real-870a8a10aed4b8e93c1209d77f9d32fe.png"},16319:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/MOD_structure-ba9568eeea2276cab64769247f235edf.png"}}]);