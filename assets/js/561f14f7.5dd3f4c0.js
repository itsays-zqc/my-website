"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9849],{46459:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(87462),i=(n(67294),n(3905)),r=n(87617);const o={},l="Directional Coupler",s={unversionedId:"examples/PIC/DirectionalCoupler/DirectionalCoupler",id:"examples/PIC/DirectionalCoupler/DirectionalCoupler",title:"Directional Coupler",description:"Introduction",source:"@site/docs/examples/PIC/DirectionalCoupler/DirectionalCoupler.md",sourceDirName:"examples/PIC/DirectionalCoupler",slug:"/examples/PIC/DirectionalCoupler/",permalink:"/my-website/docs/examples/PIC/DirectionalCoupler/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/examples/PIC/DirectionalCoupler/DirectionalCoupler.md",tags:[],version:"current",frontMatter:{},sidebar:"examplesSidebar",previous:{title:"Passive Devices",permalink:"/my-website/docs/category/passive-devices"},next:{title:"Grating Coupler",permalink:"/my-website/docs/examples/PIC/GratingCoupler/"}},m={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Simulation Methods",id:"simulation-methods",level:2},{value:"Directional Coupler(FDE module)",id:"directional-couplerfde-module",level:2},{value:"1. Basic Operations",id:"1-basic-operations",level:3},{value:"1.1 Import File",id:"11-import-file",level:4},{value:"1.2 SDK Initialization",id:"12-sdk-initialization",level:4},{value:"2. Code Description",id:"2-code-description",level:3},{value:"2.1 import Modules",id:"21-import-modules",level:4},{value:"2.2 Define Simulation",id:"22-define-simulation",level:4},{value:"2.3 Define Parameters",id:"23-define-parameters",level:4},{value:"2.4 Define Materials",id:"24-define-materials",level:4},{value:"2.5 Create Model",id:"25-create-model",level:4},{value:"2.6 FDE Simulation",id:"26-fde-simulation",level:4},{value:"2.7 Add Sub-mesh",id:"27-add-sub-mesh",level:4},{value:"2.8 Add Analysis",id:"28-add-analysis",level:4},{value:"2.9 Retrieve Results",id:"29-retrieve-results",level:4},{value:"2.10 Switches",id:"210-switches",level:4},{value:"3. Output Results",id:"3-output-results",level:3},{value:"Directional Coupler(FDTD module)",id:"directional-couplerfdtd-module",level:2},{value:"1. Basic Operations",id:"1-basic-operations-1",level:3},{value:"2. Code Description",id:"2-code-description-1",level:3},{value:"2.1 Define Parameters",id:"21-define-parameters",level:4},{value:"2.2 Define Materials",id:"22-define-materials",level:4},{value:"2.3 Define Waveform",id:"23-define-waveform",level:4},{value:"2.4 Create ModelBoundary",id:"24-create-modelboundary",level:4},{value:"2.5 FDTD Simulation/local mesh",id:"25-fdtd-simulationlocal-mesh",level:4},{value:"2.6 Source",id:"26-source",level:4},{value:"2.7 Monitor",id:"27-monitor",level:4},{value:"2.8 Calculate Source",id:"28-calculate-source",level:4},{value:"2.9 Run Simulation",id:"29-run-simulation",level:4},{value:"2.10 Analysis",id:"210-analysis",level:4},{value:"2.11 Results",id:"211-results",level:4},{value:"2.12 Switches",id:"212-switches",level:4},{value:"3. Output Results",id:"3-output-results-1",level:3},{value:"Supplement",id:"supplement",level:2},{value:"References",id:"references",level:2}],d={toc:p},u="wrapper";function c(e){let{components:t,...o}=e;return(0,i.kt)(u,(0,a.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"directional-coupler"},"Directional Coupler"),(0,i.kt)("font",{face:"Calibri"},(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Directional couplers (DC) are an important category of optical splitters. They are typically composed of two adjacent single-mode waveguides, and the coupling coefficient is determined by both the length of the coupler and the spacing between them. This feature allows for effective control of the splitting ratio."),(0,i.kt)("p",null,"When it comes to directional couplers, we pay close attention to several key parameters, including ",(0,i.kt)("strong",{parentName:"p"},"insertion loss"),", ",(0,i.kt)("strong",{parentName:"p"},"splitting ratio"),", ",(0,i.kt)("strong",{parentName:"p"},"device dimensions"),", and ",(0,i.kt)("strong",{parentName:"p"},"operating bandwidth"),".")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"introDC1",src:n(58802).Z,width:"1044",height:"573"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"introDC2",src:n(30244).Z,width:"751",height:"521"}))))),(0,i.kt)("h2",{id:"simulation-methods"},"Simulation Methods"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"FDE module")," can be used to calculate the symmetric and anti-symmetric mode field distributions of the directional coupler\u2019s two arms. From these calculations, the effective index can be determined, allowing for the theoretical calculation of the coupling length required to achieve the target splitting ratio."),(0,i.kt)("p",null,"And the ",(0,i.kt)("inlineCode",{parentName:"p"},"FDTD module")," can be used to perform precise calculations of light propagation in the DC. The light field transmission images in the monitor allow for a visual assessment,the related data of which facilitate further optimization and validation of the coupling length and spacing parameters in the DC splitter."),(0,i.kt)("p",null,"After data processing, it can be obtained that the splitting ratio, insertion loss, and operating bandwidth of DC. In designing high-performance directional couplers for various optical communication and integrated photonics applications, these calculations and optimization processes are instrumental.")),(0,i.kt)("h2",{id:"directional-couplerfde-module"},"Directional Coupler(FDE module)"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Using the ",(0,i.kt)("inlineCode",{parentName:"p"},"FDE module"),", we will calculate symmetric and antisymmetric modes in a Directional Coupler modeled with the SDK. The input light can be considered a combination of the symmetric mode and the antisymmetric mode so that we can precisely calculate the coupling coefficient by effective index from the FDE module. Referring to the ",(0,i.kt)("em",{parentName:"p"},"Silicon Photonics Design")," written by Lukas Chrostowski, we build the structure of the Directional coupler in the simulation.")),(0,i.kt)("h3",{id:"1-basic-operations"},"1. Basic Operations"),(0,i.kt)("h4",{id:"11-import-file"},"1.1 Import File"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Once you have installed and configured the environment, import the python code and the GDS layout. The example library and related model code are usually located in the directory :",(0,i.kt)("inlineCode",{parentName:"p"},"examples/func_demo"),". The GDS file is generally imported into the path :",(0,i.kt)("inlineCode",{parentName:"p"},"examples/examples_gds"))),(0,i.kt)("h4",{id:"12-sdk-initialization"},"1.2 SDK Initialization"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Create a new terminal and run the code after you import the python script and GDS file. Max-Optics SDK may take some time to connect the service.")),(0,i.kt)("h3",{id:"2-code-description"},"2. Code Description"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Now let's learn the meaning of functions and parameters that correspond to the code.")),(0,i.kt)("h4",{id:"21-import-modules"},"2.1 import Modules"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"To begin, we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," command to call the relevant functional modules. For instance, we import the  ",(0,i.kt)("inlineCode",{parentName:"p"},"typing")," ,  ",(0,i.kt)("inlineCode",{parentName:"p"},"os")," and  ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," module in python. At the same time ,we import the customized module ",(0,i.kt)("inlineCode",{parentName:"p"},"maxoptics_sdk.all "),"and ",(0,i.kt)("inlineCode",{parentName:"p"},"maxoptics_sdk.helper"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from typing import List, Literal, NamedTuple\nimport os\nimport time\nimport maxoptics_sdk.all as mo\nfrom maxoptics_sdk.helper import timed, with_path\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"typing")," module provides support for type hints and annotations, which are used to indicate the expected types of variables, function arguments, and return values in your code. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"os")," module provides a way to use operating system-dependent functionality such as reading or writing to the file system, working with environment variables, and executing system commands.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," module provides various functions to work with time-related operations and to measure time intervals. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"maxoptics_sdk")," package provides all in one optical simulation with Python."),(0,i.kt)("h4",{id:"22-define-simulation"},"2.2 Define Simulation"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Firstly, We define parameters and give them a default value, such as the simulation wavelength and grid accuracy. Note that we can override this value in the following code.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def simulation(*, run_mode="local", wavelength =1.55, grid = 0.02, number_of_trial_modes = 20, run_options: "RunOptions", **kwargs, ):\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"The provided code contains comments that define the simulation parameters. Let's explain each of these parameters. ",(0,i.kt)("br",null),"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"simulation")," is used to define the simulation parameters for the program. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"run_mode")," parameter determines the type of calculation resources to be used. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"wavelength")," parameter specifies the wavelength of the input light in micrometers. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"grid")," parameter represents the grid accuracy in micrometers. ",(0,i.kt)("br",null),"Lastly, the ",(0,i.kt)("inlineCode",{parentName:"p"},"number_of_trial_modes")," parameter sets the number of modes to be calculated.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"**kwargs")," is a special syntax used in function definitions to accept an arbitrary number of keyword arguments as a dictionary.")),(0,i.kt)("h4",{id:"23-define-parameters"},"2.3 Define Parameters"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Define commonly used parameters in region 0, such as the width and height of the simulation boundary, the start time of the simulation, the path and name for the simulation output, the path to the imported GDS layout, and other parameters required for structural parameterized modeling.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# region --- 0. General Parameters ---\n  yspan_solver = 5\n  zspan_solver = 2\n  time_str = time.strftime('%Y%m%d_%H%M%S', time.localtime())\n  path = kwargs['path']\n  simu_name = f'FDE_DC_yspan={yspan_solver}_{time_str}'\n  gds_file_root_path = os.path.abspath(os.path.join(path, '..'))\n  gds_file = gds_file_root_path + '/examples_gds/DC.gds'\n  project_name = f'{simu_name}_{run_mode}_{time_str}'\n  plot_path = kwargs.get('plot_dir', path) + '/plots/' + project_name + '/'\n  kL = [f'0{k}' for k in range(5)]\n  export_options = {\"export_csv\": True, \"export_mat\": True, \"export_zbf\": True}\n  l_bend=5.6 # the length of z bend\n  l_arm=15 # the length of 2 arms\n  l_input=2.5 # the length of input wg\n# endregion\n")),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"The code defines several parameters and variables necessary for the simulation process. The ",(0,i.kt)("inlineCode",{parentName:"p"},"yspan_solver")," parameter represents the width of the simulation boundary specified in micrometers. Similarly, the ",(0,i.kt)("inlineCode",{parentName:"p"},"zspan_solver")," parameter denotes the height of the simulation boundary in micrometers. The ",(0,i.kt)("inlineCode",{parentName:"p"},"time_str")," variable is used to obtain the current time as a timestamp for the simulation.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"path")," variable defines the file path for the simulation, while ",(0,i.kt)("inlineCode",{parentName:"p"},"simu_name")," specifies the name of the simulation file.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"gds_file_root_path")," variable defines the path for importing the GDS layout. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"project_name")," variable assigns a name to the project for the simulation output. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"plot_path")," variable determines the directory where the simulation result plots will be saved. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"export_options")," parameter allows for the definition of options for exporting the simulation results.",(0,i.kt)("br",null),"Lastly, the variables ",(0,i.kt)("inlineCode",{parentName:"p"},"l_bend")," ,",(0,i.kt)("inlineCode",{parentName:"p"},"l_arm"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"l_input")," represent the lengths of specific components within the simulation, such as the length of the z-bend, the length of the two arms, and the length of the input waveguide, respectively. ",(0,i.kt)("br",null),"These parameters and variables together facilitate the successful execution and organization of the simulation process.")),(0,i.kt)("h4",{id:"24-define-materials"},"2.4 Define Materials"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Indeed, let's proceed to the next step, where we set up the materials required for the simulation in region 2. In this case, we will directly use relevant materials from the MO  material library.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# region --- 2. Material ---\n  mt = pj.Material()\n  mt.add_lib(name='Si', data=mo.Material.Si_Palik, order=2)\n  mt.add_lib(name='SiO2', data=mo.Material.SiO2_Palik, order=2)\n  mt.add_lib(name='Air', data=mo.Material.Air, order=2)\n# endregion\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"add_lib")," is used to define three parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),",",(0,i.kt)("inlineCode",{parentName:"p"},"data")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"order"),". ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," calls up the property of simulation materials in the MO material library. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Order")," parameter determines the mesh order for the material during the simulation. ",(0,i.kt)("br",null),"Besides, we also support users to customize the material with ",(0,i.kt)("inlineCode",{parentName:"p"},"add_nondispersion"),"function."),(0,i.kt)("h4",{id:"25-create-model"},"2.5 Create Model"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Next, we will create the Directional Coupler model in region 3. We have two options for modeling the structure:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 3. Structure ---\n    st = pj.Structure()\n    st.add_geometry(\n        name="box",\n        type="gds_file",\n        property={\n            "general": {"path": gds_file, "cell_name": "TOP", "layer_name": (1, 1)},\n            "geometry": {"x": 0, "y": 0, "z": 0.11, "z_span": 6},\n            "material": {"material": mt["SiO2"], "mesh_order": 1}, }, )\n\n    st.add_geometry(\n        name="dc",\n        type="gds_file",\n        property={\n            "general": {"path": gds_file, "cell_name": "TOP", "layer_name": (0, 0)},\n            "geometry": {"x": 0, "y": 0, "z": 0.11, "z_span": 0.22},\n            "material": {"material": mt["Si"], "mesh_order": 2}, }, )\n    st.add_geometry(\n        name="slab",\n        type="Rectangle",\n        property={\n            "geometry": {\n                "x_min": -l_input - l_bend - l_beam / 2 - 3, "x_max": l_input + l_bend + l_beam / 2 + 3,\n                "y": 0, "y_span": 8, "z": 0.045, "z_span": 0.09,},\n            "material": {"material": mt["Si"], "mesh_order": 2}, }, )\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Here, we import the DC layout from the GDS file. we can create the\xa0DC model directly within\xa0the SDK\xa0using\xa0the ",(0,i.kt)("inlineCode",{parentName:"p"},"Structure"),"\xa0function.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter defines the structure name.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," parameter specifies the structure type.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"path"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"cell_name"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"layer_name")," parameters point to the GDS file and specify the relevant layers and cell names used in the layout.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"geometry"),"\xa0parameter\xa0sets\xa0the\xa0structure's\xa0coordinates. ",(0,i.kt)("br",null),"The\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"material"),"\xa0parameter\xa0specifies\xa0the\xa0material\xa0properties ",(0,i.kt)("br",null),"The\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"mesh_order"),"\xa0parameter\xa0sets\xa0the\xa0mesh\xa0order\xa0for\xa0building structures.")),(0,i.kt)("h4",{id:"26-fde-simulation"},"2.6 FDE Simulation"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"After establishing the model, we can add the simulation region in region 4.We add the FDE simulation module to support mode calculations and frequency scans. We can also and define the simulation boundary conditions. This involves specifying the geometry of the simulation region, the boundary conditions in the xyz directions, and detailed parameters.")),(0,i.kt)("div",{class:"text-justify"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 4. Simulation ---\nsimu = pj.Simulation()\nsimu.add(\n    name=simu_name,\n    type="FDE",\n    property={\n        "background_material": mt["SiO2"],\n        "geometry": {\n            "x": 0, "x_span": 0, "y": 0, "y_span": yspan_solver, "z": 0, "z_span": zspan_solver,},\n        "boundary_conditions": {\n            "y_min_bc": "PEC", "y_max_bc": "PEC", "z_min_bc": "PEC", "z_max_bc": "PEC",},\n        \'general\': {\'solver_type\': \'2d_x_normal\'},  # default is \'2d_x_normal\' [\'2d_x_normal\',\'2d_y_normal\',\'2d_z_normal\']\n        "mesh_settings": {\n                "mesh_refinement": { "mesh_refinement": "curve_mesh" }, "mesh_factor": 1.2, "global_mesh_uniform_grid": { "dy": grid, "dz": grid, }, }, }, )\nsimu_res = simu[simu_name].run()\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In this code segment, the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter defines the name of the simulation module.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"general")," parameter specifies the type of the simulation module within the structure. It supports the following list selection",(0,i.kt)("inlineCode",{parentName:"p"},"['2d_x_normal','2d_y_normal','2d_z_normal']"),".",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"mesh_settings")," parameter is set to the previously defined the mesh.",(0,i.kt)("br",null)),(0,i.kt)("p",null,"In this case,we use Perfect Electric Conductor(PEC) boundary condition. The PEC boundary condition is a modeling approach used to simulate the behavior of perfectly conducting surfaces or boundaries in electromagnetic wave propagation analyses. This effectively models the behavior of a material with infinite conductivity and perfect electrical shielding. This boundary condition is particularly relevant when dealing with the interaction of light and electromagnetic fields with highly conductive materials, such as metals. ",(0,i.kt)("br",null),"Moreover, We also provide the usual boundary condition like  Perfectly Matched Layer(PML) and Perfect Magnetic Conductor (PMC), you can change the ",(0,i.kt)("inlineCode",{parentName:"p"},"PEC")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"PML")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"PMC"),"of 4 dimensions in the code.")),(0,i.kt)("h4",{id:"27-add-sub-mesh"},"2.7 Add Sub-mesh"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"To achieve more accurate calculations of the model's modal fields, we can add a sub-mesh in region 5.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 5. Sub Mesh ---\nlm = pj.LocalMesh()\nlm.add(\n    name="sub_mesh",\n    property={\n        "general": {"dx": 0.002, "dy": 0.002, "dz": 0.002},\n        "geometry": {\n            "x": 0, "x_span": 6, "y": 0, "y_span": 2, "z": 0, "z_span": 0.2, }, }, )\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In this code segment, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"LocalMesh")," to add a sub-mesh.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter defines the name of the mesh.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"general")," parameter specifies the grid accuracy in the xyz directions (in this case, 0.002 micrometers in each direction).",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"geometry")," parameter sets the coordinates of the sub-mesh.")),(0,i.kt)("h4",{id:"28-add-analysis"},"2.8 Add Analysis"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Such as mode expansion and frequency analysis, we can add a sub-mesh in region 5 to achieve more analysis.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 6. Analysis ---\nanalysis = pj.Analysis()\nanalysis.add_analysis(\n    name="Mesh Structure",\n    type="FDEAnalysis",\n    props={\n        "workflow_id": simu_res.workflow_id,\n        "simulation_name": "FDE",\n        "modal_analysis": {\n            "calculate_modes": run_options.run, "mesh_structure": False, "wavelength": wavelength, "wavelength_offset": 0.0001, "number_of_trial_modes": number_of_trial_modes, "search": "max_index",  # [\'near_n\',\'max_index\'] "n": 1, "calculate_group_index": False, # \'mode_removal\': {\'threshold\': 0.02},\n            "bent_waveguide": {\n                "bent_waveguide": False, "radius": 1, "orientation": 0, "location": "simulation_center",\n            },\n        },\n        "frequency_analysis": {\n            "frequency_analysis": run_options.run_frequency_sweep, "start_wavelength": 1.50, "stop_wavelength": 1.60, "number_of_points": 3, "effective_index": 2.67, "detailed_dispersion_calculation": False,\n        },\n    }\n)\nresult_fde = analysis["Mesh Structure"].run()\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"wavelength")," parameter sets the wavelength-related parameters for the simulation.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"search")," parameter specifies the mode search type. It supports the following list selection",(0,i.kt)("inlineCode",{parentName:"p"},"['near_n','max_index']"),".",(0,i.kt)("br",null),"In this case, we use ",(0,i.kt)("inlineCode",{parentName:"p"},"max_index")," to automatically search for the mode with max index in the structure. To use the \u2018near_n\u2019, we need to set the data in \u2018n\u2019.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"bent_waveguide")," parameter can be used to set parameters for a bent waveguide.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"frequency_analysis")," parameter allows us to set parameters for frequency scans or mode calculations with varying wavelengths.")),(0,i.kt)("h4",{id:"29-retrieve-results"},"2.9 Retrieve Results"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In region 7, you can retrieve and store the simulation results.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 7. See Results ---\n    if run_options.run:\n            k = kL[2]\n            res = result_fde.extract( data="calculate_modes", savepath=f"{plot_path}{k}_neff_table", export_csv=True, )\n            print(res.to_string(index=False))\n            for m in range(len(res)):\n                k = kL[3]\n                result_fde.extract( data="calculate_modes", savepath=f"{plot_path}{k}_mode{m}", attribute="Ey", real=True, imag=False, mode=m, show=False, **export_options, )\n\n    if run_options.run_frequency_sweep:\n            k = kL[4]\n            result_fde.extract( data="frequency_analysis", savepath=f"{plot_path}{k}_freq_sweep_neff", attribute="neff", real=True, imag=True, show=False, export_csv=True, export_mat=True, )\n    return project_name\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"extract")," function allows you to extract specific simulation results and store them for further analysis.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"attribute")," parameter specifies the type of simulation results to be extracted.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"mode")," parameter corresponds to the index of the FDE calculation mode.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"real")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"imag")," parameters are used to extract the real and imaginary parts of the simulation results, respectively. ",(0,i.kt)("br",null),"If you run the frenquency sweep to calculate mode at different wavelength, you can also extract the relevant results. As an example above, we extrat the effective index.")),(0,i.kt)("h4",{id:"210-switches"},"2.10 Switches"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In this section of the code, the ",(0,i.kt)("inlineCode",{parentName:"p"},"simulation")," function is called and executed, which allows you to reset relevant parameters for more convenient parameter scanning and optimization design. We also support control switches for various functionalities at the end of the code, and you can use configuration flags(True or False). These flags can be used to turn specific functionalities on or off, making it easier to check the model and perform efficient calculations.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'class RunOptions(NamedTuple):\n    index_preview: bool\n    run: bool\n    run_frequency_sweep: bool\n    extract: bool\n\n\nif __name__ == "__main__":\n    simulation(\n        run_mode="local", wavelength=1.55, grid=0.02, number_of_trial_modes=3,\n        run_options=RunOptions( index_preview=True, run=True, run_frequency_sweep=True, extract=True ), )\n\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"By turning on/off the relevant functionalities, you can control the simulation process and obtain the desired results. For example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"index_preview")," is to control whether to output images of the structural refractive index. ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," determines whether to run the program. ",(0,i.kt)("inlineCode",{parentName:"p"},"run_frequency_sweep")," is used to enable frequency scanning, and ",(0,i.kt)("inlineCode",{parentName:"p"},"extract")," is used to control data extraction. Properly utilizing these switches can help you inspect the simulation effectively.")),(0,i.kt)("h3",{id:"3-output-results"},"3. Output Results"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"The results of the calculation mode will be stored in a CSV format file for subsequent data processing in Python and Excel."))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"\u2003",(0,i.kt)("strong",{parentName:"th"},"mode_order"),"\u2003"),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"th"},"TE ratio")),(0,i.kt)("th",{parentName:"tr",align:"center"},"\xa0",(0,i.kt)("strong",{parentName:"th"},"neff_real"),"\xa0"),(0,i.kt)("th",{parentName:"tr",align:"center"},"\xa0",(0,i.kt)("strong",{parentName:"th"},"neff_imag"),"\xa0"),(0,i.kt)("th",{parentName:"tr",align:"center"},"\xa0",(0,i.kt)("strong",{parentName:"th"},"ng_real"),"\xa0"),(0,i.kt)("th",{parentName:"tr",align:"center"},"\xa0",(0,i.kt)("strong",{parentName:"th"},"ng_imag"),"\xa0"),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"th"},"wavelength(nm)")),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"th"},"loss(dB/cm)")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0.986860"),(0,i.kt)("td",{parentName:"tr",align:"center"},"2.593169"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1550"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"1"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0.987740"),(0,i.kt)("td",{parentName:"tr",align:"center"},"2.542372"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1550"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"2"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0.941287"),(0,i.kt)("td",{parentName:"tr",align:"center"},"2.129843"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1550"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0")))),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Image of the Ey electric field component intensity in symmetric and antisymmetric mode modes."))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"image-20230808144936139",src:n(55173).Z,width:"640",height:"480"})),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"image-20230808144943253",src:n(63625).Z,width:"640",height:"480"}))))),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"According to the effective refractive index of the obtained mode field, Python is used for data processing and drawing."))),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"\u2003","The coupling length under the gap between two waveguides is calculated with the formula:")),(0,i.kt)(r.BlockMath,{math:"L_x = \\frac{\\lambda}{2|neff_1-neff_2|}",mdxType:"BlockMath"}),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"\u2003","We can also get the coupling coefficient by the formula:")),(0,i.kt)(r.BlockMath,{math:"\\kappa = |sin(\\frac{\\pi\\delta(n)L}{\\lambda})|",mdxType:"BlockMath"}),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"image-20230808163408183",src:n(53033).Z,width:"370",height:"299"})),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"image-20230808163423264",src:n(40200).Z,width:"386",height:"283"})),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"image-20230808163438000",src:n(90575).Z,width:"370",height:"283"}))))),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},"Similarly, we can obtain the relationship between the gap (distance) between two waveguides and the coupling coefficient and the relationship between the wavelength and the coupling length."))),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"image-20230808163512785",src:n(20510).Z,width:"475",height:"315"})),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"image-20230808163518735",src:n(21387).Z,width:"475",height:"315"})))))),(0,i.kt)("h2",{id:"directional-couplerfdtd-module"},"Directional Coupler(FDTD module)"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Next, we will learn how to model a Directional Coupler using the SDK and calculate the light propagation in the structure using the FDTD module.")),(0,i.kt)("h3",{id:"1-basic-operations-1"},"1. Basic Operations"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Similarly, after installing and configuring the environment, we import the relevant python code file  and the GDS layout for the model. The example library and related model code are typically stored in the directory ",(0,i.kt)("inlineCode",{parentName:"p"},"examples/func_demo"),", and the GDS file is imported into the folder ",(0,i.kt)("inlineCode",{parentName:"p"},"examples/examples_gds"),".")),(0,i.kt)("h3",{id:"2-code-description-1"},"2. Code Description"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Next, we will continue to learn about the specific functionalities corresponding to the code.")),(0,i.kt)("h4",{id:"21-define-parameters"},"2.1 Define Parameters"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Like the operations with the FDE module, after configuring the simulation wavelength, grid precision, and other parameters, we need to set the relevant parameters for simulation and parameterized modeling in Region 0. This includes defining the paths and names for the simulation files and output results and specifying the path for importing the GDS layout.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 0. General Parameters ---\nl_bend=5.6 # the length of z bend\nl_beam=15 # the length of 2 beams\nl_input=2.5 # the length of input wg\nmonitor_w = 3.0\nmonitor_h = 2.0\nwaveform_name = "wv" + str(round(wavelength * 1000))\ntime_str = time.strftime("%Y%m%d_%H%M%S", time.localtime())\npath = kwargs["path"]\nsimu_name = "FDTD_DC"\nproject_name = f\'{simu_name}_{time_str}\'\nplot_path = f\'{path}/plots/{project_name}/\'\ngds_file_root_path = os.path.abspath(os.path.join(path, \'..\'))\ngds_file = gds_file_root_path + "/examples_gds/DC.gds"\n# endregion\n')),(0,i.kt)("h4",{id:"22-define-materials"},"2.2 Define Materials"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Subsequently, in Region 2, we ues the materials required for the simulation. We also support users to specify the refractive indices of Si (Silicon) and SiO2 (Silicon Dioxide) materials.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 2. Material ---\nmt = pj.Material()\nmt.add_lib(name=\'Si\', data=mo.Material.Si_Palik, order=2)\nmt.add_lib(name=\'SiO2\', data=mo.Material.SiO2_Palik, order=2)\n# mt.add_nondispersion(name="Si", data=[(3.472, 0)], order=2)\n# mt.add_nondispersion(name="SiO2", data=[(1.444, 0)], order=2)\nmt.add_lib(name="Air", data=mo.Material.Air, order=2)\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"add_nondispersion")," function adds a non-dispersion material to the project in the simulation. ",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"data"),", is specified as a list, typically in the format ",(0,i.kt)("inlineCode",{parentName:"p"},"[(index real, index imag)]"),". This list contains the complex refractive index values for the material, enabling the simulation to model its optical properties accurately.",(0,i.kt)("br",null),"The function allows users to incorporate non-dispersion materials into the simulation, contributing to a comprehensive and precise optical analysis of the system under investigation.")),(0,i.kt)("h4",{id:"23-define-waveform"},"2.3 Define Waveform"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In Region 3, we define the parameters relevant to the wavelength.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# region --- 3. Waveform ---\nwv = pj.Waveform()\nwv.add(name=waveform_name, wavelength_center=wavelength, wavelength_span=wavelength_span)\n# endregion\n")),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Waveform")," function is used to retrieve the waveform manager for the current project. It allows users to access and manipulate the waveform sources used in the simulation.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter specifies the name of the waveform source.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"wavelength_center")," parameter defines the center of the wavelength range for the source.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"wavelength_span")," parameter determines the span of the wavelength range for the source.")),(0,i.kt)("h4",{id:"24-create-modelboundary"},"2.4 Create Model\\Boundary"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Next, similar to the procedure in the FDE module, in Region 4, we create the model by importing the GDS layout. Subsequently, in Region 5, we establish the boundary conditions.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 4. Structure ---\n    st = pj.Structure()\n\nst.add_geometry(\n    name="box",\n    type="gds_file",\n    property={\n        "general": { "path": gds_file, "cell_name": "TOP", "layer_name": (1, 1) },\n        "geometry": {"x": 0, "y": 0, "z": 0.11, "z_span": 6},\n        "material": {"material": mt["SiO2"], "mesh_order": 1} }, )\nst.add_geometry(\n    name="dc",\n    type="gds_file",\n    property={\n        "general": { "path": gds_file, "cell_name": "TOP", "layer_name": (0, 0) },\n        "geometry": {"x": 0, "y": 0, "z": 0.11, "z_span": 0.22},\n        "material": {"material": mt["Si"], "mesh_order": 2} }, )\nst.add_geometry(\n    name=\'slab\',\n    type=\'Rectangle\',\n    property={\n        \'geometry\': { \'x_min\': -l_input-l_bend-l_beam/2-3, \'x_max\':l_input+l_bend+l_beam/2+3, \'y\': 0, \'y_span\': 8, \'z\': 0.045, \'z_span\': 0.09 },\n        \'material\': {\'material\': mt[\'Si\'], \'mesh_order\': 2}, } , )\n# endregion\n\n# region --- 5. Boundary ---\nbc = { "pml_layer": 8, "pml_kappa": 2, "pml_sigma": 0.8, "pml_polynomial": 3, "pml_alpha": 0, "pml_alpha_polynomial": 1, }\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In this code segment, we set detailed parameters for the PML boundar.")),(0,i.kt)("h4",{id:"25-fdtd-simulationlocal-mesh"},"2.5 FDTD Simulation/local mesh"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In\xa0Region\xa06,\xa0we\xa0add\xa0the\xa0FDTD\xa0simulation.  Additionally, in Region 7, we can set the sub-mesh for improved precision.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 6. Simulation ---\nsimu = pj.Simulation()\nsimu.add(\n    name=simu_name,\n    type="FDTD",\n    property={\n        "background_material": mt["SiO2"],\n        "geometry": { "x": 0, "x_span": 2*(l_input+l_bend+l_beam/2-0.5), "y": 0, "y_span": 6, "z": 0.11, "z_span": monitor_h },\n        "boundary_conditions": { "x_min_bc": "PML", "x_max_bc": "PML", "y_min_bc": "PML", "y_max_bc": "PML", "z_min_bc": "PML", "z_max_bc": "PML",\n            "pml_settings": { "x_min_pml": bc, "x_max_pml": bc, "y_min_pml": bc, "y_max_pml": bc, "z_min_pml": bc, "z_max_pml": bc, }, },\n        "general": { "simulation_time": 10000, },\n        "mesh_settings": {\n            "mesh_factor": 1.2,\n            "mesh_type": "auto_non_uniform",\n            "mesh_accuracy": {"cells_per_wavelength": grids_per_lambda},\n            "minimum_mesh_step_settings": {"min_mesh_step": 1e-4},\n            "mesh_refinement": { "mesh_refinement": "curve_mesh", } },\n        # \'advanced_options\': {\'auto_shutoff\': {\'auto_shutoff_min\': 1.00e-4, \'down_sample_time\': 200}},\n        # \'thread_setting\': {\'thread\': 4}\n    }, )\n# endregion\n\n# region --- 7. Sub Mesh ---\nlm = pj.LocalMesh()\nlm.add(\n    name="sub_mesh",\n    property={\n        "general": { "dx": 0.05, "dy": 0.02, "dz": 0.02 },\n        "geometry": { "x": 0, "x_span": 2*(l_input+l_bend+l_beam/2-0.5), "y": 0, "y_span": 6, "z": 0.11, "z_span": monitor_h }, }, )\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Simulation")," manager is critical for setting up and running simulations in the current project.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter allows users to assign a unique name to the simulation for identification purposes.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," parameter defines the type of the simulation.",(0,i.kt)("br",null),"we define the boundary conditions for the simulation using the ",(0,i.kt)("inlineCode",{parentName:"p"},"boundary")," dictionary, where the x ,y and the z directions all have PML boundary conditions.The ",(0,i.kt)("inlineCode",{parentName:"p"},"simulation_time")," parameter specifies the duration of the simulation.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"mesh_settings")," parameter enables users to configure various settings related to the simulation mesh. The ",(0,i.kt)("inlineCode",{parentName:"p"},"mesh_accuracy")," parameter controls the precision of the mesh used in the simulation.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"cells_per_wavelength")," parameter determines the wavelength precision used in the simulation.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"minimum_mesh_step_settings")," parameter sets the minimum mesh step, allowing users to define the smallest allowable size for mesh elements.",(0,i.kt)("br",null),"Users can tailor the simulation setup to meet their requirements by utilizing these input parameters, enabling accurate and efficient electromagnetic simulations of complex optical structures.")),(0,i.kt)("h4",{id:"26-source"},"2.6 Source"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Then we need to establish the light source in the input waveguide, as shown in Region 8.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 8. ModeSource ---\nsrc = pj.Source()\nsrc.add(\n    name="source",\n    type="mode_source",\n    # axis="x_forward",\n        property={\n            "general": { "mode_selection": "user_select", "waveform": {"waveform_id_select": wv[waveform_name]}, "inject_axis": "x", "direction": "forward", },\n            "geometry": { "x": -l_input-l_beam/2-l_bend+2, "x_span": 0, "y": 1.35, "y_span": monitor_w, "z": 0.11, "z_span": monitor_h },\n            "modal_analysis": { "mode_removal": {"threshold": 0.01} } , }, )\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Source")," function is utilized to retrieve the source manager for the current project.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," parameter specifies the type of the source and is formatted as either ",(0,i.kt)("inlineCode",{parentName:"p"},'["mode_source"] or ["gaussian_source"]'),".",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter represents the name assigned to the source.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"inject_axis")," parameter defines the axis of the source.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"property")," parameter allows for defining specific properties associated with the source.")),(0,i.kt)("h4",{id:"27-monitor"},"2.7 Monitor"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In Region 9, we set up the monitors.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 9. Monitor ---\n# region --- 9.0 GlobalMonitor ---\nmn = pj.Monitor()\nmn.add(\n    name="Global Option",\n    type="global_option",\n    property={\n        "frequency_power": {\n            "spacing_type": "wavelength",\n            "spacing_limit": "center_span",\n            "wavelength_center": wavelength,\n            "wavelength_span":wavelength_span,\n            "frequency_points": 3 }, }, )\n# endregion\n\n# region --- 9.1 z_normal ---\nmn.add(\n    name="z_normal",\n    type="power_monitor",\n    property={\n        "general": {\n            "frequency_profile": { "wavelength_center": wavelength, "wavelength_span": 0.1, "frequency_points": 3, },\n        },\n        "geometry": {\n            "monitor_type": "2d_z_normal",\n            "x": 0, "x_span": 2*(l_input+l_bend+l_beam/2-0.5), "y": 0, "y_span": 5, "z": 0.11, "z_span": 0 }, }, )\n# endregion\n\n# region --- 9.2 input ---\nmn.add(\n    type="power_monitor",\n    name="input_reflect",\n    property={\n        "general": {\n            "frequency_profile": { "wavelength_center": wavelength, "wavelength_span": 0.1, "frequency_points": 11 } },\n        "geometry": {\n            "monitor_type": "2d_x_normal",\n            "x": -l_input-l_beam/2-l_bend+1.5, "x_span": 0, "y": 1.35, "y_span": monitor_w, "z": 0.11, "z_span": monitor_h }, } )\n# endregion\n\n# region --- 9.3 through ---\nmn.add(\n    type="power_monitor",\n    name="through",\n    property={\n        "general": {\n            "frequency_profile": { "wavelength_center": wavelength, "wavelength_span": 0.1, "frequency_points": 11 } },\n        "geometry": {\n            "monitor_type": "2d_x_normal",\n            "x": l_input+l_beam/2+l_bend-2, "x_span": 0, "y": 1.35, "y_span": 2, "z": 0.11, "z_span": monitor_h }, }, )\n# endregion\n\n# region --- 9.4 cross ---\nmn.add(\n    name="cross",\n    type="power_monitor",\n    property={\n        "general": {\n            "frequency_profile": { "wavelength_center": wavelength, "wavelength_span": 0.1, "frequency_points": 11 } },\n         "geometry": {\n            "monitor_type": "2d_x_normal",\n            "x": l_input+l_beam/2+l_bend-2,\n            "x_span": 0, "y": -1.35, "y_span": 2, "z": 0.11, "z_span": monitor_h }, } )\n# endregion\n# endregion\n')),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"For the global monitor, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Monitor")," function is utilized to retrieve the monitor manager for the current project, which allows users to access and manage various types of monitors used during simulation.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter represents the name of the Global Option associated with the monitor.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," parameter defines the type of the Global Option and is formatted as a list containing one of several monitor types. The ",(0,i.kt)("inlineCode",{parentName:"p"},"property")," parameter is used to define and set the relevant parameters specific to the chosen monitor type. These parameters control the monitor's behavior and data collection settings during the simulation."),(0,i.kt)("p",null,"The power monitor is a configuration setting that allows users to specify various simulation parameters.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter assigns a name to the power monitor.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," parameter defines the type of power monitor.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"general")," parameter pertains to settings related to the frequency domain and frequency-dependent behaviors of the simulation.",(0,i.kt)("br",null),"The ",(0,i.kt)("inlineCode",{parentName:"p"},"geometry")," parameter is used to define the geometric characteristics of the simulated structure.",(0,i.kt)("br",null))),(0,i.kt)("h4",{id:"28-calculate-source"},"2.8 Calculate Source"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"To calculate the input mode light and save its electric field intensity data in region 10.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 10. Calculate Mode ---\nif run_options.calculate_modes:\n    simu[simu_name].preview_modes(\n        source_name = "source",\n        savepath=f"{plot_path}00_source_modeprofile_fdeonly",\n        attribute="E", real=True, imag=True, mode=0, show=False, export_csv=True, )\n# endregion\n')),(0,i.kt)("h4",{id:"29-run-simulation"},"2.9 Run Simulation"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Then,\xa0in\xa0Region\xa011,\xa0we\xa0run\xa0the\xa0simulation.\xa0")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# region --- 11. Run ---\nif run_options.run:\n    fdtd_res = simu[simu_name].run()\n# endregion\n")),(0,i.kt)("h4",{id:"210-analysis"},"2.10 Analysis"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In\xa0Region\xa012,\xa0we\xa0run\xa0the\xa0analysis for the simulation.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"mode_expansion")," parameter involves relevant settings for mode expansion simulations. Users can customize the simulation settings by utilizing these input parameters to achieve accurate and comprehensive results based on their specific simulation requirements.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 12. Run ---\nanalysis = pj.Analysis()\nanalysis.add(\n    name="me_through",\n    type="mode_expansion",\n    property={\n            "workflow_id": fdtd_res.workflow_id,\n            "mode_expansion": {\n                "direction": "positive",\n                "monitors_for_expansion": [ {"name": "me_through", "frequency_monitor": "through"} ],\n                "mode_calculation": {\n                    "mode_selection": "user_select",\n                    "mode_index": [0, 1, 2, 3],\n                    "override_global_monitor_setting": { "wavelength_center": wavelength, "wavelength_span": 0.1, "frequency_points": 11, }, }, }, } )\nanalysis.add(\n    name="me_cross",\n    type="mode_expansion",\n    property={\n            "workflow_id": fdtd_res.workflow_id,\n            "mode_expansion": {\n                "direction": "positive",\n                "monitors_for_expansion": [ {"name": "me_cross", "frequency_monitor": "cross"} ],\n                "mode_calculation": {\n                    "mode_selection": "user_select",\n                    "mode_index": [0, 1, 2, 3],\n                    "override_global_monitor_setting": { "wavelength_center": wavelength, "wavelength_span": 0.1, "frequency_points": 11, }, }, }, } )\nme_res1 = analysis["me_through"].run()\nme_res2 = analysis["me_cross"].run()\n# endregion\n')),(0,i.kt)("h4",{id:"211-results"},"2.11 Results"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"In Region 13, we define the desired output results. Lastly, we control the switches of various functional modules at the end of the Python file.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 13. See Results ---\nif run_options.extract and run_options.run:\n    # region --- z_normal ---\n    """ 01_top_profile """\n    for \u03bb in [1.5, 1.55, 1.6]:\n        fdtd_res.extract(\n            data="fdtd:power_monitor",\n            savepath=plot_path + "01_top_profile" + str(\u03bb) + "um",\n            monitor_name="z_normal",\n            target="intensity",\n            attribute="E",\n            real=True, imag=True, wavelength=str(\u03bb), plot_x="x", plot_y="y", show=False, export_csv=True, )\n        # endregion\n\n        # # region --- through ---\n        """ 01_monitorThrough_modeprofile_fdtd """\n        fdtd_res.extract(\n            data="fdtd:power_monitor",\n            savepath=plot_path + "01_monitorThrough_modeprofile_fdtd_"+ f"{wavelength}" + "um",\n            monitor_name="through",\n            target="intensity",\n            attribute="E",\n            real=True, imag=False, wavelength=f"{wavelength}", plot_x="y", plot_y="z", show=False, export_csv=True, )\n        # # """ 02_Trans_ThroughVsLambda_power """\n        fdtd_res.extract(\n            data="fdtd:power_monitor",\n            savepath=plot_path + "02_Trans_ThroughVsLambda_power",\n            monitor_name="through",\n            target="line",\n            attribute="T",\n            real=True, imag=False, plot_x="wavelength", show=False, export_csv=True, )\n        # # """ 021_ME_ThroughVsLambda_mode """\n        me_res1.extract(\n            data="fdtd:mode_expansion",\n            savepath=plot_path + "021_ME_ThroughVsLambda_mode",\n            target="line",\n            attribute="T_forward",\n            real=True, imag=True, monitor_name="through", mode_expansion_name="me_through", mode=0, plot_x="wavelength", show=False, export_csv=True, )\n        # # region --- cross ---\n        """ 01_monitorcross_modeprofile_fdtd """\n        fdtd_res.extract(\n            data="fdtd:power_monitor",\n            savepath=plot_path + "01_monitorcross_modeprofile_fdtd_"+ f"{wavelength}" + "um",\n            monitor_name="cross",\n            target="intensity",\n            attribute="E",\n            real=True, imag=False, wavelength=f"{wavelength}", plot_x="y", plot_y="z", show=False, export_csv=True, )\n        # # """ 02_Trans_crossVsLambda_power """\n        fdtd_res.extract(\n            data="fdtd:power_monitor",\n            savepath=plot_path + "02_Trans_crossVsLambda_power",\n            monitor_name="cross",\n            target="line",\n            attribute="T",\n            real=True, imag=False, plot_x="wavelength", show=False, export_csv=True, )\n        # # """ 021_ME_crossVsLambda_mode """\n        me_res2.extract(\n            data="fdtd:mode_expansion",\n            savepath=plot_path + "021_ME_crossVsLambda_mode",\n            target="line",\n            attribute="T_forward",\n            real=True, imag=True, monitor_name="cross", mode_expansion_name="me_cross", mode=0, plot_x="wavelength", show=False, export_csv=True, )\n    # endregion\n\n')),(0,i.kt)("h4",{id:"212-switches"},"2.12 Switches"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"At the end of all codes, We control the switches of various functional modules.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'class RunOptions(NamedTuple):\n    index_preview: bool\n    calculate_modes: bool\n    run: bool\n    extract: bool\n\n\nif __name__ == "__main__":\n    simulation( wavelength=1.55, wavelength_span=0.1 , grids_per_lambda=6,\n        run_options=RunOptions(\n            index_preview=True, run=True, calculate_modes=True, extract=True ), )\n')),(0,i.kt)("h3",{id:"3-output-results-1"},"3. Output Results"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"After running the program, we can obtain a series of corresponding output results:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Incident light electric field intensity, CRO output port electric field intensity, and TRU output port electric field intensity."))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"00_source_modeprofile_fdeonly",src:n(21146).Z,width:"640",height:"480"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"01_monitorCross_modeprofile_fdtd",src:n(69062).Z,width:"640",height:"480"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"01_monitorThrough_modeprofile_fdtd",src:n(47088).Z,width:"640",height:"480"}))))),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"DC (Directional Coupler)  Z-direction electric field intensity at different wavelengths: 1.50 ",(0,i.kt)("em",{parentName:"li"},"\u03bc"),"m, 1.55 ",(0,i.kt)("em",{parentName:"li"},"\u03bc"),"m, and 1.60 ",(0,i.kt)("em",{parentName:"li"},"\u03bc"),"m."))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"01_top_profile_1.5um",src:n(62335).Z,width:"640",height:"480"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"01_top_profile_1.6um",src:n(60084).Z,width:"640",height:"480"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"01_top_profile_1.55um",src:n(37424).Z,width:"640",height:"480"}))))),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Cross output port and TRU output port transmittance at different wavelengths,from 1.50 ",(0,i.kt)("em",{parentName:"li"},"\u03bc"),"m to 1.60 ",(0,i.kt)("em",{parentName:"li"},"\u03bc"),"m."))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"02_Trans_CrossVsLambda_power",src:n(36092).Z,width:"640",height:"480"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"02_Trans_ThroughVsLambda_power",src:n(92824).Z,width:"640",height:"480"}))))),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"TE0 mode transmittance at Cross output port and TRU output port for different wavelengths,,from 1.50 ",(0,i.kt)("em",{parentName:"li"},"\u03bc"),"m to 1.60 ",(0,i.kt)("em",{parentName:"li"},"\u03bc"),"m."))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"021_ME_CrossVsLambda_mode",src:n(38288).Z,width:"640",height:"480"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"021_ME_ThroughVsLambda_mode",src:n(76165).Z,width:"640",height:"480"}))))),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Based on the information provided, we can get the following results  when propogating wavelength  is 1.55 ",(0,i.kt)("em",{parentName:"p"},"\u03bc"),"m and the two arm length of directional couper is equal to 15 ",(0,i.kt)("em",{parentName:"p"},"\u03bc"),"m: 1. Insertion Loss: 0.236 dB; 2. Power Split Ratio: 11.2 : 83.3 (or approximately 11.2% to one port and 82.8% to the other port); 3. Dimensions: Approximately 5 ",(0,i.kt)("em",{parentName:"p"},"\u03bc"),"m X 25 ",(0,i.kt)("em",{parentName:"p"},"\u03bc"),"m.")),(0,i.kt)("h2",{id:"supplement"},"Supplement"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,'To view a function\'s definition and supported parameters or a parameter dictionary, you can right-click on its name and select "Go to Definition"  or press "Ctrl" while left-clicking on its name to view its definition, showing the available parameters and their descriptions.')),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("div",{class:"text-justify"},(0,i.kt)("p",null,"Chrostowski, L., & Hochberg, M. (2015). Silicon Photonics Design: From Devices to Systems. Cambridge: Cambridge University Press. doi:10.1017/CBO9781316084168"))))}c.isMDXComponent=!0},21146:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/00_source_modeprofile_fdeonly-6f4624830057a4d4f11240585f64f101.png"},47088:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/01_monitorThrough_modeprofile_fdtd_1.55um-f29023d3cbe8fa9f79c191d8ed1bb052.png"},69062:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/01_monitorcross_modeprofile_fdtd_1.55um-62fe7865ef1647451a4811e2f7abe293.png"},37424:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/01_top_profile1.55um-d66f363088c3441a0f982e3cfb08cb82.png"},62335:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/01_top_profile1.5um-7eeb3321ccfc34a131f49eae1183c440.png"},60084:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/01_top_profile1.6um-c623738bef2ec60e7fa9627a6bee6c3f.png"},76165:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/021_ME_ThroughVsLambda_mode-fa9e490a7f66d216a60272e2c22937d3.png"},36092:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/02_Trans_CrossVsLambda_power-fb186f4e5a5705f916882d7a0447eca1.png"},92824:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/02_Trans_ThroughVsLambda_power-1855cb03e5194984945dca8cb2227712.png"},55173:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/03_mode0-8060dd407ca96bde9d10ff777bfd9541.png"},63625:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/03_mode1-bd4913c6e817bbe6f74ed4feda9aba3a.png"},20510:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/1-60f1eb465d6b47b47df8e7db1cb1b1d6.png"},21387:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2-1404ceea159102d7d1a074b72ad64930.png"},38288:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/ME_crossVsLambda_mode-8c3889b5dbaa91da856d76837fa0bfda.png"},53033:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image-20230808163408183-cd7bd3263914e174815c4df854695f65.png"},40200:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image-20230808163423264-46244a9ded9daf878d6c2911076bbc6d.png"},90575:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image-20230808163438000-18b972e232de6807e1a810215565cde8.png"},58802:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/introDC1-6e1015f0f1d4f1c18730c819bd1d1e6c.png"},30244:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/introDC2-d20b7930df6a871b15b2ee28c0c27022.png"}}]);