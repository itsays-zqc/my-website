"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5147],{42702:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var n=a(87462),r=(a(67294),a(3905)),i=a(87617);const l={},o="Microring Resonator",s={unversionedId:"examples/SDK Examples/PIC/MicroringResonator/MicroringResonator",id:"examples/SDK Examples/PIC/MicroringResonator/MicroringResonator",title:"Microring Resonator",description:"Introduction",source:"@site/docs/examples/SDK Examples/PIC/MicroringResonator/MicroringResonator.md",sourceDirName:"examples/SDK Examples/PIC/MicroringResonator",slug:"/examples/SDK Examples/PIC/MicroringResonator/",permalink:"/my-website/docs/examples/SDK Examples/PIC/MicroringResonator/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"examplesSidebar",previous:{title:"Multi-Mode Interference",permalink:"/my-website/docs/examples/SDK Examples/PIC/MMI/"},next:{title:"Polarization Splitter-Rotator",permalink:"/my-website/docs/examples/SDK Examples/PIC/PolarizationSplitter-Rotator/"}},d={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Simulation",id:"simulation",level:2},{value:"1 Code Description",id:"1-code-description",level:3},{value:"1.1 Import Toolkit",id:"11-import-toolkit",level:4},{value:"1.2  Define Simulation Function and parameters",id:"12--define-simulation-function-and-parameters",level:4},{value:"1.3 Create project",id:"13-create-project",level:4},{value:"1.4 Add Material",id:"14-add-material",level:4},{value:"1.5 Add waveform",id:"15-add-waveform",level:4},{value:"1.6 Add Structure",id:"16-add-structure",level:4},{value:"1.9 Add Solver",id:"19-add-solver",level:4},{value:"1.8 Add FDTD Port",id:"18-add-fdtd-port",level:4},{value:"1.10 Add Monitor",id:"110-add-monitor",level:4},{value:"1.11 View Structure",id:"111-view-structure",level:4},{value:"1.12 Run",id:"112-run",level:4},{value:"1.13 Run and Extract Results",id:"113-run-and-extract-results",level:4},{value:"1.14 Control Switch",id:"114-control-switch",level:4},{value:"2. Output results",id:"2-output-results",level:3},{value:"Length of ring",id:"length-of-ring",level:4},{value:"Couple gap and length",id:"couple-gap-and-length",level:4},{value:"Transmission",id:"transmission",level:4},{value:"References",id:"references",level:2}],m={toc:p},u="wrapper";function c(t){let{components:e,...l}=t;return(0,r.kt)(u,(0,n.Z)({},m,l,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"microring-resonator"},"Microring Resonator"),(0,r.kt)("font",{face:"Calibri"},(0,r.kt)("div",{class:"text-justify"},(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(94860).Z,width:"5669",height:"2126"}),"\nMicroring resonator is important filtering device in photonic integrated circuits, the high performance filter require a wide free spectrum range(FSR) and high quality factor. Obtaining a large spectral range for microring resonator requires the use of a small radius, but too small radius can cause bending loss and reduce the quality factor. In order to meet the requirements of wide free spectrum range and high quality factor, it is necessary to carefully design the size of the ring and coupling efficiency."),(0,r.kt)("p",null,"In this example, we demonstrate the use of finite difference eigenmode(FDE) solver to calculate the group refractive index of an optical waveguide, then calculate the effective refractive index of symmetric and anti symmetric modes at the coupling region between the straight waveguide and the ring, and finally use 3D FDTD simulation to calculate the transmittance of the drop port."),(0,r.kt)("h2",{id:"simulation"},"Simulation"),(0,r.kt)("h3",{id:"1-code-description"},"1 Code Description"),(0,r.kt)("h4",{id:"11-import-toolkit"},"1.1 Import Toolkit"),(0,r.kt)("p",null,'First, we need to import "maxoptics_sdk" and third-party package of Python. The import module for FDE and FDTD simulation as follows.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"from typing import List, Literal, NamedTuple\nimport time\nimport maxoptics_sdk.all as mo\nfrom maxoptics_sdk.helper import timed, with_path\n")),(0,r.kt)("h4",{id:"12--define-simulation-function-and-parameters"},"1.2  Define Simulation Function and parameters"),(0,r.kt)("p",null,"To facilitate parameter changes, we can define function to encapsulate the entire simulation project. Before starting the simulation, you can define variables to control the parameters. As shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def simulation(*, wavelength, grid, number_of_trial_modes, run_options: "RunOptions", **kwargs):\n# region --- 0. General Parameters ---\nwidth = 0.4\nradius = 2.8\nwaveform_name = f"wv{wavelength*1e3}"\n\npath = kwargs["path"]\nsimu_name = f"Microring_resonator"\ntime_str = time.strftime("%Y%m%d_%H%M%S", time.localtime())\nproject_name = f"{simu_name}_local_{time_str}"\nplot_path = f"{path}/plots/{project_name}/"\nkL = [f"0{k}" for k in range(5)]\nexport_options = {"export_csv": True, "export_mat": True, "export_zbf": True}\n# endregion\n')),(0,r.kt)("h4",{id:"13-create-project"},"1.3 Create project"),(0,r.kt)("p",null,'We create an empty project by instantiating "Project()" in the simulation environment and define the name of project.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# region --- 1. Project ---\npj = mo.Project(name=project_name)\n# endregion\n")),(0,r.kt)("h4",{id:"14-add-material"},"1.4 Add Material"),(0,r.kt)("div",{class:"text-justify"},(0,r.kt)("p",null,' Here we demonstrate using "Material()" to instance the material module into the project, "add_nondispersion" and "add_lib" functions are available to create materials. You can refer to the following script to set materials.')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 2. Material ---\nmt = pj.Material()\nmt.add_lib(name="Si", data=mo.Material.Si_Palik, order=2)\nmt.add_lib(name="SiO2", data=mo.Material.SiO2_Palik, order=2)\n# endregion\n')),(0,r.kt)("p",null,'The "name" defines the name of the added material.',(0,r.kt)("br",null),'\nThe "data" specifies the real and imaginary parts of the refractive index of the material.',(0,r.kt)("br",null),'\nThe "order" specifies the mesh order of the material.'),(0,r.kt)("h4",{id:"15-add-waveform"},"1.5 Add waveform"),(0,r.kt)("p",null,"Adding a light source for simulating in 3D FDTD, and we use ",(0,r.kt)("inlineCode",{parentName:"p"},"Waveform")," to set the waveform parameters of the light source."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# region --- 3. Waveform ---\nwv = pj.Waveform()\nwv.add(name=waveform_name, type='gaussian_waveform',\n        property={'set': 'frequency_wavelength',  # selections are ['frequency_wavelength','time_domain']\n                    'set_frequency_wavelength': {\n                        'range_type': 'wavelength',  # selections are ['frequency','wavelength']\n                        'range_limit': 'center_span',  # selections are ['min_max','center_span']\n                        'wavelength_center': wavelength,\n                        'wavelength_span': 0.1,},\n                    }\n        )\nwv_id = wv[waveform_name]\n# endregion\n")),(0,r.kt)("p",null,'The "name" sets the name of the waveform.',(0,r.kt)("br",null),'\nThe "wavelength_center" sets the center wavelength of the light source.\nThe "wavelength_span" sets the wavelength range of the light source.'),(0,r.kt)("h4",{id:"16-add-structure"},"1.6 Add Structure"),(0,r.kt)("div",{class:"text-justify"},'The microring resonator is typical filter for SOI waveguide, including two straight optical waveguides and a ring-shaped waveguide. We use "Structure()" to instance the structure module to the project, "add_geometry" function is available for adding structures.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 4. Structure ---\nst = pj.Structure()\n\nst.add_geometry(name="ring", type="Ring",\n                property={ "geometry": { "x": 0, "y": 0, "z": 0, "z_span": 0.22,\n                                        "inner_radius": radius - width/2, "outer_radius": radius + width/2},\n                            "material": {"material": mt["Si"], "mesh_order": 3 }})\nst.add_geometry(name="wg_1", type="Rectangle",\n                property={"geometry": {"x": 0, "x_span": 15, "y": 3.3, "y_span": width, "z": 0, "z_span": 0.22},\n                            "material": {"material": mt["Si"], "mesh_order": 3}})\nst.add_geometry(name="wg_2", type="Rectangle",\n                property={"geometry": {"x": 0, "x_span": 15, "y": -3.3, "y_span": width, "z": 0, "z_span": 0.22},\n                            "material": {"material": mt["Si"], "mesh_order": 3}})\n# endregion                           \n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Key"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Type"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"x","\u2003","\u2003","\u2003","\u2003"),(0,r.kt)("td",{parentName:"tr",align:"left"},"0","\u2003","\u2003","\u2003","\u2003"),(0,r.kt)("td",{parentName:"tr",align:"center"},"float","\u2003","\u2003","\u2003","\u2003"),(0,r.kt)("td",{parentName:"tr",align:"left"},"center position in the x-direction of the geometric structure ","\xa0","\u2003","\u2003","\u2003","\u2003","\u2003","\u2003")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"material"),(0,r.kt)("td",{parentName:"tr",align:"left"},"mt",'["Si"]'),(0,r.kt)("td",{parentName:"tr",align:"center"},"material"),(0,r.kt)("td",{parentName:"tr",align:"left"},"select the material added Materials")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"mesh_order"),(0,r.kt)("td",{parentName:"tr",align:"left"},"3"),(0,r.kt)("td",{parentName:"tr",align:"center"},"integer"),(0,r.kt)("td",{parentName:"tr",align:"left"},"set the priority of the material")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"x"),(0,r.kt)("td",{parentName:"tr",align:"left"},"0"),(0,r.kt)("td",{parentName:"tr",align:"center"},"float"),(0,r.kt)("td",{parentName:"tr",align:"left"},"the center coordinate of the ring in the x-direction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"y"),(0,r.kt)("td",{parentName:"tr",align:"left"},"0"),(0,r.kt)("td",{parentName:"tr",align:"center"},"float"),(0,r.kt)("td",{parentName:"tr",align:"left"},"the center coordinate of the ring in the y-direction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"z"),(0,r.kt)("td",{parentName:"tr",align:"left"},"0"),(0,r.kt)("td",{parentName:"tr",align:"center"},"float"),(0,r.kt)("td",{parentName:"tr",align:"left"},"the center coordinate of the ring in the z-direction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"z_span"),(0,r.kt)("td",{parentName:"tr",align:"left"},"0"),(0,r.kt)("td",{parentName:"tr",align:"center"},"float"),(0,r.kt)("td",{parentName:"tr",align:"left"},"the thickness of the ring in the z-direction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"inner_radius"),(0,r.kt)("td",{parentName:"tr",align:"left"},"2.6"),(0,r.kt)("td",{parentName:"tr",align:"center"},"float"),(0,r.kt)("td",{parentName:"tr",align:"left"},"the size of the inner radius of the ring")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"outer_radius"),(0,r.kt)("td",{parentName:"tr",align:"left"},"3"),(0,r.kt)("td",{parentName:"tr",align:"center"},"float"),(0,r.kt)("td",{parentName:"tr",align:"left"},"the size of the outer radius of the ring")))),(0,r.kt)("p",null,"The properties of the ring structure are shown in the table above, properties of ",(0,r.kt)("inlineCode",{parentName:"p"},"Rectangle")," can refer to the settings of the ring. Select simulation material by using ",(0,r.kt)("inlineCode",{parentName:"p"},"mesh_order")," in areas where geometry overlaps, the priority of structural materials needs to be higher than that of background material."),(0,r.kt)("h4",{id:"19-add-solver"},"1.9 Add Solver"),(0,r.kt)("div",{class:"text-justify"},'We use the "Simulation()" to instance the simulation module into the project and the "add" function to add an EME solver for the simulation. The properties settings of FDE and FDTD solvers as follows.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 7. Simulation\nsimu = pj.Simulation()\nsimu.add(name=simu_name, type="FDTD",\n            property={"background_material": mt["SiO2"],\n                    "geometry": {"x": 0, "x_span": 9, "y": 0, "y_span": 9, "z": 0, "z_span": 2},\n                    "boundary_conditions": {\n                    "x_min_bc": "PML", "x_max_bc": "PML", "y_min_bc": "PML", "y_max_bc": "PML", "z_min_bc": "PML", "z_max_bc": "PML",\n                    "pml_settings": {"all_pml": {"layers": 8, "kappa": 2, "sigma": 0.8, "polynomial": 3, "alpha": 0, "alpha_polynomial": 1}}},\n                    "general": {"simulation_time": 4000},\n                    "mesh_settings": {"mesh_factor": 1.2, "mesh_type": "auto_non_uniform",\n                                    "mesh_accuracy": {"cells_per_wavelength": grids_per_lambda},\n                                    "minimum_mesh_step_settings": {"min_mesh_step": 1e-4},\n                                    "mesh_refinement": {"mesh_refinement": "curve_mesh"}},\n                    "advanced_options": {"auto_shutoff": {"auto_shutoff_min": 1.00e-4, "down_sample_time": 200}},\n                })\n# endregion\n\n')),(0,r.kt)("p",null,"The properties settings for the FDE solver as follows."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Key"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"solver_type"),(0,r.kt)("td",{parentName:"tr",align:null},"2d_x_normal"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"select the solution plane")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dy"),(0,r.kt)("td",{parentName:"tr",align:null},"grid"),(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"grid size along the y-direction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dz"),(0,r.kt)("td",{parentName:"tr",align:null},"grid"),(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"grid size along the z-direction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"calculate_modes"),(0,r.kt)("td",{parentName:"tr",align:null},"run_options.run_fde"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"choose whether to calculate the mode of the waveguide")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mesh_structure"),(0,r.kt)("td",{parentName:"tr",align:null},"False"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"choose whether to calculate the refractive index distribution of the structure")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"wavelength"),(0,r.kt)("td",{parentName:"tr",align:null},"wavelength"),(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"calculate the wavelength of the mode")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"number_of_trial_modes"),(0,r.kt)("td",{parentName:"tr",align:null},"number_of_trial_modes"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"number of solving modes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"search"),(0,r.kt)("td",{parentName:"tr",align:null},"max_index"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},'choose "max_index" or "near_n" for finding modes')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"calculate_group_index"),(0,r.kt)("td",{parentName:"tr",align:null},"True"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"choose whether to calculate the group refractive index")))),(0,r.kt)("p",null,"The properties settings for the FDTD solver as follows."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Key"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"simulation_time"),(0,r.kt)("td",{parentName:"tr",align:null},"5000"),(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"set the maximum simulation time")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mesh_type"),(0,r.kt)("td",{parentName:"tr",align:null},"auto_non_uniform"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"select 'auto_non_uniform' or 'uniform' to set the type of grid")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cells_per_wavelength"),(0,r.kt)("td",{parentName:"tr",align:null},"grids_per_lambda"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"set the size of the grid")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"min_mesh_step"),(0,r.kt)("td",{parentName:"tr",align:null},"1e-4"),(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"set the minimum grid size")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"auto_shutoff_min"),(0,r.kt)("td",{parentName:"tr",align:null},"1.e-4"),(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"set the energy threshold for terminating the simulation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"down_sample_time"),(0,r.kt)("td",{parentName:"tr",align:null},"200"),(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"set additional simulation duration")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"thread"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"number of threads allocated to run the program")))),(0,r.kt)("p",null,'In the settings of the FDE solver, use "calculate',(0,r.kt)("em",{parentName:"p"},'modes" controls whether to calculate the mode. Note that we need to calculate the group refractive index of the waveguide, so set the "calculate'),' group_index" to True.'),(0,r.kt)("p",null,'In the setting of the FDTD solver, "simulation_time" is used to control the simulation time. We set the simulation time to 4000 fs, which is greater than the default value of 1000 fs. The micro ring resonator has a high quality factor, its simulation requires longer time. If the simulation time is set too small and the simulation stops before the field decays, the results obtained are incorrect.'),(0,r.kt)("h4",{id:"18-add-fdtd-port"},"1.8 Add FDTD Port"),(0,r.kt)("div",{class:"text-justify"},(0,r.kt)("p",null,'In the FDTD simulation, at least a light source is required. We use the "Port()" to instance the port object into the project and the "add" function to add FDTD ports for the simulation. A port can serve not only as a source but also as a monitor. If there are multiple ports, it is necessary to specify which port is the source in the port group. The settings for the FDTD ports as follows.')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 6. Source ---\npt = pj.Port(property={"waveform_id": wv_struct, "source_port": "port_1","monitor_frequency_points":9})\n\npt.add(name="port_1", type="fdtd_port",\n        property={"geometry": {"x": -4.25, "x_span": 0, "y": 3.3, "y_span": 2.5, "z": 0, "z_span": 2},\n                    "modal_properties": {"general": {"inject_axis": "x_axis", "direction": "forward", "mode_selection": "fundamental"}}})\npt.add(name="port_2", type="fdtd_port",\n        property={"geometry": {"x": -4.25, "x_span": 0, "y": -3.3, "y_span": 2.5, "z": 0, "z_span": 2},\n                    "modal_properties": {"general": {"inject_axis": "x_axis", "direction": "forward", "mode_selection": "fundamental"}}})\npt.add(name="port_3", type="fdtd_port",\n        property={"geometry": {"x": 4.25, "x_span": 0, "y": 3.3, "y_span": 2.5, "z": 0, "z_span": 2},\n                    "modal_properties": {"general": {"inject_axis": "x_axis", "direction": "backward", "mode_selection": "fundamental"}}})\npt.add(name="port_4", type="fdtd_port",\n        property={"geometry": {"x": 4.25, "x_span": 0, "y": -3.3, "y_span": 2.5, "z": 0, "z_span": 2},\n                    "modal_properties": {"general": {"inject_axis": "x_axis", "direction": "backward", "mode_selection": "fundamental"}}})\n# endregion\n')),(0,r.kt)("h1",{id:"endregion"},"endregion"),(0,r.kt)("h4",{id:"110-add-monitor"},"1.10 Add Monitor"),(0,r.kt)("p",null,'We use the "Monitor()" to instance the monitor object into the project and the "add" function to add monitors. The port can automatically calculate the transmittance and field profile of the cross-section. In time-domain simulation, it is necessary to add a time monitor at the end of the simulation to check the field strength to judge the accuracy of the simulation results.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 8. Monitor ---  \n""" 6.0 GlobalMonitor """\nmn = pj.Monitor()\nmn.add(name="Global Option", type="global_option", property={\n        "frequency_power": {  # "sample_spacing": "uniform", "use_wavelength_spacing": True, ["min_max","center_span"]\n            "spacing_type": "wavelength", "spacing_limit": "center_span", "wavelength_center": wavelength, "wavelength_span": 0.1, "frequency_points": 11 } }, )\nmn.add(name="time_monitor_point", type="time_monitor", \n        property={ "general": { "stop_method": "end_of_simulation", "start_time": 0, "stop_time": 100, "number_of_snapshots": 0 }, \n        "geometry": { "monitor_type": "point", "x": 0, "x_span": 0, "y": 2.8, "y_span": 0, "z": 0, "z_span": 0 }, \n        "advanced": {"sampling_rate": {"min_sampling_per_cycle": 10}}})\n\nmn.add(name="z_normal", type="power_monitor",\n        property={ "general": {\n            "frequency_profile": { "wavelength_center": wavelength, "wavelength_span": 0.1, "frequency_points": 11}},\n            "geometry": { "monitor_type": "2d_z_normal",\n                            "x": 0, "x_span": 9, "y": 0, "y_span": 9, "z": 0, "z_span": 0 } })\n#endregion\n')),(0,r.kt)("h4",{id:"111-view-structure"},"1.11 View Structure"),(0,r.kt)("p",null,'You can use the "structure_show" function to view the top view of the structure, or use the "show3d()" call gui to check simulation settings.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 9. Structure Show ---\nst.structure_show(fig_type="png", show=False, savepath=f"{plot_path}00_{simu_name}")\n# simu[simu_name].show3d()\n# endregion\n')),(0,r.kt)("h4",{id:"112-run"},"1.12 Run"),(0,r.kt)("p",null,'Pass in the name of the simulation and use "run" function to run the simulation.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# region --- 10. Run ---\neme_res = simu[simu_name].run()\n# endregion\n")),(0,r.kt)("h4",{id:"113-run-and-extract-results"},"1.13 Run and Extract Results"),(0,r.kt)("div",{class:"text-justify"},'The extract function is used to extract data from the result data, where "data" is the calculation result data, "savepath" is the storage path, "target" is the classification of the data, and "monitor_name" is the name of the monitor. The data extraction reference is as follows.. The script demonstration is as follows.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# region --- 11. See Results ---\nif run_options.extract:\n\n    if run_options.run_fde:\n        k = kL[1]\n        res = results.extract(data="calculate_modes", savepath=f"{plot_path}{k}_neff_table", export_csv=True)\n        print(res.to_string(index=False))\n        for m in range(len(res)):\n            k = kL[2]\n            results.extract(data="calculate_modes", savepath=f"{plot_path}{k}_mode{m}",\n                                attribute="Ey", mode=m, real=True, imag=False, **export_options, show=False)\n\n    if run_options.run_fdtd:\n\n        """ 01_time monitor """\n        fdtd_res.extract(data=\'fdtd:time_monitor\', savepath=f"{plot_path}{kL[1]}_TransVstime",\n                         monitor_name=\'time_monitor_point\', target=\'line\', attribute=\'E\',plot_x=\'time\', real=True, \n                         imag=True, export_csv=True, show=False)\n\n        """ 02_top_profile """\n        fdtd_res.extract(data="fdtd:power_monitor", savepath=f"{plot_path}{kL[2]}_profile", monitor_name="z_normal", \n                            target="intensity", attribute="E", wavelength=f"{wavelength}",  export_csv=True)\n\n        """ 03port1_modeprofile """\n        fdtd_res.extract(data="fdtd:port_mode_info", savepath=f"{plot_path}{kL[3]}_port_1_profile",\n                            target="intensity", attribute="E", port_name="port_1", mode=0, export_csv=True)\n\n        """ 031_port1_Lambda_power """\n        fdtd_res.extract(data="fdtd:power_monitor", savepath=f"{plot_path}{kL[3]}_port_1_T",\n                            target="line", attribute="T", port_name="port_1", plot_x="wavelength", export_csv=True)\n\n        """ 032_port2_Lambda_power """\n        fdtd_res.extract(data="fdtd:power_monitor", savepath=f"{plot_path}{kL[3]}_port_2_T",\n                            target="line", attribute="T", port_name="port_2", plot_x="wavelength", export_csv=True)\n                            \n        """ 033_port3_Lambda_power """\n        fdtd_res.extract(data="fdtd:power_monitor", savepath=f"{plot_path}{kL[3]}_port_3_T",\n                            target="line", attribute="T", port_name="port_3", plot_x="wavelength", export_csv=True)\n\n        """ 034_port4_Lambda_power """\n        fdtd_res.extract(data="fdtd:power_monitor", savepath=f"{plot_path}{kL[3]}_port_4_T",\n                            target="line", attribute="T", port_name="port_4", plot_x="wavelength", export_csv=True)    \n\n# endregion\n\n')),(0,r.kt)("h4",{id:"114-control-switch"},"1.14 Control Switch"),(0,r.kt)("p",null,'We can control the operation of the simulation by passing in bool values through tuple, as shown in the following code. In each simulation, only one solver will be enabled. When using the FDE solver, set "run_fde" to True and "run_fdtd" to False; When using the FDTD solver, set "run_fdtd" to True and "run_fde" to False.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class RunOptions(NamedTuple):\n    index_preview: bool\n    run_fde: bool\n    run_fdtd: bool\n    extract: bool\n\nif __name__ == "__main__":\n        simulation(wavelength=1.55, grids_per_lambda=6, run_options=RunOptions(index_preview=False, run=True, extract=True))\n\n')),(0,r.kt)("h3",{id:"2-output-results"},"2. Output results"),(0,r.kt)("h4",{id:"length-of-ring"},"Length of ring"),(0,r.kt)("p",null,"The light traveling in the waveguide generates evanescent field on its surface, so energy couples into a nearby waveguide as the waveguide approaches. We design a microring resonant filter with an FSR of 30nm, and we can calculate the effective circumference of the microring according to the following formula. The FDE solver can be used to calculate the group refractive index of the waveguide. The following table shows the group refractive index of the waveguide cross-section in the first three modes with a wavelength of 1.55um."),(0,r.kt)(i.BlockMath,{math:" 2{\\pi}R= {\\lambda}^2/(FSR*n_g)",mdxType:"BlockMath"}),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"order"),(0,r.kt)("th",{parentName:"tr",align:null},"TEratio"),(0,r.kt)("th",{parentName:"tr",align:null},"neff_real"),(0,r.kt)("th",{parentName:"tr",align:null},"neff_imag"),(0,r.kt)("th",{parentName:"tr",align:null},"ng_real"),(0,r.kt)("th",{parentName:"tr",align:null},"ng_imag"),(0,r.kt)("th",{parentName:"tr",align:null},"wavelength_nm"),(0,r.kt)("th",{parentName:"tr",align:null},"loss_dBpcm"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"0.966627"),(0,r.kt)("td",{parentName:"tr",align:null},"2.227503"),(0,r.kt)("td",{parentName:"tr",align:null},"0.0"),(0,r.kt)("td",{parentName:"tr",align:null},"4.434594"),(0,r.kt)("td",{parentName:"tr",align:null},"0.0"),(0,r.kt)("td",{parentName:"tr",align:null},"1550.0"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0.046759"),(0,r.kt)("td",{parentName:"tr",align:null},"1.692711"),(0,r.kt)("td",{parentName:"tr",align:null},"0.0"),(0,r.kt)("td",{parentName:"tr",align:null},"3.467810"),(0,r.kt)("td",{parentName:"tr",align:null},"0.0"),(0,r.kt)("td",{parentName:"tr",align:null},"1550.0"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"0.599748"),(0,r.kt)("td",{parentName:"tr",align:null},"1.430406"),(0,r.kt)("td",{parentName:"tr",align:null},"0.0"),(0,r.kt)("td",{parentName:"tr",align:null},"1.683888"),(0,r.kt)("td",{parentName:"tr",align:null},"0.0"),(0,r.kt)("td",{parentName:"tr",align:null},"1550.0"),(0,r.kt)("td",{parentName:"tr",align:null},"0")))),(0,r.kt)("p",null,"Considering the transmission of the fundamental mode of TE polarization, a group refractive index of 4.43 can be obtained. Therefore, selecting a ring with an effective radius of 2.87um can meet the free spectrum range of 30nm."),(0,r.kt)("h4",{id:"couple-gap-and-length"},"Couple gap and length"),(0,r.kt)("p",null,"The length of the coupling region can be calculated based on the effective refractive index difference between symmetric and antisymmetric modes, as shown in the following formula. Setting the gap between the straight waveguide and the ring to 100nm can generate strong mutual coupling. Using the FDE solver to calculate the effective refractive index of the coupling region between the waveguide and the microring, the corresponding mode distribution is as follows."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(6363).Z,width:"5669",height:"2126"})),(0,r.kt)("p",null,"The coupling distance calculated at wavelength of 1.55um more than 1.4 um. You can choose to increase the radius of the ring to reduce the coupling length. We choose to set the coupling length to zero and obtain sufficient coupling length and expected loop length by increasing the radius."),(0,r.kt)(i.BlockMath,{math:"L={\\lambda}/({\\pi}{\\Delta}n)sin^{-1}(|t12|)",mdxType:"BlockMath"}),(0,r.kt)("h4",{id:"transmission"},"Transmission"),(0,r.kt)("p",null,"Calculate the resonant response of a straight waveguide coupled to a microring with a radius of 2.8um using 3D FDTD. Adding a mode light source as an excitation for straight waveguide, and use a power monitor to view the field distribution and transmittance."),(0,r.kt)("p",null,"When the light field coupled into the microring meets the resonance condition, it will output from the dorp port. As shown in the figure below, there is the maximum electric field at the drop port at the resonant wavelength."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(14078).Z,width:"5669",height:"2126"})),(0,r.kt)("p",null,"The transmittance of the drop end is shown in the following figure."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(59524).Z,width:"5669",height:"2126"})),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("p",null,"Hammer, M. and Hiremath, K.R. and Stoffer, R. (2004) Analytical approaches to the description of optical microresonator devices. (Invited) In: Microresonators as Building Blocks for VLSI Photonics, 18-25 October 2003, Erice, Italy. pp. 48-71. AIP Conference Proceedings 709. Springer. ISSN 0094-243X ISBN 978-0-7354-0184-6."))))}c.isMDXComponent=!0},6363:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/MRR_FDE-2d545182c4d4cfc5fc7d05cc15ffc5c0.png"},14078:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/MRR_xy-779ce71a6618087db8168a05e03c09af.png"},59524:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/T_drop-85f92340f83dc21e3c16d425ddf96c75.png"},94860:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/mr-e4b1e4645a9842620e37b2eb6622147d.png"}}]);