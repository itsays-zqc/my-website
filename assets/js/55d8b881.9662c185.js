"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1980],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",_={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(a),c=i,u=m["".concat(s,".").concat(c)]||m[c]||_[c]||r;return a?n.createElement(u,l(l({ref:t},d),{},{components:a})):n.createElement(u,l({ref:t},d))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},799:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>_,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={},l="Modulator",o={unversionedId:"examples/MOD/MOD",id:"examples/MOD/MOD",title:"Modulator",description:"Introduction",source:"@site/docs/examples/MOD/MOD.md",sourceDirName:"examples/MOD",slug:"/examples/MOD/",permalink:"/my-website/docs/examples/MOD/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/examples/MOD/MOD.md",tags:[],version:"current",frontMatter:{},sidebar:"examplesSidebar",previous:{title:"Optical scattering and far-field radiation",permalink:"/my-website/docs/examples/Optical_scattering_and_far-field_radiation/"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Simulation Methods",id:"simulation-methods",level:2},{value:"Simulation Structure",id:"simulation-structure",level:2},{value:"1. Basic Operations",id:"1-basic-operations",level:3},{value:"2. Code description",id:"2-code-description",level:3},{value:"2.1 Import Modules",id:"21-import-modules",level:4},{value:"2.2 Define Parameters",id:"22-define-parameters",level:4},{value:"2.2.1 General Parameters",id:"221-general-parameters",level:5},{value:"2.2.2 Structure Geometry",id:"222-structure-geometry",level:5},{value:"2.2.3 Electrical Simulation Boundary",id:"223-electrical-simulation-boundary",level:5},{value:"2.2.4 Optical simulation Boundary",id:"224-optical-simulation-boundary",level:5},{value:"2.3 Define Engineering Function",id:"23-define-engineering-function",level:4},{value:"2.3.1 Creat Project",id:"231-creat-project",level:5},{value:"2.3.2 Set Material",id:"232-set-material",level:5},{value:"2.3.3 Define structure",id:"233-define-structure",level:5},{value:"2.3.4 Add Doping",id:"234-add-doping",level:5},{value:"2.3.5 Set Optical Simulate Boundry",id:"235-set-optical-simulate-boundry",level:5},{value:"2.3.6 Add Mesh",id:"236-add-mesh",level:5},{value:"2.3.7 Define Structure File",id:"237-define-structure-file",level:5},{value:"2.3.8 Set Simulate Solver",id:"238-set-simulate-solver",level:5},{value:"3. Output Result",id:"3-output-result",level:3},{value:"Analytic Character",id:"analytic-character",level:2},{value:"1.Modulation efficiency",id:"1modulation-efficiency",level:3},{value:"1.1 Basic Operations",id:"11-basic-operations",level:4},{value:"1.2 Code Description",id:"12-code-description",level:4},{value:"1.2.1 Import Modules",id:"121-import-modules",level:5},{value:"1.2.2 Define Parameters",id:"122-define-parameters",level:5},{value:"1.2.3 Set Path",id:"123-set-path",level:5},{value:"1.2.4 Confirm swing of voltage",id:"124-confirm-swing-of-voltage",level:5},{value:"1.2.5 Creat Component",id:"125-creat-component",level:5},{value:"1.2.6 Set Simulation",id:"126-set-simulation",level:5},{value:"1.2.7 Run",id:"127-run",level:5},{value:"1.2.8 Extract Parameters",id:"128-extract-parameters",level:5},{value:"1.2.9 Calculate",id:"129-calculate",level:5},{value:"1.3 Output Result",id:"13-output-result",level:4},{value:"1.3.1 Loss",id:"131-loss",level:5},{value:"1.3.2 Effective Index",id:"132-effective-index",level:5},{value:"1.3.3 Modulation efficiency",id:"133-modulation-efficiency",level:5},{value:"2.Capacitance And Resistance",id:"2capacitance-and-resistance",level:3},{value:"2.1 Basic Operations",id:"21-basic-operations",level:4},{value:"2.2 Code Description",id:"22-code-description",level:4},{value:"2.2.1 Import Modules",id:"221-import-modules",level:5},{value:"2.2.2 Define Parameters",id:"222-define-parameters",level:5},{value:"2.2.3 Set Path",id:"223-set-path",level:5},{value:"2.2.4 Creat Component",id:"224-creat-component",level:5},{value:"2.2.5 Set Simulation",id:"225-set-simulation",level:5},{value:"2.2.6 Run",id:"226-run",level:5},{value:"2.2.7 Extract Parameters",id:"227-extract-parameters",level:5},{value:"2.2.8 Calculate",id:"228-calculate",level:5},{value:"2.3 Output Result",id:"23-output-result",level:4},{value:"2.3.1 Capacitance",id:"231-capacitance",level:5},{value:"2.3.2 Photocurrent",id:"232-photocurrent",level:5},{value:"2.3.3 Resistance",id:"233-resistance",level:5}],d={toc:p},m="wrapper";function _(e){let{components:t,...r}=e;return(0,i.kt)(m,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"modulator"},"Modulator"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"\u200b\tWe have developed an electro-optic modulator based on carrier-depletion mechanism in silicon to simulate carrier and index distribution in a global structure. The drift and diffusion of carriers result in depletion at the PN junction. Applying a reverse bias voltage at the cathode broadens the depletion region, altering the carrier concentration and modulating the material's refractive index. Gaussian doping was employed in this model. Modulation efficiency, capacitance, and resistance were calculated to analyze the electro-optic characteristics of the modulator."),(0,i.kt)("p",null,"\u200b\tThe figure below illustrates the device structure we constructed, wherein the aluminum electrode is applied to the silicon modulator, and the entire device is encapsulated with silicon dioxide material."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(7522).Z,width:"956",height:"490"})),(0,i.kt)("h2",{id:"simulation-methods"},"Simulation Methods"),(0,i.kt)("p",null,"\u200b\t"),(0,i.kt)("h2",{id:"simulation-structure"},"Simulation Structure"),(0,i.kt)("p",null,"\u200b\tThe present structural file provides a comprehensive guide for constructing a simulation structure and establishing a Gaussian doping distribution. Initially, one must construct the geometric structure of the device, incorporate materials and physical field models, specify the doping distribution, and simulation boundary conditions, and set the light source and simulation solver. Eventually, the simulation result data should be extracted and output. "),(0,i.kt)("p",null,"\u200b\tOur simulation is designed with a light source entering along the X-axis, and the primary optoelectronic characteristic analysis takes place within the three-dimensional structure on the YZ plane. Gaussian doping method is employed to enhance the bandwidth and improve the performance of high-speed devices. The FDE solver is utilized to solve the distribution of effective refractive index, and the OEedvice solver is used to solve the doping distribution of the device. Finally, we generate ad output the  distribution map iof doping and index in modulator structure."),(0,i.kt)("p",null,"Application Library path: ",(0,i.kt)("inlineCode",{parentName:"p"},":\\SDK\\V2.3.0.4\\examples\\active_demo\\doping_function\\MOD\\MOD00_structure.py")),(0,i.kt)("h3",{id:"1-basic-operations"},"1. Basic Operations"),(0,i.kt)("p",null,"\u200b\tIt is essential to incorporate materials for structure. Although module of ",(0,i.kt)("inlineCode",{parentName:"p"},"maxoptics_sdk.all")," provides default values for standard semiconductors, these values can be customized in ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD_material.py")," . "),(0,i.kt)("p",null,"\u200b\tApplication Library path: ",(0,i.kt)("inlineCode",{parentName:"p"},":\\SDK\\V2.3.0.4\\examples\\active_demo\\doping_function\\MOD\\MOD_material.py")),(0,i.kt)("p",null,"\u200b\tThe module of ",(0,i.kt)("inlineCode",{parentName:"p"},"basic")," specifies the electron affinity and relative dielectric permittivity of the material. It is crucial to define the mode type and parameter values, if another model is used instead of the default. The default mobility model of Silicon is ",(0,i.kt)("inlineCode",{parentName:"p"},"Analytic")," , but we use the mobility model of ",(0,i.kt)("inlineCode",{parentName:"p"},"Masetti")," in this modulator. The ",(0,i.kt)("inlineCode",{parentName:"p"},"band")," module includes the model of bandgap, bandgap narrowing , and recombination of  Auger, SRH, and Radiative. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'elec_Si_properties = {"basic": {"model": "Default",\n                                "Default": {"affinity": 4.2-1.11452/2.0, "permitti": 11.7}, "print": 1},\n                      "mobility": {"model": "Masetti",\n                                   "Masetti": {"mu_min2_h": 44.9, "mumax_e": 1471, "mumax_h": 470.5, "pc_h": 0}, "print": 1},\n                      "band": {"model": "Default",\n                               "Default": {\n                                   # DOS\n                                   "dos_formula": 2, "nc300": 3.21657e19, "nv300": 1.82868e19,\n                                   # Bandgap\n                                   "eg0": 1.16, "chi0": 4.2-1.16/2,\n                                   # Bandgap Narrowing\n                                   "bgn_model": "OldSlotboom", "e0_bgn_oldslotboom": 0.0045, "n0_bgn_oldslotboom": 1.00e17, "deg0_oldslotboom": 0,\n                                   # Auger Recombination\n                                   "augan": 2.8e-31, "augap": 9.9e-32, "augbn": 0, "augbp": 0, "augcn": 0, "augcp": 0, "aughn": 0, "aughp": 0,\n                                   # SRH Recombination\n                                   "taunmax": 3.3e-6, "taupmax": 4e-6, "nsrh_n": 7.1e15, "nsrh_p": 7.1e15, "nc_f": 1.5, "nv_f": 1.5, \n                                   # Radiative Recombination\n                                   "c_direct": 1.6e-14,}, "print": 1}}\n')),(0,i.kt)("p",null,"\u200b\tThe parameter values of ",(0,i.kt)("inlineCode",{parentName:"p"},"matparas_1550")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"matparas_1310")," are used for converting carrier distribution to a change in refractive index."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'matparas_1550 = {\n    "dn_an": -8.8e-22,\n    "dn_en": 1,\n    "dn_ap": -8.5e-18,\n    "dn_ep": 0.8,\n    "dalpha_an": 8.5e-18,\n    "dalpha_en": 1,\n    "dalpha_ap": 6.0e-18,\n    "dalpha_ep": 1\n}\n\nmatparas_1310 = {\n    "dn_an": -6.2e-22,\n    "dn_en": 1,\n    "dn_ap": -6e-18,\n    "dn_ep": 0.8,\n    "dalpha_an": 6e-18,\n    "dalpha_en": 1,\n    "dalpha_ap": 4e-18,\n    "dalpha_ep": 1\n}\n')),(0,i.kt)("h3",{id:"2-code-description"},"2. Code description"),(0,i.kt)("h4",{id:"21-import-modules"},"2.1 Import Modules"),(0,i.kt)("p",null,"\u200b\tTo begion, we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," command to call the relevant functional modules and  parameter values of material from previously defined file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import maxoptics_sdk.all as mo\nimport os\nimport time\nfrom maxoptics_sdk.helper import timed\nfrom pathlib import Path\nfrom MOD_material import matparas_1550, matparas_1310, elec_Si_properties\n")),(0,i.kt)("h4",{id:"22-define-parameters"},"2.2 Define Parameters"),(0,i.kt)("h5",{id:"221-general-parameters"},"2.2.1 General Parameters"),(0,i.kt)("p",null,"\u200b\tWe define these parameters for entire simulation process."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'wavelength = 1.31   \negrid_local = 0.01  \nogrid_global_y = 0.02   \nogrid_global_z = 0.02   \nogrid_local = 0.002   \ntemperature = 300   \nnormal_length = 10000   \nssac_amplitude = 0.001  # V\nrun_mode = "local"\nsimu_name = "MOD00_struc"\n')),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Units"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"wavelength"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the optical wavelength of the source beam (in the vacuum) for mono-spectral simulations.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"egrid_loacal"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the appropriate size of mesh in the Y and Z direction for overall region of FDE simulation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ogrid_global_y"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the mesh spacing in the Y direction for region of optical simulation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ogrid_global_z"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the mesh spacing in the Z direction for region of optical simulation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ogrid_local"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the mesh spacing in the Y and Z direction for local region of optical simulation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"temperature"),(0,i.kt)("td",{parentName:"tr",align:null},"K"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the temperature in Kelvin.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"normal_length"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the extent of a mesh section in the X direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ssac_amplitude"),(0,i.kt)("td",{parentName:"tr",align:null},"V"),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"run_mode"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the simulate model.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"simu_name"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies this file name to define name of output result folder.")))),(0,i.kt)("p",null,"\u200b\tsince we explore two communication wavelength, you should define the wavelength, and use next code to choose  relavent parameters values, which we defines in ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD_material.py")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"if wavelength > 1.4:\n    Si_index_vs_doping = matparas_1550\nelse:\n    Si_index_vs_doping = matparas_1310\n")),(0,i.kt)("h5",{id:"222-structure-geometry"},"2.2.2 Structure Geometry"),(0,i.kt)("p",null,"\u200b\tYou should define the location of material in X, Y and Z direction about the modulator structure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"st_x_min = -0.3\nst_x_max = 0.3\nst_x_mean = 0.5*(st_x_min+st_x_max)\nst_x_span = st_x_max-st_x_min\n\nst_y_min = -5\nst_y_max = 5\nst_y_mean = 0.5*(st_y_min+st_y_max)\nst_y_span = st_y_max-st_y_min\n\nst_z_min = -0.3\nst_z_max = 0.8\n\nslab_height = 0.09\nrg_height = 0.22\nrg_width = 0.5\nelec_height = 0.5\nelec_width = 1.2\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Units"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"x_min, x_max, y_min, y_max, z_min, z_max"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the minimum or maximum value in X/Y boundary of modulator structure.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"x_mean, x_span, y_mean, y_span, z_mean, z_span"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the center or spacing value in X/Y boundary of modulator structure.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"slab_height"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the height of slab layer in Z direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"rg_height"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the height of RG layer in Z direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"elec_height, elec_width"),(0,i.kt)("td",{parentName:"tr",align:null},"um"),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the Z-direction height and Y-direction width of electron.")))),(0,i.kt)("h5",{id:"223-electrical-simulation-boundary"},"2.2.3 Electrical Simulation Boundary"),(0,i.kt)("p",null,"\u200b\tSpecifies the  boundary of electrical simulation for ",(0,i.kt)("inlineCode",{parentName:"p"},"OEDevice")," solver in 3D direction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"oe_x_min = -0.3\noe_x_max = 0.3\noe_x_mean = 0.5*(oe_x_min+oe_x_max)\noe_x_span = oe_x_max-oe_x_min\n\noe_y_min = -4.9\noe_y_max = 4.9\noe_y_mean = 0.5*(oe_y_min+oe_y_max)\noe_y_span = oe_y_max-oe_y_min\n\noe_z_min = -0.3\noe_z_max = 0.8\noe_z_mean = 0.5*(oe_z_min+oe_z_max)\noe_z_span = oe_z_max-oe_z_min\n")),(0,i.kt)("p",null,"\u200b\tSpecifies the  concentration of uniform doping by ",(0,i.kt)("inlineCode",{parentName:"p"},"constant_con")," and its boundary throuth ",(0,i.kt)("inlineCode",{parentName:"p"},"center")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"span")," in Y-Z plane."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"constant_y_center = 0\nconstant_y_span = 10\nconstant_z_center = 0.1\nconstant_z_span = 0.3\nconstant_con = 1e15\n")),(0,i.kt)("p",null,"\u200b\tSpecifies the  junction width and peak concentration of gaussian doping by",(0,i.kt)("inlineCode",{parentName:"p"},"_jw")," and  ",(0,i.kt)("inlineCode",{parentName:"p"},"_con")," , its boundary throuth ",(0,i.kt)("inlineCode",{parentName:"p"},"center")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"span")," in Y-Z plane of slab."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"p_slab_y_center = -2.575\np_slab_y_span = 4.85\np_slab_z_center = -0.105\np_slab_z_span = 0.39\np_slab_jw = 0.1\np_slab_con = 7e17\n\nn_slab_y_center = 2.575\nn_slab_y_span = 4.85\nn_slab_z_center = -0.105\nn_slab_z_span = 0.39\nn_slab_jw = 0.1\nn_slab_con = 5e17\n")),(0,i.kt)("p",null,"\u200b\tSpecifies the doping region of high concentration in slab layer, including boundary\u3001junction width and peak concentration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"p_plus_y_center = -3.5\np_plus_y_span = 3\np_plus_z_center = -0.04\np_plus_z_span = 0.52\np_plus_jw = 0.1\np_plus_con = 1e19\n\nn_plus_y_center = 3.5\nn_plus_y_span = 3\nn_plus_z_center = -0.04\nn_plus_z_span = 0.52\nn_plus_jw = 0.1\nn_plus_con = 1e19\n")),(0,i.kt)("p",null,"\u200b\tSpecifies the doping region of high concentration in waveguide structure, including boundary\u3001junction width and peak concentration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"p_wg_y_center = -0.12\np_wg_y_span = 0.36\np_wg_z_center = 0.1275\np_wg_z_span = 0.255\np_wg_jw = 0.12\np_wg_con = 5e17\n\nn_wg_y_center = 0.105\nn_wg_y_span = 0.29\nn_wg_z_center = 0.12\nn_wg_z_span = 0.235\nn_wg_jw = 0.11\nn_wg_con = 7e17\n")),(0,i.kt)("h5",{id:"224-optical-simulation-boundary"},"2.2.4 Optical simulation Boundary"),(0,i.kt)("p",null,"\u200b\tSpecifies the boundary of optical simulation  for ",(0,i.kt)("inlineCode",{parentName:"p"},"FDE")," solver in 3D direction. We only consider optical characteristic of Y-Z plane, since the light travels along X-axis."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x_min = 0\nx_max = 0\nx_mean = 0.5*(x_min+x_max)\nx_span = x_max-x_min\n\ny_min = -2.3\ny_max = 2.3\ny_mean = 0.5*(y_min+y_max)\ny_span = y_max-y_min\n\nz_min = -1.5\nz_max = 1.5\nz_mean = 0.5*(z_min+z_max)\nz_span = z_max-z_min\n")),(0,i.kt)("h4",{id:"23-define-engineering-function"},"2.3 Define Engineering Function"),(0,i.kt)("p",null,"\u200b\tTo facilitate the calling of other simulation scripts, it is recommended to define a function that can set materials, model, dope, and add boundary conditions."),(0,i.kt)("h5",{id:"231-creat-project"},"2.3.1 Creat Project"),(0,i.kt)("p",null,"\u200b\tCreate a new simulation project."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def mod_project(project_name, run_mode, st_type):\n    pj = mo.Project(name=project_name, location=run_mode)\n")),(0,i.kt)("h5",{id:"232-set-material"},"2.3.2 Set Material"),(0,i.kt)("p",null,"\u200b\tThe electrical and optical parameters of SiO2\u3001Aluminium and Si materials in the material library can be accessed. If the parameters defined in the Si section of ",(0,i.kt)("inlineCode",{parentName:"p"},"MOD_material.py"),"  are different from the default parameters in the material library, the former will be prioritized. In the overlapping area of the materials, the material with a higher order value will take precedence over the one with a lower value. If the values are the same, the material defined later will override the one defined earlier. It is worth noting that the material Aluminium will call the PEC material library."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'mt = pj.Material()\n    mt.add_lib(name="mat_sio2", data=mo.OE_Material.SiO2, order=1)\n    mt.add_lib(name="mat_al", data=mo.OE_Material.Al, order=2)\n    mt.add_lib(name="mat_si", data=mo.OE_Material.Si, order=2, override=elec_Si_properties)\n    mt["mat_sio2"].set_optical_material(data=mo.Material.SiO2_Palik)\n    mt["mat_si"].set_optical_material(data=mo.Material.Si_Palik)\n    mt["mat_al"].set_optical_material(data=mo.Material.PEC)\n')),(0,i.kt)("h5",{id:"233-define-structure"},"2.3.3 Define structure"),(0,i.kt)("p",null,"\u200b\tTo begin with, it is advisable to define the geometric region of the device structure and add materials to this region. The background material, which is usually Air or SiO2, should be added first. You can choose the geometry of structure in ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," ,  call materila library added above by ",(0,i.kt)("inlineCode",{parentName:"p"},"material")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},' st = pj.Structure(mesh_type="curve_mesh", mesh_factor=1.4, background_material=mt["mat_sio2"])\n\n    st.add_geometry(name="BOX", type="Rectangle", property={\n        "material": {"material": mt["mat_sio2"]},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": st_y_mean, "y_span": st_y_span, "z_min": st_z_min, "z_max": slab_height}})\n\n    st.add_geometry(name="SOX", type="Rectangle", property={\n        "material": {"material": mt["mat_sio2"]},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": st_y_mean, "y_span": st_y_span, "z_min": slab_height, "z_max": st_z_max}})\n\n    st.add_geometry(name="Slab", type="Rectangle", property={\n        "material": {"material": mt["mat_si"]},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": st_y_mean, "y_span": st_y_span, "z_min": 0, "z_max": slab_height}})\n\n    st.add_geometry(name="Rg", type="Rectangle", property={\n        "material": {"material": mt["mat_si"]},\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": 0, "y_span": rg_width, "z_min": slab_height, "z_max": rg_height}})\n')),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Units"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"name"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Restricts the applicability of the statement to regions with the specified name.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"material"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Restricts the applicability of the statement to regions of the specified material.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"type"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the  geometry of specified region.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"geometry"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies the boundary of specified region in 3D direction")))),(0,i.kt)("p",null,"\u200b\tWe offer several alternative electrode region for establishing the electrical simulation area."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'if st_type == "normal":\n        st.add_geometry(name="Anode", type="Rectangle", property={\n            "material": {"material": mt["mat_al"]},\n            "geometry": {"x": st_x_mean, "x_span": st_x_span, "y_min": st_y_min, "y_max": st_y_min + elec_width,\n                         "z_min": slab_height, "z_max": slab_height + elec_height}})\n\n        st.add_geometry(name="Cathode", type="Rectangle", property={\n            "material": {"material": mt["mat_al"]},\n            "geometry": {"x": st_x_mean, "x_span": st_x_span, "y_min": st_y_max - elec_width, "y_max": st_y_max,\n                         "z_min": slab_height, "z_max": slab_height + elec_height}})\n\n    elif st_type == "slab_N":\n        st.add_geometry(name="Cathode", type="Rectangle", property={\n            "material": {"material": mt["mat_al"]},\n            "geometry": {"x": st_x_mean, "x_span": st_x_span, "y_min": st_y_max - elec_width, "y_max": st_y_max,\n                         "z_min": slab_height, "z_max": slab_height + elec_height}})\n\n        st.add_geometry(name="Ground", type="Rectangle", property={\n            "material": {"material": mt["mat_al"]},\n            "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": st_y_mean, "y_span": rg_width, "z_min": 0, "z_max": rg_height}})\n\n    elif st_type == "slab_P":\n        st.add_geometry(name="Anode", type="Rectangle", property={\n            "material": {"material": mt["mat_al"]},\n            "geometry": {"x": st_x_mean, "x_span": st_x_span, "y_min": st_y_min, "y_max": st_y_min + elec_width,\n                         "z_min": slab_height, "z_max": slab_height + elec_height}})\n\n        st.add_geometry(name="Ground", type="Rectangle", property={\n            "material": {"material": mt["mat_al"]},\n            "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": st_y_mean, "y_span": rg_width, "z_min": 0, "z_max": rg_height}})\n    else:\n        print("st_type must be chosen from \'normal\', \'slab_N\', \'slab_P\'")\n        raise\n')),(0,i.kt)("h5",{id:"234-add-doping"},"2.3.4 Add Doping"),(0,i.kt)("p",null,"\u200b\tYou should define the basic parameters of doping module, such as  type\u3001region and model. Then define source face\u3001junction width peak concentration and  reference concentration in gaussian doping, or only concenteration in uniform doping.  ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," specifies the n-type or donor dopant in ",(0,i.kt)("inlineCode",{parentName:"p"},'"n"')," , and  p-type or acceptor dopant in ",(0,i.kt)("inlineCode",{parentName:"p"},'"p"')," , which may be used with gaussian and uniform prodile types.  ",(0,i.kt)("inlineCode",{parentName:"p"},"ref_concentration")," specifies the ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'st.add_doping(name="background_doping", type="p", property={\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": constant_y_center, "y_span": constant_y_span, "z": constant_z_center, "z_span": constant_z_span},\n        "general": {"distribution_function": "constant", "concentration": constant_con}})\n\n    st.add_doping(name="p_slab", type="p", property={\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": p_slab_y_center, "y_span": p_slab_y_span, "z": p_slab_z_center, "z_span": p_slab_z_span},\n        "general": {"distribution_function": "gaussian", "source_face": "upper_z", "junction_width": p_slab_jw, "concentration": p_slab_con, "ref_concentration": 1e6}})\n\n    st.add_doping(name="n_slab", type="n", property={\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": n_slab_y_center, "y_span": n_slab_y_span, "z": n_slab_z_center, "z_span": n_slab_z_span},\n        "general": {"distribution_function": "gaussian", "source_face": "upper_z", "junction_width": n_slab_jw, "concentration": n_slab_con, "ref_concentration": 1e6}})\n\n    st.add_doping(name="p_plus", type="p", property={\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": p_plus_y_center, "y_span": p_plus_y_span, "z": p_plus_z_center, "z_span": p_plus_z_span},\n        "general": {"distribution_function": "gaussian", "source_face": "upper_z", "junction_width": p_plus_jw, "concentration": p_plus_con, "ref_concentration": 1e6}})\n\n    st.add_doping(name="n_plus", type="n", property={\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": n_plus_y_center, "y_span": n_plus_y_span, "z": n_plus_z_center, "z_span": n_plus_z_span},\n        "general": {"distribution_function": "gaussian", "source_face": "upper_z", "junction_width": n_plus_jw, "concentration": n_plus_con, "ref_concentration": 1e6}})\n\n    st.add_doping(name="p_wg", type="p", property={\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": p_wg_y_center, "y_span": p_wg_y_span, "z": p_wg_z_center, "z_span": p_wg_z_span},\n        "general": {"distribution_function": "gaussian", "source_face": "lower_y", "junction_width": p_wg_jw, "concentration": p_wg_con, "ref_concentration": 1e6}})\n\n    st.add_doping(name="n_wg", type="n", property={\n        "geometry": {"x": st_x_mean, "x_span": st_x_span, "y": n_wg_y_center, "y_span": n_wg_y_span, "z": n_wg_z_center, "z_span": n_wg_z_span},\n        "general": {"distribution_function": "gaussian", "source_face": "upper_y", "junction_width": n_wg_jw, "concentration": n_wg_con, "ref_concentration": 1e6}})\n\n')),(0,i.kt)("h5",{id:"235-set-optical-simulate-boundry"},"2.3.5 Set Optical Simulate Boundry"),(0,i.kt)("p",null,"\u200b\tYou should set the boundry of optical simulation for ",(0,i.kt)("inlineCode",{parentName:"p"},"FDE")," solver."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'st.OBoundary(property={\n        "geometry": {"x": x_mean, "y": y_mean, "z": z_mean, "x_span": x_span, "y_span": y_span, "z_span": z_span},\n        "boundary": {"y_min": "PEC", "y_max": "PEC", "z_min": "PEC", "z_max": "PEC"}})\n')),(0,i.kt)("h5",{id:"236-add-mesh"},"2.3.6 Add Mesh"),(0,i.kt)("p",null,"\u200b\tWhen specifying meshes, a balance should be struck between accuracy and numerical efficiency. The accuracy, convergence, and program memory of the subsequent computation are all affected by the quality and size of the elements in the mesh, making mesh partitioning crucial in this module. Achieving accuracy requires a fine mesh that can resolve all significant features of the solution, while numerical efficiency requires a coarse mesh that minimizes the total number of grid points.  "),(0,i.kt)("p",null,"\u200b\tDue to the relatively simple structure of this modulator, a rough initial mesh can be established for electrical and optical simulation of the entire device. In order to obtain more accurate calculation results and better convergence, the ",(0,i.kt)("inlineCode",{parentName:"p"},"emesh"),"  module is employed to refine the mesh of the regions with significant electrical characteristics."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'st.add_mesh(name="OMesh_Local", property={\n        "geometry": {"x": x_mean, "x_span": x_span, "y": 0, "y_span": 2*rg_width, "z_min": -0.5*rg_height, "z_max": 1.5*rg_height},\n        "general": {"dy": ogrid_local, "dz": ogrid_local}})\nst.add_emesh(name="EMesh_Local", property={\n                 "y_min": st_y_min, "y_max": st_y_max, "z_min": st_z_min, "z_max": st_z_max, "mesh_size": egrid_local})\n')),(0,i.kt)("h5",{id:"237-define-structure-file"},"2.3.7 Define Structure File"),(0,i.kt)("p",null,"\u200b\tYou should call the previous defined simulation module and define the name and path of the output file. "),(0,i.kt)("p",null,"\u200b\tThrough invoking the ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," module and adding it to the file name, the output file of each simulation can be unique, which facilitates accurate file retrieval after multiple simulations. The ",(0,i.kt)("inlineCode",{parentName:"p"},"plot_path")," will be used as the path for saving extracted results and is set here to the plots folder in the same directory as the script. If this path does not exist, the ",(0,i.kt)("inlineCode",{parentName:"p"},"os.makedirs"),"  function needs to be called to create the path."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'return pj\n\ntime_str = time.strftime("%Y%m%d_%H%M%S/", time.localtime())\n\n@timed\ndef preview():\n    pj = mod_project(project_name=simu_name + time_str, run_mode="local", st_type="normal")\n\n    plot_path = str(Path(__file__).parent.as_posix()) + "/plots/"\n    if not os.path.exists(plot_path):\n        os.makedirs(plot_path)\n')),(0,i.kt)("h5",{id:"238-set-simulate-solver"},"2.3.8 Set Simulate Solver"),(0,i.kt)("p",null," \t Adding electrical and optical silmulation solver, is the prerequisite for output structure file. You can specify solver name and type in ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," module, and then define its other property. "),(0,i.kt)("p",null,"\u200b\tThe type of ",(0,i.kt)("inlineCode",{parentName:"p"},"AFDE")," is finite difference eigenmode (FDE) simulation module for active devices, which can be used to investigate the refractive index distribution of a device. This solver solves the single-frequency Maxwell's equations directly on a discretized grid of the waveguide cross-section, enabling exploration of the refractive index distribution of the device. The FDE analysis module can then be used to set the boundary conditions, define the model, mesh structure, and wavelength of the light source for calculation. "),(0,i.kt)("p",null,"\u200b\tThe type of ",(0,i.kt)("inlineCode",{parentName:"p"},"OEDevice")," module can be invoked to enable the charge carrier transport solver for analyzing the optoelectronic properties of a device. Since the simulation analysis is conducted in the two-dimensional Y-Z plane that is perpendicular to the X-axis, ",(0,i.kt)("inlineCode",{parentName:"p"},"2d_x_normal"),"  is adopted to define the simulation calculation geometry."),(0,i.kt)("p",null,"\u200b\tWe utilize the ",(0,i.kt)("inlineCode",{parentName:"p"},"Newton")," iteration method for calculation, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"MUMPS"),"  direct solver is employed as the linear solver. The ",(0,i.kt)("inlineCode",{parentName:"p"},"max_iterations")," parameter defines the maximum number of nonlinear iterations. When the number of iterations exceeds this value, the solver reports failure. Additionally, we define the length of the three-dimensional X direction and the solution mode and temperature during the composite process. For this study, we set the solver to solve the steady state of the device at room temperature."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'simu = pj.Simulation()\nsimu.add(name="preview_fde", type="AFDE", property={\n        "mesh_settings": {"global_mesh_uniform_grid": {"dy": ogrid_global_y, "dz": ogrid_global_z}},\n        "fde_analysis": {"modal_analysis": {"calculate_modes": False, "mesh_structure": False, "wavelength": wavelength},\n                         "modulator_analysis": {"modulator_analysis": True, "wavelength": wavelength, "np_path": ""}},\n        "other": {**Si_index_vs_doping}})\n\nsimu.add(name="preview_oedevice", type="OEDevice", property={\n        "geometry": {"dimension": "2d_x_normal", "x": oe_x_mean, "x_span": 0, "y": oe_y_mean, "y_span": oe_y_span, "z_min": oe_z_min, "z_max": oe_z_max},\n        "general": {"norm_length": normal_length, "solver_mode": "steady_state", "simulation_temperature": temperature},\n        "advanced": {"non_linear_solver": "Newton", "linear_solver": "MUMPS", "max_iterations": 50}})\n\n\n')),(0,i.kt)("p",null,"\u200b\tYou can invoke the ",(0,i.kt)("inlineCode",{parentName:"p"},"FDE"),"  module to analyze the refractive index distribution of the device. To define the region of the refractive index distribution to be extracted in ",(0,i.kt)("inlineCode",{parentName:"p"},"geometry"),' , which is the coordinate in the two-dimensional Y-Z plane at X-axis equal to 0. Then, define the file name of the result image and save it to the "plot" folder.'),(0,i.kt)("p",null,"\u200b\tTo analyze the doping distribution of the device, the ",(0,i.kt)("inlineCode",{parentName:"p"},"OEDevice"),'  module can be invoked. First, define the region from which to extract the refractive index distribution, which is the coordinate in the two-dimensional Y-Z plane where the X-axis equals 0. Then, define the file name for the resulting image and save it to the "plot" folder. Additionally, save the simulation process to the "log" folder in the "project" directory.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'simu["preview_oedevice"].run_doping(name="x_in", property={\n        "geometry": {"dimension": "2d_x_normal", "x": oe_x_mean, "x_span": 0, "y": oe_y_mean, "y_span": oe_y_span, "z_min": oe_z_min, "z_max": oe_z_max}},\n        norm="log", scale="equal", superimpose=False, show=False,\n        material_list=["Si"], cmin=8e14, savepath=plot_path + simu_name + "_" + time_str + "doping")\n\nsimu["preview_fde"].run_index(name="index_preview_x_0", property={\n        "geometry": {"x": 0, "x_span": 0, "y": 0, "y_span": 6, "z": 0.3, "z_span": 1}},\n        savepath=plot_path + simu_name + "_" + time_str + "Index", export_csv=False, show=False)\n')),(0,i.kt)("h3",{id:"3-output-result"},"3. Output Result"),(0,i.kt)("p",null,"\u200b\tHere, we present the device geometry as defined in the structure file, along with the P-type and N-type dopant distributions, and the overall doping distribution."),(0,i.kt)("p",null,"Application Library path: ",(0,i.kt)("inlineCode",{parentName:"p"},":\\SDK\\V2.3.0.4\\examples\\active_demo\\doping\\MOD\\plots\\MOD00_struct-time\\doping")," "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Boron Active Doping"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Net Doping"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Phosphorus Active Doping"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:a(4288).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:a(955).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:a(4097).Z,width:"1200",height:"800"}))))),(0,i.kt)("p",null,"\u200b\tWe can see the distribution of the refractive index in the radial direction of the three coordinates of the device."),(0,i.kt)("p",null,"Application Library path: ",(0,i.kt)("inlineCode",{parentName:"p"},":\\SDK\\V2.3.0.4\\examples\\active_demo\\doping\\MOD\\plots\\MOD00_struct-time")," "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"X-axis"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Y-axis"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Z-axis"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"![](../MOD/plot/MOD00_struc/Index.index X.png)"),(0,i.kt)("td",{parentName:"tr",align:"center"},"![](../MOD/plot/MOD00_struc/Index.index Y.png)"),(0,i.kt)("td",{parentName:"tr",align:"center"},"![](../MOD/plot/MOD00_struc/Index.index Z.png)")))),(0,i.kt)("h2",{id:"analytic-character"},"Analytic Character"),(0,i.kt)("h3",{id:"1modulation-efficiency"},"1.Modulation efficiency"),(0,i.kt)("p",null,"\u200b\tThe half-wave voltage refers to the applied voltage required by the modulator's optical signal to generate a phase difference of pi radians, directly reflecting the modulation efficiency of the modulator. Usually, the modulation efficiency of a device is represented by multiplying the half-wave voltage with a parameter that represents the length of the modulator required for phase variation. A smaller value of this parameter indicates higher modulation efficiency, resulting in a smaller required device size."),(0,i.kt)("h4",{id:"11-basic-operations"},"1.1 Basic Operations"),(0,i.kt)("p",null,"\u200b\tBefore analyzing the characteristic parameters of the device, you need to set up the simulation environment in advance and invoke the modules into the file by  ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," ."),(0,i.kt)("h4",{id:"12-code-description"},"1.2 Code Description"),(0,i.kt)("h5",{id:"121-import-modules"},"1.2.1 Import Modules"),(0,i.kt)("p",null,"\u200b\tTo begion, we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," command to call the relevant functional modules."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from MOD00_structure import *\nimport time\nimport os\nfrom pathlib import Path\nimport numpy as np\nimport sys\nfrom matplotlib import pyplot as plt\nimport warnings\n")),(0,i.kt)("p",null,"\u200b\tFor specific instructions, see the description document of PD device."),(0,i.kt)("p",null,"\u200b\tBy adding the runtime function module to the file name, you can ensure the orderly storage of simulation results without data overlay or overwriting during multiple simulation runs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'start = time.time()\ntime_str = time.strftime("%Y%m%d_%H%M%S/", time.localtime())\n')),(0,i.kt)("h5",{id:"122-define-parameters"},"1.2.2 Define Parameters"),(0,i.kt)("p",null,"\u200b\tThe operational mechanism of the device we simulated in this study primarily revolves around the application of a reverse voltage to modify the width of the depletion region, thereby effectively modifying the carrier concentration and subsequently modulating the refractive index. Hence, it is necessary to specify the voltage of initial\u3001termination and step, with both parameters expressed in volts. It is important to note that  ",(0,i.kt)("inlineCode",{parentName:"p"},"vpi_vswing")," is twice the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"tcad_vstep"),"  ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"tcad_vmin = -0.5   \ntcad_vmax = 4      \ntcad_vstep = 0.5   \nvpi_vswing = 1.0   suggest as 2*tcad_vstep\n")),(0,i.kt)("h5",{id:"123-set-path"},"1.2.3 Set Path"),(0,i.kt)("p",null,"\u200b\tYou could define the project name of path, and then set the parameters for path."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'simu_name = "MOD0A_vpi"\nproject_name = simu_name + "_" + run_mode + "_" + time_str\n\nplot_path = str(Path(__file__).parent.as_posix()) + "/plots/"\nif not os.path.exists(plot_path):\n    os.makedirs(plot_path)\nneff_real_folder = plot_path + project_name + "neffreal"\nneff_imag_folder = plot_path + project_name + "neffimag"\nloss_folder = plot_path + project_name + "loss"\nvpil_folder = plot_path + project_name + "vpil"\nvpiloss_folder = plot_path + project_name + "vpiloss"\n')),(0,i.kt)("h5",{id:"124-confirm-swing-of-voltage"},"1.2.4 Confirm swing of voltage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'di = int(np.round(np.abs(vpi_vswing/tcad_vstep/2)))  # Count dot num between volt of vpi and neff.\nif di < 1:\n    sys.exit("\\x1b[6;30;41m" + "\\nError: vpi_swing must be >= tcad_vstep." + "\\x1b[0m")\nif np.abs((np.abs(vpi_vswing)-np.abs(di*tcad_vstep*2))/tcad_vstep) > 0.01:\n    warnings.warn("\\x1b[6;30;43m" + "\\n[Warning: vpi_swing is %(t)sV in program]" % {"t": di*2*tcad_vstep} + "\\x1b[0m", UserWarning)\n')),(0,i.kt)("h5",{id:"125-creat-component"},"1.2.5 Creat Component"),(0,i.kt)("h4",{id:""}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'pj = mod_project(project_name, run_mode, st_type="normal")\nst = pj.Structure()\n\nst.add_electrode(name="cathode", property={\n    "solid": "Cathode", "bc_mode": "steady_state",\n    "sweep_type": "range", "range_start": tcad_vmin, "range_stop": tcad_vmax, "range_interval": tcad_vstep, "apply_AC_small_signal": "none"})\nst.add_electrode(name="anode", property={\n    "solid": "Anode", "bc_mode": "steady_state",\n    "sweep_type": "single", "voltage": 0, "apply_AC_small_signal": "none"})\n')),(0,i.kt)("h5",{id:"126-set-simulation"},"1.2.6 Set Simulation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'simu = pj.Simulation()\nsimu.add(name="oedevice", type="OEDevice", property={\n    "geometry": {"dimension": "2d_x_normal", "x": oe_x_mean, "x_span": 0, "y": oe_y_mean, "y_span": oe_y_span, "z_min": oe_z_min, "z_max": oe_z_max},\n    "general": {"norm_length": normal_length, "solver_mode": "steady_state", "simulation_temperature": temperature},\n    "advanced": {"non_linear_solver": "Newton", "linear_solver": "MUMPS", "max_iterations": 50}})\n\nsimu.add(name="fde", type="AFDE", property={\n    "mesh_settings": {"global_mesh_uniform_grid": {"dy": ogrid_global_y, "dz": ogrid_global_z}},\n    "fde_analysis": {"modal_analysis": {"calculate_modes": False, "mesh_structure": False, "wavelength": wavelength},\n                     "modulator_analysis": {"modulator_analysis": True, "wavelength": wavelength, "mode_select": 0, "np_path": ""}},\n    "other": {**Si_index_vs_doping}})\n')),(0,i.kt)("h5",{id:"127-run"},"1.2.7 Run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'result_device = simu["oedevice"].run()\nresult_fde = simu["fde"].run()\n')),(0,i.kt)("h5",{id:"128-extract-parameters"},"1.2.8 Extract Parameters"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'result_fde.extract(data="effective_index", export_csv=True, operation="real", show=False, savepath=plot_path + project_name + "neffreal")\nresult_fde.extract(data="effective_index", export_csv=True, operation="imag", show=False, savepath=plot_path + project_name + "neffimag")\nresult_fde.extract(data="loss", export_csv=True, show=False, savepath=plot_path + project_name + "loss")\nresult_fde.extract(data="vpil", export_csv=True, show=False, savepath=plot_path + project_name + "vpil")\nresult_fde.extract(data="vpiloss", export_csv=True, show=False, savepath=plot_path + project_name + "vpiloss")\n')),(0,i.kt)("h5",{id:"129-calculate"},"1.2.9 Calculate"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"neff_file = os.path.join(neff_real_folder, \"0_effective index_Real.csv\")\nloss_file = os.path.join(loss_folder, \"0_loss_Real.csv\")\n\nfor i in range(10):\n    neff_file = os.path.join(neff_real_folder, str(i) + \"_effective index_Real.csv\")\n    if os.path.exists(neff_file):\n        break\n\nfor i in range(10):\n    loss_file = os.path.join(loss_folder, str(i) + \"_loss_Real.csv\")\n    if os.path.exists(loss_file):\n        break\n\nrawdata = np.genfromtxt(neff_file, skip_header=3, delimiter=',')\n\nneff = rawdata[:,1]\nvolt = rawdata[:,0]\n\nrawdata = np.genfromtxt(loss_file, skip_header=3, delimiter=',')\n\nloss = rawdata[:,1]\n\nvpil = []\nvolt_out = []\nvpiloss = []\nfor i in range(di, len(volt)-di):\n    volt_out.append(volt[i])\n    vpil.append((volt[i+di]-volt[i-di])/(neff[i+di]-neff[i-di])*wavelength/2*1e-4)\n    vpiloss.append(vpil[-1]*loss[i])\n\nvpil_file = os.path.join(vpil_folder, \"0_VpiL_Real.csv\")\nvpil_pic = os.path.join(vpil_folder, \"0_VpiL_Real.png\")\nvpiloss_file = os.path.join(vpiloss_folder, \"0_VpiLoss_Real.csv\")\nvpiloss_pic = os.path.join(vpiloss_folder, \"0_VpiLoss_Real.png\")\n\nif not os.path.exists(vpil_folder):\n    os.makedirs(vpil_folder)\n\nif not os.path.exists(vpiloss_folder):\n    os.makedirs(vpiloss_folder)\n\nnp.savetxt(vpil_file, np.array((volt_out, vpil)).T, fmt='%f,%.15f', header='voltage,VpiL')\nnp.savetxt(vpiloss_file, np.array((volt_out, vpiloss)).T, fmt='%f,%.15f', header='voltage,VpiLoss')\n\nfontsize = 20\nlinewidth = 1\nplt.rcParams.update({\"font.size\": fontsize})\nfig, ax = plt.subplots()\nfig.set_size_inches(12, 8)\nax.plot(volt_out, vpil, 'b', linewidth=linewidth, label=\"VpiL\")\nax.plot(volt_out, vpil, 'bo')\nax.set_xlabel('VBias[V]')\nax.set_ylabel('VpiL[V\xb7cm]')\nplt.legend()\nplt.ticklabel_format(style='sci', scilimits=(-1, 2))\nax.grid()\nplt.savefig(vpil_pic)\nplt.close()\n\nfig, ax = plt.subplots()\nfig.set_size_inches(12, 8)\nax.plot(volt_out, vpiloss, 'b', linewidth=linewidth, label=\"VpiLoss\")\nax.plot(volt_out, vpiloss, 'bo')\nax.set_xlabel('VBias[V]')\nax.set_ylabel('VpiLoss[V\xb7dB]')\nplt.legend()\nplt.ticklabel_format(style='sci', scilimits=(-1, 2))\nax.grid()\nplt.savefig(vpiloss_pic)\nplt.close()\n\n# endregion\n\nprint(\"\\x1b[6;30;42m\" + \"[Finished in %(t)s mins]\" % {\"t\": round((time.time() - start)/60, 2)} + \"\\x1b[0m\")\n")),(0,i.kt)("h4",{id:"13-output-result"},"1.3 Output Result"),(0,i.kt)("h5",{id:"131-loss"},"1.3.1 Loss"),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(9328).Z,width:"1200",height:"800"})),(0,i.kt)("h5",{id:"132-effective-index"},"1.3.2 Effective Index"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Reffective index real"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Reffective index imaginary"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:a(6352).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:"center"},"![](../MOD/plot/MOD0A_vpi_loca_time/neffimag/0_effective index_Imaginary.png)")))),(0,i.kt)("h5",{id:"133-modulation-efficiency"},"1.3.3 Modulation efficiency"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"VpiL"),(0,i.kt)("th",{parentName:"tr",align:"center"},"VpiLoss"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:a(1017).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("img",{src:a(1452).Z,width:"1200",height:"800"}))))),(0,i.kt)("h3",{id:"2capacitance-and-resistance"},"2.Capacitance And Resistance"),(0,i.kt)("p",null,"\u200b\tCapacitance and resistance play crucial roles in determining the performance of devices. Optimal capacitance values enable the modulator to selectively allow or block signals within specific frequency ranges, facilitating signal coupling. Suitable resistance values enable adjustment of signal amplitude and modulation current determination."),(0,i.kt)("h4",{id:"21-basic-operations"},"2.1 Basic Operations"),(0,i.kt)("h4",{id:"22-code-description"},"2.2 Code Description"),(0,i.kt)("h5",{id:"221-import-modules"},"2.2.1 Import Modules"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from MOD00_structure import *\nimport time\nimport os\nfrom pathlib import Path\nimport re\nimport numpy as np\nfrom matplotlib import pyplot as plt\n")),(0,i.kt)("h5",{id:"222-define-parameters"},"2.2.2 Define Parameters"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"tcad_vmin = -0.5  \ntcad_vmax = 4     \ntcad_vstep = 0.5   \n")),(0,i.kt)("h5",{id:"223-set-path"},"2.2.3 Set Path"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'start = time.time()\ntime_str = time.strftime("%Y%m%d_%H%M%S/", time.localtime())\nsimu_name = "MOD0B_RC"\nproject_name = simu_name + "_" + run_mode + "_" + time_str\n\nplot_path = str(Path(__file__).parent.as_posix()) + "/plots/"\nif not os.path.exists(plot_path):\n    os.makedirs(plot_path)\n')),(0,i.kt)("h5",{id:"224-creat-component"},"2.2.4 Creat Component"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'pj = mod_project(project_name, run_mode, st_type="normal")\nst = pj.Structure()\n\nst.add_electrode(name="cathode", property={\n    "solid": "Cathode", "bc_mode": "steady_state",\n    "sweep_type": "range", "range_start": tcad_vmin, "range_stop": tcad_vmax, "range_interval": tcad_vstep, "apply_AC_small_signal": "All"})\n\nst.add_electrode(name="anode", property={\n    "solid": "Anode", "bc_mode": "steady_state",\n    "sweep_type": "single", "voltage": 0, "apply_AC_small_signal": "none"})\n')),(0,i.kt)("h5",{id:"225-set-simulation"},"2.2.5 Set Simulation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'simu = pj.Simulation()\n\nsimu.add(name="oedevice", type="OEDevice", property={\n    "geometry": {"dimension": "2d_x_normal", "x": oe_x_mean, "x_span": 0, "y": oe_y_mean, "y_span": oe_y_span, "z_min": oe_z_min, "z_max": oe_z_max},\n    "general": {"norm_length": normal_length, "solver_mode": "SSAC", "simulation_temperature": temperature},\n    "small_signal_ac": {"frequency_spacing": "log", "log_start_frequency": 1e6, "log_stop_frequency": 1e10, "log_num_frequency_points": 3, "perturbation_amplitude": ssac_amplitude},\n    "advanced": {"non_linear_solver": "Newton", "linear_solver": "MUMPS", "max_iterations": 50}})\n')),(0,i.kt)("h5",{id:"226-run"},"2.2.6 Run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'result_device = simu["oedevice"].run()\n')),(0,i.kt)("h5",{id:"227-extract-parameters"},"2.2.7 Extract Parameters"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'Iac_real_folder = plot_path + project_name + "Iac_real"\nIac_imag_folder = plot_path + project_name + "Iac_imag"\nresult_device.extract(data="Iac", electrode="cathode", operation="real", export_csv=True, show=False, savepath=Iac_real_folder)\nresult_device.extract(data="Iac", electrode="cathode", operation="imag", export_csv=True, show=False, savepath=Iac_imag_folder)\n')),(0,i.kt)("h5",{id:"228-calculate"},"2.2.8 Calculate"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'Iac_real_files = []\nIac_imag_files = []\nresistance_files = []\ncapacitance_files = []\nfile_regex = r"([0-9]+)_Iac_Real_(.*)\\.csv"\nfor file in os.listdir(Iac_real_folder):\n    if re.match(file_regex, file, re.I):\n        search_group = re.search(file_regex, file, re.I)\n        if search_group != None:\n            Iac_real_files.append(file)\n            Iac_imag_files.append(search_group.group(1) + "_Iac_Imaginary_" + search_group.group(2) + ".csv")\n            resistance_files.append(search_group.group(1) + "_Resistance_" + search_group.group(2) + ".csv")\n            capacitance_files.append(search_group.group(1) + "_Capacitance_" + search_group.group(2) + ".csv")\n\nresistance_folder = plot_path + project_name + "Resistance"\ncapacitance_folder = plot_path + project_name + "Capacitance"\n\nif not os.path.exists(resistance_folder):\n    os.makedirs(resistance_folder)\n\nif not os.path.exists(capacitance_folder):\n    os.makedirs(capacitance_folder)\n\nfor i in range(len(Iac_real_files)):\n    Iac_real_file = os.path.join(Iac_real_folder, Iac_real_files[i])\n    Iac_imag_file = os.path.join(Iac_imag_folder, Iac_imag_files[i])\n    resistance_file = os.path.join(resistance_folder, resistance_files[i])\n    capacitance_file = os.path.join(capacitance_folder, capacitance_files[i])\n\n    Iac_real_data = np.genfromtxt(Iac_real_file, skip_header=3, delimiter=",")\n    Iac_imag_data = np.genfromtxt(Iac_imag_file, skip_header=3, delimiter=",")\n\n    with open(Iac_real_file, \'r\') as fp:\n        line = fp.readline()\n        line = fp.readline()\n        frequency = float(re.search(r".*frequency=(.*)\\[MHz\\]", line, re.I).group(1))*1e6\n\n    if len(Iac_real_data.shape) < 2:\n        Iac_real_data.reshape((1, len(Iac_real_data)))\n        Iac_imag_data.reshape((1, len(Iac_imag_data)))\n\n    Vdc = Iac_real_data[:,0]\n    Vac = ssac_amplitude\n    Iac_real = Iac_real_data[:,1]\n    Iac_imag = Iac_imag_data[:,1]\n    Iac = Iac_real + 1j*Iac_imag\n    Z = Vac/Iac\n    R = np.abs(np.real(Z))\n    C = np.abs(np.imag(1/Z)/(2*np.pi*frequency))\n\n    np.savetxt(resistance_file, np.array((Vdc, R)).T, fmt=\'%f,%.15e\', header=\'voltage,resistance\')\n    np.savetxt(capacitance_file, np.array((Vdc, C)).T, fmt=\'%f,%.15e\', header=\'voltage,capacitance\')\n    \n    resistance_fig = os.path.splitext(resistance_file)[0] + ".jpg"\n    capacitance_fig = os.path.splitext(capacitance_file)[0] + ".jpg"\n    fontsize = 20\n    linewidth = 1\n    plt.rcParams.update({"font.size": fontsize})\n    fig, ax = plt.subplots()\n    fig.set_size_inches(12, 8)\n    ax.plot(Vdc, R, \'b\', linewidth=linewidth, label="resistance_" + str(frequency*1e-6) + "MHz")\n    ax.plot(Vdc, R, \'bo\')\n    ax.set_xlabel(\'VBias[V]\')\n    ax.set_ylabel(\'Resistance[Ohm]\')\n    plt.legend()\n    plt.ticklabel_format(style=\'sci\', scilimits=(-1, 2))\n    ax.grid()\n    plt.savefig(resistance_fig)\n    plt.close()\n\n    fig, ax = plt.subplots()\n    fig.set_size_inches(12, 8)\n    ax.plot(Vdc, C, \'b\', linewidth=linewidth, label="capacitance_" + str(frequency*1e-6) + "MHz")\n    ax.plot(Vdc, C, \'bo\')\n    ax.set_xlabel(\'VBias[V]\')\n    ax.set_ylabel(\'Capacitance[F]\')\n    plt.legend()\n    plt.ticklabel_format(style=\'sci\', scilimits=(-1, 2))\n    ax.grid()\n    plt.savefig(capacitance_fig)\n    plt.close()\n# endregion\n\nprint("\\x1b[6;30;42m" + "[Finished in %(t)s mins]" % {"t": round((time.time() - start)/60, 2)} + "\\x1b[0m")\n\n')),(0,i.kt)("h4",{id:"23-output-result"},"2.3 Output Result"),(0,i.kt)("h5",{id:"231-capacitance"},"2.3.1 Capacitance"),(0,i.kt)("p",null,"different frequency "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"1 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"100 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"10000 MHZ"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(3119).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(101).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(2437).Z,width:"1200",height:"800"}))))),(0,i.kt)("h5",{id:"232-photocurrent"},"2.3.2 Photocurrent"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null},"1 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"100 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"10000 MHZ"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Real"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(9530).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(8228).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{parentName:"td",src:"D:../MOD/plot/MOD0B_RC_local_time/Iac_real/0_Iac_Real_10000.0MHz.png",alt:null}))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Image"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(4796).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(2081).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(8535).Z,width:"1200",height:"800"}))))),(0,i.kt)("h5",{id:"233-resistance"},"2.3.3 Resistance"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"1 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"100 MHZ"),(0,i.kt)("th",{parentName:"tr",align:null},"10000 MHZ"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(5081).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(5159).Z,width:"1200",height:"800"})),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("img",{src:a(9962).Z,width:"1200",height:"800"}))))))}_.isMDXComponent=!0},4288:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/BoronActive_dop-3a9d9a1ca03fa84a7cb5243fc18e7a1c.jpg"},955:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/NetDoping_dop-bd11f01ea0e6e1ddf0d40f04d8c0e460.jpg"},4097:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/PhosphorusActive_dop-5093e33735f5f6531e9e011800d9c5d0.jpg"},9328:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_loss_Real-f57256029a34a21de342d447129dda39.png"},6352:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_effective index_Real-d2348313d128ef9fde35166b3b3067d6.png"},1017:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_VpiL_Real-4e05ebdce4c4c39bcb14b393878395a1.png"},1452:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_VpiLoss_Real-870a8a10aed4b8e93c1209d77f9d32fe.png"},3119:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Capacitance_1.0MHz-336a583b4e62998773724cee0fa4b1b2.jpg"},101:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Capacitance_100.0MHz-6f7f6d16983325ea84849e6b0f372e3a.jpg"},2437:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Capacitance_10000.0MHz-14f8f502028f80d986b57452e6e0ae28.jpg"},4796:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Iac_Imaginary_1.0MHz-638dc7c289bd8aaf81ef68d399abdb22.png"},2081:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Iac_Imaginary_100.0MHz-b3917513b5f4675ee274ac08c5ca827f.png"},8535:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Iac_Imaginary_10000.0MHz-3e12f0ea13923e81f84967cc7c448ebf.png"},9530:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Iac_Real_1.0MHz-d6506f2908d9233f0c52fd8bf3474d01.png"},8228:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Iac_Real_100.0MHz-cd207132038054975cbe3fbcf5254d60.png"},5081:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Resistance_1.0MHz-ec62313403169e6518c6a6082051b91d.jpg"},5159:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Resistance_100.0MHz-89bea2a084bc7514afa9498952627714.jpg"},9962:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0_Resistance_10000.0MHz-3b74b23c060e15d6c448deb33e46aff9.jpg"},7522:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/MOD_structure-b3d859b957126e5933d1d059078dc903.png"}}]);